// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'kagami.openapi.dtos.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$AccountDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'accountType')
  String get accountType;
  @JsonKey(name: 'contactInfo')
  ContactInfoDto? get contactInfo;
  @JsonKey(name: 'personalInfo')
  PersonalInfoDto? get personalInfo;
  @JsonKey(name: 'addressList')
  List<AddressInfoDto>? get addressList;

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AccountDtoCopyWith<AccountDto> get copyWith =>
      _$AccountDtoCopyWithImpl<AccountDto>(this as AccountDto, _$identity);

  /// Serializes this AccountDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AccountDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.accountType, accountType) ||
                other.accountType == accountType) &&
            (identical(other.contactInfo, contactInfo) ||
                other.contactInfo == contactInfo) &&
            (identical(other.personalInfo, personalInfo) ||
                other.personalInfo == personalInfo) &&
            const DeepCollectionEquality()
                .equals(other.addressList, addressList));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, accountType, contactInfo,
      personalInfo, const DeepCollectionEquality().hash(addressList));

  @override
  String toString() {
    return 'AccountDto(id: $id, accountType: $accountType, contactInfo: $contactInfo, personalInfo: $personalInfo, addressList: $addressList)';
  }
}

/// @nodoc
abstract mixin class $AccountDtoCopyWith<$Res> {
  factory $AccountDtoCopyWith(
          AccountDto value, $Res Function(AccountDto) _then) =
      _$AccountDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'accountType') String accountType,
      @JsonKey(name: 'contactInfo') ContactInfoDto? contactInfo,
      @JsonKey(name: 'personalInfo') PersonalInfoDto? personalInfo,
      @JsonKey(name: 'addressList') List<AddressInfoDto>? addressList});

  $ContactInfoDtoCopyWith<$Res>? get contactInfo;
  $PersonalInfoDtoCopyWith<$Res>? get personalInfo;
}

/// @nodoc
class _$AccountDtoCopyWithImpl<$Res> implements $AccountDtoCopyWith<$Res> {
  _$AccountDtoCopyWithImpl(this._self, this._then);

  final AccountDto _self;
  final $Res Function(AccountDto) _then;

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? accountType = null,
    Object? contactInfo = freezed,
    Object? personalInfo = freezed,
    Object? addressList = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      accountType: null == accountType
          ? _self.accountType
          : accountType // ignore: cast_nullable_to_non_nullable
              as String,
      contactInfo: freezed == contactInfo
          ? _self.contactInfo
          : contactInfo // ignore: cast_nullable_to_non_nullable
              as ContactInfoDto?,
      personalInfo: freezed == personalInfo
          ? _self.personalInfo
          : personalInfo // ignore: cast_nullable_to_non_nullable
              as PersonalInfoDto?,
      addressList: freezed == addressList
          ? _self.addressList
          : addressList // ignore: cast_nullable_to_non_nullable
              as List<AddressInfoDto>?,
    ));
  }

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ContactInfoDtoCopyWith<$Res>? get contactInfo {
    if (_self.contactInfo == null) {
      return null;
    }

    return $ContactInfoDtoCopyWith<$Res>(_self.contactInfo!, (value) {
      return _then(_self.copyWith(contactInfo: value));
    });
  }

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PersonalInfoDtoCopyWith<$Res>? get personalInfo {
    if (_self.personalInfo == null) {
      return null;
    }

    return $PersonalInfoDtoCopyWith<$Res>(_self.personalInfo!, (value) {
      return _then(_self.copyWith(personalInfo: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AccountDto].
extension AccountDtoPatterns on AccountDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AccountDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AccountDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AccountDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'accountType') String accountType,
            @JsonKey(name: 'contactInfo') ContactInfoDto? contactInfo,
            @JsonKey(name: 'personalInfo') PersonalInfoDto? personalInfo,
            @JsonKey(name: 'addressList') List<AddressInfoDto>? addressList)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that.id, _that.accountType, _that.contactInfo,
            _that.personalInfo, _that.addressList);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'accountType') String accountType,
            @JsonKey(name: 'contactInfo') ContactInfoDto? contactInfo,
            @JsonKey(name: 'personalInfo') PersonalInfoDto? personalInfo,
            @JsonKey(name: 'addressList') List<AddressInfoDto>? addressList)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto():
        return $default(_that.id, _that.accountType, _that.contactInfo,
            _that.personalInfo, _that.addressList);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'accountType') String accountType,
            @JsonKey(name: 'contactInfo') ContactInfoDto? contactInfo,
            @JsonKey(name: 'personalInfo') PersonalInfoDto? personalInfo,
            @JsonKey(name: 'addressList') List<AddressInfoDto>? addressList)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that.id, _that.accountType, _that.contactInfo,
            _that.personalInfo, _that.addressList);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AccountDto implements AccountDto {
  _AccountDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'accountType') required this.accountType,
      @JsonKey(name: 'contactInfo') this.contactInfo,
      @JsonKey(name: 'personalInfo') this.personalInfo,
      @JsonKey(name: 'addressList') final List<AddressInfoDto>? addressList})
      : _addressList = addressList;
  factory _AccountDto.fromJson(Map<String, dynamic> json) =>
      _$AccountDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'accountType')
  final String accountType;
  @override
  @JsonKey(name: 'contactInfo')
  final ContactInfoDto? contactInfo;
  @override
  @JsonKey(name: 'personalInfo')
  final PersonalInfoDto? personalInfo;
  final List<AddressInfoDto>? _addressList;
  @override
  @JsonKey(name: 'addressList')
  List<AddressInfoDto>? get addressList {
    final value = _addressList;
    if (value == null) return null;
    if (_addressList is EqualUnmodifiableListView) return _addressList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AccountDtoCopyWith<_AccountDto> get copyWith =>
      __$AccountDtoCopyWithImpl<_AccountDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AccountDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AccountDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.accountType, accountType) ||
                other.accountType == accountType) &&
            (identical(other.contactInfo, contactInfo) ||
                other.contactInfo == contactInfo) &&
            (identical(other.personalInfo, personalInfo) ||
                other.personalInfo == personalInfo) &&
            const DeepCollectionEquality()
                .equals(other._addressList, _addressList));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, accountType, contactInfo,
      personalInfo, const DeepCollectionEquality().hash(_addressList));

  @override
  String toString() {
    return 'AccountDto(id: $id, accountType: $accountType, contactInfo: $contactInfo, personalInfo: $personalInfo, addressList: $addressList)';
  }
}

/// @nodoc
abstract mixin class _$AccountDtoCopyWith<$Res>
    implements $AccountDtoCopyWith<$Res> {
  factory _$AccountDtoCopyWith(
          _AccountDto value, $Res Function(_AccountDto) _then) =
      __$AccountDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'accountType') String accountType,
      @JsonKey(name: 'contactInfo') ContactInfoDto? contactInfo,
      @JsonKey(name: 'personalInfo') PersonalInfoDto? personalInfo,
      @JsonKey(name: 'addressList') List<AddressInfoDto>? addressList});

  @override
  $ContactInfoDtoCopyWith<$Res>? get contactInfo;
  @override
  $PersonalInfoDtoCopyWith<$Res>? get personalInfo;
}

/// @nodoc
class __$AccountDtoCopyWithImpl<$Res> implements _$AccountDtoCopyWith<$Res> {
  __$AccountDtoCopyWithImpl(this._self, this._then);

  final _AccountDto _self;
  final $Res Function(_AccountDto) _then;

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? accountType = null,
    Object? contactInfo = freezed,
    Object? personalInfo = freezed,
    Object? addressList = freezed,
  }) {
    return _then(_AccountDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      accountType: null == accountType
          ? _self.accountType
          : accountType // ignore: cast_nullable_to_non_nullable
              as String,
      contactInfo: freezed == contactInfo
          ? _self.contactInfo
          : contactInfo // ignore: cast_nullable_to_non_nullable
              as ContactInfoDto?,
      personalInfo: freezed == personalInfo
          ? _self.personalInfo
          : personalInfo // ignore: cast_nullable_to_non_nullable
              as PersonalInfoDto?,
      addressList: freezed == addressList
          ? _self._addressList
          : addressList // ignore: cast_nullable_to_non_nullable
              as List<AddressInfoDto>?,
    ));
  }

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ContactInfoDtoCopyWith<$Res>? get contactInfo {
    if (_self.contactInfo == null) {
      return null;
    }

    return $ContactInfoDtoCopyWith<$Res>(_self.contactInfo!, (value) {
      return _then(_self.copyWith(contactInfo: value));
    });
  }

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PersonalInfoDtoCopyWith<$Res>? get personalInfo {
    if (_self.personalInfo == null) {
      return null;
    }

    return $PersonalInfoDtoCopyWith<$Res>(_self.personalInfo!, (value) {
      return _then(_self.copyWith(personalInfo: value));
    });
  }
}

/// @nodoc
mixin _$AddressInfoDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'accountID')
  String? get accountID;
  @JsonKey(name: 'address1')
  String? get address1;
  @JsonKey(name: 'address2')
  String? get address2;
  @JsonKey(name: 'address3')
  String? get address3;
  @JsonKey(name: 'city')
  String? get city;
  @JsonKey(name: 'country')
  String? get country;
  @JsonKey(name: 'postalCode')
  String? get postalCode;
  @JsonKey(name: 'addressType')
  String? get addressType;

  /// Create a copy of AddressInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AddressInfoDtoCopyWith<AddressInfoDto> get copyWith =>
      _$AddressInfoDtoCopyWithImpl<AddressInfoDto>(
          this as AddressInfoDto, _$identity);

  /// Serializes this AddressInfoDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AddressInfoDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.accountID, accountID) ||
                other.accountID == accountID) &&
            (identical(other.address1, address1) ||
                other.address1 == address1) &&
            (identical(other.address2, address2) ||
                other.address2 == address2) &&
            (identical(other.address3, address3) ||
                other.address3 == address3) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.postalCode, postalCode) ||
                other.postalCode == postalCode) &&
            (identical(other.addressType, addressType) ||
                other.addressType == addressType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, accountID, address1,
      address2, address3, city, country, postalCode, addressType);

  @override
  String toString() {
    return 'AddressInfoDto(id: $id, accountID: $accountID, address1: $address1, address2: $address2, address3: $address3, city: $city, country: $country, postalCode: $postalCode, addressType: $addressType)';
  }
}

/// @nodoc
abstract mixin class $AddressInfoDtoCopyWith<$Res> {
  factory $AddressInfoDtoCopyWith(
          AddressInfoDto value, $Res Function(AddressInfoDto) _then) =
      _$AddressInfoDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'accountID') String? accountID,
      @JsonKey(name: 'address1') String? address1,
      @JsonKey(name: 'address2') String? address2,
      @JsonKey(name: 'address3') String? address3,
      @JsonKey(name: 'city') String? city,
      @JsonKey(name: 'country') String? country,
      @JsonKey(name: 'postalCode') String? postalCode,
      @JsonKey(name: 'addressType') String? addressType});
}

/// @nodoc
class _$AddressInfoDtoCopyWithImpl<$Res>
    implements $AddressInfoDtoCopyWith<$Res> {
  _$AddressInfoDtoCopyWithImpl(this._self, this._then);

  final AddressInfoDto _self;
  final $Res Function(AddressInfoDto) _then;

  /// Create a copy of AddressInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? accountID = freezed,
    Object? address1 = freezed,
    Object? address2 = freezed,
    Object? address3 = freezed,
    Object? city = freezed,
    Object? country = freezed,
    Object? postalCode = freezed,
    Object? addressType = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      accountID: freezed == accountID
          ? _self.accountID
          : accountID // ignore: cast_nullable_to_non_nullable
              as String?,
      address1: freezed == address1
          ? _self.address1
          : address1 // ignore: cast_nullable_to_non_nullable
              as String?,
      address2: freezed == address2
          ? _self.address2
          : address2 // ignore: cast_nullable_to_non_nullable
              as String?,
      address3: freezed == address3
          ? _self.address3
          : address3 // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      country: freezed == country
          ? _self.country
          : country // ignore: cast_nullable_to_non_nullable
              as String?,
      postalCode: freezed == postalCode
          ? _self.postalCode
          : postalCode // ignore: cast_nullable_to_non_nullable
              as String?,
      addressType: freezed == addressType
          ? _self.addressType
          : addressType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AddressInfoDto].
extension AddressInfoDtoPatterns on AddressInfoDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AddressInfoDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AddressInfoDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AddressInfoDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressInfoDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AddressInfoDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressInfoDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'accountID') String? accountID,
            @JsonKey(name: 'address1') String? address1,
            @JsonKey(name: 'address2') String? address2,
            @JsonKey(name: 'address3') String? address3,
            @JsonKey(name: 'city') String? city,
            @JsonKey(name: 'country') String? country,
            @JsonKey(name: 'postalCode') String? postalCode,
            @JsonKey(name: 'addressType') String? addressType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AddressInfoDto() when $default != null:
        return $default(
            _that.id,
            _that.accountID,
            _that.address1,
            _that.address2,
            _that.address3,
            _that.city,
            _that.country,
            _that.postalCode,
            _that.addressType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'accountID') String? accountID,
            @JsonKey(name: 'address1') String? address1,
            @JsonKey(name: 'address2') String? address2,
            @JsonKey(name: 'address3') String? address3,
            @JsonKey(name: 'city') String? city,
            @JsonKey(name: 'country') String? country,
            @JsonKey(name: 'postalCode') String? postalCode,
            @JsonKey(name: 'addressType') String? addressType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressInfoDto():
        return $default(
            _that.id,
            _that.accountID,
            _that.address1,
            _that.address2,
            _that.address3,
            _that.city,
            _that.country,
            _that.postalCode,
            _that.addressType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'accountID') String? accountID,
            @JsonKey(name: 'address1') String? address1,
            @JsonKey(name: 'address2') String? address2,
            @JsonKey(name: 'address3') String? address3,
            @JsonKey(name: 'city') String? city,
            @JsonKey(name: 'country') String? country,
            @JsonKey(name: 'postalCode') String? postalCode,
            @JsonKey(name: 'addressType') String? addressType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressInfoDto() when $default != null:
        return $default(
            _that.id,
            _that.accountID,
            _that.address1,
            _that.address2,
            _that.address3,
            _that.city,
            _that.country,
            _that.postalCode,
            _that.addressType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AddressInfoDto implements AddressInfoDto {
  _AddressInfoDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'accountID') this.accountID,
      @JsonKey(name: 'address1') this.address1,
      @JsonKey(name: 'address2') this.address2,
      @JsonKey(name: 'address3') this.address3,
      @JsonKey(name: 'city') this.city,
      @JsonKey(name: 'country') this.country,
      @JsonKey(name: 'postalCode') this.postalCode,
      @JsonKey(name: 'addressType') this.addressType});
  factory _AddressInfoDto.fromJson(Map<String, dynamic> json) =>
      _$AddressInfoDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'accountID')
  final String? accountID;
  @override
  @JsonKey(name: 'address1')
  final String? address1;
  @override
  @JsonKey(name: 'address2')
  final String? address2;
  @override
  @JsonKey(name: 'address3')
  final String? address3;
  @override
  @JsonKey(name: 'city')
  final String? city;
  @override
  @JsonKey(name: 'country')
  final String? country;
  @override
  @JsonKey(name: 'postalCode')
  final String? postalCode;
  @override
  @JsonKey(name: 'addressType')
  final String? addressType;

  /// Create a copy of AddressInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AddressInfoDtoCopyWith<_AddressInfoDto> get copyWith =>
      __$AddressInfoDtoCopyWithImpl<_AddressInfoDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AddressInfoDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddressInfoDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.accountID, accountID) ||
                other.accountID == accountID) &&
            (identical(other.address1, address1) ||
                other.address1 == address1) &&
            (identical(other.address2, address2) ||
                other.address2 == address2) &&
            (identical(other.address3, address3) ||
                other.address3 == address3) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.postalCode, postalCode) ||
                other.postalCode == postalCode) &&
            (identical(other.addressType, addressType) ||
                other.addressType == addressType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, accountID, address1,
      address2, address3, city, country, postalCode, addressType);

  @override
  String toString() {
    return 'AddressInfoDto(id: $id, accountID: $accountID, address1: $address1, address2: $address2, address3: $address3, city: $city, country: $country, postalCode: $postalCode, addressType: $addressType)';
  }
}

/// @nodoc
abstract mixin class _$AddressInfoDtoCopyWith<$Res>
    implements $AddressInfoDtoCopyWith<$Res> {
  factory _$AddressInfoDtoCopyWith(
          _AddressInfoDto value, $Res Function(_AddressInfoDto) _then) =
      __$AddressInfoDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'accountID') String? accountID,
      @JsonKey(name: 'address1') String? address1,
      @JsonKey(name: 'address2') String? address2,
      @JsonKey(name: 'address3') String? address3,
      @JsonKey(name: 'city') String? city,
      @JsonKey(name: 'country') String? country,
      @JsonKey(name: 'postalCode') String? postalCode,
      @JsonKey(name: 'addressType') String? addressType});
}

/// @nodoc
class __$AddressInfoDtoCopyWithImpl<$Res>
    implements _$AddressInfoDtoCopyWith<$Res> {
  __$AddressInfoDtoCopyWithImpl(this._self, this._then);

  final _AddressInfoDto _self;
  final $Res Function(_AddressInfoDto) _then;

  /// Create a copy of AddressInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? accountID = freezed,
    Object? address1 = freezed,
    Object? address2 = freezed,
    Object? address3 = freezed,
    Object? city = freezed,
    Object? country = freezed,
    Object? postalCode = freezed,
    Object? addressType = freezed,
  }) {
    return _then(_AddressInfoDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      accountID: freezed == accountID
          ? _self.accountID
          : accountID // ignore: cast_nullable_to_non_nullable
              as String?,
      address1: freezed == address1
          ? _self.address1
          : address1 // ignore: cast_nullable_to_non_nullable
              as String?,
      address2: freezed == address2
          ? _self.address2
          : address2 // ignore: cast_nullable_to_non_nullable
              as String?,
      address3: freezed == address3
          ? _self.address3
          : address3 // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      country: freezed == country
          ? _self.country
          : country // ignore: cast_nullable_to_non_nullable
              as String?,
      postalCode: freezed == postalCode
          ? _self.postalCode
          : postalCode // ignore: cast_nullable_to_non_nullable
              as String?,
      addressType: freezed == addressType
          ? _self.addressType
          : addressType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$AttendanceDto {
  @JsonKey(name: 'date')
  DateTime get date;
  @JsonKey(name: 'attendanceStatus')
  String? get attendanceStatus;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'utcDate')
  DateTime? get utcDate;

  /// Create a copy of AttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AttendanceDtoCopyWith<AttendanceDto> get copyWith =>
      _$AttendanceDtoCopyWithImpl<AttendanceDto>(
          this as AttendanceDto, _$identity);

  /// Serializes this AttendanceDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AttendanceDto &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, date, attendanceStatus, remarks, utcDate);

  @override
  String toString() {
    return 'AttendanceDto(date: $date, attendanceStatus: $attendanceStatus, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class $AttendanceDtoCopyWith<$Res> {
  factory $AttendanceDtoCopyWith(
          AttendanceDto value, $Res Function(AttendanceDto) _then) =
      _$AttendanceDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class _$AttendanceDtoCopyWithImpl<$Res>
    implements $AttendanceDtoCopyWith<$Res> {
  _$AttendanceDtoCopyWithImpl(this._self, this._then);

  final AttendanceDto _self;
  final $Res Function(AttendanceDto) _then;

  /// Create a copy of AttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_self.copyWith(
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AttendanceDto].
extension AttendanceDtoPatterns on AttendanceDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AttendanceDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendanceDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AttendanceDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AttendanceDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendanceDto() when $default != null:
        return $default(
            _that.date, _that.attendanceStatus, _that.remarks, _that.utcDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceDto():
        return $default(
            _that.date, _that.attendanceStatus, _that.remarks, _that.utcDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceDto() when $default != null:
        return $default(
            _that.date, _that.attendanceStatus, _that.remarks, _that.utcDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AttendanceDto implements AttendanceDto {
  _AttendanceDto(
      {@JsonKey(name: 'date') required this.date,
      @JsonKey(name: 'attendanceStatus') this.attendanceStatus,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'utcDate') this.utcDate});
  factory _AttendanceDto.fromJson(Map<String, dynamic> json) =>
      _$AttendanceDtoFromJson(json);

  @override
  @JsonKey(name: 'date')
  final DateTime date;
  @override
  @JsonKey(name: 'attendanceStatus')
  final String? attendanceStatus;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'utcDate')
  final DateTime? utcDate;

  /// Create a copy of AttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AttendanceDtoCopyWith<_AttendanceDto> get copyWith =>
      __$AttendanceDtoCopyWithImpl<_AttendanceDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AttendanceDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AttendanceDto &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, date, attendanceStatus, remarks, utcDate);

  @override
  String toString() {
    return 'AttendanceDto(date: $date, attendanceStatus: $attendanceStatus, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class _$AttendanceDtoCopyWith<$Res>
    implements $AttendanceDtoCopyWith<$Res> {
  factory _$AttendanceDtoCopyWith(
          _AttendanceDto value, $Res Function(_AttendanceDto) _then) =
      __$AttendanceDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class __$AttendanceDtoCopyWithImpl<$Res>
    implements _$AttendanceDtoCopyWith<$Res> {
  __$AttendanceDtoCopyWithImpl(this._self, this._then);

  final _AttendanceDto _self;
  final $Res Function(_AttendanceDto) _then;

  /// Create a copy of AttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? date = null,
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_AttendanceDto(
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$AttendanceVODto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'date')
  DateTime get date;
  @JsonKey(name: 'attendanceStatus')
  String? get attendanceStatus;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'utcDate')
  DateTime? get utcDate;

  /// Create a copy of AttendanceVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AttendanceVODtoCopyWith<AttendanceVODto> get copyWith =>
      _$AttendanceVODtoCopyWithImpl<AttendanceVODto>(
          this as AttendanceVODto, _$identity);

  /// Serializes this AttendanceVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AttendanceVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, attendanceStatus, remarks, utcDate);

  @override
  String toString() {
    return 'AttendanceVODto(id: $id, studentId: $studentId, date: $date, attendanceStatus: $attendanceStatus, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class $AttendanceVODtoCopyWith<$Res> {
  factory $AttendanceVODtoCopyWith(
          AttendanceVODto value, $Res Function(AttendanceVODto) _then) =
      _$AttendanceVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class _$AttendanceVODtoCopyWithImpl<$Res>
    implements $AttendanceVODtoCopyWith<$Res> {
  _$AttendanceVODtoCopyWithImpl(this._self, this._then);

  final AttendanceVODto _self;
  final $Res Function(AttendanceVODto) _then;

  /// Create a copy of AttendanceVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AttendanceVODto].
extension AttendanceVODtoPatterns on AttendanceVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AttendanceVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendanceVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AttendanceVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AttendanceVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendanceVODto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date,
            _that.attendanceStatus, _that.remarks, _that.utcDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceVODto():
        return $default(_that.id, _that.studentId, _that.date,
            _that.attendanceStatus, _that.remarks, _that.utcDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceVODto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date,
            _that.attendanceStatus, _that.remarks, _that.utcDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AttendanceVODto implements AttendanceVODto {
  _AttendanceVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'date') required this.date,
      @JsonKey(name: 'attendanceStatus') this.attendanceStatus,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'utcDate') this.utcDate});
  factory _AttendanceVODto.fromJson(Map<String, dynamic> json) =>
      _$AttendanceVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'date')
  final DateTime date;
  @override
  @JsonKey(name: 'attendanceStatus')
  final String? attendanceStatus;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'utcDate')
  final DateTime? utcDate;

  /// Create a copy of AttendanceVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AttendanceVODtoCopyWith<_AttendanceVODto> get copyWith =>
      __$AttendanceVODtoCopyWithImpl<_AttendanceVODto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AttendanceVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AttendanceVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, attendanceStatus, remarks, utcDate);

  @override
  String toString() {
    return 'AttendanceVODto(id: $id, studentId: $studentId, date: $date, attendanceStatus: $attendanceStatus, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class _$AttendanceVODtoCopyWith<$Res>
    implements $AttendanceVODtoCopyWith<$Res> {
  factory _$AttendanceVODtoCopyWith(
          _AttendanceVODto value, $Res Function(_AttendanceVODto) _then) =
      __$AttendanceVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class __$AttendanceVODtoCopyWithImpl<$Res>
    implements _$AttendanceVODtoCopyWith<$Res> {
  __$AttendanceVODtoCopyWithImpl(this._self, this._then);

  final _AttendanceVODto _self;
  final $Res Function(_AttendanceVODto) _then;

  /// Create a copy of AttendanceVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_AttendanceVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$AttendeeDto {
  @JsonKey(name: 'emailAddress')
  EmailAddressDto? get emailAddress;
  @JsonKey(name: '@odata.type')
  String? get odataType;
  @JsonKey(name: 'type')
  AttendeeTypeDto? get type;
  @JsonKey(name: 'proposedNewTime')
  TimeSlotDto? get proposedNewTime;
  @JsonKey(name: 'status')
  ResponseStatusDto? get status;

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AttendeeDtoCopyWith<AttendeeDto> get copyWith =>
      _$AttendeeDtoCopyWithImpl<AttendeeDto>(this as AttendeeDto, _$identity);

  /// Serializes this AttendeeDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AttendeeDto &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.proposedNewTime, proposedNewTime) ||
                other.proposedNewTime == proposedNewTime) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, emailAddress, odataType, type, proposedNewTime, status);

  @override
  String toString() {
    return 'AttendeeDto(emailAddress: $emailAddress, odataType: $odataType, type: $type, proposedNewTime: $proposedNewTime, status: $status)';
  }
}

/// @nodoc
abstract mixin class $AttendeeDtoCopyWith<$Res> {
  factory $AttendeeDtoCopyWith(
          AttendeeDto value, $Res Function(AttendeeDto) _then) =
      _$AttendeeDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'emailAddress') EmailAddressDto? emailAddress,
      @JsonKey(name: '@odata.type') String? odataType,
      @JsonKey(name: 'type') AttendeeTypeDto? type,
      @JsonKey(name: 'proposedNewTime') TimeSlotDto? proposedNewTime,
      @JsonKey(name: 'status') ResponseStatusDto? status});

  $EmailAddressDtoCopyWith<$Res>? get emailAddress;
  $TimeSlotDtoCopyWith<$Res>? get proposedNewTime;
  $ResponseStatusDtoCopyWith<$Res>? get status;
}

/// @nodoc
class _$AttendeeDtoCopyWithImpl<$Res> implements $AttendeeDtoCopyWith<$Res> {
  _$AttendeeDtoCopyWithImpl(this._self, this._then);

  final AttendeeDto _self;
  final $Res Function(AttendeeDto) _then;

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? emailAddress = freezed,
    Object? odataType = freezed,
    Object? type = freezed,
    Object? proposedNewTime = freezed,
    Object? status = freezed,
  }) {
    return _then(_self.copyWith(
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as EmailAddressDto?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as AttendeeTypeDto?,
      proposedNewTime: freezed == proposedNewTime
          ? _self.proposedNewTime
          : proposedNewTime // ignore: cast_nullable_to_non_nullable
              as TimeSlotDto?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as ResponseStatusDto?,
    ));
  }

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmailAddressDtoCopyWith<$Res>? get emailAddress {
    if (_self.emailAddress == null) {
      return null;
    }

    return $EmailAddressDtoCopyWith<$Res>(_self.emailAddress!, (value) {
      return _then(_self.copyWith(emailAddress: value));
    });
  }

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TimeSlotDtoCopyWith<$Res>? get proposedNewTime {
    if (_self.proposedNewTime == null) {
      return null;
    }

    return $TimeSlotDtoCopyWith<$Res>(_self.proposedNewTime!, (value) {
      return _then(_self.copyWith(proposedNewTime: value));
    });
  }

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseStatusDtoCopyWith<$Res>? get status {
    if (_self.status == null) {
      return null;
    }

    return $ResponseStatusDtoCopyWith<$Res>(_self.status!, (value) {
      return _then(_self.copyWith(status: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AttendeeDto].
extension AttendeeDtoPatterns on AttendeeDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AttendeeDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendeeDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AttendeeDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendeeDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AttendeeDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendeeDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'emailAddress') EmailAddressDto? emailAddress,
            @JsonKey(name: '@odata.type') String? odataType,
            @JsonKey(name: 'type') AttendeeTypeDto? type,
            @JsonKey(name: 'proposedNewTime') TimeSlotDto? proposedNewTime,
            @JsonKey(name: 'status') ResponseStatusDto? status)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendeeDto() when $default != null:
        return $default(_that.emailAddress, _that.odataType, _that.type,
            _that.proposedNewTime, _that.status);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'emailAddress') EmailAddressDto? emailAddress,
            @JsonKey(name: '@odata.type') String? odataType,
            @JsonKey(name: 'type') AttendeeTypeDto? type,
            @JsonKey(name: 'proposedNewTime') TimeSlotDto? proposedNewTime,
            @JsonKey(name: 'status') ResponseStatusDto? status)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendeeDto():
        return $default(_that.emailAddress, _that.odataType, _that.type,
            _that.proposedNewTime, _that.status);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'emailAddress') EmailAddressDto? emailAddress,
            @JsonKey(name: '@odata.type') String? odataType,
            @JsonKey(name: 'type') AttendeeTypeDto? type,
            @JsonKey(name: 'proposedNewTime') TimeSlotDto? proposedNewTime,
            @JsonKey(name: 'status') ResponseStatusDto? status)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendeeDto() when $default != null:
        return $default(_that.emailAddress, _that.odataType, _that.type,
            _that.proposedNewTime, _that.status);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AttendeeDto implements AttendeeDto {
  _AttendeeDto(
      {@JsonKey(name: 'emailAddress') this.emailAddress,
      @JsonKey(name: '@odata.type') this.odataType,
      @JsonKey(name: 'type') this.type,
      @JsonKey(name: 'proposedNewTime') this.proposedNewTime,
      @JsonKey(name: 'status') this.status});
  factory _AttendeeDto.fromJson(Map<String, dynamic> json) =>
      _$AttendeeDtoFromJson(json);

  @override
  @JsonKey(name: 'emailAddress')
  final EmailAddressDto? emailAddress;
  @override
  @JsonKey(name: '@odata.type')
  final String? odataType;
  @override
  @JsonKey(name: 'type')
  final AttendeeTypeDto? type;
  @override
  @JsonKey(name: 'proposedNewTime')
  final TimeSlotDto? proposedNewTime;
  @override
  @JsonKey(name: 'status')
  final ResponseStatusDto? status;

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AttendeeDtoCopyWith<_AttendeeDto> get copyWith =>
      __$AttendeeDtoCopyWithImpl<_AttendeeDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AttendeeDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AttendeeDto &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.proposedNewTime, proposedNewTime) ||
                other.proposedNewTime == proposedNewTime) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, emailAddress, odataType, type, proposedNewTime, status);

  @override
  String toString() {
    return 'AttendeeDto(emailAddress: $emailAddress, odataType: $odataType, type: $type, proposedNewTime: $proposedNewTime, status: $status)';
  }
}

/// @nodoc
abstract mixin class _$AttendeeDtoCopyWith<$Res>
    implements $AttendeeDtoCopyWith<$Res> {
  factory _$AttendeeDtoCopyWith(
          _AttendeeDto value, $Res Function(_AttendeeDto) _then) =
      __$AttendeeDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'emailAddress') EmailAddressDto? emailAddress,
      @JsonKey(name: '@odata.type') String? odataType,
      @JsonKey(name: 'type') AttendeeTypeDto? type,
      @JsonKey(name: 'proposedNewTime') TimeSlotDto? proposedNewTime,
      @JsonKey(name: 'status') ResponseStatusDto? status});

  @override
  $EmailAddressDtoCopyWith<$Res>? get emailAddress;
  @override
  $TimeSlotDtoCopyWith<$Res>? get proposedNewTime;
  @override
  $ResponseStatusDtoCopyWith<$Res>? get status;
}

/// @nodoc
class __$AttendeeDtoCopyWithImpl<$Res> implements _$AttendeeDtoCopyWith<$Res> {
  __$AttendeeDtoCopyWithImpl(this._self, this._then);

  final _AttendeeDto _self;
  final $Res Function(_AttendeeDto) _then;

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? emailAddress = freezed,
    Object? odataType = freezed,
    Object? type = freezed,
    Object? proposedNewTime = freezed,
    Object? status = freezed,
  }) {
    return _then(_AttendeeDto(
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as EmailAddressDto?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as AttendeeTypeDto?,
      proposedNewTime: freezed == proposedNewTime
          ? _self.proposedNewTime
          : proposedNewTime // ignore: cast_nullable_to_non_nullable
              as TimeSlotDto?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as ResponseStatusDto?,
    ));
  }

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmailAddressDtoCopyWith<$Res>? get emailAddress {
    if (_self.emailAddress == null) {
      return null;
    }

    return $EmailAddressDtoCopyWith<$Res>(_self.emailAddress!, (value) {
      return _then(_self.copyWith(emailAddress: value));
    });
  }

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TimeSlotDtoCopyWith<$Res>? get proposedNewTime {
    if (_self.proposedNewTime == null) {
      return null;
    }

    return $TimeSlotDtoCopyWith<$Res>(_self.proposedNewTime!, (value) {
      return _then(_self.copyWith(proposedNewTime: value));
    });
  }

  /// Create a copy of AttendeeDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseStatusDtoCopyWith<$Res>? get status {
    if (_self.status == null) {
      return null;
    }

    return $ResponseStatusDtoCopyWith<$Res>(_self.status!, (value) {
      return _then(_self.copyWith(status: value));
    });
  }
}

/// @nodoc
mixin _$AuthorisedPickUpDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'indentifyNo')
  String? get indentifyNo;
  @JsonKey(name: 'relationship')
  String? get relationship;
  @JsonKey(name: 'contactNumber')
  String? get contactNumber;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'image')
  String? get image;

  /// Create a copy of AuthorisedPickUpDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AuthorisedPickUpDtoCopyWith<AuthorisedPickUpDto> get copyWith =>
      _$AuthorisedPickUpDtoCopyWithImpl<AuthorisedPickUpDto>(
          this as AuthorisedPickUpDto, _$identity);

  /// Serializes this AuthorisedPickUpDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AuthorisedPickUpDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.indentifyNo, indentifyNo) ||
                other.indentifyNo == indentifyNo) &&
            (identical(other.relationship, relationship) ||
                other.relationship == relationship) &&
            (identical(other.contactNumber, contactNumber) ||
                other.contactNumber == contactNumber) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, studentId, name, indentifyNo,
      relationship, contactNumber, remarks, image);

  @override
  String toString() {
    return 'AuthorisedPickUpDto(id: $id, studentId: $studentId, name: $name, indentifyNo: $indentifyNo, relationship: $relationship, contactNumber: $contactNumber, remarks: $remarks, image: $image)';
  }
}

/// @nodoc
abstract mixin class $AuthorisedPickUpDtoCopyWith<$Res> {
  factory $AuthorisedPickUpDtoCopyWith(
          AuthorisedPickUpDto value, $Res Function(AuthorisedPickUpDto) _then) =
      _$AuthorisedPickUpDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'indentifyNo') String? indentifyNo,
      @JsonKey(name: 'relationship') String? relationship,
      @JsonKey(name: 'contactNumber') String? contactNumber,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'image') String? image});
}

/// @nodoc
class _$AuthorisedPickUpDtoCopyWithImpl<$Res>
    implements $AuthorisedPickUpDtoCopyWith<$Res> {
  _$AuthorisedPickUpDtoCopyWithImpl(this._self, this._then);

  final AuthorisedPickUpDto _self;
  final $Res Function(AuthorisedPickUpDto) _then;

  /// Create a copy of AuthorisedPickUpDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? name = freezed,
    Object? indentifyNo = freezed,
    Object? relationship = freezed,
    Object? contactNumber = freezed,
    Object? remarks = freezed,
    Object? image = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      indentifyNo: freezed == indentifyNo
          ? _self.indentifyNo
          : indentifyNo // ignore: cast_nullable_to_non_nullable
              as String?,
      relationship: freezed == relationship
          ? _self.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as String?,
      contactNumber: freezed == contactNumber
          ? _self.contactNumber
          : contactNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _self.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AuthorisedPickUpDto].
extension AuthorisedPickUpDtoPatterns on AuthorisedPickUpDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AuthorisedPickUpDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPickUpDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AuthorisedPickUpDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPickUpDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AuthorisedPickUpDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPickUpDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'indentifyNo') String? indentifyNo,
            @JsonKey(name: 'relationship') String? relationship,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'image') String? image)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPickUpDto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.name,
            _that.indentifyNo,
            _that.relationship,
            _that.contactNumber,
            _that.remarks,
            _that.image);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'indentifyNo') String? indentifyNo,
            @JsonKey(name: 'relationship') String? relationship,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'image') String? image)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPickUpDto():
        return $default(
            _that.id,
            _that.studentId,
            _that.name,
            _that.indentifyNo,
            _that.relationship,
            _that.contactNumber,
            _that.remarks,
            _that.image);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'indentifyNo') String? indentifyNo,
            @JsonKey(name: 'relationship') String? relationship,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'image') String? image)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPickUpDto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.name,
            _that.indentifyNo,
            _that.relationship,
            _that.contactNumber,
            _that.remarks,
            _that.image);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AuthorisedPickUpDto implements AuthorisedPickUpDto {
  _AuthorisedPickUpDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'indentifyNo') this.indentifyNo,
      @JsonKey(name: 'relationship') this.relationship,
      @JsonKey(name: 'contactNumber') this.contactNumber,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'image') this.image});
  factory _AuthorisedPickUpDto.fromJson(Map<String, dynamic> json) =>
      _$AuthorisedPickUpDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'indentifyNo')
  final String? indentifyNo;
  @override
  @JsonKey(name: 'relationship')
  final String? relationship;
  @override
  @JsonKey(name: 'contactNumber')
  final String? contactNumber;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'image')
  final String? image;

  /// Create a copy of AuthorisedPickUpDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AuthorisedPickUpDtoCopyWith<_AuthorisedPickUpDto> get copyWith =>
      __$AuthorisedPickUpDtoCopyWithImpl<_AuthorisedPickUpDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AuthorisedPickUpDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AuthorisedPickUpDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.indentifyNo, indentifyNo) ||
                other.indentifyNo == indentifyNo) &&
            (identical(other.relationship, relationship) ||
                other.relationship == relationship) &&
            (identical(other.contactNumber, contactNumber) ||
                other.contactNumber == contactNumber) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, studentId, name, indentifyNo,
      relationship, contactNumber, remarks, image);

  @override
  String toString() {
    return 'AuthorisedPickUpDto(id: $id, studentId: $studentId, name: $name, indentifyNo: $indentifyNo, relationship: $relationship, contactNumber: $contactNumber, remarks: $remarks, image: $image)';
  }
}

/// @nodoc
abstract mixin class _$AuthorisedPickUpDtoCopyWith<$Res>
    implements $AuthorisedPickUpDtoCopyWith<$Res> {
  factory _$AuthorisedPickUpDtoCopyWith(_AuthorisedPickUpDto value,
          $Res Function(_AuthorisedPickUpDto) _then) =
      __$AuthorisedPickUpDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'indentifyNo') String? indentifyNo,
      @JsonKey(name: 'relationship') String? relationship,
      @JsonKey(name: 'contactNumber') String? contactNumber,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'image') String? image});
}

/// @nodoc
class __$AuthorisedPickUpDtoCopyWithImpl<$Res>
    implements _$AuthorisedPickUpDtoCopyWith<$Res> {
  __$AuthorisedPickUpDtoCopyWithImpl(this._self, this._then);

  final _AuthorisedPickUpDto _self;
  final $Res Function(_AuthorisedPickUpDto) _then;

  /// Create a copy of AuthorisedPickUpDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? name = freezed,
    Object? indentifyNo = freezed,
    Object? relationship = freezed,
    Object? contactNumber = freezed,
    Object? remarks = freezed,
    Object? image = freezed,
  }) {
    return _then(_AuthorisedPickUpDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      indentifyNo: freezed == indentifyNo
          ? _self.indentifyNo
          : indentifyNo // ignore: cast_nullable_to_non_nullable
              as String?,
      relationship: freezed == relationship
          ? _self.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as String?,
      contactNumber: freezed == contactNumber
          ? _self.contactNumber
          : contactNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _self.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$BookEventRequestParameterDto {
  @JsonKey(name: 'teacherAccountId')
  String? get teacherAccountId;
  @JsonKey(name: 'organiserEmail')
  String? get organiserEmail;
  @JsonKey(name: 'eventId')
  String? get eventId;
  @JsonKey(name: 'studentName')
  String? get studentName;
  @JsonKey(name: 'recipients')
  List<CalendarInviteRecipientDto>? get recipients;

  /// Create a copy of BookEventRequestParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BookEventRequestParameterDtoCopyWith<BookEventRequestParameterDto>
      get copyWith => _$BookEventRequestParameterDtoCopyWithImpl<
              BookEventRequestParameterDto>(
          this as BookEventRequestParameterDto, _$identity);

  /// Serializes this BookEventRequestParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BookEventRequestParameterDto &&
            (identical(other.teacherAccountId, teacherAccountId) ||
                other.teacherAccountId == teacherAccountId) &&
            (identical(other.organiserEmail, organiserEmail) ||
                other.organiserEmail == organiserEmail) &&
            (identical(other.eventId, eventId) || other.eventId == eventId) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName) &&
            const DeepCollectionEquality()
                .equals(other.recipients, recipients));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherAccountId, organiserEmail,
      eventId, studentName, const DeepCollectionEquality().hash(recipients));

  @override
  String toString() {
    return 'BookEventRequestParameterDto(teacherAccountId: $teacherAccountId, organiserEmail: $organiserEmail, eventId: $eventId, studentName: $studentName, recipients: $recipients)';
  }
}

/// @nodoc
abstract mixin class $BookEventRequestParameterDtoCopyWith<$Res> {
  factory $BookEventRequestParameterDtoCopyWith(
          BookEventRequestParameterDto value,
          $Res Function(BookEventRequestParameterDto) _then) =
      _$BookEventRequestParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherAccountId') String? teacherAccountId,
      @JsonKey(name: 'organiserEmail') String? organiserEmail,
      @JsonKey(name: 'eventId') String? eventId,
      @JsonKey(name: 'studentName') String? studentName,
      @JsonKey(name: 'recipients')
      List<CalendarInviteRecipientDto>? recipients});
}

/// @nodoc
class _$BookEventRequestParameterDtoCopyWithImpl<$Res>
    implements $BookEventRequestParameterDtoCopyWith<$Res> {
  _$BookEventRequestParameterDtoCopyWithImpl(this._self, this._then);

  final BookEventRequestParameterDto _self;
  final $Res Function(BookEventRequestParameterDto) _then;

  /// Create a copy of BookEventRequestParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? teacherAccountId = freezed,
    Object? organiserEmail = freezed,
    Object? eventId = freezed,
    Object? studentName = freezed,
    Object? recipients = freezed,
  }) {
    return _then(_self.copyWith(
      teacherAccountId: freezed == teacherAccountId
          ? _self.teacherAccountId
          : teacherAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      organiserEmail: freezed == organiserEmail
          ? _self.organiserEmail
          : organiserEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      eventId: freezed == eventId
          ? _self.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
      recipients: freezed == recipients
          ? _self.recipients
          : recipients // ignore: cast_nullable_to_non_nullable
              as List<CalendarInviteRecipientDto>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [BookEventRequestParameterDto].
extension BookEventRequestParameterDtoPatterns on BookEventRequestParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BookEventRequestParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BookEventRequestParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BookEventRequestParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BookEventRequestParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BookEventRequestParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BookEventRequestParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherAccountId') String? teacherAccountId,
            @JsonKey(name: 'organiserEmail') String? organiserEmail,
            @JsonKey(name: 'eventId') String? eventId,
            @JsonKey(name: 'studentName') String? studentName,
            @JsonKey(name: 'recipients')
            List<CalendarInviteRecipientDto>? recipients)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BookEventRequestParameterDto() when $default != null:
        return $default(_that.teacherAccountId, _that.organiserEmail,
            _that.eventId, _that.studentName, _that.recipients);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherAccountId') String? teacherAccountId,
            @JsonKey(name: 'organiserEmail') String? organiserEmail,
            @JsonKey(name: 'eventId') String? eventId,
            @JsonKey(name: 'studentName') String? studentName,
            @JsonKey(name: 'recipients')
            List<CalendarInviteRecipientDto>? recipients)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BookEventRequestParameterDto():
        return $default(_that.teacherAccountId, _that.organiserEmail,
            _that.eventId, _that.studentName, _that.recipients);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'teacherAccountId') String? teacherAccountId,
            @JsonKey(name: 'organiserEmail') String? organiserEmail,
            @JsonKey(name: 'eventId') String? eventId,
            @JsonKey(name: 'studentName') String? studentName,
            @JsonKey(name: 'recipients')
            List<CalendarInviteRecipientDto>? recipients)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BookEventRequestParameterDto() when $default != null:
        return $default(_that.teacherAccountId, _that.organiserEmail,
            _that.eventId, _that.studentName, _that.recipients);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BookEventRequestParameterDto implements BookEventRequestParameterDto {
  _BookEventRequestParameterDto(
      {@JsonKey(name: 'teacherAccountId') this.teacherAccountId,
      @JsonKey(name: 'organiserEmail') this.organiserEmail,
      @JsonKey(name: 'eventId') this.eventId,
      @JsonKey(name: 'studentName') this.studentName,
      @JsonKey(name: 'recipients')
      final List<CalendarInviteRecipientDto>? recipients})
      : _recipients = recipients;
  factory _BookEventRequestParameterDto.fromJson(Map<String, dynamic> json) =>
      _$BookEventRequestParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'teacherAccountId')
  final String? teacherAccountId;
  @override
  @JsonKey(name: 'organiserEmail')
  final String? organiserEmail;
  @override
  @JsonKey(name: 'eventId')
  final String? eventId;
  @override
  @JsonKey(name: 'studentName')
  final String? studentName;
  final List<CalendarInviteRecipientDto>? _recipients;
  @override
  @JsonKey(name: 'recipients')
  List<CalendarInviteRecipientDto>? get recipients {
    final value = _recipients;
    if (value == null) return null;
    if (_recipients is EqualUnmodifiableListView) return _recipients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of BookEventRequestParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BookEventRequestParameterDtoCopyWith<_BookEventRequestParameterDto>
      get copyWith => __$BookEventRequestParameterDtoCopyWithImpl<
          _BookEventRequestParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BookEventRequestParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BookEventRequestParameterDto &&
            (identical(other.teacherAccountId, teacherAccountId) ||
                other.teacherAccountId == teacherAccountId) &&
            (identical(other.organiserEmail, organiserEmail) ||
                other.organiserEmail == organiserEmail) &&
            (identical(other.eventId, eventId) || other.eventId == eventId) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName) &&
            const DeepCollectionEquality()
                .equals(other._recipients, _recipients));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherAccountId, organiserEmail,
      eventId, studentName, const DeepCollectionEquality().hash(_recipients));

  @override
  String toString() {
    return 'BookEventRequestParameterDto(teacherAccountId: $teacherAccountId, organiserEmail: $organiserEmail, eventId: $eventId, studentName: $studentName, recipients: $recipients)';
  }
}

/// @nodoc
abstract mixin class _$BookEventRequestParameterDtoCopyWith<$Res>
    implements $BookEventRequestParameterDtoCopyWith<$Res> {
  factory _$BookEventRequestParameterDtoCopyWith(
          _BookEventRequestParameterDto value,
          $Res Function(_BookEventRequestParameterDto) _then) =
      __$BookEventRequestParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherAccountId') String? teacherAccountId,
      @JsonKey(name: 'organiserEmail') String? organiserEmail,
      @JsonKey(name: 'eventId') String? eventId,
      @JsonKey(name: 'studentName') String? studentName,
      @JsonKey(name: 'recipients')
      List<CalendarInviteRecipientDto>? recipients});
}

/// @nodoc
class __$BookEventRequestParameterDtoCopyWithImpl<$Res>
    implements _$BookEventRequestParameterDtoCopyWith<$Res> {
  __$BookEventRequestParameterDtoCopyWithImpl(this._self, this._then);

  final _BookEventRequestParameterDto _self;
  final $Res Function(_BookEventRequestParameterDto) _then;

  /// Create a copy of BookEventRequestParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? teacherAccountId = freezed,
    Object? organiserEmail = freezed,
    Object? eventId = freezed,
    Object? studentName = freezed,
    Object? recipients = freezed,
  }) {
    return _then(_BookEventRequestParameterDto(
      teacherAccountId: freezed == teacherAccountId
          ? _self.teacherAccountId
          : teacherAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      organiserEmail: freezed == organiserEmail
          ? _self.organiserEmail
          : organiserEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      eventId: freezed == eventId
          ? _self.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
      recipients: freezed == recipients
          ? _self._recipients
          : recipients // ignore: cast_nullable_to_non_nullable
              as List<CalendarInviteRecipientDto>?,
    ));
  }
}

/// @nodoc
mixin _$CalendarInviteRecipientDto {
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'email')
  String? get email;

  /// Create a copy of CalendarInviteRecipientDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CalendarInviteRecipientDtoCopyWith<CalendarInviteRecipientDto>
      get copyWith =>
          _$CalendarInviteRecipientDtoCopyWithImpl<CalendarInviteRecipientDto>(
              this as CalendarInviteRecipientDto, _$identity);

  /// Serializes this CalendarInviteRecipientDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CalendarInviteRecipientDto &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, email);

  @override
  String toString() {
    return 'CalendarInviteRecipientDto(name: $name, email: $email)';
  }
}

/// @nodoc
abstract mixin class $CalendarInviteRecipientDtoCopyWith<$Res> {
  factory $CalendarInviteRecipientDtoCopyWith(CalendarInviteRecipientDto value,
          $Res Function(CalendarInviteRecipientDto) _then) =
      _$CalendarInviteRecipientDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String? name,
      @JsonKey(name: 'email') String? email});
}

/// @nodoc
class _$CalendarInviteRecipientDtoCopyWithImpl<$Res>
    implements $CalendarInviteRecipientDtoCopyWith<$Res> {
  _$CalendarInviteRecipientDtoCopyWithImpl(this._self, this._then);

  final CalendarInviteRecipientDto _self;
  final $Res Function(CalendarInviteRecipientDto) _then;

  /// Create a copy of CalendarInviteRecipientDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? email = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CalendarInviteRecipientDto].
extension CalendarInviteRecipientDtoPatterns on CalendarInviteRecipientDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CalendarInviteRecipientDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CalendarInviteRecipientDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CalendarInviteRecipientDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarInviteRecipientDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CalendarInviteRecipientDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarInviteRecipientDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CalendarInviteRecipientDto() when $default != null:
        return $default(_that.name, _that.email);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarInviteRecipientDto():
        return $default(_that.name, _that.email);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarInviteRecipientDto() when $default != null:
        return $default(_that.name, _that.email);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CalendarInviteRecipientDto implements CalendarInviteRecipientDto {
  _CalendarInviteRecipientDto(
      {@JsonKey(name: 'name') this.name, @JsonKey(name: 'email') this.email});
  factory _CalendarInviteRecipientDto.fromJson(Map<String, dynamic> json) =>
      _$CalendarInviteRecipientDtoFromJson(json);

  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'email')
  final String? email;

  /// Create a copy of CalendarInviteRecipientDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CalendarInviteRecipientDtoCopyWith<_CalendarInviteRecipientDto>
      get copyWith => __$CalendarInviteRecipientDtoCopyWithImpl<
          _CalendarInviteRecipientDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CalendarInviteRecipientDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CalendarInviteRecipientDto &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, email);

  @override
  String toString() {
    return 'CalendarInviteRecipientDto(name: $name, email: $email)';
  }
}

/// @nodoc
abstract mixin class _$CalendarInviteRecipientDtoCopyWith<$Res>
    implements $CalendarInviteRecipientDtoCopyWith<$Res> {
  factory _$CalendarInviteRecipientDtoCopyWith(
          _CalendarInviteRecipientDto value,
          $Res Function(_CalendarInviteRecipientDto) _then) =
      __$CalendarInviteRecipientDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String? name,
      @JsonKey(name: 'email') String? email});
}

/// @nodoc
class __$CalendarInviteRecipientDtoCopyWithImpl<$Res>
    implements _$CalendarInviteRecipientDtoCopyWith<$Res> {
  __$CalendarInviteRecipientDtoCopyWithImpl(this._self, this._then);

  final _CalendarInviteRecipientDto _self;
  final $Res Function(_CalendarInviteRecipientDto) _then;

  /// Create a copy of CalendarInviteRecipientDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? email = freezed,
  }) {
    return _then(_CalendarInviteRecipientDto(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$CalendarItemParameterDto {
  @JsonKey(name: 'eventId')
  String? get eventId;
  @JsonKey(name: 'email')
  String? get email;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'subject')
  String? get subject;
  @JsonKey(name: 'category')
  String? get category;
  @JsonKey(name: 'startDate')
  DateTime? get startDate;
  @JsonKey(name: 'endDate')
  DateTime? get endDate;
  @JsonKey(name: 'attendees')
  List<AttendeeDto>? get attendees;
  @JsonKey(name: 'isOnlineMeeting')
  bool? get isOnlineMeeting;
  @JsonKey(name: 'resourcePermission')
  ResourcePermissionDto? get resourcePermission;

  /// Create a copy of CalendarItemParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CalendarItemParameterDtoCopyWith<CalendarItemParameterDto> get copyWith =>
      _$CalendarItemParameterDtoCopyWithImpl<CalendarItemParameterDto>(
          this as CalendarItemParameterDto, _$identity);

  /// Serializes this CalendarItemParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CalendarItemParameterDto &&
            (identical(other.eventId, eventId) || other.eventId == eventId) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.subject, subject) || other.subject == subject) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            const DeepCollectionEquality().equals(other.attendees, attendees) &&
            (identical(other.isOnlineMeeting, isOnlineMeeting) ||
                other.isOnlineMeeting == isOnlineMeeting) &&
            (identical(other.resourcePermission, resourcePermission) ||
                other.resourcePermission == resourcePermission));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      eventId,
      email,
      name,
      subject,
      category,
      startDate,
      endDate,
      const DeepCollectionEquality().hash(attendees),
      isOnlineMeeting,
      resourcePermission);

  @override
  String toString() {
    return 'CalendarItemParameterDto(eventId: $eventId, email: $email, name: $name, subject: $subject, category: $category, startDate: $startDate, endDate: $endDate, attendees: $attendees, isOnlineMeeting: $isOnlineMeeting, resourcePermission: $resourcePermission)';
  }
}

/// @nodoc
abstract mixin class $CalendarItemParameterDtoCopyWith<$Res> {
  factory $CalendarItemParameterDtoCopyWith(CalendarItemParameterDto value,
          $Res Function(CalendarItemParameterDto) _then) =
      _$CalendarItemParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'eventId') String? eventId,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'subject') String? subject,
      @JsonKey(name: 'category') String? category,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'attendees') List<AttendeeDto>? attendees,
      @JsonKey(name: 'isOnlineMeeting') bool? isOnlineMeeting,
      @JsonKey(name: 'resourcePermission')
      ResourcePermissionDto? resourcePermission});

  $ResourcePermissionDtoCopyWith<$Res>? get resourcePermission;
}

/// @nodoc
class _$CalendarItemParameterDtoCopyWithImpl<$Res>
    implements $CalendarItemParameterDtoCopyWith<$Res> {
  _$CalendarItemParameterDtoCopyWithImpl(this._self, this._then);

  final CalendarItemParameterDto _self;
  final $Res Function(CalendarItemParameterDto) _then;

  /// Create a copy of CalendarItemParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? eventId = freezed,
    Object? email = freezed,
    Object? name = freezed,
    Object? subject = freezed,
    Object? category = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? attendees = freezed,
    Object? isOnlineMeeting = freezed,
    Object? resourcePermission = freezed,
  }) {
    return _then(_self.copyWith(
      eventId: freezed == eventId
          ? _self.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      subject: freezed == subject
          ? _self.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as String?,
      category: freezed == category
          ? _self.category
          : category // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      attendees: freezed == attendees
          ? _self.attendees
          : attendees // ignore: cast_nullable_to_non_nullable
              as List<AttendeeDto>?,
      isOnlineMeeting: freezed == isOnlineMeeting
          ? _self.isOnlineMeeting
          : isOnlineMeeting // ignore: cast_nullable_to_non_nullable
              as bool?,
      resourcePermission: freezed == resourcePermission
          ? _self.resourcePermission
          : resourcePermission // ignore: cast_nullable_to_non_nullable
              as ResourcePermissionDto?,
    ));
  }

  /// Create a copy of CalendarItemParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResourcePermissionDtoCopyWith<$Res>? get resourcePermission {
    if (_self.resourcePermission == null) {
      return null;
    }

    return $ResourcePermissionDtoCopyWith<$Res>(_self.resourcePermission!,
        (value) {
      return _then(_self.copyWith(resourcePermission: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CalendarItemParameterDto].
extension CalendarItemParameterDtoPatterns on CalendarItemParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CalendarItemParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CalendarItemParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CalendarItemParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CalendarItemParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'eventId') String? eventId,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'subject') String? subject,
            @JsonKey(name: 'category') String? category,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'attendees') List<AttendeeDto>? attendees,
            @JsonKey(name: 'isOnlineMeeting') bool? isOnlineMeeting,
            @JsonKey(name: 'resourcePermission')
            ResourcePermissionDto? resourcePermission)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CalendarItemParameterDto() when $default != null:
        return $default(
            _that.eventId,
            _that.email,
            _that.name,
            _that.subject,
            _that.category,
            _that.startDate,
            _that.endDate,
            _that.attendees,
            _that.isOnlineMeeting,
            _that.resourcePermission);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'eventId') String? eventId,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'subject') String? subject,
            @JsonKey(name: 'category') String? category,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'attendees') List<AttendeeDto>? attendees,
            @JsonKey(name: 'isOnlineMeeting') bool? isOnlineMeeting,
            @JsonKey(name: 'resourcePermission')
            ResourcePermissionDto? resourcePermission)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemParameterDto():
        return $default(
            _that.eventId,
            _that.email,
            _that.name,
            _that.subject,
            _that.category,
            _that.startDate,
            _that.endDate,
            _that.attendees,
            _that.isOnlineMeeting,
            _that.resourcePermission);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'eventId') String? eventId,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'subject') String? subject,
            @JsonKey(name: 'category') String? category,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'attendees') List<AttendeeDto>? attendees,
            @JsonKey(name: 'isOnlineMeeting') bool? isOnlineMeeting,
            @JsonKey(name: 'resourcePermission')
            ResourcePermissionDto? resourcePermission)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemParameterDto() when $default != null:
        return $default(
            _that.eventId,
            _that.email,
            _that.name,
            _that.subject,
            _that.category,
            _that.startDate,
            _that.endDate,
            _that.attendees,
            _that.isOnlineMeeting,
            _that.resourcePermission);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CalendarItemParameterDto implements CalendarItemParameterDto {
  _CalendarItemParameterDto(
      {@JsonKey(name: 'eventId') this.eventId,
      @JsonKey(name: 'email') this.email,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'subject') this.subject,
      @JsonKey(name: 'category') this.category,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'attendees') final List<AttendeeDto>? attendees,
      @JsonKey(name: 'isOnlineMeeting') this.isOnlineMeeting,
      @JsonKey(name: 'resourcePermission') this.resourcePermission})
      : _attendees = attendees;
  factory _CalendarItemParameterDto.fromJson(Map<String, dynamic> json) =>
      _$CalendarItemParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'eventId')
  final String? eventId;
  @override
  @JsonKey(name: 'email')
  final String? email;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'subject')
  final String? subject;
  @override
  @JsonKey(name: 'category')
  final String? category;
  @override
  @JsonKey(name: 'startDate')
  final DateTime? startDate;
  @override
  @JsonKey(name: 'endDate')
  final DateTime? endDate;
  final List<AttendeeDto>? _attendees;
  @override
  @JsonKey(name: 'attendees')
  List<AttendeeDto>? get attendees {
    final value = _attendees;
    if (value == null) return null;
    if (_attendees is EqualUnmodifiableListView) return _attendees;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'isOnlineMeeting')
  final bool? isOnlineMeeting;
  @override
  @JsonKey(name: 'resourcePermission')
  final ResourcePermissionDto? resourcePermission;

  /// Create a copy of CalendarItemParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CalendarItemParameterDtoCopyWith<_CalendarItemParameterDto> get copyWith =>
      __$CalendarItemParameterDtoCopyWithImpl<_CalendarItemParameterDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CalendarItemParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CalendarItemParameterDto &&
            (identical(other.eventId, eventId) || other.eventId == eventId) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.subject, subject) || other.subject == subject) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            const DeepCollectionEquality()
                .equals(other._attendees, _attendees) &&
            (identical(other.isOnlineMeeting, isOnlineMeeting) ||
                other.isOnlineMeeting == isOnlineMeeting) &&
            (identical(other.resourcePermission, resourcePermission) ||
                other.resourcePermission == resourcePermission));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      eventId,
      email,
      name,
      subject,
      category,
      startDate,
      endDate,
      const DeepCollectionEquality().hash(_attendees),
      isOnlineMeeting,
      resourcePermission);

  @override
  String toString() {
    return 'CalendarItemParameterDto(eventId: $eventId, email: $email, name: $name, subject: $subject, category: $category, startDate: $startDate, endDate: $endDate, attendees: $attendees, isOnlineMeeting: $isOnlineMeeting, resourcePermission: $resourcePermission)';
  }
}

/// @nodoc
abstract mixin class _$CalendarItemParameterDtoCopyWith<$Res>
    implements $CalendarItemParameterDtoCopyWith<$Res> {
  factory _$CalendarItemParameterDtoCopyWith(_CalendarItemParameterDto value,
          $Res Function(_CalendarItemParameterDto) _then) =
      __$CalendarItemParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'eventId') String? eventId,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'subject') String? subject,
      @JsonKey(name: 'category') String? category,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'attendees') List<AttendeeDto>? attendees,
      @JsonKey(name: 'isOnlineMeeting') bool? isOnlineMeeting,
      @JsonKey(name: 'resourcePermission')
      ResourcePermissionDto? resourcePermission});

  @override
  $ResourcePermissionDtoCopyWith<$Res>? get resourcePermission;
}

/// @nodoc
class __$CalendarItemParameterDtoCopyWithImpl<$Res>
    implements _$CalendarItemParameterDtoCopyWith<$Res> {
  __$CalendarItemParameterDtoCopyWithImpl(this._self, this._then);

  final _CalendarItemParameterDto _self;
  final $Res Function(_CalendarItemParameterDto) _then;

  /// Create a copy of CalendarItemParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? eventId = freezed,
    Object? email = freezed,
    Object? name = freezed,
    Object? subject = freezed,
    Object? category = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? attendees = freezed,
    Object? isOnlineMeeting = freezed,
    Object? resourcePermission = freezed,
  }) {
    return _then(_CalendarItemParameterDto(
      eventId: freezed == eventId
          ? _self.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      subject: freezed == subject
          ? _self.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as String?,
      category: freezed == category
          ? _self.category
          : category // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      attendees: freezed == attendees
          ? _self._attendees
          : attendees // ignore: cast_nullable_to_non_nullable
              as List<AttendeeDto>?,
      isOnlineMeeting: freezed == isOnlineMeeting
          ? _self.isOnlineMeeting
          : isOnlineMeeting // ignore: cast_nullable_to_non_nullable
              as bool?,
      resourcePermission: freezed == resourcePermission
          ? _self.resourcePermission
          : resourcePermission // ignore: cast_nullable_to_non_nullable
              as ResourcePermissionDto?,
    ));
  }

  /// Create a copy of CalendarItemParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResourcePermissionDtoCopyWith<$Res>? get resourcePermission {
    if (_self.resourcePermission == null) {
      return null;
    }

    return $ResourcePermissionDtoCopyWith<$Res>(_self.resourcePermission!,
        (value) {
      return _then(_self.copyWith(resourcePermission: value));
    });
  }
}

/// @nodoc
mixin _$ChangePasswordParameterDto {
  @JsonKey(name: 'currentPassword')
  String? get currentPassword;
  @JsonKey(name: 'newPassword')
  String? get newPassword;

  /// Create a copy of ChangePasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChangePasswordParameterDtoCopyWith<ChangePasswordParameterDto>
      get copyWith =>
          _$ChangePasswordParameterDtoCopyWithImpl<ChangePasswordParameterDto>(
              this as ChangePasswordParameterDto, _$identity);

  /// Serializes this ChangePasswordParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChangePasswordParameterDto &&
            (identical(other.currentPassword, currentPassword) ||
                other.currentPassword == currentPassword) &&
            (identical(other.newPassword, newPassword) ||
                other.newPassword == newPassword));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, currentPassword, newPassword);

  @override
  String toString() {
    return 'ChangePasswordParameterDto(currentPassword: $currentPassword, newPassword: $newPassword)';
  }
}

/// @nodoc
abstract mixin class $ChangePasswordParameterDtoCopyWith<$Res> {
  factory $ChangePasswordParameterDtoCopyWith(ChangePasswordParameterDto value,
          $Res Function(ChangePasswordParameterDto) _then) =
      _$ChangePasswordParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'currentPassword') String? currentPassword,
      @JsonKey(name: 'newPassword') String? newPassword});
}

/// @nodoc
class _$ChangePasswordParameterDtoCopyWithImpl<$Res>
    implements $ChangePasswordParameterDtoCopyWith<$Res> {
  _$ChangePasswordParameterDtoCopyWithImpl(this._self, this._then);

  final ChangePasswordParameterDto _self;
  final $Res Function(ChangePasswordParameterDto) _then;

  /// Create a copy of ChangePasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPassword = freezed,
    Object? newPassword = freezed,
  }) {
    return _then(_self.copyWith(
      currentPassword: freezed == currentPassword
          ? _self.currentPassword
          : currentPassword // ignore: cast_nullable_to_non_nullable
              as String?,
      newPassword: freezed == newPassword
          ? _self.newPassword
          : newPassword // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChangePasswordParameterDto].
extension ChangePasswordParameterDtoPatterns on ChangePasswordParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChangePasswordParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChangePasswordParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChangePasswordParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChangePasswordParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChangePasswordParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChangePasswordParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'currentPassword') String? currentPassword,
            @JsonKey(name: 'newPassword') String? newPassword)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChangePasswordParameterDto() when $default != null:
        return $default(_that.currentPassword, _that.newPassword);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'currentPassword') String? currentPassword,
            @JsonKey(name: 'newPassword') String? newPassword)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChangePasswordParameterDto():
        return $default(_that.currentPassword, _that.newPassword);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'currentPassword') String? currentPassword,
            @JsonKey(name: 'newPassword') String? newPassword)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChangePasswordParameterDto() when $default != null:
        return $default(_that.currentPassword, _that.newPassword);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChangePasswordParameterDto implements ChangePasswordParameterDto {
  _ChangePasswordParameterDto(
      {@JsonKey(name: 'currentPassword') this.currentPassword,
      @JsonKey(name: 'newPassword') this.newPassword});
  factory _ChangePasswordParameterDto.fromJson(Map<String, dynamic> json) =>
      _$ChangePasswordParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'currentPassword')
  final String? currentPassword;
  @override
  @JsonKey(name: 'newPassword')
  final String? newPassword;

  /// Create a copy of ChangePasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChangePasswordParameterDtoCopyWith<_ChangePasswordParameterDto>
      get copyWith => __$ChangePasswordParameterDtoCopyWithImpl<
          _ChangePasswordParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChangePasswordParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChangePasswordParameterDto &&
            (identical(other.currentPassword, currentPassword) ||
                other.currentPassword == currentPassword) &&
            (identical(other.newPassword, newPassword) ||
                other.newPassword == newPassword));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, currentPassword, newPassword);

  @override
  String toString() {
    return 'ChangePasswordParameterDto(currentPassword: $currentPassword, newPassword: $newPassword)';
  }
}

/// @nodoc
abstract mixin class _$ChangePasswordParameterDtoCopyWith<$Res>
    implements $ChangePasswordParameterDtoCopyWith<$Res> {
  factory _$ChangePasswordParameterDtoCopyWith(
          _ChangePasswordParameterDto value,
          $Res Function(_ChangePasswordParameterDto) _then) =
      __$ChangePasswordParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'currentPassword') String? currentPassword,
      @JsonKey(name: 'newPassword') String? newPassword});
}

/// @nodoc
class __$ChangePasswordParameterDtoCopyWithImpl<$Res>
    implements _$ChangePasswordParameterDtoCopyWith<$Res> {
  __$ChangePasswordParameterDtoCopyWithImpl(this._self, this._then);

  final _ChangePasswordParameterDto _self;
  final $Res Function(_ChangePasswordParameterDto) _then;

  /// Create a copy of ChangePasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? currentPassword = freezed,
    Object? newPassword = freezed,
  }) {
    return _then(_ChangePasswordParameterDto(
      currentPassword: freezed == currentPassword
          ? _self.currentPassword
          : currentPassword // ignore: cast_nullable_to_non_nullable
              as String?,
      newPassword: freezed == newPassword
          ? _self.newPassword
          : newPassword // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$CheckInOutDto {
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'date')
  DateTime get date;
  @JsonKey(name: 'checkType')
  String? get checkType;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'photo')
  String? get photo;
  @JsonKey(name: 'utcDate')
  DateTime? get utcDate;

  /// Create a copy of CheckInOutDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CheckInOutDtoCopyWith<CheckInOutDto> get copyWith =>
      _$CheckInOutDtoCopyWithImpl<CheckInOutDto>(
          this as CheckInOutDto, _$identity);

  /// Serializes this CheckInOutDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CheckInOutDto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, studentId, date, checkType, remarks, photo, utcDate);

  @override
  String toString() {
    return 'CheckInOutDto(studentId: $studentId, date: $date, checkType: $checkType, remarks: $remarks, photo: $photo, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class $CheckInOutDtoCopyWith<$Res> {
  factory $CheckInOutDtoCopyWith(
          CheckInOutDto value, $Res Function(CheckInOutDto) _then) =
      _$CheckInOutDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class _$CheckInOutDtoCopyWithImpl<$Res>
    implements $CheckInOutDtoCopyWith<$Res> {
  _$CheckInOutDtoCopyWithImpl(this._self, this._then);

  final CheckInOutDto _self;
  final $Res Function(CheckInOutDto) _then;

  /// Create a copy of CheckInOutDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentId = null,
    Object? date = null,
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? photo = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_self.copyWith(
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CheckInOutDto].
extension CheckInOutDtoPatterns on CheckInOutDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CheckInOutDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CheckInOutDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CheckInOutDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CheckInOutDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CheckInOutDto() when $default != null:
        return $default(_that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutDto():
        return $default(_that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutDto() when $default != null:
        return $default(_that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CheckInOutDto implements CheckInOutDto {
  _CheckInOutDto(
      {@JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'date') required this.date,
      @JsonKey(name: 'checkType') this.checkType,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'photo') this.photo,
      @JsonKey(name: 'utcDate') this.utcDate});
  factory _CheckInOutDto.fromJson(Map<String, dynamic> json) =>
      _$CheckInOutDtoFromJson(json);

  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'date')
  final DateTime date;
  @override
  @JsonKey(name: 'checkType')
  final String? checkType;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'photo')
  final String? photo;
  @override
  @JsonKey(name: 'utcDate')
  final DateTime? utcDate;

  /// Create a copy of CheckInOutDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CheckInOutDtoCopyWith<_CheckInOutDto> get copyWith =>
      __$CheckInOutDtoCopyWithImpl<_CheckInOutDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CheckInOutDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CheckInOutDto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, studentId, date, checkType, remarks, photo, utcDate);

  @override
  String toString() {
    return 'CheckInOutDto(studentId: $studentId, date: $date, checkType: $checkType, remarks: $remarks, photo: $photo, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class _$CheckInOutDtoCopyWith<$Res>
    implements $CheckInOutDtoCopyWith<$Res> {
  factory _$CheckInOutDtoCopyWith(
          _CheckInOutDto value, $Res Function(_CheckInOutDto) _then) =
      __$CheckInOutDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class __$CheckInOutDtoCopyWithImpl<$Res>
    implements _$CheckInOutDtoCopyWith<$Res> {
  __$CheckInOutDtoCopyWithImpl(this._self, this._then);

  final _CheckInOutDto _self;
  final $Res Function(_CheckInOutDto) _then;

  /// Create a copy of CheckInOutDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentId = null,
    Object? date = null,
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? photo = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_CheckInOutDto(
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$CheckInOutParameterDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'date')
  DateTime get date;
  @JsonKey(name: 'checkType')
  String? get checkType;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'photo')
  String? get photo;
  @JsonKey(name: 'utcDate')
  DateTime? get utcDate;

  /// Create a copy of CheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CheckInOutParameterDtoCopyWith<CheckInOutParameterDto> get copyWith =>
      _$CheckInOutParameterDtoCopyWithImpl<CheckInOutParameterDto>(
          this as CheckInOutParameterDto, _$identity);

  /// Serializes this CheckInOutParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CheckInOutParameterDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, checkType, remarks, photo, utcDate);

  @override
  String toString() {
    return 'CheckInOutParameterDto(id: $id, studentId: $studentId, date: $date, checkType: $checkType, remarks: $remarks, photo: $photo, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class $CheckInOutParameterDtoCopyWith<$Res> {
  factory $CheckInOutParameterDtoCopyWith(CheckInOutParameterDto value,
          $Res Function(CheckInOutParameterDto) _then) =
      _$CheckInOutParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class _$CheckInOutParameterDtoCopyWithImpl<$Res>
    implements $CheckInOutParameterDtoCopyWith<$Res> {
  _$CheckInOutParameterDtoCopyWithImpl(this._self, this._then);

  final CheckInOutParameterDto _self;
  final $Res Function(CheckInOutParameterDto) _then;

  /// Create a copy of CheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? photo = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CheckInOutParameterDto].
extension CheckInOutParameterDtoPatterns on CheckInOutParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CheckInOutParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CheckInOutParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CheckInOutParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CheckInOutParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CheckInOutParameterDto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutParameterDto():
        return $default(_that.id, _that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutParameterDto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CheckInOutParameterDto implements CheckInOutParameterDto {
  _CheckInOutParameterDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'date') required this.date,
      @JsonKey(name: 'checkType') this.checkType,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'photo') this.photo,
      @JsonKey(name: 'utcDate') this.utcDate});
  factory _CheckInOutParameterDto.fromJson(Map<String, dynamic> json) =>
      _$CheckInOutParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'date')
  final DateTime date;
  @override
  @JsonKey(name: 'checkType')
  final String? checkType;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'photo')
  final String? photo;
  @override
  @JsonKey(name: 'utcDate')
  final DateTime? utcDate;

  /// Create a copy of CheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CheckInOutParameterDtoCopyWith<_CheckInOutParameterDto> get copyWith =>
      __$CheckInOutParameterDtoCopyWithImpl<_CheckInOutParameterDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CheckInOutParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CheckInOutParameterDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, checkType, remarks, photo, utcDate);

  @override
  String toString() {
    return 'CheckInOutParameterDto(id: $id, studentId: $studentId, date: $date, checkType: $checkType, remarks: $remarks, photo: $photo, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class _$CheckInOutParameterDtoCopyWith<$Res>
    implements $CheckInOutParameterDtoCopyWith<$Res> {
  factory _$CheckInOutParameterDtoCopyWith(_CheckInOutParameterDto value,
          $Res Function(_CheckInOutParameterDto) _then) =
      __$CheckInOutParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class __$CheckInOutParameterDtoCopyWithImpl<$Res>
    implements _$CheckInOutParameterDtoCopyWith<$Res> {
  __$CheckInOutParameterDtoCopyWithImpl(this._self, this._then);

  final _CheckInOutParameterDto _self;
  final $Res Function(_CheckInOutParameterDto) _then;

  /// Create a copy of CheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? photo = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_CheckInOutParameterDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$CheckInOutVODto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'date')
  DateTime get date;
  @JsonKey(name: 'checkType')
  String? get checkType;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'photo')
  String? get photo;
  @JsonKey(name: 'utcDate')
  DateTime? get utcDate;

  /// Create a copy of CheckInOutVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CheckInOutVODtoCopyWith<CheckInOutVODto> get copyWith =>
      _$CheckInOutVODtoCopyWithImpl<CheckInOutVODto>(
          this as CheckInOutVODto, _$identity);

  /// Serializes this CheckInOutVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CheckInOutVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, checkType, remarks, photo, utcDate);

  @override
  String toString() {
    return 'CheckInOutVODto(id: $id, studentId: $studentId, date: $date, checkType: $checkType, remarks: $remarks, photo: $photo, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class $CheckInOutVODtoCopyWith<$Res> {
  factory $CheckInOutVODtoCopyWith(
          CheckInOutVODto value, $Res Function(CheckInOutVODto) _then) =
      _$CheckInOutVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class _$CheckInOutVODtoCopyWithImpl<$Res>
    implements $CheckInOutVODtoCopyWith<$Res> {
  _$CheckInOutVODtoCopyWithImpl(this._self, this._then);

  final CheckInOutVODto _self;
  final $Res Function(CheckInOutVODto) _then;

  /// Create a copy of CheckInOutVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? photo = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CheckInOutVODto].
extension CheckInOutVODtoPatterns on CheckInOutVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CheckInOutVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CheckInOutVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CheckInOutVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CheckInOutVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CheckInOutVODto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutVODto():
        return $default(_that.id, _that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CheckInOutVODto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date, _that.checkType,
            _that.remarks, _that.photo, _that.utcDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CheckInOutVODto implements CheckInOutVODto {
  _CheckInOutVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'date') required this.date,
      @JsonKey(name: 'checkType') this.checkType,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'photo') this.photo,
      @JsonKey(name: 'utcDate') this.utcDate});
  factory _CheckInOutVODto.fromJson(Map<String, dynamic> json) =>
      _$CheckInOutVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'date')
  final DateTime date;
  @override
  @JsonKey(name: 'checkType')
  final String? checkType;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'photo')
  final String? photo;
  @override
  @JsonKey(name: 'utcDate')
  final DateTime? utcDate;

  /// Create a copy of CheckInOutVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CheckInOutVODtoCopyWith<_CheckInOutVODto> get copyWith =>
      __$CheckInOutVODtoCopyWithImpl<_CheckInOutVODto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CheckInOutVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CheckInOutVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, checkType, remarks, photo, utcDate);

  @override
  String toString() {
    return 'CheckInOutVODto(id: $id, studentId: $studentId, date: $date, checkType: $checkType, remarks: $remarks, photo: $photo, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class _$CheckInOutVODtoCopyWith<$Res>
    implements $CheckInOutVODtoCopyWith<$Res> {
  factory _$CheckInOutVODtoCopyWith(
          _CheckInOutVODto value, $Res Function(_CheckInOutVODto) _then) =
      __$CheckInOutVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class __$CheckInOutVODtoCopyWithImpl<$Res>
    implements _$CheckInOutVODtoCopyWith<$Res> {
  __$CheckInOutVODtoCopyWithImpl(this._self, this._then);

  final _CheckInOutVODto _self;
  final $Res Function(_CheckInOutVODto) _then;

  /// Create a copy of CheckInOutVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? photo = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_CheckInOutVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$ChildConfigVODto {
  @JsonKey(name: 'showBilling')
  bool? get showBilling;
  @JsonKey(name: 'showDailyRoutine')
  bool? get showDailyRoutine;
  @JsonKey(name: 'enablePTCBooking')
  bool? get enablePTCBooking;
  @JsonKey(name: 'enableMedication')
  bool? get enableMedication;
  @JsonKey(name: 'medicationAcceptDays')
  int? get medicationAcceptDays;
  @JsonKey(name: 'medicationAllowBeforeHour')
  int? get medicationAllowBeforeHour;
  @JsonKey(name: 'medicationLimit')
  int? get medicationLimit;

  /// Create a copy of ChildConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChildConfigVODtoCopyWith<ChildConfigVODto> get copyWith =>
      _$ChildConfigVODtoCopyWithImpl<ChildConfigVODto>(
          this as ChildConfigVODto, _$identity);

  /// Serializes this ChildConfigVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChildConfigVODto &&
            (identical(other.showBilling, showBilling) ||
                other.showBilling == showBilling) &&
            (identical(other.showDailyRoutine, showDailyRoutine) ||
                other.showDailyRoutine == showDailyRoutine) &&
            (identical(other.enablePTCBooking, enablePTCBooking) ||
                other.enablePTCBooking == enablePTCBooking) &&
            (identical(other.enableMedication, enableMedication) ||
                other.enableMedication == enableMedication) &&
            (identical(other.medicationAcceptDays, medicationAcceptDays) ||
                other.medicationAcceptDays == medicationAcceptDays) &&
            (identical(other.medicationAllowBeforeHour,
                    medicationAllowBeforeHour) ||
                other.medicationAllowBeforeHour == medicationAllowBeforeHour) &&
            (identical(other.medicationLimit, medicationLimit) ||
                other.medicationLimit == medicationLimit));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      showBilling,
      showDailyRoutine,
      enablePTCBooking,
      enableMedication,
      medicationAcceptDays,
      medicationAllowBeforeHour,
      medicationLimit);

  @override
  String toString() {
    return 'ChildConfigVODto(showBilling: $showBilling, showDailyRoutine: $showDailyRoutine, enablePTCBooking: $enablePTCBooking, enableMedication: $enableMedication, medicationAcceptDays: $medicationAcceptDays, medicationAllowBeforeHour: $medicationAllowBeforeHour, medicationLimit: $medicationLimit)';
  }
}

/// @nodoc
abstract mixin class $ChildConfigVODtoCopyWith<$Res> {
  factory $ChildConfigVODtoCopyWith(
          ChildConfigVODto value, $Res Function(ChildConfigVODto) _then) =
      _$ChildConfigVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'showBilling') bool? showBilling,
      @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
      @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking,
      @JsonKey(name: 'enableMedication') bool? enableMedication,
      @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
      @JsonKey(name: 'medicationAllowBeforeHour')
      int? medicationAllowBeforeHour,
      @JsonKey(name: 'medicationLimit') int? medicationLimit});
}

/// @nodoc
class _$ChildConfigVODtoCopyWithImpl<$Res>
    implements $ChildConfigVODtoCopyWith<$Res> {
  _$ChildConfigVODtoCopyWithImpl(this._self, this._then);

  final ChildConfigVODto _self;
  final $Res Function(ChildConfigVODto) _then;

  /// Create a copy of ChildConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? showBilling = freezed,
    Object? showDailyRoutine = freezed,
    Object? enablePTCBooking = freezed,
    Object? enableMedication = freezed,
    Object? medicationAcceptDays = freezed,
    Object? medicationAllowBeforeHour = freezed,
    Object? medicationLimit = freezed,
  }) {
    return _then(_self.copyWith(
      showBilling: freezed == showBilling
          ? _self.showBilling
          : showBilling // ignore: cast_nullable_to_non_nullable
              as bool?,
      showDailyRoutine: freezed == showDailyRoutine
          ? _self.showDailyRoutine
          : showDailyRoutine // ignore: cast_nullable_to_non_nullable
              as bool?,
      enablePTCBooking: freezed == enablePTCBooking
          ? _self.enablePTCBooking
          : enablePTCBooking // ignore: cast_nullable_to_non_nullable
              as bool?,
      enableMedication: freezed == enableMedication
          ? _self.enableMedication
          : enableMedication // ignore: cast_nullable_to_non_nullable
              as bool?,
      medicationAcceptDays: freezed == medicationAcceptDays
          ? _self.medicationAcceptDays
          : medicationAcceptDays // ignore: cast_nullable_to_non_nullable
              as int?,
      medicationAllowBeforeHour: freezed == medicationAllowBeforeHour
          ? _self.medicationAllowBeforeHour
          : medicationAllowBeforeHour // ignore: cast_nullable_to_non_nullable
              as int?,
      medicationLimit: freezed == medicationLimit
          ? _self.medicationLimit
          : medicationLimit // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChildConfigVODto].
extension ChildConfigVODtoPatterns on ChildConfigVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChildConfigVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChildConfigVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChildConfigVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChildConfigVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChildConfigVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChildConfigVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'showBilling') bool? showBilling,
            @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
            @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking,
            @JsonKey(name: 'enableMedication') bool? enableMedication,
            @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
            @JsonKey(name: 'medicationAllowBeforeHour')
            int? medicationAllowBeforeHour,
            @JsonKey(name: 'medicationLimit') int? medicationLimit)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChildConfigVODto() when $default != null:
        return $default(
            _that.showBilling,
            _that.showDailyRoutine,
            _that.enablePTCBooking,
            _that.enableMedication,
            _that.medicationAcceptDays,
            _that.medicationAllowBeforeHour,
            _that.medicationLimit);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'showBilling') bool? showBilling,
            @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
            @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking,
            @JsonKey(name: 'enableMedication') bool? enableMedication,
            @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
            @JsonKey(name: 'medicationAllowBeforeHour')
            int? medicationAllowBeforeHour,
            @JsonKey(name: 'medicationLimit') int? medicationLimit)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChildConfigVODto():
        return $default(
            _that.showBilling,
            _that.showDailyRoutine,
            _that.enablePTCBooking,
            _that.enableMedication,
            _that.medicationAcceptDays,
            _that.medicationAllowBeforeHour,
            _that.medicationLimit);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'showBilling') bool? showBilling,
            @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
            @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking,
            @JsonKey(name: 'enableMedication') bool? enableMedication,
            @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
            @JsonKey(name: 'medicationAllowBeforeHour')
            int? medicationAllowBeforeHour,
            @JsonKey(name: 'medicationLimit') int? medicationLimit)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChildConfigVODto() when $default != null:
        return $default(
            _that.showBilling,
            _that.showDailyRoutine,
            _that.enablePTCBooking,
            _that.enableMedication,
            _that.medicationAcceptDays,
            _that.medicationAllowBeforeHour,
            _that.medicationLimit);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChildConfigVODto implements ChildConfigVODto {
  _ChildConfigVODto(
      {@JsonKey(name: 'showBilling') this.showBilling,
      @JsonKey(name: 'showDailyRoutine') this.showDailyRoutine,
      @JsonKey(name: 'enablePTCBooking') this.enablePTCBooking,
      @JsonKey(name: 'enableMedication') this.enableMedication,
      @JsonKey(name: 'medicationAcceptDays') this.medicationAcceptDays,
      @JsonKey(name: 'medicationAllowBeforeHour')
      this.medicationAllowBeforeHour,
      @JsonKey(name: 'medicationLimit') this.medicationLimit});
  factory _ChildConfigVODto.fromJson(Map<String, dynamic> json) =>
      _$ChildConfigVODtoFromJson(json);

  @override
  @JsonKey(name: 'showBilling')
  final bool? showBilling;
  @override
  @JsonKey(name: 'showDailyRoutine')
  final bool? showDailyRoutine;
  @override
  @JsonKey(name: 'enablePTCBooking')
  final bool? enablePTCBooking;
  @override
  @JsonKey(name: 'enableMedication')
  final bool? enableMedication;
  @override
  @JsonKey(name: 'medicationAcceptDays')
  final int? medicationAcceptDays;
  @override
  @JsonKey(name: 'medicationAllowBeforeHour')
  final int? medicationAllowBeforeHour;
  @override
  @JsonKey(name: 'medicationLimit')
  final int? medicationLimit;

  /// Create a copy of ChildConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChildConfigVODtoCopyWith<_ChildConfigVODto> get copyWith =>
      __$ChildConfigVODtoCopyWithImpl<_ChildConfigVODto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChildConfigVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChildConfigVODto &&
            (identical(other.showBilling, showBilling) ||
                other.showBilling == showBilling) &&
            (identical(other.showDailyRoutine, showDailyRoutine) ||
                other.showDailyRoutine == showDailyRoutine) &&
            (identical(other.enablePTCBooking, enablePTCBooking) ||
                other.enablePTCBooking == enablePTCBooking) &&
            (identical(other.enableMedication, enableMedication) ||
                other.enableMedication == enableMedication) &&
            (identical(other.medicationAcceptDays, medicationAcceptDays) ||
                other.medicationAcceptDays == medicationAcceptDays) &&
            (identical(other.medicationAllowBeforeHour,
                    medicationAllowBeforeHour) ||
                other.medicationAllowBeforeHour == medicationAllowBeforeHour) &&
            (identical(other.medicationLimit, medicationLimit) ||
                other.medicationLimit == medicationLimit));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      showBilling,
      showDailyRoutine,
      enablePTCBooking,
      enableMedication,
      medicationAcceptDays,
      medicationAllowBeforeHour,
      medicationLimit);

  @override
  String toString() {
    return 'ChildConfigVODto(showBilling: $showBilling, showDailyRoutine: $showDailyRoutine, enablePTCBooking: $enablePTCBooking, enableMedication: $enableMedication, medicationAcceptDays: $medicationAcceptDays, medicationAllowBeforeHour: $medicationAllowBeforeHour, medicationLimit: $medicationLimit)';
  }
}

/// @nodoc
abstract mixin class _$ChildConfigVODtoCopyWith<$Res>
    implements $ChildConfigVODtoCopyWith<$Res> {
  factory _$ChildConfigVODtoCopyWith(
          _ChildConfigVODto value, $Res Function(_ChildConfigVODto) _then) =
      __$ChildConfigVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'showBilling') bool? showBilling,
      @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
      @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking,
      @JsonKey(name: 'enableMedication') bool? enableMedication,
      @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
      @JsonKey(name: 'medicationAllowBeforeHour')
      int? medicationAllowBeforeHour,
      @JsonKey(name: 'medicationLimit') int? medicationLimit});
}

/// @nodoc
class __$ChildConfigVODtoCopyWithImpl<$Res>
    implements _$ChildConfigVODtoCopyWith<$Res> {
  __$ChildConfigVODtoCopyWithImpl(this._self, this._then);

  final _ChildConfigVODto _self;
  final $Res Function(_ChildConfigVODto) _then;

  /// Create a copy of ChildConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? showBilling = freezed,
    Object? showDailyRoutine = freezed,
    Object? enablePTCBooking = freezed,
    Object? enableMedication = freezed,
    Object? medicationAcceptDays = freezed,
    Object? medicationAllowBeforeHour = freezed,
    Object? medicationLimit = freezed,
  }) {
    return _then(_ChildConfigVODto(
      showBilling: freezed == showBilling
          ? _self.showBilling
          : showBilling // ignore: cast_nullable_to_non_nullable
              as bool?,
      showDailyRoutine: freezed == showDailyRoutine
          ? _self.showDailyRoutine
          : showDailyRoutine // ignore: cast_nullable_to_non_nullable
              as bool?,
      enablePTCBooking: freezed == enablePTCBooking
          ? _self.enablePTCBooking
          : enablePTCBooking // ignore: cast_nullable_to_non_nullable
              as bool?,
      enableMedication: freezed == enableMedication
          ? _self.enableMedication
          : enableMedication // ignore: cast_nullable_to_non_nullable
              as bool?,
      medicationAcceptDays: freezed == medicationAcceptDays
          ? _self.medicationAcceptDays
          : medicationAcceptDays // ignore: cast_nullable_to_non_nullable
              as int?,
      medicationAllowBeforeHour: freezed == medicationAllowBeforeHour
          ? _self.medicationAllowBeforeHour
          : medicationAllowBeforeHour // ignore: cast_nullable_to_non_nullable
              as int?,
      medicationLimit: freezed == medicationLimit
          ? _self.medicationLimit
          : medicationLimit // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$CommunicationsParameterDto {
  @JsonKey(name: 'topic')
  String? get topic;
  @JsonKey(name: 'notificationType')
  String? get notificationType;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'body')
  String? get body;
  @JsonKey(name: 'referenceId')
  String? get referenceId;
  @JsonKey(name: 'notificationIds')
  String? get notificationIds;

  /// Create a copy of CommunicationsParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CommunicationsParameterDtoCopyWith<CommunicationsParameterDto>
      get copyWith =>
          _$CommunicationsParameterDtoCopyWithImpl<CommunicationsParameterDto>(
              this as CommunicationsParameterDto, _$identity);

  /// Serializes this CommunicationsParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CommunicationsParameterDto &&
            (identical(other.topic, topic) || other.topic == topic) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.referenceId, referenceId) ||
                other.referenceId == referenceId) &&
            (identical(other.notificationIds, notificationIds) ||
                other.notificationIds == notificationIds));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, topic, notificationType, title,
      body, referenceId, notificationIds);

  @override
  String toString() {
    return 'CommunicationsParameterDto(topic: $topic, notificationType: $notificationType, title: $title, body: $body, referenceId: $referenceId, notificationIds: $notificationIds)';
  }
}

/// @nodoc
abstract mixin class $CommunicationsParameterDtoCopyWith<$Res> {
  factory $CommunicationsParameterDtoCopyWith(CommunicationsParameterDto value,
          $Res Function(CommunicationsParameterDto) _then) =
      _$CommunicationsParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'topic') String? topic,
      @JsonKey(name: 'notificationType') String? notificationType,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'body') String? body,
      @JsonKey(name: 'referenceId') String? referenceId,
      @JsonKey(name: 'notificationIds') String? notificationIds});
}

/// @nodoc
class _$CommunicationsParameterDtoCopyWithImpl<$Res>
    implements $CommunicationsParameterDtoCopyWith<$Res> {
  _$CommunicationsParameterDtoCopyWithImpl(this._self, this._then);

  final CommunicationsParameterDto _self;
  final $Res Function(CommunicationsParameterDto) _then;

  /// Create a copy of CommunicationsParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? topic = freezed,
    Object? notificationType = freezed,
    Object? title = freezed,
    Object? body = freezed,
    Object? referenceId = freezed,
    Object? notificationIds = freezed,
  }) {
    return _then(_self.copyWith(
      topic: freezed == topic
          ? _self.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      referenceId: freezed == referenceId
          ? _self.referenceId
          : referenceId // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationIds: freezed == notificationIds
          ? _self.notificationIds
          : notificationIds // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CommunicationsParameterDto].
extension CommunicationsParameterDtoPatterns on CommunicationsParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CommunicationsParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CommunicationsParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CommunicationsParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CommunicationsParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CommunicationsParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CommunicationsParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'topic') String? topic,
            @JsonKey(name: 'notificationType') String? notificationType,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'referenceId') String? referenceId,
            @JsonKey(name: 'notificationIds') String? notificationIds)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CommunicationsParameterDto() when $default != null:
        return $default(_that.topic, _that.notificationType, _that.title,
            _that.body, _that.referenceId, _that.notificationIds);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'topic') String? topic,
            @JsonKey(name: 'notificationType') String? notificationType,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'referenceId') String? referenceId,
            @JsonKey(name: 'notificationIds') String? notificationIds)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CommunicationsParameterDto():
        return $default(_that.topic, _that.notificationType, _that.title,
            _that.body, _that.referenceId, _that.notificationIds);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'topic') String? topic,
            @JsonKey(name: 'notificationType') String? notificationType,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'referenceId') String? referenceId,
            @JsonKey(name: 'notificationIds') String? notificationIds)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CommunicationsParameterDto() when $default != null:
        return $default(_that.topic, _that.notificationType, _that.title,
            _that.body, _that.referenceId, _that.notificationIds);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CommunicationsParameterDto implements CommunicationsParameterDto {
  _CommunicationsParameterDto(
      {@JsonKey(name: 'topic') this.topic,
      @JsonKey(name: 'notificationType') this.notificationType,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'body') this.body,
      @JsonKey(name: 'referenceId') this.referenceId,
      @JsonKey(name: 'notificationIds') this.notificationIds});
  factory _CommunicationsParameterDto.fromJson(Map<String, dynamic> json) =>
      _$CommunicationsParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'topic')
  final String? topic;
  @override
  @JsonKey(name: 'notificationType')
  final String? notificationType;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'body')
  final String? body;
  @override
  @JsonKey(name: 'referenceId')
  final String? referenceId;
  @override
  @JsonKey(name: 'notificationIds')
  final String? notificationIds;

  /// Create a copy of CommunicationsParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CommunicationsParameterDtoCopyWith<_CommunicationsParameterDto>
      get copyWith => __$CommunicationsParameterDtoCopyWithImpl<
          _CommunicationsParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CommunicationsParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CommunicationsParameterDto &&
            (identical(other.topic, topic) || other.topic == topic) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.referenceId, referenceId) ||
                other.referenceId == referenceId) &&
            (identical(other.notificationIds, notificationIds) ||
                other.notificationIds == notificationIds));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, topic, notificationType, title,
      body, referenceId, notificationIds);

  @override
  String toString() {
    return 'CommunicationsParameterDto(topic: $topic, notificationType: $notificationType, title: $title, body: $body, referenceId: $referenceId, notificationIds: $notificationIds)';
  }
}

/// @nodoc
abstract mixin class _$CommunicationsParameterDtoCopyWith<$Res>
    implements $CommunicationsParameterDtoCopyWith<$Res> {
  factory _$CommunicationsParameterDtoCopyWith(
          _CommunicationsParameterDto value,
          $Res Function(_CommunicationsParameterDto) _then) =
      __$CommunicationsParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'topic') String? topic,
      @JsonKey(name: 'notificationType') String? notificationType,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'body') String? body,
      @JsonKey(name: 'referenceId') String? referenceId,
      @JsonKey(name: 'notificationIds') String? notificationIds});
}

/// @nodoc
class __$CommunicationsParameterDtoCopyWithImpl<$Res>
    implements _$CommunicationsParameterDtoCopyWith<$Res> {
  __$CommunicationsParameterDtoCopyWithImpl(this._self, this._then);

  final _CommunicationsParameterDto _self;
  final $Res Function(_CommunicationsParameterDto) _then;

  /// Create a copy of CommunicationsParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? topic = freezed,
    Object? notificationType = freezed,
    Object? title = freezed,
    Object? body = freezed,
    Object? referenceId = freezed,
    Object? notificationIds = freezed,
  }) {
    return _then(_CommunicationsParameterDto(
      topic: freezed == topic
          ? _self.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      referenceId: freezed == referenceId
          ? _self.referenceId
          : referenceId // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationIds: freezed == notificationIds
          ? _self.notificationIds
          : notificationIds // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ContactInfoDto {
  @JsonKey(name: 'accountId')
  String get accountId;
  @JsonKey(name: 'mobilePhone')
  String? get mobilePhone;
  @JsonKey(name: 'homePhone')
  String? get homePhone;
  @JsonKey(name: 'emailAddress')
  String? get emailAddress;

  /// Create a copy of ContactInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ContactInfoDtoCopyWith<ContactInfoDto> get copyWith =>
      _$ContactInfoDtoCopyWithImpl<ContactInfoDto>(
          this as ContactInfoDto, _$identity);

  /// Serializes this ContactInfoDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ContactInfoDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.mobilePhone, mobilePhone) ||
                other.mobilePhone == mobilePhone) &&
            (identical(other.homePhone, homePhone) ||
                other.homePhone == homePhone) &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, accountId, mobilePhone, homePhone, emailAddress);

  @override
  String toString() {
    return 'ContactInfoDto(accountId: $accountId, mobilePhone: $mobilePhone, homePhone: $homePhone, emailAddress: $emailAddress)';
  }
}

/// @nodoc
abstract mixin class $ContactInfoDtoCopyWith<$Res> {
  factory $ContactInfoDtoCopyWith(
          ContactInfoDto value, $Res Function(ContactInfoDto) _then) =
      _$ContactInfoDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') String accountId,
      @JsonKey(name: 'mobilePhone') String? mobilePhone,
      @JsonKey(name: 'homePhone') String? homePhone,
      @JsonKey(name: 'emailAddress') String? emailAddress});
}

/// @nodoc
class _$ContactInfoDtoCopyWithImpl<$Res>
    implements $ContactInfoDtoCopyWith<$Res> {
  _$ContactInfoDtoCopyWithImpl(this._self, this._then);

  final ContactInfoDto _self;
  final $Res Function(ContactInfoDto) _then;

  /// Create a copy of ContactInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountId = null,
    Object? mobilePhone = freezed,
    Object? homePhone = freezed,
    Object? emailAddress = freezed,
  }) {
    return _then(_self.copyWith(
      accountId: null == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String,
      mobilePhone: freezed == mobilePhone
          ? _self.mobilePhone
          : mobilePhone // ignore: cast_nullable_to_non_nullable
              as String?,
      homePhone: freezed == homePhone
          ? _self.homePhone
          : homePhone // ignore: cast_nullable_to_non_nullable
              as String?,
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ContactInfoDto].
extension ContactInfoDtoPatterns on ContactInfoDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ContactInfoDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ContactInfoDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ContactInfoDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactInfoDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ContactInfoDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactInfoDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') String accountId,
            @JsonKey(name: 'mobilePhone') String? mobilePhone,
            @JsonKey(name: 'homePhone') String? homePhone,
            @JsonKey(name: 'emailAddress') String? emailAddress)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ContactInfoDto() when $default != null:
        return $default(_that.accountId, _that.mobilePhone, _that.homePhone,
            _that.emailAddress);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') String accountId,
            @JsonKey(name: 'mobilePhone') String? mobilePhone,
            @JsonKey(name: 'homePhone') String? homePhone,
            @JsonKey(name: 'emailAddress') String? emailAddress)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactInfoDto():
        return $default(_that.accountId, _that.mobilePhone, _that.homePhone,
            _that.emailAddress);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'accountId') String accountId,
            @JsonKey(name: 'mobilePhone') String? mobilePhone,
            @JsonKey(name: 'homePhone') String? homePhone,
            @JsonKey(name: 'emailAddress') String? emailAddress)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactInfoDto() when $default != null:
        return $default(_that.accountId, _that.mobilePhone, _that.homePhone,
            _that.emailAddress);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ContactInfoDto implements ContactInfoDto {
  _ContactInfoDto(
      {@JsonKey(name: 'accountId') required this.accountId,
      @JsonKey(name: 'mobilePhone') this.mobilePhone,
      @JsonKey(name: 'homePhone') this.homePhone,
      @JsonKey(name: 'emailAddress') this.emailAddress});
  factory _ContactInfoDto.fromJson(Map<String, dynamic> json) =>
      _$ContactInfoDtoFromJson(json);

  @override
  @JsonKey(name: 'accountId')
  final String accountId;
  @override
  @JsonKey(name: 'mobilePhone')
  final String? mobilePhone;
  @override
  @JsonKey(name: 'homePhone')
  final String? homePhone;
  @override
  @JsonKey(name: 'emailAddress')
  final String? emailAddress;

  /// Create a copy of ContactInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ContactInfoDtoCopyWith<_ContactInfoDto> get copyWith =>
      __$ContactInfoDtoCopyWithImpl<_ContactInfoDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ContactInfoDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ContactInfoDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.mobilePhone, mobilePhone) ||
                other.mobilePhone == mobilePhone) &&
            (identical(other.homePhone, homePhone) ||
                other.homePhone == homePhone) &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, accountId, mobilePhone, homePhone, emailAddress);

  @override
  String toString() {
    return 'ContactInfoDto(accountId: $accountId, mobilePhone: $mobilePhone, homePhone: $homePhone, emailAddress: $emailAddress)';
  }
}

/// @nodoc
abstract mixin class _$ContactInfoDtoCopyWith<$Res>
    implements $ContactInfoDtoCopyWith<$Res> {
  factory _$ContactInfoDtoCopyWith(
          _ContactInfoDto value, $Res Function(_ContactInfoDto) _then) =
      __$ContactInfoDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') String accountId,
      @JsonKey(name: 'mobilePhone') String? mobilePhone,
      @JsonKey(name: 'homePhone') String? homePhone,
      @JsonKey(name: 'emailAddress') String? emailAddress});
}

/// @nodoc
class __$ContactInfoDtoCopyWithImpl<$Res>
    implements _$ContactInfoDtoCopyWith<$Res> {
  __$ContactInfoDtoCopyWithImpl(this._self, this._then);

  final _ContactInfoDto _self;
  final $Res Function(_ContactInfoDto) _then;

  /// Create a copy of ContactInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? accountId = null,
    Object? mobilePhone = freezed,
    Object? homePhone = freezed,
    Object? emailAddress = freezed,
  }) {
    return _then(_ContactInfoDto(
      accountId: null == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String,
      mobilePhone: freezed == mobilePhone
          ? _self.mobilePhone
          : mobilePhone // ignore: cast_nullable_to_non_nullable
              as String?,
      homePhone: freezed == homePhone
          ? _self.homePhone
          : homePhone // ignore: cast_nullable_to_non_nullable
              as String?,
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$CourseComponentAttendanceDto {
  @JsonKey(name: 'createdById')
  String? get createdById;
  @JsonKey(name: 'createdDateTime')
  DateTime? get createdDateTime;
  @JsonKey(name: 'lastModifiedById')
  String? get lastModifiedById;
  @JsonKey(name: 'lastModifiedDateTime')
  DateTime? get lastModifiedDateTime;
  @JsonKey(name: 'createdByName')
  String? get createdByName;
  @JsonKey(name: 'lastModifiedByName')
  String? get lastModifiedByName;
  @JsonKey(name: 'courseComponentId')
  int? get courseComponentId;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'attendanceDate')
  DateTime? get attendanceDate;
  @JsonKey(name: 'attendanceStatus')
  String? get attendanceStatus;
  @JsonKey(name: 'attendanceRemarks')
  String? get attendanceRemarks;

  /// Create a copy of CourseComponentAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CourseComponentAttendanceDtoCopyWith<CourseComponentAttendanceDto>
      get copyWith => _$CourseComponentAttendanceDtoCopyWithImpl<
              CourseComponentAttendanceDto>(
          this as CourseComponentAttendanceDto, _$identity);

  /// Serializes this CourseComponentAttendanceDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CourseComponentAttendanceDto &&
            (identical(other.createdById, createdById) ||
                other.createdById == createdById) &&
            (identical(other.createdDateTime, createdDateTime) ||
                other.createdDateTime == createdDateTime) &&
            (identical(other.lastModifiedById, lastModifiedById) ||
                other.lastModifiedById == lastModifiedById) &&
            (identical(other.lastModifiedDateTime, lastModifiedDateTime) ||
                other.lastModifiedDateTime == lastModifiedDateTime) &&
            (identical(other.createdByName, createdByName) ||
                other.createdByName == createdByName) &&
            (identical(other.lastModifiedByName, lastModifiedByName) ||
                other.lastModifiedByName == lastModifiedByName) &&
            (identical(other.courseComponentId, courseComponentId) ||
                other.courseComponentId == courseComponentId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.attendanceDate, attendanceDate) ||
                other.attendanceDate == attendanceDate) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.attendanceRemarks, attendanceRemarks) ||
                other.attendanceRemarks == attendanceRemarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      createdById,
      createdDateTime,
      lastModifiedById,
      lastModifiedDateTime,
      createdByName,
      lastModifiedByName,
      courseComponentId,
      studentId,
      attendanceDate,
      attendanceStatus,
      attendanceRemarks);

  @override
  String toString() {
    return 'CourseComponentAttendanceDto(createdById: $createdById, createdDateTime: $createdDateTime, lastModifiedById: $lastModifiedById, lastModifiedDateTime: $lastModifiedDateTime, createdByName: $createdByName, lastModifiedByName: $lastModifiedByName, courseComponentId: $courseComponentId, studentId: $studentId, attendanceDate: $attendanceDate, attendanceStatus: $attendanceStatus, attendanceRemarks: $attendanceRemarks)';
  }
}

/// @nodoc
abstract mixin class $CourseComponentAttendanceDtoCopyWith<$Res> {
  factory $CourseComponentAttendanceDtoCopyWith(
          CourseComponentAttendanceDto value,
          $Res Function(CourseComponentAttendanceDto) _then) =
      _$CourseComponentAttendanceDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'createdById') String? createdById,
      @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
      @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
      @JsonKey(name: 'lastModifiedDateTime') DateTime? lastModifiedDateTime,
      @JsonKey(name: 'createdByName') String? createdByName,
      @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
      @JsonKey(name: 'courseComponentId') int? courseComponentId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'attendanceRemarks') String? attendanceRemarks});
}

/// @nodoc
class _$CourseComponentAttendanceDtoCopyWithImpl<$Res>
    implements $CourseComponentAttendanceDtoCopyWith<$Res> {
  _$CourseComponentAttendanceDtoCopyWithImpl(this._self, this._then);

  final CourseComponentAttendanceDto _self;
  final $Res Function(CourseComponentAttendanceDto) _then;

  /// Create a copy of CourseComponentAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? createdById = freezed,
    Object? createdDateTime = freezed,
    Object? lastModifiedById = freezed,
    Object? lastModifiedDateTime = freezed,
    Object? createdByName = freezed,
    Object? lastModifiedByName = freezed,
    Object? courseComponentId = freezed,
    Object? studentId = freezed,
    Object? attendanceDate = freezed,
    Object? attendanceStatus = freezed,
    Object? attendanceRemarks = freezed,
  }) {
    return _then(_self.copyWith(
      createdById: freezed == createdById
          ? _self.createdById
          : createdById // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDateTime: freezed == createdDateTime
          ? _self.createdDateTime
          : createdDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastModifiedById: freezed == lastModifiedById
          ? _self.lastModifiedById
          : lastModifiedById // ignore: cast_nullable_to_non_nullable
              as String?,
      lastModifiedDateTime: freezed == lastModifiedDateTime
          ? _self.lastModifiedDateTime
          : lastModifiedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdByName: freezed == createdByName
          ? _self.createdByName
          : createdByName // ignore: cast_nullable_to_non_nullable
              as String?,
      lastModifiedByName: freezed == lastModifiedByName
          ? _self.lastModifiedByName
          : lastModifiedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      courseComponentId: freezed == courseComponentId
          ? _self.courseComponentId
          : courseComponentId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceDate: freezed == attendanceDate
          ? _self.attendanceDate
          : attendanceDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceRemarks: freezed == attendanceRemarks
          ? _self.attendanceRemarks
          : attendanceRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CourseComponentAttendanceDto].
extension CourseComponentAttendanceDtoPatterns on CourseComponentAttendanceDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CourseComponentAttendanceDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CourseComponentAttendanceDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CourseComponentAttendanceDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'createdById') String? createdById,
            @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
            @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
            @JsonKey(name: 'lastModifiedDateTime')
            DateTime? lastModifiedDateTime,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'attendanceRemarks') String? attendanceRemarks)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceDto() when $default != null:
        return $default(
            _that.createdById,
            _that.createdDateTime,
            _that.lastModifiedById,
            _that.lastModifiedDateTime,
            _that.createdByName,
            _that.lastModifiedByName,
            _that.courseComponentId,
            _that.studentId,
            _that.attendanceDate,
            _that.attendanceStatus,
            _that.attendanceRemarks);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'createdById') String? createdById,
            @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
            @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
            @JsonKey(name: 'lastModifiedDateTime')
            DateTime? lastModifiedDateTime,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'attendanceRemarks') String? attendanceRemarks)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceDto():
        return $default(
            _that.createdById,
            _that.createdDateTime,
            _that.lastModifiedById,
            _that.lastModifiedDateTime,
            _that.createdByName,
            _that.lastModifiedByName,
            _that.courseComponentId,
            _that.studentId,
            _that.attendanceDate,
            _that.attendanceStatus,
            _that.attendanceRemarks);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'createdById') String? createdById,
            @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
            @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
            @JsonKey(name: 'lastModifiedDateTime')
            DateTime? lastModifiedDateTime,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'attendanceRemarks') String? attendanceRemarks)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceDto() when $default != null:
        return $default(
            _that.createdById,
            _that.createdDateTime,
            _that.lastModifiedById,
            _that.lastModifiedDateTime,
            _that.createdByName,
            _that.lastModifiedByName,
            _that.courseComponentId,
            _that.studentId,
            _that.attendanceDate,
            _that.attendanceStatus,
            _that.attendanceRemarks);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CourseComponentAttendanceDto implements CourseComponentAttendanceDto {
  _CourseComponentAttendanceDto(
      {@JsonKey(name: 'createdById') this.createdById,
      @JsonKey(name: 'createdDateTime') this.createdDateTime,
      @JsonKey(name: 'lastModifiedById') this.lastModifiedById,
      @JsonKey(name: 'lastModifiedDateTime') this.lastModifiedDateTime,
      @JsonKey(name: 'createdByName') this.createdByName,
      @JsonKey(name: 'lastModifiedByName') this.lastModifiedByName,
      @JsonKey(name: 'courseComponentId') this.courseComponentId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'attendanceDate') this.attendanceDate,
      @JsonKey(name: 'attendanceStatus') this.attendanceStatus,
      @JsonKey(name: 'attendanceRemarks') this.attendanceRemarks});
  factory _CourseComponentAttendanceDto.fromJson(Map<String, dynamic> json) =>
      _$CourseComponentAttendanceDtoFromJson(json);

  @override
  @JsonKey(name: 'createdById')
  final String? createdById;
  @override
  @JsonKey(name: 'createdDateTime')
  final DateTime? createdDateTime;
  @override
  @JsonKey(name: 'lastModifiedById')
  final String? lastModifiedById;
  @override
  @JsonKey(name: 'lastModifiedDateTime')
  final DateTime? lastModifiedDateTime;
  @override
  @JsonKey(name: 'createdByName')
  final String? createdByName;
  @override
  @JsonKey(name: 'lastModifiedByName')
  final String? lastModifiedByName;
  @override
  @JsonKey(name: 'courseComponentId')
  final int? courseComponentId;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'attendanceDate')
  final DateTime? attendanceDate;
  @override
  @JsonKey(name: 'attendanceStatus')
  final String? attendanceStatus;
  @override
  @JsonKey(name: 'attendanceRemarks')
  final String? attendanceRemarks;

  /// Create a copy of CourseComponentAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CourseComponentAttendanceDtoCopyWith<_CourseComponentAttendanceDto>
      get copyWith => __$CourseComponentAttendanceDtoCopyWithImpl<
          _CourseComponentAttendanceDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CourseComponentAttendanceDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CourseComponentAttendanceDto &&
            (identical(other.createdById, createdById) ||
                other.createdById == createdById) &&
            (identical(other.createdDateTime, createdDateTime) ||
                other.createdDateTime == createdDateTime) &&
            (identical(other.lastModifiedById, lastModifiedById) ||
                other.lastModifiedById == lastModifiedById) &&
            (identical(other.lastModifiedDateTime, lastModifiedDateTime) ||
                other.lastModifiedDateTime == lastModifiedDateTime) &&
            (identical(other.createdByName, createdByName) ||
                other.createdByName == createdByName) &&
            (identical(other.lastModifiedByName, lastModifiedByName) ||
                other.lastModifiedByName == lastModifiedByName) &&
            (identical(other.courseComponentId, courseComponentId) ||
                other.courseComponentId == courseComponentId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.attendanceDate, attendanceDate) ||
                other.attendanceDate == attendanceDate) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.attendanceRemarks, attendanceRemarks) ||
                other.attendanceRemarks == attendanceRemarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      createdById,
      createdDateTime,
      lastModifiedById,
      lastModifiedDateTime,
      createdByName,
      lastModifiedByName,
      courseComponentId,
      studentId,
      attendanceDate,
      attendanceStatus,
      attendanceRemarks);

  @override
  String toString() {
    return 'CourseComponentAttendanceDto(createdById: $createdById, createdDateTime: $createdDateTime, lastModifiedById: $lastModifiedById, lastModifiedDateTime: $lastModifiedDateTime, createdByName: $createdByName, lastModifiedByName: $lastModifiedByName, courseComponentId: $courseComponentId, studentId: $studentId, attendanceDate: $attendanceDate, attendanceStatus: $attendanceStatus, attendanceRemarks: $attendanceRemarks)';
  }
}

/// @nodoc
abstract mixin class _$CourseComponentAttendanceDtoCopyWith<$Res>
    implements $CourseComponentAttendanceDtoCopyWith<$Res> {
  factory _$CourseComponentAttendanceDtoCopyWith(
          _CourseComponentAttendanceDto value,
          $Res Function(_CourseComponentAttendanceDto) _then) =
      __$CourseComponentAttendanceDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'createdById') String? createdById,
      @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
      @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
      @JsonKey(name: 'lastModifiedDateTime') DateTime? lastModifiedDateTime,
      @JsonKey(name: 'createdByName') String? createdByName,
      @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
      @JsonKey(name: 'courseComponentId') int? courseComponentId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'attendanceRemarks') String? attendanceRemarks});
}

/// @nodoc
class __$CourseComponentAttendanceDtoCopyWithImpl<$Res>
    implements _$CourseComponentAttendanceDtoCopyWith<$Res> {
  __$CourseComponentAttendanceDtoCopyWithImpl(this._self, this._then);

  final _CourseComponentAttendanceDto _self;
  final $Res Function(_CourseComponentAttendanceDto) _then;

  /// Create a copy of CourseComponentAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? createdById = freezed,
    Object? createdDateTime = freezed,
    Object? lastModifiedById = freezed,
    Object? lastModifiedDateTime = freezed,
    Object? createdByName = freezed,
    Object? lastModifiedByName = freezed,
    Object? courseComponentId = freezed,
    Object? studentId = freezed,
    Object? attendanceDate = freezed,
    Object? attendanceStatus = freezed,
    Object? attendanceRemarks = freezed,
  }) {
    return _then(_CourseComponentAttendanceDto(
      createdById: freezed == createdById
          ? _self.createdById
          : createdById // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDateTime: freezed == createdDateTime
          ? _self.createdDateTime
          : createdDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastModifiedById: freezed == lastModifiedById
          ? _self.lastModifiedById
          : lastModifiedById // ignore: cast_nullable_to_non_nullable
              as String?,
      lastModifiedDateTime: freezed == lastModifiedDateTime
          ? _self.lastModifiedDateTime
          : lastModifiedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdByName: freezed == createdByName
          ? _self.createdByName
          : createdByName // ignore: cast_nullable_to_non_nullable
              as String?,
      lastModifiedByName: freezed == lastModifiedByName
          ? _self.lastModifiedByName
          : lastModifiedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      courseComponentId: freezed == courseComponentId
          ? _self.courseComponentId
          : courseComponentId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceDate: freezed == attendanceDate
          ? _self.attendanceDate
          : attendanceDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceRemarks: freezed == attendanceRemarks
          ? _self.attendanceRemarks
          : attendanceRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$CourseComponentAttendanceParameterDto {
  @JsonKey(name: 'courseComponentId')
  int? get courseComponentId;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'attendanceDate')
  DateTime? get attendanceDate;
  @JsonKey(name: 'attendanceStatus')
  String? get attendanceStatus;

  /// Create a copy of CourseComponentAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CourseComponentAttendanceParameterDtoCopyWith<
          CourseComponentAttendanceParameterDto>
      get copyWith => _$CourseComponentAttendanceParameterDtoCopyWithImpl<
              CourseComponentAttendanceParameterDto>(
          this as CourseComponentAttendanceParameterDto, _$identity);

  /// Serializes this CourseComponentAttendanceParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CourseComponentAttendanceParameterDto &&
            (identical(other.courseComponentId, courseComponentId) ||
                other.courseComponentId == courseComponentId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.attendanceDate, attendanceDate) ||
                other.attendanceDate == attendanceDate) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, courseComponentId, studentId,
      attendanceDate, attendanceStatus);

  @override
  String toString() {
    return 'CourseComponentAttendanceParameterDto(courseComponentId: $courseComponentId, studentId: $studentId, attendanceDate: $attendanceDate, attendanceStatus: $attendanceStatus)';
  }
}

/// @nodoc
abstract mixin class $CourseComponentAttendanceParameterDtoCopyWith<$Res> {
  factory $CourseComponentAttendanceParameterDtoCopyWith(
          CourseComponentAttendanceParameterDto value,
          $Res Function(CourseComponentAttendanceParameterDto) _then) =
      _$CourseComponentAttendanceParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'courseComponentId') int? courseComponentId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus});
}

/// @nodoc
class _$CourseComponentAttendanceParameterDtoCopyWithImpl<$Res>
    implements $CourseComponentAttendanceParameterDtoCopyWith<$Res> {
  _$CourseComponentAttendanceParameterDtoCopyWithImpl(this._self, this._then);

  final CourseComponentAttendanceParameterDto _self;
  final $Res Function(CourseComponentAttendanceParameterDto) _then;

  /// Create a copy of CourseComponentAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? courseComponentId = freezed,
    Object? studentId = freezed,
    Object? attendanceDate = freezed,
    Object? attendanceStatus = freezed,
  }) {
    return _then(_self.copyWith(
      courseComponentId: freezed == courseComponentId
          ? _self.courseComponentId
          : courseComponentId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceDate: freezed == attendanceDate
          ? _self.attendanceDate
          : attendanceDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CourseComponentAttendanceParameterDto].
extension CourseComponentAttendanceParameterDtoPatterns
    on CourseComponentAttendanceParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CourseComponentAttendanceParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CourseComponentAttendanceParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CourseComponentAttendanceParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceParameterDto() when $default != null:
        return $default(_that.courseComponentId, _that.studentId,
            _that.attendanceDate, _that.attendanceStatus);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceParameterDto():
        return $default(_that.courseComponentId, _that.studentId,
            _that.attendanceDate, _that.attendanceStatus);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentAttendanceParameterDto() when $default != null:
        return $default(_that.courseComponentId, _that.studentId,
            _that.attendanceDate, _that.attendanceStatus);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CourseComponentAttendanceParameterDto
    implements CourseComponentAttendanceParameterDto {
  _CourseComponentAttendanceParameterDto(
      {@JsonKey(name: 'courseComponentId') this.courseComponentId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'attendanceDate') this.attendanceDate,
      @JsonKey(name: 'attendanceStatus') this.attendanceStatus});
  factory _CourseComponentAttendanceParameterDto.fromJson(
          Map<String, dynamic> json) =>
      _$CourseComponentAttendanceParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'courseComponentId')
  final int? courseComponentId;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'attendanceDate')
  final DateTime? attendanceDate;
  @override
  @JsonKey(name: 'attendanceStatus')
  final String? attendanceStatus;

  /// Create a copy of CourseComponentAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CourseComponentAttendanceParameterDtoCopyWith<
          _CourseComponentAttendanceParameterDto>
      get copyWith => __$CourseComponentAttendanceParameterDtoCopyWithImpl<
          _CourseComponentAttendanceParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CourseComponentAttendanceParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CourseComponentAttendanceParameterDto &&
            (identical(other.courseComponentId, courseComponentId) ||
                other.courseComponentId == courseComponentId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.attendanceDate, attendanceDate) ||
                other.attendanceDate == attendanceDate) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, courseComponentId, studentId,
      attendanceDate, attendanceStatus);

  @override
  String toString() {
    return 'CourseComponentAttendanceParameterDto(courseComponentId: $courseComponentId, studentId: $studentId, attendanceDate: $attendanceDate, attendanceStatus: $attendanceStatus)';
  }
}

/// @nodoc
abstract mixin class _$CourseComponentAttendanceParameterDtoCopyWith<$Res>
    implements $CourseComponentAttendanceParameterDtoCopyWith<$Res> {
  factory _$CourseComponentAttendanceParameterDtoCopyWith(
          _CourseComponentAttendanceParameterDto value,
          $Res Function(_CourseComponentAttendanceParameterDto) _then) =
      __$CourseComponentAttendanceParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'courseComponentId') int? courseComponentId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
      @JsonKey(name: 'attendanceStatus') String? attendanceStatus});
}

/// @nodoc
class __$CourseComponentAttendanceParameterDtoCopyWithImpl<$Res>
    implements _$CourseComponentAttendanceParameterDtoCopyWith<$Res> {
  __$CourseComponentAttendanceParameterDtoCopyWithImpl(this._self, this._then);

  final _CourseComponentAttendanceParameterDto _self;
  final $Res Function(_CourseComponentAttendanceParameterDto) _then;

  /// Create a copy of CourseComponentAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? courseComponentId = freezed,
    Object? studentId = freezed,
    Object? attendanceDate = freezed,
    Object? attendanceStatus = freezed,
  }) {
    return _then(_CourseComponentAttendanceParameterDto(
      courseComponentId: freezed == courseComponentId
          ? _self.courseComponentId
          : courseComponentId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceDate: freezed == attendanceDate
          ? _self.attendanceDate
          : attendanceDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$CourseComponentStudentParameterDto {
  @JsonKey(name: 'courseComponentId')
  int? get courseComponentId;
  @JsonKey(name: 'academicYearId')
  String? get academicYearId;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'isActive')
  bool? get isActive;

  /// Create a copy of CourseComponentStudentParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CourseComponentStudentParameterDtoCopyWith<
          CourseComponentStudentParameterDto>
      get copyWith => _$CourseComponentStudentParameterDtoCopyWithImpl<
              CourseComponentStudentParameterDto>(
          this as CourseComponentStudentParameterDto, _$identity);

  /// Serializes this CourseComponentStudentParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CourseComponentStudentParameterDto &&
            (identical(other.courseComponentId, courseComponentId) ||
                other.courseComponentId == courseComponentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, courseComponentId, academicYearId, studentId, isActive);

  @override
  String toString() {
    return 'CourseComponentStudentParameterDto(courseComponentId: $courseComponentId, academicYearId: $academicYearId, studentId: $studentId, isActive: $isActive)';
  }
}

/// @nodoc
abstract mixin class $CourseComponentStudentParameterDtoCopyWith<$Res> {
  factory $CourseComponentStudentParameterDtoCopyWith(
          CourseComponentStudentParameterDto value,
          $Res Function(CourseComponentStudentParameterDto) _then) =
      _$CourseComponentStudentParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'courseComponentId') int? courseComponentId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'isActive') bool? isActive});
}

/// @nodoc
class _$CourseComponentStudentParameterDtoCopyWithImpl<$Res>
    implements $CourseComponentStudentParameterDtoCopyWith<$Res> {
  _$CourseComponentStudentParameterDtoCopyWithImpl(this._self, this._then);

  final CourseComponentStudentParameterDto _self;
  final $Res Function(CourseComponentStudentParameterDto) _then;

  /// Create a copy of CourseComponentStudentParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? courseComponentId = freezed,
    Object? academicYearId = freezed,
    Object? studentId = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_self.copyWith(
      courseComponentId: freezed == courseComponentId
          ? _self.courseComponentId
          : courseComponentId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CourseComponentStudentParameterDto].
extension CourseComponentStudentParameterDtoPatterns
    on CourseComponentStudentParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CourseComponentStudentParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CourseComponentStudentParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CourseComponentStudentParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentStudentParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CourseComponentStudentParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentStudentParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'isActive') bool? isActive)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CourseComponentStudentParameterDto() when $default != null:
        return $default(_that.courseComponentId, _that.academicYearId,
            _that.studentId, _that.isActive);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'isActive') bool? isActive)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentStudentParameterDto():
        return $default(_that.courseComponentId, _that.academicYearId,
            _that.studentId, _that.isActive);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'courseComponentId') int? courseComponentId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'isActive') bool? isActive)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CourseComponentStudentParameterDto() when $default != null:
        return $default(_that.courseComponentId, _that.academicYearId,
            _that.studentId, _that.isActive);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CourseComponentStudentParameterDto
    implements CourseComponentStudentParameterDto {
  _CourseComponentStudentParameterDto(
      {@JsonKey(name: 'courseComponentId') this.courseComponentId,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'isActive') this.isActive});
  factory _CourseComponentStudentParameterDto.fromJson(
          Map<String, dynamic> json) =>
      _$CourseComponentStudentParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'courseComponentId')
  final int? courseComponentId;
  @override
  @JsonKey(name: 'academicYearId')
  final String? academicYearId;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'isActive')
  final bool? isActive;

  /// Create a copy of CourseComponentStudentParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CourseComponentStudentParameterDtoCopyWith<
          _CourseComponentStudentParameterDto>
      get copyWith => __$CourseComponentStudentParameterDtoCopyWithImpl<
          _CourseComponentStudentParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CourseComponentStudentParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CourseComponentStudentParameterDto &&
            (identical(other.courseComponentId, courseComponentId) ||
                other.courseComponentId == courseComponentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, courseComponentId, academicYearId, studentId, isActive);

  @override
  String toString() {
    return 'CourseComponentStudentParameterDto(courseComponentId: $courseComponentId, academicYearId: $academicYearId, studentId: $studentId, isActive: $isActive)';
  }
}

/// @nodoc
abstract mixin class _$CourseComponentStudentParameterDtoCopyWith<$Res>
    implements $CourseComponentStudentParameterDtoCopyWith<$Res> {
  factory _$CourseComponentStudentParameterDtoCopyWith(
          _CourseComponentStudentParameterDto value,
          $Res Function(_CourseComponentStudentParameterDto) _then) =
      __$CourseComponentStudentParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'courseComponentId') int? courseComponentId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'isActive') bool? isActive});
}

/// @nodoc
class __$CourseComponentStudentParameterDtoCopyWithImpl<$Res>
    implements _$CourseComponentStudentParameterDtoCopyWith<$Res> {
  __$CourseComponentStudentParameterDtoCopyWithImpl(this._self, this._then);

  final _CourseComponentStudentParameterDto _self;
  final $Res Function(_CourseComponentStudentParameterDto) _then;

  /// Create a copy of CourseComponentStudentParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? courseComponentId = freezed,
    Object? academicYearId = freezed,
    Object? studentId = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_CourseComponentStudentParameterDto(
      courseComponentId: freezed == courseComponentId
          ? _self.courseComponentId
          : courseComponentId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$CustomNotificationParametersDto {
  @JsonKey(name: 'teacherId')
  String? get teacherId;
  @JsonKey(name: 'schoolId')
  String? get schoolId;
  @JsonKey(name: 'ptcInfo')
  String? get ptcInfo;
  @JsonKey(name: 'tagStudents')
  List<TagStudentsDto>? get tagStudents;
  @JsonKey(name: 'tagClasses')
  List<TagClassDto>? get tagClasses;
  @JsonKey(name: 'tagLevels')
  List<TagLevelDto>? get tagLevels;

  /// Create a copy of CustomNotificationParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CustomNotificationParametersDtoCopyWith<CustomNotificationParametersDto>
      get copyWith => _$CustomNotificationParametersDtoCopyWithImpl<
              CustomNotificationParametersDto>(
          this as CustomNotificationParametersDto, _$identity);

  /// Serializes this CustomNotificationParametersDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CustomNotificationParametersDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.ptcInfo, ptcInfo) || other.ptcInfo == ptcInfo) &&
            const DeepCollectionEquality()
                .equals(other.tagStudents, tagStudents) &&
            const DeepCollectionEquality()
                .equals(other.tagClasses, tagClasses) &&
            const DeepCollectionEquality().equals(other.tagLevels, tagLevels));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      teacherId,
      schoolId,
      ptcInfo,
      const DeepCollectionEquality().hash(tagStudents),
      const DeepCollectionEquality().hash(tagClasses),
      const DeepCollectionEquality().hash(tagLevels));

  @override
  String toString() {
    return 'CustomNotificationParametersDto(teacherId: $teacherId, schoolId: $schoolId, ptcInfo: $ptcInfo, tagStudents: $tagStudents, tagClasses: $tagClasses, tagLevels: $tagLevels)';
  }
}

/// @nodoc
abstract mixin class $CustomNotificationParametersDtoCopyWith<$Res> {
  factory $CustomNotificationParametersDtoCopyWith(
          CustomNotificationParametersDto value,
          $Res Function(CustomNotificationParametersDto) _then) =
      _$CustomNotificationParametersDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'ptcInfo') String? ptcInfo,
      @JsonKey(name: 'tagStudents') List<TagStudentsDto>? tagStudents,
      @JsonKey(name: 'tagClasses') List<TagClassDto>? tagClasses,
      @JsonKey(name: 'tagLevels') List<TagLevelDto>? tagLevels});
}

/// @nodoc
class _$CustomNotificationParametersDtoCopyWithImpl<$Res>
    implements $CustomNotificationParametersDtoCopyWith<$Res> {
  _$CustomNotificationParametersDtoCopyWithImpl(this._self, this._then);

  final CustomNotificationParametersDto _self;
  final $Res Function(CustomNotificationParametersDto) _then;

  /// Create a copy of CustomNotificationParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? teacherId = freezed,
    Object? schoolId = freezed,
    Object? ptcInfo = freezed,
    Object? tagStudents = freezed,
    Object? tagClasses = freezed,
    Object? tagLevels = freezed,
  }) {
    return _then(_self.copyWith(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      ptcInfo: freezed == ptcInfo
          ? _self.ptcInfo
          : ptcInfo // ignore: cast_nullable_to_non_nullable
              as String?,
      tagStudents: freezed == tagStudents
          ? _self.tagStudents
          : tagStudents // ignore: cast_nullable_to_non_nullable
              as List<TagStudentsDto>?,
      tagClasses: freezed == tagClasses
          ? _self.tagClasses
          : tagClasses // ignore: cast_nullable_to_non_nullable
              as List<TagClassDto>?,
      tagLevels: freezed == tagLevels
          ? _self.tagLevels
          : tagLevels // ignore: cast_nullable_to_non_nullable
              as List<TagLevelDto>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CustomNotificationParametersDto].
extension CustomNotificationParametersDtoPatterns
    on CustomNotificationParametersDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CustomNotificationParametersDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CustomNotificationParametersDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CustomNotificationParametersDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CustomNotificationParametersDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CustomNotificationParametersDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CustomNotificationParametersDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'ptcInfo') String? ptcInfo,
            @JsonKey(name: 'tagStudents') List<TagStudentsDto>? tagStudents,
            @JsonKey(name: 'tagClasses') List<TagClassDto>? tagClasses,
            @JsonKey(name: 'tagLevels') List<TagLevelDto>? tagLevels)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CustomNotificationParametersDto() when $default != null:
        return $default(_that.teacherId, _that.schoolId, _that.ptcInfo,
            _that.tagStudents, _that.tagClasses, _that.tagLevels);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'ptcInfo') String? ptcInfo,
            @JsonKey(name: 'tagStudents') List<TagStudentsDto>? tagStudents,
            @JsonKey(name: 'tagClasses') List<TagClassDto>? tagClasses,
            @JsonKey(name: 'tagLevels') List<TagLevelDto>? tagLevels)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CustomNotificationParametersDto():
        return $default(_that.teacherId, _that.schoolId, _that.ptcInfo,
            _that.tagStudents, _that.tagClasses, _that.tagLevels);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'ptcInfo') String? ptcInfo,
            @JsonKey(name: 'tagStudents') List<TagStudentsDto>? tagStudents,
            @JsonKey(name: 'tagClasses') List<TagClassDto>? tagClasses,
            @JsonKey(name: 'tagLevels') List<TagLevelDto>? tagLevels)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CustomNotificationParametersDto() when $default != null:
        return $default(_that.teacherId, _that.schoolId, _that.ptcInfo,
            _that.tagStudents, _that.tagClasses, _that.tagLevels);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CustomNotificationParametersDto
    implements CustomNotificationParametersDto {
  _CustomNotificationParametersDto(
      {@JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'schoolId') this.schoolId,
      @JsonKey(name: 'ptcInfo') this.ptcInfo,
      @JsonKey(name: 'tagStudents') final List<TagStudentsDto>? tagStudents,
      @JsonKey(name: 'tagClasses') final List<TagClassDto>? tagClasses,
      @JsonKey(name: 'tagLevels') final List<TagLevelDto>? tagLevels})
      : _tagStudents = tagStudents,
        _tagClasses = tagClasses,
        _tagLevels = tagLevels;
  factory _CustomNotificationParametersDto.fromJson(
          Map<String, dynamic> json) =>
      _$CustomNotificationParametersDtoFromJson(json);

  @override
  @JsonKey(name: 'teacherId')
  final String? teacherId;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;
  @override
  @JsonKey(name: 'ptcInfo')
  final String? ptcInfo;
  final List<TagStudentsDto>? _tagStudents;
  @override
  @JsonKey(name: 'tagStudents')
  List<TagStudentsDto>? get tagStudents {
    final value = _tagStudents;
    if (value == null) return null;
    if (_tagStudents is EqualUnmodifiableListView) return _tagStudents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<TagClassDto>? _tagClasses;
  @override
  @JsonKey(name: 'tagClasses')
  List<TagClassDto>? get tagClasses {
    final value = _tagClasses;
    if (value == null) return null;
    if (_tagClasses is EqualUnmodifiableListView) return _tagClasses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<TagLevelDto>? _tagLevels;
  @override
  @JsonKey(name: 'tagLevels')
  List<TagLevelDto>? get tagLevels {
    final value = _tagLevels;
    if (value == null) return null;
    if (_tagLevels is EqualUnmodifiableListView) return _tagLevels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of CustomNotificationParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CustomNotificationParametersDtoCopyWith<_CustomNotificationParametersDto>
      get copyWith => __$CustomNotificationParametersDtoCopyWithImpl<
          _CustomNotificationParametersDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CustomNotificationParametersDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CustomNotificationParametersDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.ptcInfo, ptcInfo) || other.ptcInfo == ptcInfo) &&
            const DeepCollectionEquality()
                .equals(other._tagStudents, _tagStudents) &&
            const DeepCollectionEquality()
                .equals(other._tagClasses, _tagClasses) &&
            const DeepCollectionEquality()
                .equals(other._tagLevels, _tagLevels));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      teacherId,
      schoolId,
      ptcInfo,
      const DeepCollectionEquality().hash(_tagStudents),
      const DeepCollectionEquality().hash(_tagClasses),
      const DeepCollectionEquality().hash(_tagLevels));

  @override
  String toString() {
    return 'CustomNotificationParametersDto(teacherId: $teacherId, schoolId: $schoolId, ptcInfo: $ptcInfo, tagStudents: $tagStudents, tagClasses: $tagClasses, tagLevels: $tagLevels)';
  }
}

/// @nodoc
abstract mixin class _$CustomNotificationParametersDtoCopyWith<$Res>
    implements $CustomNotificationParametersDtoCopyWith<$Res> {
  factory _$CustomNotificationParametersDtoCopyWith(
          _CustomNotificationParametersDto value,
          $Res Function(_CustomNotificationParametersDto) _then) =
      __$CustomNotificationParametersDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'ptcInfo') String? ptcInfo,
      @JsonKey(name: 'tagStudents') List<TagStudentsDto>? tagStudents,
      @JsonKey(name: 'tagClasses') List<TagClassDto>? tagClasses,
      @JsonKey(name: 'tagLevels') List<TagLevelDto>? tagLevels});
}

/// @nodoc
class __$CustomNotificationParametersDtoCopyWithImpl<$Res>
    implements _$CustomNotificationParametersDtoCopyWith<$Res> {
  __$CustomNotificationParametersDtoCopyWithImpl(this._self, this._then);

  final _CustomNotificationParametersDto _self;
  final $Res Function(_CustomNotificationParametersDto) _then;

  /// Create a copy of CustomNotificationParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? teacherId = freezed,
    Object? schoolId = freezed,
    Object? ptcInfo = freezed,
    Object? tagStudents = freezed,
    Object? tagClasses = freezed,
    Object? tagLevels = freezed,
  }) {
    return _then(_CustomNotificationParametersDto(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      ptcInfo: freezed == ptcInfo
          ? _self.ptcInfo
          : ptcInfo // ignore: cast_nullable_to_non_nullable
              as String?,
      tagStudents: freezed == tagStudents
          ? _self._tagStudents
          : tagStudents // ignore: cast_nullable_to_non_nullable
              as List<TagStudentsDto>?,
      tagClasses: freezed == tagClasses
          ? _self._tagClasses
          : tagClasses // ignore: cast_nullable_to_non_nullable
              as List<TagClassDto>?,
      tagLevels: freezed == tagLevels
          ? _self._tagLevels
          : tagLevels // ignore: cast_nullable_to_non_nullable
              as List<TagLevelDto>?,
    ));
  }
}

/// @nodoc
mixin _$DailyLogAttendanceDto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'attendanceDate')
  DateTime? get attendanceDate;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'createdBy')
  String? get createdBy;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'updatedBy')
  String? get updatedBy;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of DailyLogAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DailyLogAttendanceDtoCopyWith<DailyLogAttendanceDto> get copyWith =>
      _$DailyLogAttendanceDtoCopyWithImpl<DailyLogAttendanceDto>(
          this as DailyLogAttendanceDto, _$identity);

  /// Serializes this DailyLogAttendanceDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DailyLogAttendanceDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.attendanceDate, attendanceDate) ||
                other.attendanceDate == attendanceDate) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.updatedBy, updatedBy) ||
                other.updatedBy == updatedBy) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, studentId, attendanceDate,
      status, remarks, createdBy, createdDate, updatedBy, updatedDate);

  @override
  String toString() {
    return 'DailyLogAttendanceDto(id: $id, studentId: $studentId, attendanceDate: $attendanceDate, status: $status, remarks: $remarks, createdBy: $createdBy, createdDate: $createdDate, updatedBy: $updatedBy, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $DailyLogAttendanceDtoCopyWith<$Res> {
  factory $DailyLogAttendanceDtoCopyWith(DailyLogAttendanceDto value,
          $Res Function(DailyLogAttendanceDto) _then) =
      _$DailyLogAttendanceDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'updatedBy') String? updatedBy,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$DailyLogAttendanceDtoCopyWithImpl<$Res>
    implements $DailyLogAttendanceDtoCopyWith<$Res> {
  _$DailyLogAttendanceDtoCopyWithImpl(this._self, this._then);

  final DailyLogAttendanceDto _self;
  final $Res Function(DailyLogAttendanceDto) _then;

  /// Create a copy of DailyLogAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? attendanceDate = freezed,
    Object? status = freezed,
    Object? remarks = freezed,
    Object? createdBy = freezed,
    Object? createdDate = freezed,
    Object? updatedBy = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceDate: freezed == attendanceDate
          ? _self.attendanceDate
          : attendanceDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedBy: freezed == updatedBy
          ? _self.updatedBy
          : updatedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [DailyLogAttendanceDto].
extension DailyLogAttendanceDtoPatterns on DailyLogAttendanceDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DailyLogAttendanceDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DailyLogAttendanceDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DailyLogAttendanceDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DailyLogAttendanceDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DailyLogAttendanceDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DailyLogAttendanceDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'updatedBy') String? updatedBy,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DailyLogAttendanceDto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.attendanceDate,
            _that.status,
            _that.remarks,
            _that.createdBy,
            _that.createdDate,
            _that.updatedBy,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'updatedBy') String? updatedBy,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DailyLogAttendanceDto():
        return $default(
            _that.id,
            _that.studentId,
            _that.attendanceDate,
            _that.status,
            _that.remarks,
            _that.createdBy,
            _that.createdDate,
            _that.updatedBy,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'updatedBy') String? updatedBy,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DailyLogAttendanceDto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.attendanceDate,
            _that.status,
            _that.remarks,
            _that.createdBy,
            _that.createdDate,
            _that.updatedBy,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DailyLogAttendanceDto implements DailyLogAttendanceDto {
  _DailyLogAttendanceDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'attendanceDate') this.attendanceDate,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'createdBy') this.createdBy,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'updatedBy') this.updatedBy,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _DailyLogAttendanceDto.fromJson(Map<String, dynamic> json) =>
      _$DailyLogAttendanceDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'attendanceDate')
  final DateTime? attendanceDate;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'createdBy')
  final String? createdBy;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'updatedBy')
  final String? updatedBy;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of DailyLogAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DailyLogAttendanceDtoCopyWith<_DailyLogAttendanceDto> get copyWith =>
      __$DailyLogAttendanceDtoCopyWithImpl<_DailyLogAttendanceDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DailyLogAttendanceDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DailyLogAttendanceDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.attendanceDate, attendanceDate) ||
                other.attendanceDate == attendanceDate) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.updatedBy, updatedBy) ||
                other.updatedBy == updatedBy) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, studentId, attendanceDate,
      status, remarks, createdBy, createdDate, updatedBy, updatedDate);

  @override
  String toString() {
    return 'DailyLogAttendanceDto(id: $id, studentId: $studentId, attendanceDate: $attendanceDate, status: $status, remarks: $remarks, createdBy: $createdBy, createdDate: $createdDate, updatedBy: $updatedBy, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$DailyLogAttendanceDtoCopyWith<$Res>
    implements $DailyLogAttendanceDtoCopyWith<$Res> {
  factory _$DailyLogAttendanceDtoCopyWith(_DailyLogAttendanceDto value,
          $Res Function(_DailyLogAttendanceDto) _then) =
      __$DailyLogAttendanceDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'attendanceDate') DateTime? attendanceDate,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'updatedBy') String? updatedBy,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$DailyLogAttendanceDtoCopyWithImpl<$Res>
    implements _$DailyLogAttendanceDtoCopyWith<$Res> {
  __$DailyLogAttendanceDtoCopyWithImpl(this._self, this._then);

  final _DailyLogAttendanceDto _self;
  final $Res Function(_DailyLogAttendanceDto) _then;

  /// Create a copy of DailyLogAttendanceDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? attendanceDate = freezed,
    Object? status = freezed,
    Object? remarks = freezed,
    Object? createdBy = freezed,
    Object? createdDate = freezed,
    Object? updatedBy = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_DailyLogAttendanceDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      attendanceDate: freezed == attendanceDate
          ? _self.attendanceDate
          : attendanceDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedBy: freezed == updatedBy
          ? _self.updatedBy
          : updatedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$DateTimeTimeZoneDto {
  @JsonKey(name: 'dateTime')
  String? get dateTime;
  @JsonKey(name: 'timeZone')
  String? get timeZone;
  @JsonKey(name: '@odata.type')
  String? get odataType;

  /// Create a copy of DateTimeTimeZoneDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DateTimeTimeZoneDtoCopyWith<DateTimeTimeZoneDto> get copyWith =>
      _$DateTimeTimeZoneDtoCopyWithImpl<DateTimeTimeZoneDto>(
          this as DateTimeTimeZoneDto, _$identity);

  /// Serializes this DateTimeTimeZoneDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DateTimeTimeZoneDto &&
            (identical(other.dateTime, dateTime) ||
                other.dateTime == dateTime) &&
            (identical(other.timeZone, timeZone) ||
                other.timeZone == timeZone) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, dateTime, timeZone, odataType);

  @override
  String toString() {
    return 'DateTimeTimeZoneDto(dateTime: $dateTime, timeZone: $timeZone, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class $DateTimeTimeZoneDtoCopyWith<$Res> {
  factory $DateTimeTimeZoneDtoCopyWith(
          DateTimeTimeZoneDto value, $Res Function(DateTimeTimeZoneDto) _then) =
      _$DateTimeTimeZoneDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'dateTime') String? dateTime,
      @JsonKey(name: 'timeZone') String? timeZone,
      @JsonKey(name: '@odata.type') String? odataType});
}

/// @nodoc
class _$DateTimeTimeZoneDtoCopyWithImpl<$Res>
    implements $DateTimeTimeZoneDtoCopyWith<$Res> {
  _$DateTimeTimeZoneDtoCopyWithImpl(this._self, this._then);

  final DateTimeTimeZoneDto _self;
  final $Res Function(DateTimeTimeZoneDto) _then;

  /// Create a copy of DateTimeTimeZoneDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTime = freezed,
    Object? timeZone = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_self.copyWith(
      dateTime: freezed == dateTime
          ? _self.dateTime
          : dateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      timeZone: freezed == timeZone
          ? _self.timeZone
          : timeZone // ignore: cast_nullable_to_non_nullable
              as String?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [DateTimeTimeZoneDto].
extension DateTimeTimeZoneDtoPatterns on DateTimeTimeZoneDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DateTimeTimeZoneDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DateTimeTimeZoneDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DateTimeTimeZoneDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DateTimeTimeZoneDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DateTimeTimeZoneDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DateTimeTimeZoneDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'dateTime') String? dateTime,
            @JsonKey(name: 'timeZone') String? timeZone,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DateTimeTimeZoneDto() when $default != null:
        return $default(_that.dateTime, _that.timeZone, _that.odataType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'dateTime') String? dateTime,
            @JsonKey(name: 'timeZone') String? timeZone,
            @JsonKey(name: '@odata.type') String? odataType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DateTimeTimeZoneDto():
        return $default(_that.dateTime, _that.timeZone, _that.odataType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'dateTime') String? dateTime,
            @JsonKey(name: 'timeZone') String? timeZone,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DateTimeTimeZoneDto() when $default != null:
        return $default(_that.dateTime, _that.timeZone, _that.odataType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DateTimeTimeZoneDto implements DateTimeTimeZoneDto {
  _DateTimeTimeZoneDto(
      {@JsonKey(name: 'dateTime') this.dateTime,
      @JsonKey(name: 'timeZone') this.timeZone,
      @JsonKey(name: '@odata.type') this.odataType});
  factory _DateTimeTimeZoneDto.fromJson(Map<String, dynamic> json) =>
      _$DateTimeTimeZoneDtoFromJson(json);

  @override
  @JsonKey(name: 'dateTime')
  final String? dateTime;
  @override
  @JsonKey(name: 'timeZone')
  final String? timeZone;
  @override
  @JsonKey(name: '@odata.type')
  final String? odataType;

  /// Create a copy of DateTimeTimeZoneDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DateTimeTimeZoneDtoCopyWith<_DateTimeTimeZoneDto> get copyWith =>
      __$DateTimeTimeZoneDtoCopyWithImpl<_DateTimeTimeZoneDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DateTimeTimeZoneDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DateTimeTimeZoneDto &&
            (identical(other.dateTime, dateTime) ||
                other.dateTime == dateTime) &&
            (identical(other.timeZone, timeZone) ||
                other.timeZone == timeZone) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, dateTime, timeZone, odataType);

  @override
  String toString() {
    return 'DateTimeTimeZoneDto(dateTime: $dateTime, timeZone: $timeZone, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class _$DateTimeTimeZoneDtoCopyWith<$Res>
    implements $DateTimeTimeZoneDtoCopyWith<$Res> {
  factory _$DateTimeTimeZoneDtoCopyWith(_DateTimeTimeZoneDto value,
          $Res Function(_DateTimeTimeZoneDto) _then) =
      __$DateTimeTimeZoneDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'dateTime') String? dateTime,
      @JsonKey(name: 'timeZone') String? timeZone,
      @JsonKey(name: '@odata.type') String? odataType});
}

/// @nodoc
class __$DateTimeTimeZoneDtoCopyWithImpl<$Res>
    implements _$DateTimeTimeZoneDtoCopyWith<$Res> {
  __$DateTimeTimeZoneDtoCopyWithImpl(this._self, this._then);

  final _DateTimeTimeZoneDto _self;
  final $Res Function(_DateTimeTimeZoneDto) _then;

  /// Create a copy of DateTimeTimeZoneDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? dateTime = freezed,
    Object? timeZone = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_DateTimeTimeZoneDto(
      dateTime: freezed == dateTime
          ? _self.dateTime
          : dateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      timeZone: freezed == timeZone
          ? _self.timeZone
          : timeZone // ignore: cast_nullable_to_non_nullable
              as String?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$EditBookEventParameterDto {
  @JsonKey(name: 'oldOrganiserEmail')
  String? get oldOrganiserEmail;
  @JsonKey(name: 'oldEventId')
  String? get oldEventId;
  @JsonKey(name: 'newOrganiserEmail')
  String? get newOrganiserEmail;
  @JsonKey(name: 'newEventId')
  String? get newEventId;
  @JsonKey(name: 'recipients')
  List<CalendarInviteRecipientDto>? get recipients;

  /// Create a copy of EditBookEventParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EditBookEventParameterDtoCopyWith<EditBookEventParameterDto> get copyWith =>
      _$EditBookEventParameterDtoCopyWithImpl<EditBookEventParameterDto>(
          this as EditBookEventParameterDto, _$identity);

  /// Serializes this EditBookEventParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditBookEventParameterDto &&
            (identical(other.oldOrganiserEmail, oldOrganiserEmail) ||
                other.oldOrganiserEmail == oldOrganiserEmail) &&
            (identical(other.oldEventId, oldEventId) ||
                other.oldEventId == oldEventId) &&
            (identical(other.newOrganiserEmail, newOrganiserEmail) ||
                other.newOrganiserEmail == newOrganiserEmail) &&
            (identical(other.newEventId, newEventId) ||
                other.newEventId == newEventId) &&
            const DeepCollectionEquality()
                .equals(other.recipients, recipients));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      oldOrganiserEmail,
      oldEventId,
      newOrganiserEmail,
      newEventId,
      const DeepCollectionEquality().hash(recipients));

  @override
  String toString() {
    return 'EditBookEventParameterDto(oldOrganiserEmail: $oldOrganiserEmail, oldEventId: $oldEventId, newOrganiserEmail: $newOrganiserEmail, newEventId: $newEventId, recipients: $recipients)';
  }
}

/// @nodoc
abstract mixin class $EditBookEventParameterDtoCopyWith<$Res> {
  factory $EditBookEventParameterDtoCopyWith(EditBookEventParameterDto value,
          $Res Function(EditBookEventParameterDto) _then) =
      _$EditBookEventParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'oldOrganiserEmail') String? oldOrganiserEmail,
      @JsonKey(name: 'oldEventId') String? oldEventId,
      @JsonKey(name: 'newOrganiserEmail') String? newOrganiserEmail,
      @JsonKey(name: 'newEventId') String? newEventId,
      @JsonKey(name: 'recipients')
      List<CalendarInviteRecipientDto>? recipients});
}

/// @nodoc
class _$EditBookEventParameterDtoCopyWithImpl<$Res>
    implements $EditBookEventParameterDtoCopyWith<$Res> {
  _$EditBookEventParameterDtoCopyWithImpl(this._self, this._then);

  final EditBookEventParameterDto _self;
  final $Res Function(EditBookEventParameterDto) _then;

  /// Create a copy of EditBookEventParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? oldOrganiserEmail = freezed,
    Object? oldEventId = freezed,
    Object? newOrganiserEmail = freezed,
    Object? newEventId = freezed,
    Object? recipients = freezed,
  }) {
    return _then(_self.copyWith(
      oldOrganiserEmail: freezed == oldOrganiserEmail
          ? _self.oldOrganiserEmail
          : oldOrganiserEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      oldEventId: freezed == oldEventId
          ? _self.oldEventId
          : oldEventId // ignore: cast_nullable_to_non_nullable
              as String?,
      newOrganiserEmail: freezed == newOrganiserEmail
          ? _self.newOrganiserEmail
          : newOrganiserEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      newEventId: freezed == newEventId
          ? _self.newEventId
          : newEventId // ignore: cast_nullable_to_non_nullable
              as String?,
      recipients: freezed == recipients
          ? _self.recipients
          : recipients // ignore: cast_nullable_to_non_nullable
              as List<CalendarInviteRecipientDto>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [EditBookEventParameterDto].
extension EditBookEventParameterDtoPatterns on EditBookEventParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_EditBookEventParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EditBookEventParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_EditBookEventParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditBookEventParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_EditBookEventParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditBookEventParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'oldOrganiserEmail') String? oldOrganiserEmail,
            @JsonKey(name: 'oldEventId') String? oldEventId,
            @JsonKey(name: 'newOrganiserEmail') String? newOrganiserEmail,
            @JsonKey(name: 'newEventId') String? newEventId,
            @JsonKey(name: 'recipients')
            List<CalendarInviteRecipientDto>? recipients)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EditBookEventParameterDto() when $default != null:
        return $default(_that.oldOrganiserEmail, _that.oldEventId,
            _that.newOrganiserEmail, _that.newEventId, _that.recipients);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'oldOrganiserEmail') String? oldOrganiserEmail,
            @JsonKey(name: 'oldEventId') String? oldEventId,
            @JsonKey(name: 'newOrganiserEmail') String? newOrganiserEmail,
            @JsonKey(name: 'newEventId') String? newEventId,
            @JsonKey(name: 'recipients')
            List<CalendarInviteRecipientDto>? recipients)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditBookEventParameterDto():
        return $default(_that.oldOrganiserEmail, _that.oldEventId,
            _that.newOrganiserEmail, _that.newEventId, _that.recipients);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'oldOrganiserEmail') String? oldOrganiserEmail,
            @JsonKey(name: 'oldEventId') String? oldEventId,
            @JsonKey(name: 'newOrganiserEmail') String? newOrganiserEmail,
            @JsonKey(name: 'newEventId') String? newEventId,
            @JsonKey(name: 'recipients')
            List<CalendarInviteRecipientDto>? recipients)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditBookEventParameterDto() when $default != null:
        return $default(_that.oldOrganiserEmail, _that.oldEventId,
            _that.newOrganiserEmail, _that.newEventId, _that.recipients);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _EditBookEventParameterDto implements EditBookEventParameterDto {
  _EditBookEventParameterDto(
      {@JsonKey(name: 'oldOrganiserEmail') this.oldOrganiserEmail,
      @JsonKey(name: 'oldEventId') this.oldEventId,
      @JsonKey(name: 'newOrganiserEmail') this.newOrganiserEmail,
      @JsonKey(name: 'newEventId') this.newEventId,
      @JsonKey(name: 'recipients')
      final List<CalendarInviteRecipientDto>? recipients})
      : _recipients = recipients;
  factory _EditBookEventParameterDto.fromJson(Map<String, dynamic> json) =>
      _$EditBookEventParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'oldOrganiserEmail')
  final String? oldOrganiserEmail;
  @override
  @JsonKey(name: 'oldEventId')
  final String? oldEventId;
  @override
  @JsonKey(name: 'newOrganiserEmail')
  final String? newOrganiserEmail;
  @override
  @JsonKey(name: 'newEventId')
  final String? newEventId;
  final List<CalendarInviteRecipientDto>? _recipients;
  @override
  @JsonKey(name: 'recipients')
  List<CalendarInviteRecipientDto>? get recipients {
    final value = _recipients;
    if (value == null) return null;
    if (_recipients is EqualUnmodifiableListView) return _recipients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of EditBookEventParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EditBookEventParameterDtoCopyWith<_EditBookEventParameterDto>
      get copyWith =>
          __$EditBookEventParameterDtoCopyWithImpl<_EditBookEventParameterDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EditBookEventParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EditBookEventParameterDto &&
            (identical(other.oldOrganiserEmail, oldOrganiserEmail) ||
                other.oldOrganiserEmail == oldOrganiserEmail) &&
            (identical(other.oldEventId, oldEventId) ||
                other.oldEventId == oldEventId) &&
            (identical(other.newOrganiserEmail, newOrganiserEmail) ||
                other.newOrganiserEmail == newOrganiserEmail) &&
            (identical(other.newEventId, newEventId) ||
                other.newEventId == newEventId) &&
            const DeepCollectionEquality()
                .equals(other._recipients, _recipients));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      oldOrganiserEmail,
      oldEventId,
      newOrganiserEmail,
      newEventId,
      const DeepCollectionEquality().hash(_recipients));

  @override
  String toString() {
    return 'EditBookEventParameterDto(oldOrganiserEmail: $oldOrganiserEmail, oldEventId: $oldEventId, newOrganiserEmail: $newOrganiserEmail, newEventId: $newEventId, recipients: $recipients)';
  }
}

/// @nodoc
abstract mixin class _$EditBookEventParameterDtoCopyWith<$Res>
    implements $EditBookEventParameterDtoCopyWith<$Res> {
  factory _$EditBookEventParameterDtoCopyWith(_EditBookEventParameterDto value,
          $Res Function(_EditBookEventParameterDto) _then) =
      __$EditBookEventParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'oldOrganiserEmail') String? oldOrganiserEmail,
      @JsonKey(name: 'oldEventId') String? oldEventId,
      @JsonKey(name: 'newOrganiserEmail') String? newOrganiserEmail,
      @JsonKey(name: 'newEventId') String? newEventId,
      @JsonKey(name: 'recipients')
      List<CalendarInviteRecipientDto>? recipients});
}

/// @nodoc
class __$EditBookEventParameterDtoCopyWithImpl<$Res>
    implements _$EditBookEventParameterDtoCopyWith<$Res> {
  __$EditBookEventParameterDtoCopyWithImpl(this._self, this._then);

  final _EditBookEventParameterDto _self;
  final $Res Function(_EditBookEventParameterDto) _then;

  /// Create a copy of EditBookEventParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? oldOrganiserEmail = freezed,
    Object? oldEventId = freezed,
    Object? newOrganiserEmail = freezed,
    Object? newEventId = freezed,
    Object? recipients = freezed,
  }) {
    return _then(_EditBookEventParameterDto(
      oldOrganiserEmail: freezed == oldOrganiserEmail
          ? _self.oldOrganiserEmail
          : oldOrganiserEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      oldEventId: freezed == oldEventId
          ? _self.oldEventId
          : oldEventId // ignore: cast_nullable_to_non_nullable
              as String?,
      newOrganiserEmail: freezed == newOrganiserEmail
          ? _self.newOrganiserEmail
          : newOrganiserEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      newEventId: freezed == newEventId
          ? _self.newEventId
          : newEventId // ignore: cast_nullable_to_non_nullable
              as String?,
      recipients: freezed == recipients
          ? _self._recipients
          : recipients // ignore: cast_nullable_to_non_nullable
              as List<CalendarInviteRecipientDto>?,
    ));
  }
}

/// @nodoc
mixin _$EmailAddressDto {
  @JsonKey(name: 'address')
  String? get address;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: '@odata.type')
  String? get odataType;

  /// Create a copy of EmailAddressDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmailAddressDtoCopyWith<EmailAddressDto> get copyWith =>
      _$EmailAddressDtoCopyWithImpl<EmailAddressDto>(
          this as EmailAddressDto, _$identity);

  /// Serializes this EmailAddressDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmailAddressDto &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, address, name, odataType);

  @override
  String toString() {
    return 'EmailAddressDto(address: $address, name: $name, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class $EmailAddressDtoCopyWith<$Res> {
  factory $EmailAddressDtoCopyWith(
          EmailAddressDto value, $Res Function(EmailAddressDto) _then) =
      _$EmailAddressDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'address') String? address,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: '@odata.type') String? odataType});
}

/// @nodoc
class _$EmailAddressDtoCopyWithImpl<$Res>
    implements $EmailAddressDtoCopyWith<$Res> {
  _$EmailAddressDtoCopyWithImpl(this._self, this._then);

  final EmailAddressDto _self;
  final $Res Function(EmailAddressDto) _then;

  /// Create a copy of EmailAddressDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = freezed,
    Object? name = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_self.copyWith(
      address: freezed == address
          ? _self.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [EmailAddressDto].
extension EmailAddressDtoPatterns on EmailAddressDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_EmailAddressDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EmailAddressDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_EmailAddressDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmailAddressDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_EmailAddressDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmailAddressDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'address') String? address,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EmailAddressDto() when $default != null:
        return $default(_that.address, _that.name, _that.odataType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'address') String? address,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: '@odata.type') String? odataType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmailAddressDto():
        return $default(_that.address, _that.name, _that.odataType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'address') String? address,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmailAddressDto() when $default != null:
        return $default(_that.address, _that.name, _that.odataType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _EmailAddressDto implements EmailAddressDto {
  _EmailAddressDto(
      {@JsonKey(name: 'address') this.address,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: '@odata.type') this.odataType});
  factory _EmailAddressDto.fromJson(Map<String, dynamic> json) =>
      _$EmailAddressDtoFromJson(json);

  @override
  @JsonKey(name: 'address')
  final String? address;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: '@odata.type')
  final String? odataType;

  /// Create a copy of EmailAddressDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EmailAddressDtoCopyWith<_EmailAddressDto> get copyWith =>
      __$EmailAddressDtoCopyWithImpl<_EmailAddressDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmailAddressDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EmailAddressDto &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, address, name, odataType);

  @override
  String toString() {
    return 'EmailAddressDto(address: $address, name: $name, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class _$EmailAddressDtoCopyWith<$Res>
    implements $EmailAddressDtoCopyWith<$Res> {
  factory _$EmailAddressDtoCopyWith(
          _EmailAddressDto value, $Res Function(_EmailAddressDto) _then) =
      __$EmailAddressDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'address') String? address,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: '@odata.type') String? odataType});
}

/// @nodoc
class __$EmailAddressDtoCopyWithImpl<$Res>
    implements _$EmailAddressDtoCopyWith<$Res> {
  __$EmailAddressDtoCopyWithImpl(this._self, this._then);

  final _EmailAddressDto _self;
  final $Res Function(_EmailAddressDto) _then;

  /// Create a copy of EmailAddressDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? address = freezed,
    Object? name = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_EmailAddressDto(
      address: freezed == address
          ? _self.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$LastTemperatureVODto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'lastTimeStamp')
  DateTime? get lastTimeStamp;
  @JsonKey(name: 'lastTempCheck')
  String? get lastTempCheck;

  /// Create a copy of LastTemperatureVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $LastTemperatureVODtoCopyWith<LastTemperatureVODto> get copyWith =>
      _$LastTemperatureVODtoCopyWithImpl<LastTemperatureVODto>(
          this as LastTemperatureVODto, _$identity);

  /// Serializes this LastTemperatureVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LastTemperatureVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.lastTimeStamp, lastTimeStamp) ||
                other.lastTimeStamp == lastTimeStamp) &&
            (identical(other.lastTempCheck, lastTempCheck) ||
                other.lastTempCheck == lastTempCheck));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, lastTimeStamp, lastTempCheck);

  @override
  String toString() {
    return 'LastTemperatureVODto(id: $id, lastTimeStamp: $lastTimeStamp, lastTempCheck: $lastTempCheck)';
  }
}

/// @nodoc
abstract mixin class $LastTemperatureVODtoCopyWith<$Res> {
  factory $LastTemperatureVODtoCopyWith(LastTemperatureVODto value,
          $Res Function(LastTemperatureVODto) _then) =
      _$LastTemperatureVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'lastTimeStamp') DateTime? lastTimeStamp,
      @JsonKey(name: 'lastTempCheck') String? lastTempCheck});
}

/// @nodoc
class _$LastTemperatureVODtoCopyWithImpl<$Res>
    implements $LastTemperatureVODtoCopyWith<$Res> {
  _$LastTemperatureVODtoCopyWithImpl(this._self, this._then);

  final LastTemperatureVODto _self;
  final $Res Function(LastTemperatureVODto) _then;

  /// Create a copy of LastTemperatureVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? lastTimeStamp = freezed,
    Object? lastTempCheck = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      lastTimeStamp: freezed == lastTimeStamp
          ? _self.lastTimeStamp
          : lastTimeStamp // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastTempCheck: freezed == lastTempCheck
          ? _self.lastTempCheck
          : lastTempCheck // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [LastTemperatureVODto].
extension LastTemperatureVODtoPatterns on LastTemperatureVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_LastTemperatureVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LastTemperatureVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_LastTemperatureVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LastTemperatureVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_LastTemperatureVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LastTemperatureVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'lastTimeStamp') DateTime? lastTimeStamp,
            @JsonKey(name: 'lastTempCheck') String? lastTempCheck)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LastTemperatureVODto() when $default != null:
        return $default(_that.id, _that.lastTimeStamp, _that.lastTempCheck);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'lastTimeStamp') DateTime? lastTimeStamp,
            @JsonKey(name: 'lastTempCheck') String? lastTempCheck)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LastTemperatureVODto():
        return $default(_that.id, _that.lastTimeStamp, _that.lastTempCheck);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'lastTimeStamp') DateTime? lastTimeStamp,
            @JsonKey(name: 'lastTempCheck') String? lastTempCheck)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LastTemperatureVODto() when $default != null:
        return $default(_that.id, _that.lastTimeStamp, _that.lastTempCheck);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _LastTemperatureVODto implements LastTemperatureVODto {
  _LastTemperatureVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'lastTimeStamp') this.lastTimeStamp,
      @JsonKey(name: 'lastTempCheck') this.lastTempCheck});
  factory _LastTemperatureVODto.fromJson(Map<String, dynamic> json) =>
      _$LastTemperatureVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'lastTimeStamp')
  final DateTime? lastTimeStamp;
  @override
  @JsonKey(name: 'lastTempCheck')
  final String? lastTempCheck;

  /// Create a copy of LastTemperatureVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$LastTemperatureVODtoCopyWith<_LastTemperatureVODto> get copyWith =>
      __$LastTemperatureVODtoCopyWithImpl<_LastTemperatureVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$LastTemperatureVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LastTemperatureVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.lastTimeStamp, lastTimeStamp) ||
                other.lastTimeStamp == lastTimeStamp) &&
            (identical(other.lastTempCheck, lastTempCheck) ||
                other.lastTempCheck == lastTempCheck));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, lastTimeStamp, lastTempCheck);

  @override
  String toString() {
    return 'LastTemperatureVODto(id: $id, lastTimeStamp: $lastTimeStamp, lastTempCheck: $lastTempCheck)';
  }
}

/// @nodoc
abstract mixin class _$LastTemperatureVODtoCopyWith<$Res>
    implements $LastTemperatureVODtoCopyWith<$Res> {
  factory _$LastTemperatureVODtoCopyWith(_LastTemperatureVODto value,
          $Res Function(_LastTemperatureVODto) _then) =
      __$LastTemperatureVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'lastTimeStamp') DateTime? lastTimeStamp,
      @JsonKey(name: 'lastTempCheck') String? lastTempCheck});
}

/// @nodoc
class __$LastTemperatureVODtoCopyWithImpl<$Res>
    implements _$LastTemperatureVODtoCopyWith<$Res> {
  __$LastTemperatureVODtoCopyWithImpl(this._self, this._then);

  final _LastTemperatureVODto _self;
  final $Res Function(_LastTemperatureVODto) _then;

  /// Create a copy of LastTemperatureVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? lastTimeStamp = freezed,
    Object? lastTempCheck = freezed,
  }) {
    return _then(_LastTemperatureVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      lastTimeStamp: freezed == lastTimeStamp
          ? _self.lastTimeStamp
          : lastTimeStamp // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastTempCheck: freezed == lastTempCheck
          ? _self.lastTempCheck
          : lastTempCheck // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$LoginParameterDto {
  @JsonKey(name: 'loginId')
  String get loginId;
  @JsonKey(name: 'password')
  String get password;
  @JsonKey(name: 'organisation')
  String get organisation;
  @JsonKey(name: 'deviceToken')
  String? get deviceToken;
  @JsonKey(name: 'accountType')
  String? get accountType;

  /// Create a copy of LoginParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $LoginParameterDtoCopyWith<LoginParameterDto> get copyWith =>
      _$LoginParameterDtoCopyWithImpl<LoginParameterDto>(
          this as LoginParameterDto, _$identity);

  /// Serializes this LoginParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LoginParameterDto &&
            (identical(other.loginId, loginId) || other.loginId == loginId) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.organisation, organisation) ||
                other.organisation == organisation) &&
            (identical(other.deviceToken, deviceToken) ||
                other.deviceToken == deviceToken) &&
            (identical(other.accountType, accountType) ||
                other.accountType == accountType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, loginId, password, organisation, deviceToken, accountType);

  @override
  String toString() {
    return 'LoginParameterDto(loginId: $loginId, password: $password, organisation: $organisation, deviceToken: $deviceToken, accountType: $accountType)';
  }
}

/// @nodoc
abstract mixin class $LoginParameterDtoCopyWith<$Res> {
  factory $LoginParameterDtoCopyWith(
          LoginParameterDto value, $Res Function(LoginParameterDto) _then) =
      _$LoginParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'loginId') String loginId,
      @JsonKey(name: 'password') String password,
      @JsonKey(name: 'organisation') String organisation,
      @JsonKey(name: 'deviceToken') String? deviceToken,
      @JsonKey(name: 'accountType') String? accountType});
}

/// @nodoc
class _$LoginParameterDtoCopyWithImpl<$Res>
    implements $LoginParameterDtoCopyWith<$Res> {
  _$LoginParameterDtoCopyWithImpl(this._self, this._then);

  final LoginParameterDto _self;
  final $Res Function(LoginParameterDto) _then;

  /// Create a copy of LoginParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loginId = null,
    Object? password = null,
    Object? organisation = null,
    Object? deviceToken = freezed,
    Object? accountType = freezed,
  }) {
    return _then(_self.copyWith(
      loginId: null == loginId
          ? _self.loginId
          : loginId // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
      organisation: null == organisation
          ? _self.organisation
          : organisation // ignore: cast_nullable_to_non_nullable
              as String,
      deviceToken: freezed == deviceToken
          ? _self.deviceToken
          : deviceToken // ignore: cast_nullable_to_non_nullable
              as String?,
      accountType: freezed == accountType
          ? _self.accountType
          : accountType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [LoginParameterDto].
extension LoginParameterDtoPatterns on LoginParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_LoginParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LoginParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_LoginParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_LoginParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'loginId') String loginId,
            @JsonKey(name: 'password') String password,
            @JsonKey(name: 'organisation') String organisation,
            @JsonKey(name: 'deviceToken') String? deviceToken,
            @JsonKey(name: 'accountType') String? accountType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LoginParameterDto() when $default != null:
        return $default(_that.loginId, _that.password, _that.organisation,
            _that.deviceToken, _that.accountType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'loginId') String loginId,
            @JsonKey(name: 'password') String password,
            @JsonKey(name: 'organisation') String organisation,
            @JsonKey(name: 'deviceToken') String? deviceToken,
            @JsonKey(name: 'accountType') String? accountType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginParameterDto():
        return $default(_that.loginId, _that.password, _that.organisation,
            _that.deviceToken, _that.accountType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'loginId') String loginId,
            @JsonKey(name: 'password') String password,
            @JsonKey(name: 'organisation') String organisation,
            @JsonKey(name: 'deviceToken') String? deviceToken,
            @JsonKey(name: 'accountType') String? accountType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginParameterDto() when $default != null:
        return $default(_that.loginId, _that.password, _that.organisation,
            _that.deviceToken, _that.accountType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _LoginParameterDto implements LoginParameterDto {
  _LoginParameterDto(
      {@JsonKey(name: 'loginId') required this.loginId,
      @JsonKey(name: 'password') required this.password,
      @JsonKey(name: 'organisation') required this.organisation,
      @JsonKey(name: 'deviceToken') this.deviceToken,
      @JsonKey(name: 'accountType') this.accountType});
  factory _LoginParameterDto.fromJson(Map<String, dynamic> json) =>
      _$LoginParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'loginId')
  final String loginId;
  @override
  @JsonKey(name: 'password')
  final String password;
  @override
  @JsonKey(name: 'organisation')
  final String organisation;
  @override
  @JsonKey(name: 'deviceToken')
  final String? deviceToken;
  @override
  @JsonKey(name: 'accountType')
  final String? accountType;

  /// Create a copy of LoginParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$LoginParameterDtoCopyWith<_LoginParameterDto> get copyWith =>
      __$LoginParameterDtoCopyWithImpl<_LoginParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$LoginParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LoginParameterDto &&
            (identical(other.loginId, loginId) || other.loginId == loginId) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.organisation, organisation) ||
                other.organisation == organisation) &&
            (identical(other.deviceToken, deviceToken) ||
                other.deviceToken == deviceToken) &&
            (identical(other.accountType, accountType) ||
                other.accountType == accountType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, loginId, password, organisation, deviceToken, accountType);

  @override
  String toString() {
    return 'LoginParameterDto(loginId: $loginId, password: $password, organisation: $organisation, deviceToken: $deviceToken, accountType: $accountType)';
  }
}

/// @nodoc
abstract mixin class _$LoginParameterDtoCopyWith<$Res>
    implements $LoginParameterDtoCopyWith<$Res> {
  factory _$LoginParameterDtoCopyWith(
          _LoginParameterDto value, $Res Function(_LoginParameterDto) _then) =
      __$LoginParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'loginId') String loginId,
      @JsonKey(name: 'password') String password,
      @JsonKey(name: 'organisation') String organisation,
      @JsonKey(name: 'deviceToken') String? deviceToken,
      @JsonKey(name: 'accountType') String? accountType});
}

/// @nodoc
class __$LoginParameterDtoCopyWithImpl<$Res>
    implements _$LoginParameterDtoCopyWith<$Res> {
  __$LoginParameterDtoCopyWithImpl(this._self, this._then);

  final _LoginParameterDto _self;
  final $Res Function(_LoginParameterDto) _then;

  /// Create a copy of LoginParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? loginId = null,
    Object? password = null,
    Object? organisation = null,
    Object? deviceToken = freezed,
    Object? accountType = freezed,
  }) {
    return _then(_LoginParameterDto(
      loginId: null == loginId
          ? _self.loginId
          : loginId // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
      organisation: null == organisation
          ? _self.organisation
          : organisation // ignore: cast_nullable_to_non_nullable
              as String,
      deviceToken: freezed == deviceToken
          ? _self.deviceToken
          : deviceToken // ignore: cast_nullable_to_non_nullable
              as String?,
      accountType: freezed == accountType
          ? _self.accountType
          : accountType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MarkAttendanceParameterDto {
  @JsonKey(name: 'attendanceStatus')
  String? get attendanceStatus;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'optionalDateTime')
  String? get optionalDateTime;

  /// Create a copy of MarkAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MarkAttendanceParameterDtoCopyWith<MarkAttendanceParameterDto>
      get copyWith =>
          _$MarkAttendanceParameterDtoCopyWithImpl<MarkAttendanceParameterDto>(
              this as MarkAttendanceParameterDto, _$identity);

  /// Serializes this MarkAttendanceParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MarkAttendanceParameterDto &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, attendanceStatus, remarks, optionalDateTime);

  @override
  String toString() {
    return 'MarkAttendanceParameterDto(attendanceStatus: $attendanceStatus, remarks: $remarks, optionalDateTime: $optionalDateTime)';
  }
}

/// @nodoc
abstract mixin class $MarkAttendanceParameterDtoCopyWith<$Res> {
  factory $MarkAttendanceParameterDtoCopyWith(MarkAttendanceParameterDto value,
          $Res Function(MarkAttendanceParameterDto) _then) =
      _$MarkAttendanceParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime});
}

/// @nodoc
class _$MarkAttendanceParameterDtoCopyWithImpl<$Res>
    implements $MarkAttendanceParameterDtoCopyWith<$Res> {
  _$MarkAttendanceParameterDtoCopyWithImpl(this._self, this._then);

  final MarkAttendanceParameterDto _self;
  final $Res Function(MarkAttendanceParameterDto) _then;

  /// Create a copy of MarkAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? optionalDateTime = freezed,
  }) {
    return _then(_self.copyWith(
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MarkAttendanceParameterDto].
extension MarkAttendanceParameterDtoPatterns on MarkAttendanceParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MarkAttendanceParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkAttendanceParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MarkAttendanceParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkAttendanceParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MarkAttendanceParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkAttendanceParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkAttendanceParameterDto() when $default != null:
        return $default(
            _that.attendanceStatus, _that.remarks, _that.optionalDateTime);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkAttendanceParameterDto():
        return $default(
            _that.attendanceStatus, _that.remarks, _that.optionalDateTime);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkAttendanceParameterDto() when $default != null:
        return $default(
            _that.attendanceStatus, _that.remarks, _that.optionalDateTime);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MarkAttendanceParameterDto implements MarkAttendanceParameterDto {
  _MarkAttendanceParameterDto(
      {@JsonKey(name: 'attendanceStatus') this.attendanceStatus,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'optionalDateTime') this.optionalDateTime});
  factory _MarkAttendanceParameterDto.fromJson(Map<String, dynamic> json) =>
      _$MarkAttendanceParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'attendanceStatus')
  final String? attendanceStatus;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'optionalDateTime')
  final String? optionalDateTime;

  /// Create a copy of MarkAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MarkAttendanceParameterDtoCopyWith<_MarkAttendanceParameterDto>
      get copyWith => __$MarkAttendanceParameterDtoCopyWithImpl<
          _MarkAttendanceParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MarkAttendanceParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MarkAttendanceParameterDto &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, attendanceStatus, remarks, optionalDateTime);

  @override
  String toString() {
    return 'MarkAttendanceParameterDto(attendanceStatus: $attendanceStatus, remarks: $remarks, optionalDateTime: $optionalDateTime)';
  }
}

/// @nodoc
abstract mixin class _$MarkAttendanceParameterDtoCopyWith<$Res>
    implements $MarkAttendanceParameterDtoCopyWith<$Res> {
  factory _$MarkAttendanceParameterDtoCopyWith(
          _MarkAttendanceParameterDto value,
          $Res Function(_MarkAttendanceParameterDto) _then) =
      __$MarkAttendanceParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime});
}

/// @nodoc
class __$MarkAttendanceParameterDtoCopyWithImpl<$Res>
    implements _$MarkAttendanceParameterDtoCopyWith<$Res> {
  __$MarkAttendanceParameterDtoCopyWithImpl(this._self, this._then);

  final _MarkAttendanceParameterDto _self;
  final $Res Function(_MarkAttendanceParameterDto) _then;

  /// Create a copy of MarkAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? optionalDateTime = freezed,
  }) {
    return _then(_MarkAttendanceParameterDto(
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MarkCheckInOutParameterDto {
  @JsonKey(name: 'checkType')
  String? get checkType;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'optionalDateTime')
  String? get optionalDateTime;
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'file64BitString')
  String? get file64BitString;

  /// Create a copy of MarkCheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MarkCheckInOutParameterDtoCopyWith<MarkCheckInOutParameterDto>
      get copyWith =>
          _$MarkCheckInOutParameterDtoCopyWithImpl<MarkCheckInOutParameterDto>(
              this as MarkCheckInOutParameterDto, _$identity);

  /// Serializes this MarkCheckInOutParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MarkCheckInOutParameterDto &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.file64BitString, file64BitString) ||
                other.file64BitString == file64BitString));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, checkType, remarks,
      optionalDateTime, fileName, file64BitString);

  @override
  String toString() {
    return 'MarkCheckInOutParameterDto(checkType: $checkType, remarks: $remarks, optionalDateTime: $optionalDateTime, fileName: $fileName, file64BitString: $file64BitString)';
  }
}

/// @nodoc
abstract mixin class $MarkCheckInOutParameterDtoCopyWith<$Res> {
  factory $MarkCheckInOutParameterDtoCopyWith(MarkCheckInOutParameterDto value,
          $Res Function(MarkCheckInOutParameterDto) _then) =
      _$MarkCheckInOutParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'file64BitString') String? file64BitString});
}

/// @nodoc
class _$MarkCheckInOutParameterDtoCopyWithImpl<$Res>
    implements $MarkCheckInOutParameterDtoCopyWith<$Res> {
  _$MarkCheckInOutParameterDtoCopyWithImpl(this._self, this._then);

  final MarkCheckInOutParameterDto _self;
  final $Res Function(MarkCheckInOutParameterDto) _then;

  /// Create a copy of MarkCheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? optionalDateTime = freezed,
    Object? fileName = freezed,
    Object? file64BitString = freezed,
  }) {
    return _then(_self.copyWith(
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      file64BitString: freezed == file64BitString
          ? _self.file64BitString
          : file64BitString // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MarkCheckInOutParameterDto].
extension MarkCheckInOutParameterDtoPatterns on MarkCheckInOutParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MarkCheckInOutParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkCheckInOutParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MarkCheckInOutParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkCheckInOutParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MarkCheckInOutParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkCheckInOutParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'file64BitString') String? file64BitString)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkCheckInOutParameterDto() when $default != null:
        return $default(_that.checkType, _that.remarks, _that.optionalDateTime,
            _that.fileName, _that.file64BitString);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'file64BitString') String? file64BitString)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkCheckInOutParameterDto():
        return $default(_that.checkType, _that.remarks, _that.optionalDateTime,
            _that.fileName, _that.file64BitString);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'checkType') String? checkType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'file64BitString') String? file64BitString)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkCheckInOutParameterDto() when $default != null:
        return $default(_that.checkType, _that.remarks, _that.optionalDateTime,
            _that.fileName, _that.file64BitString);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MarkCheckInOutParameterDto implements MarkCheckInOutParameterDto {
  _MarkCheckInOutParameterDto(
      {@JsonKey(name: 'checkType') this.checkType,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'optionalDateTime') this.optionalDateTime,
      @JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'file64BitString') this.file64BitString});
  factory _MarkCheckInOutParameterDto.fromJson(Map<String, dynamic> json) =>
      _$MarkCheckInOutParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'checkType')
  final String? checkType;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'optionalDateTime')
  final String? optionalDateTime;
  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'file64BitString')
  final String? file64BitString;

  /// Create a copy of MarkCheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MarkCheckInOutParameterDtoCopyWith<_MarkCheckInOutParameterDto>
      get copyWith => __$MarkCheckInOutParameterDtoCopyWithImpl<
          _MarkCheckInOutParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MarkCheckInOutParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MarkCheckInOutParameterDto &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.file64BitString, file64BitString) ||
                other.file64BitString == file64BitString));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, checkType, remarks,
      optionalDateTime, fileName, file64BitString);

  @override
  String toString() {
    return 'MarkCheckInOutParameterDto(checkType: $checkType, remarks: $remarks, optionalDateTime: $optionalDateTime, fileName: $fileName, file64BitString: $file64BitString)';
  }
}

/// @nodoc
abstract mixin class _$MarkCheckInOutParameterDtoCopyWith<$Res>
    implements $MarkCheckInOutParameterDtoCopyWith<$Res> {
  factory _$MarkCheckInOutParameterDtoCopyWith(
          _MarkCheckInOutParameterDto value,
          $Res Function(_MarkCheckInOutParameterDto) _then) =
      __$MarkCheckInOutParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'checkType') String? checkType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'file64BitString') String? file64BitString});
}

/// @nodoc
class __$MarkCheckInOutParameterDtoCopyWithImpl<$Res>
    implements _$MarkCheckInOutParameterDtoCopyWith<$Res> {
  __$MarkCheckInOutParameterDtoCopyWithImpl(this._self, this._then);

  final _MarkCheckInOutParameterDto _self;
  final $Res Function(_MarkCheckInOutParameterDto) _then;

  /// Create a copy of MarkCheckInOutParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? checkType = freezed,
    Object? remarks = freezed,
    Object? optionalDateTime = freezed,
    Object? fileName = freezed,
    Object? file64BitString = freezed,
  }) {
    return _then(_MarkCheckInOutParameterDto(
      checkType: freezed == checkType
          ? _self.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      file64BitString: freezed == file64BitString
          ? _self.file64BitString
          : file64BitString // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MarkDailyRoutineParameterDto {
  @JsonKey(name: 'referenceType')
  String? get referenceType;
  @JsonKey(name: 'startTime')
  String? get startTime;
  @JsonKey(name: 'endTime')
  String? get endTime;
  @JsonKey(name: 'remarks')
  String? get remarks;

  /// Create a copy of MarkDailyRoutineParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MarkDailyRoutineParameterDtoCopyWith<MarkDailyRoutineParameterDto>
      get copyWith => _$MarkDailyRoutineParameterDtoCopyWithImpl<
              MarkDailyRoutineParameterDto>(
          this as MarkDailyRoutineParameterDto, _$identity);

  /// Serializes this MarkDailyRoutineParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MarkDailyRoutineParameterDto &&
            (identical(other.referenceType, referenceType) ||
                other.referenceType == referenceType) &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime) &&
            (identical(other.endTime, endTime) || other.endTime == endTime) &&
            (identical(other.remarks, remarks) || other.remarks == remarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, referenceType, startTime, endTime, remarks);

  @override
  String toString() {
    return 'MarkDailyRoutineParameterDto(referenceType: $referenceType, startTime: $startTime, endTime: $endTime, remarks: $remarks)';
  }
}

/// @nodoc
abstract mixin class $MarkDailyRoutineParameterDtoCopyWith<$Res> {
  factory $MarkDailyRoutineParameterDtoCopyWith(
          MarkDailyRoutineParameterDto value,
          $Res Function(MarkDailyRoutineParameterDto) _then) =
      _$MarkDailyRoutineParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'referenceType') String? referenceType,
      @JsonKey(name: 'startTime') String? startTime,
      @JsonKey(name: 'endTime') String? endTime,
      @JsonKey(name: 'remarks') String? remarks});
}

/// @nodoc
class _$MarkDailyRoutineParameterDtoCopyWithImpl<$Res>
    implements $MarkDailyRoutineParameterDtoCopyWith<$Res> {
  _$MarkDailyRoutineParameterDtoCopyWithImpl(this._self, this._then);

  final MarkDailyRoutineParameterDto _self;
  final $Res Function(MarkDailyRoutineParameterDto) _then;

  /// Create a copy of MarkDailyRoutineParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? referenceType = freezed,
    Object? startTime = freezed,
    Object? endTime = freezed,
    Object? remarks = freezed,
  }) {
    return _then(_self.copyWith(
      referenceType: freezed == referenceType
          ? _self.referenceType
          : referenceType // ignore: cast_nullable_to_non_nullable
              as String?,
      startTime: freezed == startTime
          ? _self.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as String?,
      endTime: freezed == endTime
          ? _self.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MarkDailyRoutineParameterDto].
extension MarkDailyRoutineParameterDtoPatterns on MarkDailyRoutineParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MarkDailyRoutineParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkDailyRoutineParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MarkDailyRoutineParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkDailyRoutineParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MarkDailyRoutineParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkDailyRoutineParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'referenceType') String? referenceType,
            @JsonKey(name: 'startTime') String? startTime,
            @JsonKey(name: 'endTime') String? endTime,
            @JsonKey(name: 'remarks') String? remarks)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkDailyRoutineParameterDto() when $default != null:
        return $default(
            _that.referenceType, _that.startTime, _that.endTime, _that.remarks);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'referenceType') String? referenceType,
            @JsonKey(name: 'startTime') String? startTime,
            @JsonKey(name: 'endTime') String? endTime,
            @JsonKey(name: 'remarks') String? remarks)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkDailyRoutineParameterDto():
        return $default(
            _that.referenceType, _that.startTime, _that.endTime, _that.remarks);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'referenceType') String? referenceType,
            @JsonKey(name: 'startTime') String? startTime,
            @JsonKey(name: 'endTime') String? endTime,
            @JsonKey(name: 'remarks') String? remarks)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkDailyRoutineParameterDto() when $default != null:
        return $default(
            _that.referenceType, _that.startTime, _that.endTime, _that.remarks);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MarkDailyRoutineParameterDto implements MarkDailyRoutineParameterDto {
  _MarkDailyRoutineParameterDto(
      {@JsonKey(name: 'referenceType') this.referenceType,
      @JsonKey(name: 'startTime') this.startTime,
      @JsonKey(name: 'endTime') this.endTime,
      @JsonKey(name: 'remarks') this.remarks});
  factory _MarkDailyRoutineParameterDto.fromJson(Map<String, dynamic> json) =>
      _$MarkDailyRoutineParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'referenceType')
  final String? referenceType;
  @override
  @JsonKey(name: 'startTime')
  final String? startTime;
  @override
  @JsonKey(name: 'endTime')
  final String? endTime;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;

  /// Create a copy of MarkDailyRoutineParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MarkDailyRoutineParameterDtoCopyWith<_MarkDailyRoutineParameterDto>
      get copyWith => __$MarkDailyRoutineParameterDtoCopyWithImpl<
          _MarkDailyRoutineParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MarkDailyRoutineParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MarkDailyRoutineParameterDto &&
            (identical(other.referenceType, referenceType) ||
                other.referenceType == referenceType) &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime) &&
            (identical(other.endTime, endTime) || other.endTime == endTime) &&
            (identical(other.remarks, remarks) || other.remarks == remarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, referenceType, startTime, endTime, remarks);

  @override
  String toString() {
    return 'MarkDailyRoutineParameterDto(referenceType: $referenceType, startTime: $startTime, endTime: $endTime, remarks: $remarks)';
  }
}

/// @nodoc
abstract mixin class _$MarkDailyRoutineParameterDtoCopyWith<$Res>
    implements $MarkDailyRoutineParameterDtoCopyWith<$Res> {
  factory _$MarkDailyRoutineParameterDtoCopyWith(
          _MarkDailyRoutineParameterDto value,
          $Res Function(_MarkDailyRoutineParameterDto) _then) =
      __$MarkDailyRoutineParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'referenceType') String? referenceType,
      @JsonKey(name: 'startTime') String? startTime,
      @JsonKey(name: 'endTime') String? endTime,
      @JsonKey(name: 'remarks') String? remarks});
}

/// @nodoc
class __$MarkDailyRoutineParameterDtoCopyWithImpl<$Res>
    implements _$MarkDailyRoutineParameterDtoCopyWith<$Res> {
  __$MarkDailyRoutineParameterDtoCopyWithImpl(this._self, this._then);

  final _MarkDailyRoutineParameterDto _self;
  final $Res Function(_MarkDailyRoutineParameterDto) _then;

  /// Create a copy of MarkDailyRoutineParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? referenceType = freezed,
    Object? startTime = freezed,
    Object? endTime = freezed,
    Object? remarks = freezed,
  }) {
    return _then(_MarkDailyRoutineParameterDto(
      referenceType: freezed == referenceType
          ? _self.referenceType
          : referenceType // ignore: cast_nullable_to_non_nullable
              as String?,
      startTime: freezed == startTime
          ? _self.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as String?,
      endTime: freezed == endTime
          ? _self.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MarkMassAttendanceParameterDto {
  @JsonKey(name: 'attendanceStatus')
  String? get attendanceStatus;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'studentIds')
  List<String>? get studentIds;
  @JsonKey(name: 'optionalDateTime')
  String? get optionalDateTime;

  /// Create a copy of MarkMassAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MarkMassAttendanceParameterDtoCopyWith<MarkMassAttendanceParameterDto>
      get copyWith => _$MarkMassAttendanceParameterDtoCopyWithImpl<
              MarkMassAttendanceParameterDto>(
          this as MarkMassAttendanceParameterDto, _$identity);

  /// Serializes this MarkMassAttendanceParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MarkMassAttendanceParameterDto &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            const DeepCollectionEquality()
                .equals(other.studentIds, studentIds) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, attendanceStatus, remarks,
      const DeepCollectionEquality().hash(studentIds), optionalDateTime);

  @override
  String toString() {
    return 'MarkMassAttendanceParameterDto(attendanceStatus: $attendanceStatus, remarks: $remarks, studentIds: $studentIds, optionalDateTime: $optionalDateTime)';
  }
}

/// @nodoc
abstract mixin class $MarkMassAttendanceParameterDtoCopyWith<$Res> {
  factory $MarkMassAttendanceParameterDtoCopyWith(
          MarkMassAttendanceParameterDto value,
          $Res Function(MarkMassAttendanceParameterDto) _then) =
      _$MarkMassAttendanceParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'studentIds') List<String>? studentIds,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime});
}

/// @nodoc
class _$MarkMassAttendanceParameterDtoCopyWithImpl<$Res>
    implements $MarkMassAttendanceParameterDtoCopyWith<$Res> {
  _$MarkMassAttendanceParameterDtoCopyWithImpl(this._self, this._then);

  final MarkMassAttendanceParameterDto _self;
  final $Res Function(MarkMassAttendanceParameterDto) _then;

  /// Create a copy of MarkMassAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? studentIds = freezed,
    Object? optionalDateTime = freezed,
  }) {
    return _then(_self.copyWith(
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      studentIds: freezed == studentIds
          ? _self.studentIds
          : studentIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MarkMassAttendanceParameterDto].
extension MarkMassAttendanceParameterDtoPatterns
    on MarkMassAttendanceParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MarkMassAttendanceParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkMassAttendanceParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MarkMassAttendanceParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkMassAttendanceParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MarkMassAttendanceParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkMassAttendanceParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'studentIds') List<String>? studentIds,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkMassAttendanceParameterDto() when $default != null:
        return $default(_that.attendanceStatus, _that.remarks, _that.studentIds,
            _that.optionalDateTime);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'studentIds') List<String>? studentIds,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkMassAttendanceParameterDto():
        return $default(_that.attendanceStatus, _that.remarks, _that.studentIds,
            _that.optionalDateTime);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'attendanceStatus') String? attendanceStatus,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'studentIds') List<String>? studentIds,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkMassAttendanceParameterDto() when $default != null:
        return $default(_that.attendanceStatus, _that.remarks, _that.studentIds,
            _that.optionalDateTime);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MarkMassAttendanceParameterDto
    implements MarkMassAttendanceParameterDto {
  _MarkMassAttendanceParameterDto(
      {@JsonKey(name: 'attendanceStatus') this.attendanceStatus,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'studentIds') final List<String>? studentIds,
      @JsonKey(name: 'optionalDateTime') this.optionalDateTime})
      : _studentIds = studentIds;
  factory _MarkMassAttendanceParameterDto.fromJson(Map<String, dynamic> json) =>
      _$MarkMassAttendanceParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'attendanceStatus')
  final String? attendanceStatus;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  final List<String>? _studentIds;
  @override
  @JsonKey(name: 'studentIds')
  List<String>? get studentIds {
    final value = _studentIds;
    if (value == null) return null;
    if (_studentIds is EqualUnmodifiableListView) return _studentIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'optionalDateTime')
  final String? optionalDateTime;

  /// Create a copy of MarkMassAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MarkMassAttendanceParameterDtoCopyWith<_MarkMassAttendanceParameterDto>
      get copyWith => __$MarkMassAttendanceParameterDtoCopyWithImpl<
          _MarkMassAttendanceParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MarkMassAttendanceParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MarkMassAttendanceParameterDto &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            const DeepCollectionEquality()
                .equals(other._studentIds, _studentIds) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, attendanceStatus, remarks,
      const DeepCollectionEquality().hash(_studentIds), optionalDateTime);

  @override
  String toString() {
    return 'MarkMassAttendanceParameterDto(attendanceStatus: $attendanceStatus, remarks: $remarks, studentIds: $studentIds, optionalDateTime: $optionalDateTime)';
  }
}

/// @nodoc
abstract mixin class _$MarkMassAttendanceParameterDtoCopyWith<$Res>
    implements $MarkMassAttendanceParameterDtoCopyWith<$Res> {
  factory _$MarkMassAttendanceParameterDtoCopyWith(
          _MarkMassAttendanceParameterDto value,
          $Res Function(_MarkMassAttendanceParameterDto) _then) =
      __$MarkMassAttendanceParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'attendanceStatus') String? attendanceStatus,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'studentIds') List<String>? studentIds,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime});
}

/// @nodoc
class __$MarkMassAttendanceParameterDtoCopyWithImpl<$Res>
    implements _$MarkMassAttendanceParameterDtoCopyWith<$Res> {
  __$MarkMassAttendanceParameterDtoCopyWithImpl(this._self, this._then);

  final _MarkMassAttendanceParameterDto _self;
  final $Res Function(_MarkMassAttendanceParameterDto) _then;

  /// Create a copy of MarkMassAttendanceParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? attendanceStatus = freezed,
    Object? remarks = freezed,
    Object? studentIds = freezed,
    Object? optionalDateTime = freezed,
  }) {
    return _then(_MarkMassAttendanceParameterDto(
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      studentIds: freezed == studentIds
          ? _self._studentIds
          : studentIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MarkTemperatureCheckParameterDto {
  @JsonKey(name: 'temperature')
  num? get temperature;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'optionalDateTime')
  String? get optionalDateTime;

  /// Create a copy of MarkTemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MarkTemperatureCheckParameterDtoCopyWith<MarkTemperatureCheckParameterDto>
      get copyWith => _$MarkTemperatureCheckParameterDtoCopyWithImpl<
              MarkTemperatureCheckParameterDto>(
          this as MarkTemperatureCheckParameterDto, _$identity);

  /// Serializes this MarkTemperatureCheckParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MarkTemperatureCheckParameterDto &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, temperature, remarks, optionalDateTime);

  @override
  String toString() {
    return 'MarkTemperatureCheckParameterDto(temperature: $temperature, remarks: $remarks, optionalDateTime: $optionalDateTime)';
  }
}

/// @nodoc
abstract mixin class $MarkTemperatureCheckParameterDtoCopyWith<$Res> {
  factory $MarkTemperatureCheckParameterDtoCopyWith(
          MarkTemperatureCheckParameterDto value,
          $Res Function(MarkTemperatureCheckParameterDto) _then) =
      _$MarkTemperatureCheckParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'temperature') num? temperature,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime});
}

/// @nodoc
class _$MarkTemperatureCheckParameterDtoCopyWithImpl<$Res>
    implements $MarkTemperatureCheckParameterDtoCopyWith<$Res> {
  _$MarkTemperatureCheckParameterDtoCopyWithImpl(this._self, this._then);

  final MarkTemperatureCheckParameterDto _self;
  final $Res Function(MarkTemperatureCheckParameterDto) _then;

  /// Create a copy of MarkTemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? temperature = freezed,
    Object? remarks = freezed,
    Object? optionalDateTime = freezed,
  }) {
    return _then(_self.copyWith(
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as num?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MarkTemperatureCheckParameterDto].
extension MarkTemperatureCheckParameterDtoPatterns
    on MarkTemperatureCheckParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MarkTemperatureCheckParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkTemperatureCheckParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MarkTemperatureCheckParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkTemperatureCheckParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MarkTemperatureCheckParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkTemperatureCheckParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'temperature') num? temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MarkTemperatureCheckParameterDto() when $default != null:
        return $default(
            _that.temperature, _that.remarks, _that.optionalDateTime);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'temperature') num? temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkTemperatureCheckParameterDto():
        return $default(
            _that.temperature, _that.remarks, _that.optionalDateTime);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'temperature') num? temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'optionalDateTime') String? optionalDateTime)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MarkTemperatureCheckParameterDto() when $default != null:
        return $default(
            _that.temperature, _that.remarks, _that.optionalDateTime);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MarkTemperatureCheckParameterDto
    implements MarkTemperatureCheckParameterDto {
  _MarkTemperatureCheckParameterDto(
      {@JsonKey(name: 'temperature') this.temperature,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'optionalDateTime') this.optionalDateTime});
  factory _MarkTemperatureCheckParameterDto.fromJson(
          Map<String, dynamic> json) =>
      _$MarkTemperatureCheckParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'temperature')
  final num? temperature;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'optionalDateTime')
  final String? optionalDateTime;

  /// Create a copy of MarkTemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MarkTemperatureCheckParameterDtoCopyWith<_MarkTemperatureCheckParameterDto>
      get copyWith => __$MarkTemperatureCheckParameterDtoCopyWithImpl<
          _MarkTemperatureCheckParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MarkTemperatureCheckParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MarkTemperatureCheckParameterDto &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.optionalDateTime, optionalDateTime) ||
                other.optionalDateTime == optionalDateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, temperature, remarks, optionalDateTime);

  @override
  String toString() {
    return 'MarkTemperatureCheckParameterDto(temperature: $temperature, remarks: $remarks, optionalDateTime: $optionalDateTime)';
  }
}

/// @nodoc
abstract mixin class _$MarkTemperatureCheckParameterDtoCopyWith<$Res>
    implements $MarkTemperatureCheckParameterDtoCopyWith<$Res> {
  factory _$MarkTemperatureCheckParameterDtoCopyWith(
          _MarkTemperatureCheckParameterDto value,
          $Res Function(_MarkTemperatureCheckParameterDto) _then) =
      __$MarkTemperatureCheckParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'temperature') num? temperature,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'optionalDateTime') String? optionalDateTime});
}

/// @nodoc
class __$MarkTemperatureCheckParameterDtoCopyWithImpl<$Res>
    implements _$MarkTemperatureCheckParameterDtoCopyWith<$Res> {
  __$MarkTemperatureCheckParameterDtoCopyWithImpl(this._self, this._then);

  final _MarkTemperatureCheckParameterDto _self;
  final $Res Function(_MarkTemperatureCheckParameterDto) _then;

  /// Create a copy of MarkTemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? temperature = freezed,
    Object? remarks = freezed,
    Object? optionalDateTime = freezed,
  }) {
    return _then(_MarkTemperatureCheckParameterDto(
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as num?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      optionalDateTime: freezed == optionalDateTime
          ? _self.optionalDateTime
          : optionalDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MedicineAuditDetailVODto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'medicineFormId')
  int? get medicineFormId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'dosage')
  String? get dosage;
  @JsonKey(name: 'administrationManner')
  String? get administrationManner;
  @JsonKey(name: 'medicineExpirationDate')
  DateTime? get medicineExpirationDate;
  @JsonKey(name: 'entityFileRefId')
  String? get entityFileRefId;
  @JsonKey(name: 'entityFileUrl')
  String? get entityFileUrl;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'isTaken')
  bool? get isTaken;

  /// Create a copy of MedicineAuditDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineAuditDetailVODtoCopyWith<MedicineAuditDetailVODto> get copyWith =>
      _$MedicineAuditDetailVODtoCopyWithImpl<MedicineAuditDetailVODto>(
          this as MedicineAuditDetailVODto, _$identity);

  /// Serializes this MedicineAuditDetailVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineAuditDetailVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.dosage, dosage) || other.dosage == dosage) &&
            (identical(other.administrationManner, administrationManner) ||
                other.administrationManner == administrationManner) &&
            (identical(other.medicineExpirationDate, medicineExpirationDate) ||
                other.medicineExpirationDate == medicineExpirationDate) &&
            (identical(other.entityFileRefId, entityFileRefId) ||
                other.entityFileRefId == entityFileRefId) &&
            (identical(other.entityFileUrl, entityFileUrl) ||
                other.entityFileUrl == entityFileUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.isTaken, isTaken) || other.isTaken == isTaken));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      medicineFormId,
      name,
      dosage,
      administrationManner,
      medicineExpirationDate,
      entityFileRefId,
      entityFileUrl,
      fileUrl,
      remarks,
      isTaken);

  @override
  String toString() {
    return 'MedicineAuditDetailVODto(id: $id, medicineFormId: $medicineFormId, name: $name, dosage: $dosage, administrationManner: $administrationManner, medicineExpirationDate: $medicineExpirationDate, entityFileRefId: $entityFileRefId, entityFileUrl: $entityFileUrl, fileUrl: $fileUrl, remarks: $remarks, isTaken: $isTaken)';
  }
}

/// @nodoc
abstract mixin class $MedicineAuditDetailVODtoCopyWith<$Res> {
  factory $MedicineAuditDetailVODtoCopyWith(MedicineAuditDetailVODto value,
          $Res Function(MedicineAuditDetailVODto) _then) =
      _$MedicineAuditDetailVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'dosage') String? dosage,
      @JsonKey(name: 'administrationManner') String? administrationManner,
      @JsonKey(name: 'medicineExpirationDate') DateTime? medicineExpirationDate,
      @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
      @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'isTaken') bool? isTaken});
}

/// @nodoc
class _$MedicineAuditDetailVODtoCopyWithImpl<$Res>
    implements $MedicineAuditDetailVODtoCopyWith<$Res> {
  _$MedicineAuditDetailVODtoCopyWithImpl(this._self, this._then);

  final MedicineAuditDetailVODto _self;
  final $Res Function(MedicineAuditDetailVODto) _then;

  /// Create a copy of MedicineAuditDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? medicineFormId = freezed,
    Object? name = freezed,
    Object? dosage = freezed,
    Object? administrationManner = freezed,
    Object? medicineExpirationDate = freezed,
    Object? entityFileRefId = freezed,
    Object? entityFileUrl = freezed,
    Object? fileUrl = freezed,
    Object? remarks = freezed,
    Object? isTaken = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      dosage: freezed == dosage
          ? _self.dosage
          : dosage // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationManner: freezed == administrationManner
          ? _self.administrationManner
          : administrationManner // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineExpirationDate: freezed == medicineExpirationDate
          ? _self.medicineExpirationDate
          : medicineExpirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      entityFileRefId: freezed == entityFileRefId
          ? _self.entityFileRefId
          : entityFileRefId // ignore: cast_nullable_to_non_nullable
              as String?,
      entityFileUrl: freezed == entityFileUrl
          ? _self.entityFileUrl
          : entityFileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      isTaken: freezed == isTaken
          ? _self.isTaken
          : isTaken // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineAuditDetailVODto].
extension MedicineAuditDetailVODtoPatterns on MedicineAuditDetailVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineAuditDetailVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditDetailVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineAuditDetailVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditDetailVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineAuditDetailVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditDetailVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'dosage') String? dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isTaken') bool? isTaken)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditDetailVODto() when $default != null:
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.medicineExpirationDate,
            _that.entityFileRefId,
            _that.entityFileUrl,
            _that.fileUrl,
            _that.remarks,
            _that.isTaken);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'dosage') String? dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isTaken') bool? isTaken)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditDetailVODto():
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.medicineExpirationDate,
            _that.entityFileRefId,
            _that.entityFileUrl,
            _that.fileUrl,
            _that.remarks,
            _that.isTaken);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'dosage') String? dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isTaken') bool? isTaken)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditDetailVODto() when $default != null:
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.medicineExpirationDate,
            _that.entityFileRefId,
            _that.entityFileUrl,
            _that.fileUrl,
            _that.remarks,
            _that.isTaken);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineAuditDetailVODto implements MedicineAuditDetailVODto {
  _MedicineAuditDetailVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'medicineFormId') this.medicineFormId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'dosage') this.dosage,
      @JsonKey(name: 'administrationManner') this.administrationManner,
      @JsonKey(name: 'medicineExpirationDate') this.medicineExpirationDate,
      @JsonKey(name: 'entityFileRefId') this.entityFileRefId,
      @JsonKey(name: 'entityFileUrl') this.entityFileUrl,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'isTaken') this.isTaken});
  factory _MedicineAuditDetailVODto.fromJson(Map<String, dynamic> json) =>
      _$MedicineAuditDetailVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'medicineFormId')
  final int? medicineFormId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'dosage')
  final String? dosage;
  @override
  @JsonKey(name: 'administrationManner')
  final String? administrationManner;
  @override
  @JsonKey(name: 'medicineExpirationDate')
  final DateTime? medicineExpirationDate;
  @override
  @JsonKey(name: 'entityFileRefId')
  final String? entityFileRefId;
  @override
  @JsonKey(name: 'entityFileUrl')
  final String? entityFileUrl;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'isTaken')
  final bool? isTaken;

  /// Create a copy of MedicineAuditDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineAuditDetailVODtoCopyWith<_MedicineAuditDetailVODto> get copyWith =>
      __$MedicineAuditDetailVODtoCopyWithImpl<_MedicineAuditDetailVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineAuditDetailVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineAuditDetailVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.dosage, dosage) || other.dosage == dosage) &&
            (identical(other.administrationManner, administrationManner) ||
                other.administrationManner == administrationManner) &&
            (identical(other.medicineExpirationDate, medicineExpirationDate) ||
                other.medicineExpirationDate == medicineExpirationDate) &&
            (identical(other.entityFileRefId, entityFileRefId) ||
                other.entityFileRefId == entityFileRefId) &&
            (identical(other.entityFileUrl, entityFileUrl) ||
                other.entityFileUrl == entityFileUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.isTaken, isTaken) || other.isTaken == isTaken));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      medicineFormId,
      name,
      dosage,
      administrationManner,
      medicineExpirationDate,
      entityFileRefId,
      entityFileUrl,
      fileUrl,
      remarks,
      isTaken);

  @override
  String toString() {
    return 'MedicineAuditDetailVODto(id: $id, medicineFormId: $medicineFormId, name: $name, dosage: $dosage, administrationManner: $administrationManner, medicineExpirationDate: $medicineExpirationDate, entityFileRefId: $entityFileRefId, entityFileUrl: $entityFileUrl, fileUrl: $fileUrl, remarks: $remarks, isTaken: $isTaken)';
  }
}

/// @nodoc
abstract mixin class _$MedicineAuditDetailVODtoCopyWith<$Res>
    implements $MedicineAuditDetailVODtoCopyWith<$Res> {
  factory _$MedicineAuditDetailVODtoCopyWith(_MedicineAuditDetailVODto value,
          $Res Function(_MedicineAuditDetailVODto) _then) =
      __$MedicineAuditDetailVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'dosage') String? dosage,
      @JsonKey(name: 'administrationManner') String? administrationManner,
      @JsonKey(name: 'medicineExpirationDate') DateTime? medicineExpirationDate,
      @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
      @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'isTaken') bool? isTaken});
}

/// @nodoc
class __$MedicineAuditDetailVODtoCopyWithImpl<$Res>
    implements _$MedicineAuditDetailVODtoCopyWith<$Res> {
  __$MedicineAuditDetailVODtoCopyWithImpl(this._self, this._then);

  final _MedicineAuditDetailVODto _self;
  final $Res Function(_MedicineAuditDetailVODto) _then;

  /// Create a copy of MedicineAuditDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? medicineFormId = freezed,
    Object? name = freezed,
    Object? dosage = freezed,
    Object? administrationManner = freezed,
    Object? medicineExpirationDate = freezed,
    Object? entityFileRefId = freezed,
    Object? entityFileUrl = freezed,
    Object? fileUrl = freezed,
    Object? remarks = freezed,
    Object? isTaken = freezed,
  }) {
    return _then(_MedicineAuditDetailVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      dosage: freezed == dosage
          ? _self.dosage
          : dosage // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationManner: freezed == administrationManner
          ? _self.administrationManner
          : administrationManner // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineExpirationDate: freezed == medicineExpirationDate
          ? _self.medicineExpirationDate
          : medicineExpirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      entityFileRefId: freezed == entityFileRefId
          ? _self.entityFileRefId
          : entityFileRefId // ignore: cast_nullable_to_non_nullable
              as String?,
      entityFileUrl: freezed == entityFileUrl
          ? _self.entityFileUrl
          : entityFileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      isTaken: freezed == isTaken
          ? _self.isTaken
          : isTaken // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$MedicineAuditTrailsDto {
  @JsonKey(name: 'medicineFormId')
  int? get medicineFormId;
  @JsonKey(name: 'photoUrl')
  String? get photoUrl;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'medicineDetailTakenIds')
  String? get medicineDetailTakenIds;
  @JsonKey(name: 'administratorDate')
  DateTime? get administratorDate;

  /// Create a copy of MedicineAuditTrailsDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineAuditTrailsDtoCopyWith<MedicineAuditTrailsDto> get copyWith =>
      _$MedicineAuditTrailsDtoCopyWithImpl<MedicineAuditTrailsDto>(
          this as MedicineAuditTrailsDto, _$identity);

  /// Serializes this MedicineAuditTrailsDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineAuditTrailsDto &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.photoUrl, photoUrl) ||
                other.photoUrl == photoUrl) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.medicineDetailTakenIds, medicineDetailTakenIds) ||
                other.medicineDetailTakenIds == medicineDetailTakenIds) &&
            (identical(other.administratorDate, administratorDate) ||
                other.administratorDate == administratorDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, medicineFormId, photoUrl,
      remarks, medicineDetailTakenIds, administratorDate);

  @override
  String toString() {
    return 'MedicineAuditTrailsDto(medicineFormId: $medicineFormId, photoUrl: $photoUrl, remarks: $remarks, medicineDetailTakenIds: $medicineDetailTakenIds, administratorDate: $administratorDate)';
  }
}

/// @nodoc
abstract mixin class $MedicineAuditTrailsDtoCopyWith<$Res> {
  factory $MedicineAuditTrailsDtoCopyWith(MedicineAuditTrailsDto value,
          $Res Function(MedicineAuditTrailsDto) _then) =
      _$MedicineAuditTrailsDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'photoUrl') String? photoUrl,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'medicineDetailTakenIds') String? medicineDetailTakenIds,
      @JsonKey(name: 'administratorDate') DateTime? administratorDate});
}

/// @nodoc
class _$MedicineAuditTrailsDtoCopyWithImpl<$Res>
    implements $MedicineAuditTrailsDtoCopyWith<$Res> {
  _$MedicineAuditTrailsDtoCopyWithImpl(this._self, this._then);

  final MedicineAuditTrailsDto _self;
  final $Res Function(MedicineAuditTrailsDto) _then;

  /// Create a copy of MedicineAuditTrailsDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? medicineFormId = freezed,
    Object? photoUrl = freezed,
    Object? remarks = freezed,
    Object? medicineDetailTakenIds = freezed,
    Object? administratorDate = freezed,
  }) {
    return _then(_self.copyWith(
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      photoUrl: freezed == photoUrl
          ? _self.photoUrl
          : photoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetailTakenIds: freezed == medicineDetailTakenIds
          ? _self.medicineDetailTakenIds
          : medicineDetailTakenIds // ignore: cast_nullable_to_non_nullable
              as String?,
      administratorDate: freezed == administratorDate
          ? _self.administratorDate
          : administratorDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineAuditTrailsDto].
extension MedicineAuditTrailsDtoPatterns on MedicineAuditTrailsDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineAuditTrailsDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineAuditTrailsDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineAuditTrailsDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'photoUrl') String? photoUrl,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineDetailTakenIds')
            String? medicineDetailTakenIds,
            @JsonKey(name: 'administratorDate') DateTime? administratorDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsDto() when $default != null:
        return $default(_that.medicineFormId, _that.photoUrl, _that.remarks,
            _that.medicineDetailTakenIds, _that.administratorDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'photoUrl') String? photoUrl,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineDetailTakenIds')
            String? medicineDetailTakenIds,
            @JsonKey(name: 'administratorDate') DateTime? administratorDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsDto():
        return $default(_that.medicineFormId, _that.photoUrl, _that.remarks,
            _that.medicineDetailTakenIds, _that.administratorDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'photoUrl') String? photoUrl,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineDetailTakenIds')
            String? medicineDetailTakenIds,
            @JsonKey(name: 'administratorDate') DateTime? administratorDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsDto() when $default != null:
        return $default(_that.medicineFormId, _that.photoUrl, _that.remarks,
            _that.medicineDetailTakenIds, _that.administratorDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineAuditTrailsDto implements MedicineAuditTrailsDto {
  _MedicineAuditTrailsDto(
      {@JsonKey(name: 'medicineFormId') this.medicineFormId,
      @JsonKey(name: 'photoUrl') this.photoUrl,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'medicineDetailTakenIds') this.medicineDetailTakenIds,
      @JsonKey(name: 'administratorDate') this.administratorDate});
  factory _MedicineAuditTrailsDto.fromJson(Map<String, dynamic> json) =>
      _$MedicineAuditTrailsDtoFromJson(json);

  @override
  @JsonKey(name: 'medicineFormId')
  final int? medicineFormId;
  @override
  @JsonKey(name: 'photoUrl')
  final String? photoUrl;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'medicineDetailTakenIds')
  final String? medicineDetailTakenIds;
  @override
  @JsonKey(name: 'administratorDate')
  final DateTime? administratorDate;

  /// Create a copy of MedicineAuditTrailsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineAuditTrailsDtoCopyWith<_MedicineAuditTrailsDto> get copyWith =>
      __$MedicineAuditTrailsDtoCopyWithImpl<_MedicineAuditTrailsDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineAuditTrailsDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineAuditTrailsDto &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.photoUrl, photoUrl) ||
                other.photoUrl == photoUrl) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.medicineDetailTakenIds, medicineDetailTakenIds) ||
                other.medicineDetailTakenIds == medicineDetailTakenIds) &&
            (identical(other.administratorDate, administratorDate) ||
                other.administratorDate == administratorDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, medicineFormId, photoUrl,
      remarks, medicineDetailTakenIds, administratorDate);

  @override
  String toString() {
    return 'MedicineAuditTrailsDto(medicineFormId: $medicineFormId, photoUrl: $photoUrl, remarks: $remarks, medicineDetailTakenIds: $medicineDetailTakenIds, administratorDate: $administratorDate)';
  }
}

/// @nodoc
abstract mixin class _$MedicineAuditTrailsDtoCopyWith<$Res>
    implements $MedicineAuditTrailsDtoCopyWith<$Res> {
  factory _$MedicineAuditTrailsDtoCopyWith(_MedicineAuditTrailsDto value,
          $Res Function(_MedicineAuditTrailsDto) _then) =
      __$MedicineAuditTrailsDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'photoUrl') String? photoUrl,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'medicineDetailTakenIds') String? medicineDetailTakenIds,
      @JsonKey(name: 'administratorDate') DateTime? administratorDate});
}

/// @nodoc
class __$MedicineAuditTrailsDtoCopyWithImpl<$Res>
    implements _$MedicineAuditTrailsDtoCopyWith<$Res> {
  __$MedicineAuditTrailsDtoCopyWithImpl(this._self, this._then);

  final _MedicineAuditTrailsDto _self;
  final $Res Function(_MedicineAuditTrailsDto) _then;

  /// Create a copy of MedicineAuditTrailsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? medicineFormId = freezed,
    Object? photoUrl = freezed,
    Object? remarks = freezed,
    Object? medicineDetailTakenIds = freezed,
    Object? administratorDate = freezed,
  }) {
    return _then(_MedicineAuditTrailsDto(
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      photoUrl: freezed == photoUrl
          ? _self.photoUrl
          : photoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetailTakenIds: freezed == medicineDetailTakenIds
          ? _self.medicineDetailTakenIds
          : medicineDetailTakenIds // ignore: cast_nullable_to_non_nullable
              as String?,
      administratorDate: freezed == administratorDate
          ? _self.administratorDate
          : administratorDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$MedicineAuditTrailsVerifierDto {
  @JsonKey(name: 'medicineAuditId')
  int get medicineAuditId;
  @JsonKey(name: 'remark')
  String? get remark;

  /// Create a copy of MedicineAuditTrailsVerifierDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineAuditTrailsVerifierDtoCopyWith<MedicineAuditTrailsVerifierDto>
      get copyWith => _$MedicineAuditTrailsVerifierDtoCopyWithImpl<
              MedicineAuditTrailsVerifierDto>(
          this as MedicineAuditTrailsVerifierDto, _$identity);

  /// Serializes this MedicineAuditTrailsVerifierDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineAuditTrailsVerifierDto &&
            (identical(other.medicineAuditId, medicineAuditId) ||
                other.medicineAuditId == medicineAuditId) &&
            (identical(other.remark, remark) || other.remark == remark));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, medicineAuditId, remark);

  @override
  String toString() {
    return 'MedicineAuditTrailsVerifierDto(medicineAuditId: $medicineAuditId, remark: $remark)';
  }
}

/// @nodoc
abstract mixin class $MedicineAuditTrailsVerifierDtoCopyWith<$Res> {
  factory $MedicineAuditTrailsVerifierDtoCopyWith(
          MedicineAuditTrailsVerifierDto value,
          $Res Function(MedicineAuditTrailsVerifierDto) _then) =
      _$MedicineAuditTrailsVerifierDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineAuditId') int medicineAuditId,
      @JsonKey(name: 'remark') String? remark});
}

/// @nodoc
class _$MedicineAuditTrailsVerifierDtoCopyWithImpl<$Res>
    implements $MedicineAuditTrailsVerifierDtoCopyWith<$Res> {
  _$MedicineAuditTrailsVerifierDtoCopyWithImpl(this._self, this._then);

  final MedicineAuditTrailsVerifierDto _self;
  final $Res Function(MedicineAuditTrailsVerifierDto) _then;

  /// Create a copy of MedicineAuditTrailsVerifierDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? medicineAuditId = null,
    Object? remark = freezed,
  }) {
    return _then(_self.copyWith(
      medicineAuditId: null == medicineAuditId
          ? _self.medicineAuditId
          : medicineAuditId // ignore: cast_nullable_to_non_nullable
              as int,
      remark: freezed == remark
          ? _self.remark
          : remark // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineAuditTrailsVerifierDto].
extension MedicineAuditTrailsVerifierDtoPatterns
    on MedicineAuditTrailsVerifierDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineAuditTrailsVerifierDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsVerifierDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineAuditTrailsVerifierDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsVerifierDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineAuditTrailsVerifierDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsVerifierDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'medicineAuditId') int medicineAuditId,
            @JsonKey(name: 'remark') String? remark)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsVerifierDto() when $default != null:
        return $default(_that.medicineAuditId, _that.remark);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'medicineAuditId') int medicineAuditId,
            @JsonKey(name: 'remark') String? remark)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsVerifierDto():
        return $default(_that.medicineAuditId, _that.remark);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'medicineAuditId') int medicineAuditId,
            @JsonKey(name: 'remark') String? remark)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditTrailsVerifierDto() when $default != null:
        return $default(_that.medicineAuditId, _that.remark);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineAuditTrailsVerifierDto
    implements MedicineAuditTrailsVerifierDto {
  _MedicineAuditTrailsVerifierDto(
      {@JsonKey(name: 'medicineAuditId') required this.medicineAuditId,
      @JsonKey(name: 'remark') this.remark});
  factory _MedicineAuditTrailsVerifierDto.fromJson(Map<String, dynamic> json) =>
      _$MedicineAuditTrailsVerifierDtoFromJson(json);

  @override
  @JsonKey(name: 'medicineAuditId')
  final int medicineAuditId;
  @override
  @JsonKey(name: 'remark')
  final String? remark;

  /// Create a copy of MedicineAuditTrailsVerifierDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineAuditTrailsVerifierDtoCopyWith<_MedicineAuditTrailsVerifierDto>
      get copyWith => __$MedicineAuditTrailsVerifierDtoCopyWithImpl<
          _MedicineAuditTrailsVerifierDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineAuditTrailsVerifierDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineAuditTrailsVerifierDto &&
            (identical(other.medicineAuditId, medicineAuditId) ||
                other.medicineAuditId == medicineAuditId) &&
            (identical(other.remark, remark) || other.remark == remark));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, medicineAuditId, remark);

  @override
  String toString() {
    return 'MedicineAuditTrailsVerifierDto(medicineAuditId: $medicineAuditId, remark: $remark)';
  }
}

/// @nodoc
abstract mixin class _$MedicineAuditTrailsVerifierDtoCopyWith<$Res>
    implements $MedicineAuditTrailsVerifierDtoCopyWith<$Res> {
  factory _$MedicineAuditTrailsVerifierDtoCopyWith(
          _MedicineAuditTrailsVerifierDto value,
          $Res Function(_MedicineAuditTrailsVerifierDto) _then) =
      __$MedicineAuditTrailsVerifierDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineAuditId') int medicineAuditId,
      @JsonKey(name: 'remark') String? remark});
}

/// @nodoc
class __$MedicineAuditTrailsVerifierDtoCopyWithImpl<$Res>
    implements _$MedicineAuditTrailsVerifierDtoCopyWith<$Res> {
  __$MedicineAuditTrailsVerifierDtoCopyWithImpl(this._self, this._then);

  final _MedicineAuditTrailsVerifierDto _self;
  final $Res Function(_MedicineAuditTrailsVerifierDto) _then;

  /// Create a copy of MedicineAuditTrailsVerifierDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? medicineAuditId = null,
    Object? remark = freezed,
  }) {
    return _then(_MedicineAuditTrailsVerifierDto(
      medicineAuditId: null == medicineAuditId
          ? _self.medicineAuditId
          : medicineAuditId // ignore: cast_nullable_to_non_nullable
              as int,
      remark: freezed == remark
          ? _self.remark
          : remark // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MedicineAuditWebViewVODto {
  @JsonKey(name: 'audit')
  MedicineAuditWithDetailVODto get audit;
  @JsonKey(name: 'formStartDate')
  DateTime? get formStartDate;
  @JsonKey(name: 'formEndDate')
  DateTime? get formEndDate;
  @JsonKey(name: 'student')
  StudentBaseInfoVODto? get student;

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineAuditWebViewVODtoCopyWith<MedicineAuditWebViewVODto> get copyWith =>
      _$MedicineAuditWebViewVODtoCopyWithImpl<MedicineAuditWebViewVODto>(
          this as MedicineAuditWebViewVODto, _$identity);

  /// Serializes this MedicineAuditWebViewVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineAuditWebViewVODto &&
            (identical(other.audit, audit) || other.audit == audit) &&
            (identical(other.formStartDate, formStartDate) ||
                other.formStartDate == formStartDate) &&
            (identical(other.formEndDate, formEndDate) ||
                other.formEndDate == formEndDate) &&
            (identical(other.student, student) || other.student == student));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, audit, formStartDate, formEndDate, student);

  @override
  String toString() {
    return 'MedicineAuditWebViewVODto(audit: $audit, formStartDate: $formStartDate, formEndDate: $formEndDate, student: $student)';
  }
}

/// @nodoc
abstract mixin class $MedicineAuditWebViewVODtoCopyWith<$Res> {
  factory $MedicineAuditWebViewVODtoCopyWith(MedicineAuditWebViewVODto value,
          $Res Function(MedicineAuditWebViewVODto) _then) =
      _$MedicineAuditWebViewVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'audit') MedicineAuditWithDetailVODto audit,
      @JsonKey(name: 'formStartDate') DateTime? formStartDate,
      @JsonKey(name: 'formEndDate') DateTime? formEndDate,
      @JsonKey(name: 'student') StudentBaseInfoVODto? student});

  $MedicineAuditWithDetailVODtoCopyWith<$Res> get audit;
  $StudentBaseInfoVODtoCopyWith<$Res>? get student;
}

/// @nodoc
class _$MedicineAuditWebViewVODtoCopyWithImpl<$Res>
    implements $MedicineAuditWebViewVODtoCopyWith<$Res> {
  _$MedicineAuditWebViewVODtoCopyWithImpl(this._self, this._then);

  final MedicineAuditWebViewVODto _self;
  final $Res Function(MedicineAuditWebViewVODto) _then;

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? audit = null,
    Object? formStartDate = freezed,
    Object? formEndDate = freezed,
    Object? student = freezed,
  }) {
    return _then(_self.copyWith(
      audit: null == audit
          ? _self.audit
          : audit // ignore: cast_nullable_to_non_nullable
              as MedicineAuditWithDetailVODto,
      formStartDate: freezed == formStartDate
          ? _self.formStartDate
          : formStartDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      formEndDate: freezed == formEndDate
          ? _self.formEndDate
          : formEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentBaseInfoVODto?,
    ));
  }

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MedicineAuditWithDetailVODtoCopyWith<$Res> get audit {
    return $MedicineAuditWithDetailVODtoCopyWith<$Res>(_self.audit, (value) {
      return _then(_self.copyWith(audit: value));
    });
  }

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentBaseInfoVODtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentBaseInfoVODtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }
}

/// Adds pattern-matching-related methods to [MedicineAuditWebViewVODto].
extension MedicineAuditWebViewVODtoPatterns on MedicineAuditWebViewVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineAuditWebViewVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineAuditWebViewVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineAuditWebViewVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'audit') MedicineAuditWithDetailVODto audit,
            @JsonKey(name: 'formStartDate') DateTime? formStartDate,
            @JsonKey(name: 'formEndDate') DateTime? formEndDate,
            @JsonKey(name: 'student') StudentBaseInfoVODto? student)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVODto() when $default != null:
        return $default(
            _that.audit, _that.formStartDate, _that.formEndDate, _that.student);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'audit') MedicineAuditWithDetailVODto audit,
            @JsonKey(name: 'formStartDate') DateTime? formStartDate,
            @JsonKey(name: 'formEndDate') DateTime? formEndDate,
            @JsonKey(name: 'student') StudentBaseInfoVODto? student)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVODto():
        return $default(
            _that.audit, _that.formStartDate, _that.formEndDate, _that.student);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'audit') MedicineAuditWithDetailVODto audit,
            @JsonKey(name: 'formStartDate') DateTime? formStartDate,
            @JsonKey(name: 'formEndDate') DateTime? formEndDate,
            @JsonKey(name: 'student') StudentBaseInfoVODto? student)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVODto() when $default != null:
        return $default(
            _that.audit, _that.formStartDate, _that.formEndDate, _that.student);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineAuditWebViewVODto implements MedicineAuditWebViewVODto {
  _MedicineAuditWebViewVODto(
      {@JsonKey(name: 'audit') required this.audit,
      @JsonKey(name: 'formStartDate') this.formStartDate,
      @JsonKey(name: 'formEndDate') this.formEndDate,
      @JsonKey(name: 'student') this.student});
  factory _MedicineAuditWebViewVODto.fromJson(Map<String, dynamic> json) =>
      _$MedicineAuditWebViewVODtoFromJson(json);

  @override
  @JsonKey(name: 'audit')
  final MedicineAuditWithDetailVODto audit;
  @override
  @JsonKey(name: 'formStartDate')
  final DateTime? formStartDate;
  @override
  @JsonKey(name: 'formEndDate')
  final DateTime? formEndDate;
  @override
  @JsonKey(name: 'student')
  final StudentBaseInfoVODto? student;

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineAuditWebViewVODtoCopyWith<_MedicineAuditWebViewVODto>
      get copyWith =>
          __$MedicineAuditWebViewVODtoCopyWithImpl<_MedicineAuditWebViewVODto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineAuditWebViewVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineAuditWebViewVODto &&
            (identical(other.audit, audit) || other.audit == audit) &&
            (identical(other.formStartDate, formStartDate) ||
                other.formStartDate == formStartDate) &&
            (identical(other.formEndDate, formEndDate) ||
                other.formEndDate == formEndDate) &&
            (identical(other.student, student) || other.student == student));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, audit, formStartDate, formEndDate, student);

  @override
  String toString() {
    return 'MedicineAuditWebViewVODto(audit: $audit, formStartDate: $formStartDate, formEndDate: $formEndDate, student: $student)';
  }
}

/// @nodoc
abstract mixin class _$MedicineAuditWebViewVODtoCopyWith<$Res>
    implements $MedicineAuditWebViewVODtoCopyWith<$Res> {
  factory _$MedicineAuditWebViewVODtoCopyWith(_MedicineAuditWebViewVODto value,
          $Res Function(_MedicineAuditWebViewVODto) _then) =
      __$MedicineAuditWebViewVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'audit') MedicineAuditWithDetailVODto audit,
      @JsonKey(name: 'formStartDate') DateTime? formStartDate,
      @JsonKey(name: 'formEndDate') DateTime? formEndDate,
      @JsonKey(name: 'student') StudentBaseInfoVODto? student});

  @override
  $MedicineAuditWithDetailVODtoCopyWith<$Res> get audit;
  @override
  $StudentBaseInfoVODtoCopyWith<$Res>? get student;
}

/// @nodoc
class __$MedicineAuditWebViewVODtoCopyWithImpl<$Res>
    implements _$MedicineAuditWebViewVODtoCopyWith<$Res> {
  __$MedicineAuditWebViewVODtoCopyWithImpl(this._self, this._then);

  final _MedicineAuditWebViewVODto _self;
  final $Res Function(_MedicineAuditWebViewVODto) _then;

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? audit = null,
    Object? formStartDate = freezed,
    Object? formEndDate = freezed,
    Object? student = freezed,
  }) {
    return _then(_MedicineAuditWebViewVODto(
      audit: null == audit
          ? _self.audit
          : audit // ignore: cast_nullable_to_non_nullable
              as MedicineAuditWithDetailVODto,
      formStartDate: freezed == formStartDate
          ? _self.formStartDate
          : formStartDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      formEndDate: freezed == formEndDate
          ? _self.formEndDate
          : formEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentBaseInfoVODto?,
    ));
  }

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MedicineAuditWithDetailVODtoCopyWith<$Res> get audit {
    return $MedicineAuditWithDetailVODtoCopyWith<$Res>(_self.audit, (value) {
      return _then(_self.copyWith(audit: value));
    });
  }

  /// Create a copy of MedicineAuditWebViewVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentBaseInfoVODtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentBaseInfoVODtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }
}

/// @nodoc
mixin _$MedicineAuditWebViewVOPaginationDto {
  @JsonKey(name: 'items')
  List<MedicineAuditWebViewVODto>? get items;
  @JsonKey(name: 'totalRecords')
  int? get totalRecords;
  @JsonKey(name: 'currentPage')
  int? get currentPage;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalPages')
  int? get totalPages;
  @JsonKey(name: 'hasNext')
  bool? get hasNext;
  @JsonKey(name: 'hasPrevious')
  bool? get hasPrevious;

  /// Create a copy of MedicineAuditWebViewVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineAuditWebViewVOPaginationDtoCopyWith<
          MedicineAuditWebViewVOPaginationDto>
      get copyWith => _$MedicineAuditWebViewVOPaginationDtoCopyWithImpl<
              MedicineAuditWebViewVOPaginationDto>(
          this as MedicineAuditWebViewVOPaginationDto, _$identity);

  /// Serializes this MedicineAuditWebViewVOPaginationDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineAuditWebViewVOPaginationDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.totalRecords, totalRecords) ||
                other.totalRecords == totalRecords) &&
            (identical(other.currentPage, currentPage) ||
                other.currentPage == currentPage) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.hasNext, hasNext) || other.hasNext == hasNext) &&
            (identical(other.hasPrevious, hasPrevious) ||
                other.hasPrevious == hasPrevious));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      totalRecords,
      currentPage,
      pageSize,
      totalPages,
      hasNext,
      hasPrevious);

  @override
  String toString() {
    return 'MedicineAuditWebViewVOPaginationDto(items: $items, totalRecords: $totalRecords, currentPage: $currentPage, pageSize: $pageSize, totalPages: $totalPages, hasNext: $hasNext, hasPrevious: $hasPrevious)';
  }
}

/// @nodoc
abstract mixin class $MedicineAuditWebViewVOPaginationDtoCopyWith<$Res> {
  factory $MedicineAuditWebViewVOPaginationDtoCopyWith(
          MedicineAuditWebViewVOPaginationDto value,
          $Res Function(MedicineAuditWebViewVOPaginationDto) _then) =
      _$MedicineAuditWebViewVOPaginationDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<MedicineAuditWebViewVODto>? items,
      @JsonKey(name: 'totalRecords') int? totalRecords,
      @JsonKey(name: 'currentPage') int? currentPage,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalPages') int? totalPages,
      @JsonKey(name: 'hasNext') bool? hasNext,
      @JsonKey(name: 'hasPrevious') bool? hasPrevious});
}

/// @nodoc
class _$MedicineAuditWebViewVOPaginationDtoCopyWithImpl<$Res>
    implements $MedicineAuditWebViewVOPaginationDtoCopyWith<$Res> {
  _$MedicineAuditWebViewVOPaginationDtoCopyWithImpl(this._self, this._then);

  final MedicineAuditWebViewVOPaginationDto _self;
  final $Res Function(MedicineAuditWebViewVOPaginationDto) _then;

  /// Create a copy of MedicineAuditWebViewVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? totalRecords = freezed,
    Object? currentPage = freezed,
    Object? pageSize = freezed,
    Object? totalPages = freezed,
    Object? hasNext = freezed,
    Object? hasPrevious = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<MedicineAuditWebViewVODto>?,
      totalRecords: freezed == totalRecords
          ? _self.totalRecords
          : totalRecords // ignore: cast_nullable_to_non_nullable
              as int?,
      currentPage: freezed == currentPage
          ? _self.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNext: freezed == hasNext
          ? _self.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPrevious: freezed == hasPrevious
          ? _self.hasPrevious
          : hasPrevious // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineAuditWebViewVOPaginationDto].
extension MedicineAuditWebViewVOPaginationDtoPatterns
    on MedicineAuditWebViewVOPaginationDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineAuditWebViewVOPaginationDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVOPaginationDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineAuditWebViewVOPaginationDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVOPaginationDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineAuditWebViewVOPaginationDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVOPaginationDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<MedicineAuditWebViewVODto>? items,
            @JsonKey(name: 'totalRecords') int? totalRecords,
            @JsonKey(name: 'currentPage') int? currentPage,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalPages') int? totalPages,
            @JsonKey(name: 'hasNext') bool? hasNext,
            @JsonKey(name: 'hasPrevious') bool? hasPrevious)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVOPaginationDto() when $default != null:
        return $default(_that.items, _that.totalRecords, _that.currentPage,
            _that.pageSize, _that.totalPages, _that.hasNext, _that.hasPrevious);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<MedicineAuditWebViewVODto>? items,
            @JsonKey(name: 'totalRecords') int? totalRecords,
            @JsonKey(name: 'currentPage') int? currentPage,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalPages') int? totalPages,
            @JsonKey(name: 'hasNext') bool? hasNext,
            @JsonKey(name: 'hasPrevious') bool? hasPrevious)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVOPaginationDto():
        return $default(_that.items, _that.totalRecords, _that.currentPage,
            _that.pageSize, _that.totalPages, _that.hasNext, _that.hasPrevious);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<MedicineAuditWebViewVODto>? items,
            @JsonKey(name: 'totalRecords') int? totalRecords,
            @JsonKey(name: 'currentPage') int? currentPage,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalPages') int? totalPages,
            @JsonKey(name: 'hasNext') bool? hasNext,
            @JsonKey(name: 'hasPrevious') bool? hasPrevious)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWebViewVOPaginationDto() when $default != null:
        return $default(_that.items, _that.totalRecords, _that.currentPage,
            _that.pageSize, _that.totalPages, _that.hasNext, _that.hasPrevious);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineAuditWebViewVOPaginationDto
    implements MedicineAuditWebViewVOPaginationDto {
  _MedicineAuditWebViewVOPaginationDto(
      {@JsonKey(name: 'items') final List<MedicineAuditWebViewVODto>? items,
      @JsonKey(name: 'totalRecords') this.totalRecords,
      @JsonKey(name: 'currentPage') this.currentPage,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalPages') this.totalPages,
      @JsonKey(name: 'hasNext') this.hasNext,
      @JsonKey(name: 'hasPrevious') this.hasPrevious})
      : _items = items;
  factory _MedicineAuditWebViewVOPaginationDto.fromJson(
          Map<String, dynamic> json) =>
      _$MedicineAuditWebViewVOPaginationDtoFromJson(json);

  final List<MedicineAuditWebViewVODto>? _items;
  @override
  @JsonKey(name: 'items')
  List<MedicineAuditWebViewVODto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'totalRecords')
  final int? totalRecords;
  @override
  @JsonKey(name: 'currentPage')
  final int? currentPage;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;
  @override
  @JsonKey(name: 'hasNext')
  final bool? hasNext;
  @override
  @JsonKey(name: 'hasPrevious')
  final bool? hasPrevious;

  /// Create a copy of MedicineAuditWebViewVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineAuditWebViewVOPaginationDtoCopyWith<
          _MedicineAuditWebViewVOPaginationDto>
      get copyWith => __$MedicineAuditWebViewVOPaginationDtoCopyWithImpl<
          _MedicineAuditWebViewVOPaginationDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineAuditWebViewVOPaginationDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineAuditWebViewVOPaginationDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.totalRecords, totalRecords) ||
                other.totalRecords == totalRecords) &&
            (identical(other.currentPage, currentPage) ||
                other.currentPage == currentPage) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.hasNext, hasNext) || other.hasNext == hasNext) &&
            (identical(other.hasPrevious, hasPrevious) ||
                other.hasPrevious == hasPrevious));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      totalRecords,
      currentPage,
      pageSize,
      totalPages,
      hasNext,
      hasPrevious);

  @override
  String toString() {
    return 'MedicineAuditWebViewVOPaginationDto(items: $items, totalRecords: $totalRecords, currentPage: $currentPage, pageSize: $pageSize, totalPages: $totalPages, hasNext: $hasNext, hasPrevious: $hasPrevious)';
  }
}

/// @nodoc
abstract mixin class _$MedicineAuditWebViewVOPaginationDtoCopyWith<$Res>
    implements $MedicineAuditWebViewVOPaginationDtoCopyWith<$Res> {
  factory _$MedicineAuditWebViewVOPaginationDtoCopyWith(
          _MedicineAuditWebViewVOPaginationDto value,
          $Res Function(_MedicineAuditWebViewVOPaginationDto) _then) =
      __$MedicineAuditWebViewVOPaginationDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<MedicineAuditWebViewVODto>? items,
      @JsonKey(name: 'totalRecords') int? totalRecords,
      @JsonKey(name: 'currentPage') int? currentPage,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalPages') int? totalPages,
      @JsonKey(name: 'hasNext') bool? hasNext,
      @JsonKey(name: 'hasPrevious') bool? hasPrevious});
}

/// @nodoc
class __$MedicineAuditWebViewVOPaginationDtoCopyWithImpl<$Res>
    implements _$MedicineAuditWebViewVOPaginationDtoCopyWith<$Res> {
  __$MedicineAuditWebViewVOPaginationDtoCopyWithImpl(this._self, this._then);

  final _MedicineAuditWebViewVOPaginationDto _self;
  final $Res Function(_MedicineAuditWebViewVOPaginationDto) _then;

  /// Create a copy of MedicineAuditWebViewVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? totalRecords = freezed,
    Object? currentPage = freezed,
    Object? pageSize = freezed,
    Object? totalPages = freezed,
    Object? hasNext = freezed,
    Object? hasPrevious = freezed,
  }) {
    return _then(_MedicineAuditWebViewVOPaginationDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<MedicineAuditWebViewVODto>?,
      totalRecords: freezed == totalRecords
          ? _self.totalRecords
          : totalRecords // ignore: cast_nullable_to_non_nullable
              as int?,
      currentPage: freezed == currentPage
          ? _self.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNext: freezed == hasNext
          ? _self.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPrevious: freezed == hasPrevious
          ? _self.hasPrevious
          : hasPrevious // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$MedicineAuditWithDetailVODto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'medicineFormId')
  int? get medicineFormId;
  @JsonKey(name: 'administratorDate')
  DateTime? get administratorDate;
  @JsonKey(name: 'administratorConId')
  String? get administratorConId;
  @JsonKey(name: 'administratorName')
  String? get administratorName;
  @JsonKey(name: 'administratorRemark')
  String? get administratorRemark;
  @JsonKey(name: 'photoUrl')
  String? get photoUrl;
  @JsonKey(name: 'verifierDate')
  DateTime? get verifierDate;
  @JsonKey(name: 'verifierConId')
  String? get verifierConId;
  @JsonKey(name: 'verifierName')
  String? get verifierName;
  @JsonKey(name: 'verifierRemark')
  String? get verifierRemark;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'medicineDetails')
  List<MedicineAuditDetailVODto>? get medicineDetails;

  /// Create a copy of MedicineAuditWithDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineAuditWithDetailVODtoCopyWith<MedicineAuditWithDetailVODto>
      get copyWith => _$MedicineAuditWithDetailVODtoCopyWithImpl<
              MedicineAuditWithDetailVODto>(
          this as MedicineAuditWithDetailVODto, _$identity);

  /// Serializes this MedicineAuditWithDetailVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineAuditWithDetailVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.administratorDate, administratorDate) ||
                other.administratorDate == administratorDate) &&
            (identical(other.administratorConId, administratorConId) ||
                other.administratorConId == administratorConId) &&
            (identical(other.administratorName, administratorName) ||
                other.administratorName == administratorName) &&
            (identical(other.administratorRemark, administratorRemark) ||
                other.administratorRemark == administratorRemark) &&
            (identical(other.photoUrl, photoUrl) ||
                other.photoUrl == photoUrl) &&
            (identical(other.verifierDate, verifierDate) ||
                other.verifierDate == verifierDate) &&
            (identical(other.verifierConId, verifierConId) ||
                other.verifierConId == verifierConId) &&
            (identical(other.verifierName, verifierName) ||
                other.verifierName == verifierName) &&
            (identical(other.verifierRemark, verifierRemark) ||
                other.verifierRemark == verifierRemark) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality()
                .equals(other.medicineDetails, medicineDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      medicineFormId,
      administratorDate,
      administratorConId,
      administratorName,
      administratorRemark,
      photoUrl,
      verifierDate,
      verifierConId,
      verifierName,
      verifierRemark,
      status,
      const DeepCollectionEquality().hash(medicineDetails));

  @override
  String toString() {
    return 'MedicineAuditWithDetailVODto(id: $id, medicineFormId: $medicineFormId, administratorDate: $administratorDate, administratorConId: $administratorConId, administratorName: $administratorName, administratorRemark: $administratorRemark, photoUrl: $photoUrl, verifierDate: $verifierDate, verifierConId: $verifierConId, verifierName: $verifierName, verifierRemark: $verifierRemark, status: $status, medicineDetails: $medicineDetails)';
  }
}

/// @nodoc
abstract mixin class $MedicineAuditWithDetailVODtoCopyWith<$Res> {
  factory $MedicineAuditWithDetailVODtoCopyWith(
          MedicineAuditWithDetailVODto value,
          $Res Function(MedicineAuditWithDetailVODto) _then) =
      _$MedicineAuditWithDetailVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'administratorDate') DateTime? administratorDate,
      @JsonKey(name: 'administratorConId') String? administratorConId,
      @JsonKey(name: 'administratorName') String? administratorName,
      @JsonKey(name: 'administratorRemark') String? administratorRemark,
      @JsonKey(name: 'photoUrl') String? photoUrl,
      @JsonKey(name: 'verifierDate') DateTime? verifierDate,
      @JsonKey(name: 'verifierConId') String? verifierConId,
      @JsonKey(name: 'verifierName') String? verifierName,
      @JsonKey(name: 'verifierRemark') String? verifierRemark,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'medicineDetails')
      List<MedicineAuditDetailVODto>? medicineDetails});
}

/// @nodoc
class _$MedicineAuditWithDetailVODtoCopyWithImpl<$Res>
    implements $MedicineAuditWithDetailVODtoCopyWith<$Res> {
  _$MedicineAuditWithDetailVODtoCopyWithImpl(this._self, this._then);

  final MedicineAuditWithDetailVODto _self;
  final $Res Function(MedicineAuditWithDetailVODto) _then;

  /// Create a copy of MedicineAuditWithDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? medicineFormId = freezed,
    Object? administratorDate = freezed,
    Object? administratorConId = freezed,
    Object? administratorName = freezed,
    Object? administratorRemark = freezed,
    Object? photoUrl = freezed,
    Object? verifierDate = freezed,
    Object? verifierConId = freezed,
    Object? verifierName = freezed,
    Object? verifierRemark = freezed,
    Object? status = freezed,
    Object? medicineDetails = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      administratorDate: freezed == administratorDate
          ? _self.administratorDate
          : administratorDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      administratorConId: freezed == administratorConId
          ? _self.administratorConId
          : administratorConId // ignore: cast_nullable_to_non_nullable
              as String?,
      administratorName: freezed == administratorName
          ? _self.administratorName
          : administratorName // ignore: cast_nullable_to_non_nullable
              as String?,
      administratorRemark: freezed == administratorRemark
          ? _self.administratorRemark
          : administratorRemark // ignore: cast_nullable_to_non_nullable
              as String?,
      photoUrl: freezed == photoUrl
          ? _self.photoUrl
          : photoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      verifierDate: freezed == verifierDate
          ? _self.verifierDate
          : verifierDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      verifierConId: freezed == verifierConId
          ? _self.verifierConId
          : verifierConId // ignore: cast_nullable_to_non_nullable
              as String?,
      verifierName: freezed == verifierName
          ? _self.verifierName
          : verifierName // ignore: cast_nullable_to_non_nullable
              as String?,
      verifierRemark: freezed == verifierRemark
          ? _self.verifierRemark
          : verifierRemark // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetails: freezed == medicineDetails
          ? _self.medicineDetails
          : medicineDetails // ignore: cast_nullable_to_non_nullable
              as List<MedicineAuditDetailVODto>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineAuditWithDetailVODto].
extension MedicineAuditWithDetailVODtoPatterns on MedicineAuditWithDetailVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineAuditWithDetailVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWithDetailVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineAuditWithDetailVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWithDetailVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineAuditWithDetailVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWithDetailVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'administratorDate') DateTime? administratorDate,
            @JsonKey(name: 'administratorConId') String? administratorConId,
            @JsonKey(name: 'administratorName') String? administratorName,
            @JsonKey(name: 'administratorRemark') String? administratorRemark,
            @JsonKey(name: 'photoUrl') String? photoUrl,
            @JsonKey(name: 'verifierDate') DateTime? verifierDate,
            @JsonKey(name: 'verifierConId') String? verifierConId,
            @JsonKey(name: 'verifierName') String? verifierName,
            @JsonKey(name: 'verifierRemark') String? verifierRemark,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'medicineDetails')
            List<MedicineAuditDetailVODto>? medicineDetails)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWithDetailVODto() when $default != null:
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.administratorDate,
            _that.administratorConId,
            _that.administratorName,
            _that.administratorRemark,
            _that.photoUrl,
            _that.verifierDate,
            _that.verifierConId,
            _that.verifierName,
            _that.verifierRemark,
            _that.status,
            _that.medicineDetails);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'administratorDate') DateTime? administratorDate,
            @JsonKey(name: 'administratorConId') String? administratorConId,
            @JsonKey(name: 'administratorName') String? administratorName,
            @JsonKey(name: 'administratorRemark') String? administratorRemark,
            @JsonKey(name: 'photoUrl') String? photoUrl,
            @JsonKey(name: 'verifierDate') DateTime? verifierDate,
            @JsonKey(name: 'verifierConId') String? verifierConId,
            @JsonKey(name: 'verifierName') String? verifierName,
            @JsonKey(name: 'verifierRemark') String? verifierRemark,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'medicineDetails')
            List<MedicineAuditDetailVODto>? medicineDetails)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWithDetailVODto():
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.administratorDate,
            _that.administratorConId,
            _that.administratorName,
            _that.administratorRemark,
            _that.photoUrl,
            _that.verifierDate,
            _that.verifierConId,
            _that.verifierName,
            _that.verifierRemark,
            _that.status,
            _that.medicineDetails);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'administratorDate') DateTime? administratorDate,
            @JsonKey(name: 'administratorConId') String? administratorConId,
            @JsonKey(name: 'administratorName') String? administratorName,
            @JsonKey(name: 'administratorRemark') String? administratorRemark,
            @JsonKey(name: 'photoUrl') String? photoUrl,
            @JsonKey(name: 'verifierDate') DateTime? verifierDate,
            @JsonKey(name: 'verifierConId') String? verifierConId,
            @JsonKey(name: 'verifierName') String? verifierName,
            @JsonKey(name: 'verifierRemark') String? verifierRemark,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'medicineDetails')
            List<MedicineAuditDetailVODto>? medicineDetails)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineAuditWithDetailVODto() when $default != null:
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.administratorDate,
            _that.administratorConId,
            _that.administratorName,
            _that.administratorRemark,
            _that.photoUrl,
            _that.verifierDate,
            _that.verifierConId,
            _that.verifierName,
            _that.verifierRemark,
            _that.status,
            _that.medicineDetails);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineAuditWithDetailVODto implements MedicineAuditWithDetailVODto {
  _MedicineAuditWithDetailVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'medicineFormId') this.medicineFormId,
      @JsonKey(name: 'administratorDate') this.administratorDate,
      @JsonKey(name: 'administratorConId') this.administratorConId,
      @JsonKey(name: 'administratorName') this.administratorName,
      @JsonKey(name: 'administratorRemark') this.administratorRemark,
      @JsonKey(name: 'photoUrl') this.photoUrl,
      @JsonKey(name: 'verifierDate') this.verifierDate,
      @JsonKey(name: 'verifierConId') this.verifierConId,
      @JsonKey(name: 'verifierName') this.verifierName,
      @JsonKey(name: 'verifierRemark') this.verifierRemark,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'medicineDetails')
      final List<MedicineAuditDetailVODto>? medicineDetails})
      : _medicineDetails = medicineDetails;
  factory _MedicineAuditWithDetailVODto.fromJson(Map<String, dynamic> json) =>
      _$MedicineAuditWithDetailVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'medicineFormId')
  final int? medicineFormId;
  @override
  @JsonKey(name: 'administratorDate')
  final DateTime? administratorDate;
  @override
  @JsonKey(name: 'administratorConId')
  final String? administratorConId;
  @override
  @JsonKey(name: 'administratorName')
  final String? administratorName;
  @override
  @JsonKey(name: 'administratorRemark')
  final String? administratorRemark;
  @override
  @JsonKey(name: 'photoUrl')
  final String? photoUrl;
  @override
  @JsonKey(name: 'verifierDate')
  final DateTime? verifierDate;
  @override
  @JsonKey(name: 'verifierConId')
  final String? verifierConId;
  @override
  @JsonKey(name: 'verifierName')
  final String? verifierName;
  @override
  @JsonKey(name: 'verifierRemark')
  final String? verifierRemark;
  @override
  @JsonKey(name: 'status')
  final String? status;
  final List<MedicineAuditDetailVODto>? _medicineDetails;
  @override
  @JsonKey(name: 'medicineDetails')
  List<MedicineAuditDetailVODto>? get medicineDetails {
    final value = _medicineDetails;
    if (value == null) return null;
    if (_medicineDetails is EqualUnmodifiableListView) return _medicineDetails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of MedicineAuditWithDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineAuditWithDetailVODtoCopyWith<_MedicineAuditWithDetailVODto>
      get copyWith => __$MedicineAuditWithDetailVODtoCopyWithImpl<
          _MedicineAuditWithDetailVODto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineAuditWithDetailVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineAuditWithDetailVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.administratorDate, administratorDate) ||
                other.administratorDate == administratorDate) &&
            (identical(other.administratorConId, administratorConId) ||
                other.administratorConId == administratorConId) &&
            (identical(other.administratorName, administratorName) ||
                other.administratorName == administratorName) &&
            (identical(other.administratorRemark, administratorRemark) ||
                other.administratorRemark == administratorRemark) &&
            (identical(other.photoUrl, photoUrl) ||
                other.photoUrl == photoUrl) &&
            (identical(other.verifierDate, verifierDate) ||
                other.verifierDate == verifierDate) &&
            (identical(other.verifierConId, verifierConId) ||
                other.verifierConId == verifierConId) &&
            (identical(other.verifierName, verifierName) ||
                other.verifierName == verifierName) &&
            (identical(other.verifierRemark, verifierRemark) ||
                other.verifierRemark == verifierRemark) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality()
                .equals(other._medicineDetails, _medicineDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      medicineFormId,
      administratorDate,
      administratorConId,
      administratorName,
      administratorRemark,
      photoUrl,
      verifierDate,
      verifierConId,
      verifierName,
      verifierRemark,
      status,
      const DeepCollectionEquality().hash(_medicineDetails));

  @override
  String toString() {
    return 'MedicineAuditWithDetailVODto(id: $id, medicineFormId: $medicineFormId, administratorDate: $administratorDate, administratorConId: $administratorConId, administratorName: $administratorName, administratorRemark: $administratorRemark, photoUrl: $photoUrl, verifierDate: $verifierDate, verifierConId: $verifierConId, verifierName: $verifierName, verifierRemark: $verifierRemark, status: $status, medicineDetails: $medicineDetails)';
  }
}

/// @nodoc
abstract mixin class _$MedicineAuditWithDetailVODtoCopyWith<$Res>
    implements $MedicineAuditWithDetailVODtoCopyWith<$Res> {
  factory _$MedicineAuditWithDetailVODtoCopyWith(
          _MedicineAuditWithDetailVODto value,
          $Res Function(_MedicineAuditWithDetailVODto) _then) =
      __$MedicineAuditWithDetailVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'administratorDate') DateTime? administratorDate,
      @JsonKey(name: 'administratorConId') String? administratorConId,
      @JsonKey(name: 'administratorName') String? administratorName,
      @JsonKey(name: 'administratorRemark') String? administratorRemark,
      @JsonKey(name: 'photoUrl') String? photoUrl,
      @JsonKey(name: 'verifierDate') DateTime? verifierDate,
      @JsonKey(name: 'verifierConId') String? verifierConId,
      @JsonKey(name: 'verifierName') String? verifierName,
      @JsonKey(name: 'verifierRemark') String? verifierRemark,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'medicineDetails')
      List<MedicineAuditDetailVODto>? medicineDetails});
}

/// @nodoc
class __$MedicineAuditWithDetailVODtoCopyWithImpl<$Res>
    implements _$MedicineAuditWithDetailVODtoCopyWith<$Res> {
  __$MedicineAuditWithDetailVODtoCopyWithImpl(this._self, this._then);

  final _MedicineAuditWithDetailVODto _self;
  final $Res Function(_MedicineAuditWithDetailVODto) _then;

  /// Create a copy of MedicineAuditWithDetailVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? medicineFormId = freezed,
    Object? administratorDate = freezed,
    Object? administratorConId = freezed,
    Object? administratorName = freezed,
    Object? administratorRemark = freezed,
    Object? photoUrl = freezed,
    Object? verifierDate = freezed,
    Object? verifierConId = freezed,
    Object? verifierName = freezed,
    Object? verifierRemark = freezed,
    Object? status = freezed,
    Object? medicineDetails = freezed,
  }) {
    return _then(_MedicineAuditWithDetailVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      administratorDate: freezed == administratorDate
          ? _self.administratorDate
          : administratorDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      administratorConId: freezed == administratorConId
          ? _self.administratorConId
          : administratorConId // ignore: cast_nullable_to_non_nullable
              as String?,
      administratorName: freezed == administratorName
          ? _self.administratorName
          : administratorName // ignore: cast_nullable_to_non_nullable
              as String?,
      administratorRemark: freezed == administratorRemark
          ? _self.administratorRemark
          : administratorRemark // ignore: cast_nullable_to_non_nullable
              as String?,
      photoUrl: freezed == photoUrl
          ? _self.photoUrl
          : photoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      verifierDate: freezed == verifierDate
          ? _self.verifierDate
          : verifierDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      verifierConId: freezed == verifierConId
          ? _self.verifierConId
          : verifierConId // ignore: cast_nullable_to_non_nullable
              as String?,
      verifierName: freezed == verifierName
          ? _self.verifierName
          : verifierName // ignore: cast_nullable_to_non_nullable
              as String?,
      verifierRemark: freezed == verifierRemark
          ? _self.verifierRemark
          : verifierRemark // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetails: freezed == medicineDetails
          ? _self._medicineDetails
          : medicineDetails // ignore: cast_nullable_to_non_nullable
              as List<MedicineAuditDetailVODto>?,
    ));
  }
}

/// @nodoc
mixin _$MedicineDataStudentVODto {
  @JsonKey(name: 'student')
  StudentBaseInfoVODto? get student;
  @JsonKey(name: 'activeRequestCount')
  int? get activeRequestCount;
  @JsonKey(name: 'expiredRequestCount')
  int? get expiredRequestCount;

  /// Create a copy of MedicineDataStudentVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineDataStudentVODtoCopyWith<MedicineDataStudentVODto> get copyWith =>
      _$MedicineDataStudentVODtoCopyWithImpl<MedicineDataStudentVODto>(
          this as MedicineDataStudentVODto, _$identity);

  /// Serializes this MedicineDataStudentVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineDataStudentVODto &&
            (identical(other.student, student) || other.student == student) &&
            (identical(other.activeRequestCount, activeRequestCount) ||
                other.activeRequestCount == activeRequestCount) &&
            (identical(other.expiredRequestCount, expiredRequestCount) ||
                other.expiredRequestCount == expiredRequestCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, student, activeRequestCount, expiredRequestCount);

  @override
  String toString() {
    return 'MedicineDataStudentVODto(student: $student, activeRequestCount: $activeRequestCount, expiredRequestCount: $expiredRequestCount)';
  }
}

/// @nodoc
abstract mixin class $MedicineDataStudentVODtoCopyWith<$Res> {
  factory $MedicineDataStudentVODtoCopyWith(MedicineDataStudentVODto value,
          $Res Function(MedicineDataStudentVODto) _then) =
      _$MedicineDataStudentVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'student') StudentBaseInfoVODto? student,
      @JsonKey(name: 'activeRequestCount') int? activeRequestCount,
      @JsonKey(name: 'expiredRequestCount') int? expiredRequestCount});

  $StudentBaseInfoVODtoCopyWith<$Res>? get student;
}

/// @nodoc
class _$MedicineDataStudentVODtoCopyWithImpl<$Res>
    implements $MedicineDataStudentVODtoCopyWith<$Res> {
  _$MedicineDataStudentVODtoCopyWithImpl(this._self, this._then);

  final MedicineDataStudentVODto _self;
  final $Res Function(MedicineDataStudentVODto) _then;

  /// Create a copy of MedicineDataStudentVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? student = freezed,
    Object? activeRequestCount = freezed,
    Object? expiredRequestCount = freezed,
  }) {
    return _then(_self.copyWith(
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentBaseInfoVODto?,
      activeRequestCount: freezed == activeRequestCount
          ? _self.activeRequestCount
          : activeRequestCount // ignore: cast_nullable_to_non_nullable
              as int?,
      expiredRequestCount: freezed == expiredRequestCount
          ? _self.expiredRequestCount
          : expiredRequestCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of MedicineDataStudentVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentBaseInfoVODtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentBaseInfoVODtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }
}

/// Adds pattern-matching-related methods to [MedicineDataStudentVODto].
extension MedicineDataStudentVODtoPatterns on MedicineDataStudentVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineDataStudentVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineDataStudentVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineDataStudentVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDataStudentVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineDataStudentVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDataStudentVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'student') StudentBaseInfoVODto? student,
            @JsonKey(name: 'activeRequestCount') int? activeRequestCount,
            @JsonKey(name: 'expiredRequestCount') int? expiredRequestCount)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineDataStudentVODto() when $default != null:
        return $default(
            _that.student, _that.activeRequestCount, _that.expiredRequestCount);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'student') StudentBaseInfoVODto? student,
            @JsonKey(name: 'activeRequestCount') int? activeRequestCount,
            @JsonKey(name: 'expiredRequestCount') int? expiredRequestCount)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDataStudentVODto():
        return $default(
            _that.student, _that.activeRequestCount, _that.expiredRequestCount);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'student') StudentBaseInfoVODto? student,
            @JsonKey(name: 'activeRequestCount') int? activeRequestCount,
            @JsonKey(name: 'expiredRequestCount') int? expiredRequestCount)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDataStudentVODto() when $default != null:
        return $default(
            _that.student, _that.activeRequestCount, _that.expiredRequestCount);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineDataStudentVODto implements MedicineDataStudentVODto {
  _MedicineDataStudentVODto(
      {@JsonKey(name: 'student') this.student,
      @JsonKey(name: 'activeRequestCount') this.activeRequestCount,
      @JsonKey(name: 'expiredRequestCount') this.expiredRequestCount});
  factory _MedicineDataStudentVODto.fromJson(Map<String, dynamic> json) =>
      _$MedicineDataStudentVODtoFromJson(json);

  @override
  @JsonKey(name: 'student')
  final StudentBaseInfoVODto? student;
  @override
  @JsonKey(name: 'activeRequestCount')
  final int? activeRequestCount;
  @override
  @JsonKey(name: 'expiredRequestCount')
  final int? expiredRequestCount;

  /// Create a copy of MedicineDataStudentVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineDataStudentVODtoCopyWith<_MedicineDataStudentVODto> get copyWith =>
      __$MedicineDataStudentVODtoCopyWithImpl<_MedicineDataStudentVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineDataStudentVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineDataStudentVODto &&
            (identical(other.student, student) || other.student == student) &&
            (identical(other.activeRequestCount, activeRequestCount) ||
                other.activeRequestCount == activeRequestCount) &&
            (identical(other.expiredRequestCount, expiredRequestCount) ||
                other.expiredRequestCount == expiredRequestCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, student, activeRequestCount, expiredRequestCount);

  @override
  String toString() {
    return 'MedicineDataStudentVODto(student: $student, activeRequestCount: $activeRequestCount, expiredRequestCount: $expiredRequestCount)';
  }
}

/// @nodoc
abstract mixin class _$MedicineDataStudentVODtoCopyWith<$Res>
    implements $MedicineDataStudentVODtoCopyWith<$Res> {
  factory _$MedicineDataStudentVODtoCopyWith(_MedicineDataStudentVODto value,
          $Res Function(_MedicineDataStudentVODto) _then) =
      __$MedicineDataStudentVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'student') StudentBaseInfoVODto? student,
      @JsonKey(name: 'activeRequestCount') int? activeRequestCount,
      @JsonKey(name: 'expiredRequestCount') int? expiredRequestCount});

  @override
  $StudentBaseInfoVODtoCopyWith<$Res>? get student;
}

/// @nodoc
class __$MedicineDataStudentVODtoCopyWithImpl<$Res>
    implements _$MedicineDataStudentVODtoCopyWith<$Res> {
  __$MedicineDataStudentVODtoCopyWithImpl(this._self, this._then);

  final _MedicineDataStudentVODto _self;
  final $Res Function(_MedicineDataStudentVODto) _then;

  /// Create a copy of MedicineDataStudentVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? student = freezed,
    Object? activeRequestCount = freezed,
    Object? expiredRequestCount = freezed,
  }) {
    return _then(_MedicineDataStudentVODto(
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentBaseInfoVODto?,
      activeRequestCount: freezed == activeRequestCount
          ? _self.activeRequestCount
          : activeRequestCount // ignore: cast_nullable_to_non_nullable
              as int?,
      expiredRequestCount: freezed == expiredRequestCount
          ? _self.expiredRequestCount
          : expiredRequestCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of MedicineDataStudentVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentBaseInfoVODtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentBaseInfoVODtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }
}

/// @nodoc
mixin _$MedicineDetailsDto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'name')
  String get name;
  @JsonKey(name: 'dosage')
  String get dosage;
  @JsonKey(name: 'administrationManner')
  String? get administrationManner;
  @JsonKey(name: 'entityFileRefId')
  String? get entityFileRefId;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'medicineExpirationDate')
  DateTime? get medicineExpirationDate;

  /// Create a copy of MedicineDetailsDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineDetailsDtoCopyWith<MedicineDetailsDto> get copyWith =>
      _$MedicineDetailsDtoCopyWithImpl<MedicineDetailsDto>(
          this as MedicineDetailsDto, _$identity);

  /// Serializes this MedicineDetailsDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineDetailsDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.dosage, dosage) || other.dosage == dosage) &&
            (identical(other.administrationManner, administrationManner) ||
                other.administrationManner == administrationManner) &&
            (identical(other.entityFileRefId, entityFileRefId) ||
                other.entityFileRefId == entityFileRefId) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.medicineExpirationDate, medicineExpirationDate) ||
                other.medicineExpirationDate == medicineExpirationDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, dosage,
      administrationManner, entityFileRefId, fileUrl, medicineExpirationDate);

  @override
  String toString() {
    return 'MedicineDetailsDto(id: $id, name: $name, dosage: $dosage, administrationManner: $administrationManner, entityFileRefId: $entityFileRefId, fileUrl: $fileUrl, medicineExpirationDate: $medicineExpirationDate)';
  }
}

/// @nodoc
abstract mixin class $MedicineDetailsDtoCopyWith<$Res> {
  factory $MedicineDetailsDtoCopyWith(
          MedicineDetailsDto value, $Res Function(MedicineDetailsDto) _then) =
      _$MedicineDetailsDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'dosage') String dosage,
      @JsonKey(name: 'administrationManner') String? administrationManner,
      @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'medicineExpirationDate')
      DateTime? medicineExpirationDate});
}

/// @nodoc
class _$MedicineDetailsDtoCopyWithImpl<$Res>
    implements $MedicineDetailsDtoCopyWith<$Res> {
  _$MedicineDetailsDtoCopyWithImpl(this._self, this._then);

  final MedicineDetailsDto _self;
  final $Res Function(MedicineDetailsDto) _then;

  /// Create a copy of MedicineDetailsDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? dosage = null,
    Object? administrationManner = freezed,
    Object? entityFileRefId = freezed,
    Object? fileUrl = freezed,
    Object? medicineExpirationDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      dosage: null == dosage
          ? _self.dosage
          : dosage // ignore: cast_nullable_to_non_nullable
              as String,
      administrationManner: freezed == administrationManner
          ? _self.administrationManner
          : administrationManner // ignore: cast_nullable_to_non_nullable
              as String?,
      entityFileRefId: freezed == entityFileRefId
          ? _self.entityFileRefId
          : entityFileRefId // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineExpirationDate: freezed == medicineExpirationDate
          ? _self.medicineExpirationDate
          : medicineExpirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineDetailsDto].
extension MedicineDetailsDtoPatterns on MedicineDetailsDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineDetailsDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineDetailsDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineDetailsDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'name') String name,
            @JsonKey(name: 'dosage') String dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsDto() when $default != null:
        return $default(
            _that.id,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.entityFileRefId,
            _that.fileUrl,
            _that.medicineExpirationDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'name') String name,
            @JsonKey(name: 'dosage') String dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsDto():
        return $default(
            _that.id,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.entityFileRefId,
            _that.fileUrl,
            _that.medicineExpirationDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'name') String name,
            @JsonKey(name: 'dosage') String dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsDto() when $default != null:
        return $default(
            _that.id,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.entityFileRefId,
            _that.fileUrl,
            _that.medicineExpirationDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineDetailsDto implements MedicineDetailsDto {
  _MedicineDetailsDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'dosage') required this.dosage,
      @JsonKey(name: 'administrationManner') this.administrationManner,
      @JsonKey(name: 'entityFileRefId') this.entityFileRefId,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'medicineExpirationDate') this.medicineExpirationDate});
  factory _MedicineDetailsDto.fromJson(Map<String, dynamic> json) =>
      _$MedicineDetailsDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'name')
  final String name;
  @override
  @JsonKey(name: 'dosage')
  final String dosage;
  @override
  @JsonKey(name: 'administrationManner')
  final String? administrationManner;
  @override
  @JsonKey(name: 'entityFileRefId')
  final String? entityFileRefId;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'medicineExpirationDate')
  final DateTime? medicineExpirationDate;

  /// Create a copy of MedicineDetailsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineDetailsDtoCopyWith<_MedicineDetailsDto> get copyWith =>
      __$MedicineDetailsDtoCopyWithImpl<_MedicineDetailsDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineDetailsDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineDetailsDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.dosage, dosage) || other.dosage == dosage) &&
            (identical(other.administrationManner, administrationManner) ||
                other.administrationManner == administrationManner) &&
            (identical(other.entityFileRefId, entityFileRefId) ||
                other.entityFileRefId == entityFileRefId) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.medicineExpirationDate, medicineExpirationDate) ||
                other.medicineExpirationDate == medicineExpirationDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, dosage,
      administrationManner, entityFileRefId, fileUrl, medicineExpirationDate);

  @override
  String toString() {
    return 'MedicineDetailsDto(id: $id, name: $name, dosage: $dosage, administrationManner: $administrationManner, entityFileRefId: $entityFileRefId, fileUrl: $fileUrl, medicineExpirationDate: $medicineExpirationDate)';
  }
}

/// @nodoc
abstract mixin class _$MedicineDetailsDtoCopyWith<$Res>
    implements $MedicineDetailsDtoCopyWith<$Res> {
  factory _$MedicineDetailsDtoCopyWith(
          _MedicineDetailsDto value, $Res Function(_MedicineDetailsDto) _then) =
      __$MedicineDetailsDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'dosage') String dosage,
      @JsonKey(name: 'administrationManner') String? administrationManner,
      @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'medicineExpirationDate')
      DateTime? medicineExpirationDate});
}

/// @nodoc
class __$MedicineDetailsDtoCopyWithImpl<$Res>
    implements _$MedicineDetailsDtoCopyWith<$Res> {
  __$MedicineDetailsDtoCopyWithImpl(this._self, this._then);

  final _MedicineDetailsDto _self;
  final $Res Function(_MedicineDetailsDto) _then;

  /// Create a copy of MedicineDetailsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? dosage = null,
    Object? administrationManner = freezed,
    Object? entityFileRefId = freezed,
    Object? fileUrl = freezed,
    Object? medicineExpirationDate = freezed,
  }) {
    return _then(_MedicineDetailsDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      dosage: null == dosage
          ? _self.dosage
          : dosage // ignore: cast_nullable_to_non_nullable
              as String,
      administrationManner: freezed == administrationManner
          ? _self.administrationManner
          : administrationManner // ignore: cast_nullable_to_non_nullable
              as String?,
      entityFileRefId: freezed == entityFileRefId
          ? _self.entityFileRefId
          : entityFileRefId // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineExpirationDate: freezed == medicineExpirationDate
          ? _self.medicineExpirationDate
          : medicineExpirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$MedicineDetailsVODto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'medicineFormId')
  int? get medicineFormId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'dosage')
  String? get dosage;
  @JsonKey(name: 'administrationManner')
  String? get administrationManner;
  @JsonKey(name: 'medicineExpirationDate')
  DateTime? get medicineExpirationDate;
  @JsonKey(name: 'entityFileRefId')
  String? get entityFileRefId;
  @JsonKey(name: 'entityFileUrl')
  String? get entityFileUrl;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'remarks')
  String? get remarks;

  /// Create a copy of MedicineDetailsVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineDetailsVODtoCopyWith<MedicineDetailsVODto> get copyWith =>
      _$MedicineDetailsVODtoCopyWithImpl<MedicineDetailsVODto>(
          this as MedicineDetailsVODto, _$identity);

  /// Serializes this MedicineDetailsVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineDetailsVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.dosage, dosage) || other.dosage == dosage) &&
            (identical(other.administrationManner, administrationManner) ||
                other.administrationManner == administrationManner) &&
            (identical(other.medicineExpirationDate, medicineExpirationDate) ||
                other.medicineExpirationDate == medicineExpirationDate) &&
            (identical(other.entityFileRefId, entityFileRefId) ||
                other.entityFileRefId == entityFileRefId) &&
            (identical(other.entityFileUrl, entityFileUrl) ||
                other.entityFileUrl == entityFileUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.remarks, remarks) || other.remarks == remarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      medicineFormId,
      name,
      dosage,
      administrationManner,
      medicineExpirationDate,
      entityFileRefId,
      entityFileUrl,
      fileUrl,
      remarks);

  @override
  String toString() {
    return 'MedicineDetailsVODto(id: $id, medicineFormId: $medicineFormId, name: $name, dosage: $dosage, administrationManner: $administrationManner, medicineExpirationDate: $medicineExpirationDate, entityFileRefId: $entityFileRefId, entityFileUrl: $entityFileUrl, fileUrl: $fileUrl, remarks: $remarks)';
  }
}

/// @nodoc
abstract mixin class $MedicineDetailsVODtoCopyWith<$Res> {
  factory $MedicineDetailsVODtoCopyWith(MedicineDetailsVODto value,
          $Res Function(MedicineDetailsVODto) _then) =
      _$MedicineDetailsVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'dosage') String? dosage,
      @JsonKey(name: 'administrationManner') String? administrationManner,
      @JsonKey(name: 'medicineExpirationDate') DateTime? medicineExpirationDate,
      @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
      @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'remarks') String? remarks});
}

/// @nodoc
class _$MedicineDetailsVODtoCopyWithImpl<$Res>
    implements $MedicineDetailsVODtoCopyWith<$Res> {
  _$MedicineDetailsVODtoCopyWithImpl(this._self, this._then);

  final MedicineDetailsVODto _self;
  final $Res Function(MedicineDetailsVODto) _then;

  /// Create a copy of MedicineDetailsVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? medicineFormId = freezed,
    Object? name = freezed,
    Object? dosage = freezed,
    Object? administrationManner = freezed,
    Object? medicineExpirationDate = freezed,
    Object? entityFileRefId = freezed,
    Object? entityFileUrl = freezed,
    Object? fileUrl = freezed,
    Object? remarks = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      dosage: freezed == dosage
          ? _self.dosage
          : dosage // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationManner: freezed == administrationManner
          ? _self.administrationManner
          : administrationManner // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineExpirationDate: freezed == medicineExpirationDate
          ? _self.medicineExpirationDate
          : medicineExpirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      entityFileRefId: freezed == entityFileRefId
          ? _self.entityFileRefId
          : entityFileRefId // ignore: cast_nullable_to_non_nullable
              as String?,
      entityFileUrl: freezed == entityFileUrl
          ? _self.entityFileUrl
          : entityFileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineDetailsVODto].
extension MedicineDetailsVODtoPatterns on MedicineDetailsVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineDetailsVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineDetailsVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineDetailsVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'dosage') String? dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'remarks') String? remarks)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsVODto() when $default != null:
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.medicineExpirationDate,
            _that.entityFileRefId,
            _that.entityFileUrl,
            _that.fileUrl,
            _that.remarks);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'dosage') String? dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'remarks') String? remarks)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsVODto():
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.medicineExpirationDate,
            _that.entityFileRefId,
            _that.entityFileUrl,
            _that.fileUrl,
            _that.remarks);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'dosage') String? dosage,
            @JsonKey(name: 'administrationManner') String? administrationManner,
            @JsonKey(name: 'medicineExpirationDate')
            DateTime? medicineExpirationDate,
            @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
            @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'remarks') String? remarks)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineDetailsVODto() when $default != null:
        return $default(
            _that.id,
            _that.medicineFormId,
            _that.name,
            _that.dosage,
            _that.administrationManner,
            _that.medicineExpirationDate,
            _that.entityFileRefId,
            _that.entityFileUrl,
            _that.fileUrl,
            _that.remarks);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineDetailsVODto implements MedicineDetailsVODto {
  _MedicineDetailsVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'medicineFormId') this.medicineFormId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'dosage') this.dosage,
      @JsonKey(name: 'administrationManner') this.administrationManner,
      @JsonKey(name: 'medicineExpirationDate') this.medicineExpirationDate,
      @JsonKey(name: 'entityFileRefId') this.entityFileRefId,
      @JsonKey(name: 'entityFileUrl') this.entityFileUrl,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'remarks') this.remarks});
  factory _MedicineDetailsVODto.fromJson(Map<String, dynamic> json) =>
      _$MedicineDetailsVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'medicineFormId')
  final int? medicineFormId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'dosage')
  final String? dosage;
  @override
  @JsonKey(name: 'administrationManner')
  final String? administrationManner;
  @override
  @JsonKey(name: 'medicineExpirationDate')
  final DateTime? medicineExpirationDate;
  @override
  @JsonKey(name: 'entityFileRefId')
  final String? entityFileRefId;
  @override
  @JsonKey(name: 'entityFileUrl')
  final String? entityFileUrl;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;

  /// Create a copy of MedicineDetailsVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineDetailsVODtoCopyWith<_MedicineDetailsVODto> get copyWith =>
      __$MedicineDetailsVODtoCopyWithImpl<_MedicineDetailsVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineDetailsVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineDetailsVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.dosage, dosage) || other.dosage == dosage) &&
            (identical(other.administrationManner, administrationManner) ||
                other.administrationManner == administrationManner) &&
            (identical(other.medicineExpirationDate, medicineExpirationDate) ||
                other.medicineExpirationDate == medicineExpirationDate) &&
            (identical(other.entityFileRefId, entityFileRefId) ||
                other.entityFileRefId == entityFileRefId) &&
            (identical(other.entityFileUrl, entityFileUrl) ||
                other.entityFileUrl == entityFileUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.remarks, remarks) || other.remarks == remarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      medicineFormId,
      name,
      dosage,
      administrationManner,
      medicineExpirationDate,
      entityFileRefId,
      entityFileUrl,
      fileUrl,
      remarks);

  @override
  String toString() {
    return 'MedicineDetailsVODto(id: $id, medicineFormId: $medicineFormId, name: $name, dosage: $dosage, administrationManner: $administrationManner, medicineExpirationDate: $medicineExpirationDate, entityFileRefId: $entityFileRefId, entityFileUrl: $entityFileUrl, fileUrl: $fileUrl, remarks: $remarks)';
  }
}

/// @nodoc
abstract mixin class _$MedicineDetailsVODtoCopyWith<$Res>
    implements $MedicineDetailsVODtoCopyWith<$Res> {
  factory _$MedicineDetailsVODtoCopyWith(_MedicineDetailsVODto value,
          $Res Function(_MedicineDetailsVODto) _then) =
      __$MedicineDetailsVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'dosage') String? dosage,
      @JsonKey(name: 'administrationManner') String? administrationManner,
      @JsonKey(name: 'medicineExpirationDate') DateTime? medicineExpirationDate,
      @JsonKey(name: 'entityFileRefId') String? entityFileRefId,
      @JsonKey(name: 'entityFileUrl') String? entityFileUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'remarks') String? remarks});
}

/// @nodoc
class __$MedicineDetailsVODtoCopyWithImpl<$Res>
    implements _$MedicineDetailsVODtoCopyWith<$Res> {
  __$MedicineDetailsVODtoCopyWithImpl(this._self, this._then);

  final _MedicineDetailsVODto _self;
  final $Res Function(_MedicineDetailsVODto) _then;

  /// Create a copy of MedicineDetailsVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? medicineFormId = freezed,
    Object? name = freezed,
    Object? dosage = freezed,
    Object? administrationManner = freezed,
    Object? medicineExpirationDate = freezed,
    Object? entityFileRefId = freezed,
    Object? entityFileUrl = freezed,
    Object? fileUrl = freezed,
    Object? remarks = freezed,
  }) {
    return _then(_MedicineDetailsVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      dosage: freezed == dosage
          ? _self.dosage
          : dosage // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationManner: freezed == administrationManner
          ? _self.administrationManner
          : administrationManner // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineExpirationDate: freezed == medicineExpirationDate
          ? _self.medicineExpirationDate
          : medicineExpirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      entityFileRefId: freezed == entityFileRefId
          ? _self.entityFileRefId
          : entityFileRefId // ignore: cast_nullable_to_non_nullable
              as String?,
      entityFileUrl: freezed == entityFileUrl
          ? _self.entityFileUrl
          : entityFileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MedicineFormDto {
  @JsonKey(name: 'medicineFormId')
  int? get medicineFormId;
  @JsonKey(name: 'applicationDate')
  DateTime? get applicationDate;
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'parentType')
  String? get parentType;
  @JsonKey(name: 'parentEmail')
  String? get parentEmail;
  @JsonKey(name: 'studentCourseId')
  String? get studentCourseId;
  @JsonKey(name: 'administrationTime')
  String? get administrationTime;
  @JsonKey(name: 'startDate')
  DateTime? get startDate;
  @JsonKey(name: 'endDate')
  DateTime? get endDate;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'acknowledgedBy')
  String? get acknowledgedBy;
  @JsonKey(name: 'acknowledgedDateTime')
  DateTime? get acknowledgedDateTime;
  @JsonKey(name: 'createdBy')
  String? get createdBy;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'rejectedBy')
  String? get rejectedBy;
  @JsonKey(name: 'rejectedDateTime')
  DateTime? get rejectedDateTime;
  @JsonKey(name: 'acknowledgeCancelBy')
  String? get acknowledgeCancelBy;
  @JsonKey(name: 'acknowledgeCancelDateTime')
  DateTime? get acknowledgeCancelDateTime;
  @JsonKey(name: 'updatedBy')
  String? get updatedBy;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;
  @JsonKey(name: 'schoolId')
  String? get schoolId;
  @JsonKey(name: 'classId')
  String? get classId;
  @JsonKey(name: 'rejectRemarks')
  String? get rejectRemarks;
  @JsonKey(name: 'previousStatus')
  String? get previousStatus;
  @JsonKey(name: 'previousUpdatedDate')
  DateTime? get previousUpdatedDate;

  /// Create a copy of MedicineFormDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineFormDtoCopyWith<MedicineFormDto> get copyWith =>
      _$MedicineFormDtoCopyWithImpl<MedicineFormDto>(
          this as MedicineFormDto, _$identity);

  /// Serializes this MedicineFormDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineFormDto &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.applicationDate, applicationDate) ||
                other.applicationDate == applicationDate) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.parentType, parentType) ||
                other.parentType == parentType) &&
            (identical(other.parentEmail, parentEmail) ||
                other.parentEmail == parentEmail) &&
            (identical(other.studentCourseId, studentCourseId) ||
                other.studentCourseId == studentCourseId) &&
            (identical(other.administrationTime, administrationTime) ||
                other.administrationTime == administrationTime) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.acknowledgedBy, acknowledgedBy) ||
                other.acknowledgedBy == acknowledgedBy) &&
            (identical(other.acknowledgedDateTime, acknowledgedDateTime) ||
                other.acknowledgedDateTime == acknowledgedDateTime) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.rejectedBy, rejectedBy) ||
                other.rejectedBy == rejectedBy) &&
            (identical(other.rejectedDateTime, rejectedDateTime) ||
                other.rejectedDateTime == rejectedDateTime) &&
            (identical(other.acknowledgeCancelBy, acknowledgeCancelBy) ||
                other.acknowledgeCancelBy == acknowledgeCancelBy) &&
            (identical(other.acknowledgeCancelDateTime,
                    acknowledgeCancelDateTime) ||
                other.acknowledgeCancelDateTime == acknowledgeCancelDateTime) &&
            (identical(other.updatedBy, updatedBy) ||
                other.updatedBy == updatedBy) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.rejectRemarks, rejectRemarks) ||
                other.rejectRemarks == rejectRemarks) &&
            (identical(other.previousStatus, previousStatus) ||
                other.previousStatus == previousStatus) &&
            (identical(other.previousUpdatedDate, previousUpdatedDate) ||
                other.previousUpdatedDate == previousUpdatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        medicineFormId,
        applicationDate,
        studentId,
        parentType,
        parentEmail,
        studentCourseId,
        administrationTime,
        startDate,
        endDate,
        remarks,
        status,
        acknowledgedBy,
        acknowledgedDateTime,
        createdBy,
        createdDate,
        rejectedBy,
        rejectedDateTime,
        acknowledgeCancelBy,
        acknowledgeCancelDateTime,
        updatedBy,
        updatedDate,
        schoolId,
        classId,
        rejectRemarks,
        previousStatus,
        previousUpdatedDate
      ]);

  @override
  String toString() {
    return 'MedicineFormDto(medicineFormId: $medicineFormId, applicationDate: $applicationDate, studentId: $studentId, parentType: $parentType, parentEmail: $parentEmail, studentCourseId: $studentCourseId, administrationTime: $administrationTime, startDate: $startDate, endDate: $endDate, remarks: $remarks, status: $status, acknowledgedBy: $acknowledgedBy, acknowledgedDateTime: $acknowledgedDateTime, createdBy: $createdBy, createdDate: $createdDate, rejectedBy: $rejectedBy, rejectedDateTime: $rejectedDateTime, acknowledgeCancelBy: $acknowledgeCancelBy, acknowledgeCancelDateTime: $acknowledgeCancelDateTime, updatedBy: $updatedBy, updatedDate: $updatedDate, schoolId: $schoolId, classId: $classId, rejectRemarks: $rejectRemarks, previousStatus: $previousStatus, previousUpdatedDate: $previousUpdatedDate)';
  }
}

/// @nodoc
abstract mixin class $MedicineFormDtoCopyWith<$Res> {
  factory $MedicineFormDtoCopyWith(
          MedicineFormDto value, $Res Function(MedicineFormDto) _then) =
      _$MedicineFormDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'applicationDate') DateTime? applicationDate,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'parentType') String? parentType,
      @JsonKey(name: 'parentEmail') String? parentEmail,
      @JsonKey(name: 'studentCourseId') String? studentCourseId,
      @JsonKey(name: 'administrationTime') String? administrationTime,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
      @JsonKey(name: 'acknowledgedDateTime') DateTime? acknowledgedDateTime,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'rejectedBy') String? rejectedBy,
      @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
      @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
      @JsonKey(name: 'acknowledgeCancelDateTime')
      DateTime? acknowledgeCancelDateTime,
      @JsonKey(name: 'updatedBy') String? updatedBy,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
      @JsonKey(name: 'previousStatus') String? previousStatus,
      @JsonKey(name: 'previousUpdatedDate') DateTime? previousUpdatedDate});
}

/// @nodoc
class _$MedicineFormDtoCopyWithImpl<$Res>
    implements $MedicineFormDtoCopyWith<$Res> {
  _$MedicineFormDtoCopyWithImpl(this._self, this._then);

  final MedicineFormDto _self;
  final $Res Function(MedicineFormDto) _then;

  /// Create a copy of MedicineFormDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? medicineFormId = freezed,
    Object? applicationDate = freezed,
    Object? studentId = null,
    Object? parentType = freezed,
    Object? parentEmail = freezed,
    Object? studentCourseId = freezed,
    Object? administrationTime = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? remarks = freezed,
    Object? status = freezed,
    Object? acknowledgedBy = freezed,
    Object? acknowledgedDateTime = freezed,
    Object? createdBy = freezed,
    Object? createdDate = freezed,
    Object? rejectedBy = freezed,
    Object? rejectedDateTime = freezed,
    Object? acknowledgeCancelBy = freezed,
    Object? acknowledgeCancelDateTime = freezed,
    Object? updatedBy = freezed,
    Object? updatedDate = freezed,
    Object? schoolId = freezed,
    Object? classId = freezed,
    Object? rejectRemarks = freezed,
    Object? previousStatus = freezed,
    Object? previousUpdatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      applicationDate: freezed == applicationDate
          ? _self.applicationDate
          : applicationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      parentType: freezed == parentType
          ? _self.parentType
          : parentType // ignore: cast_nullable_to_non_nullable
              as String?,
      parentEmail: freezed == parentEmail
          ? _self.parentEmail
          : parentEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      studentCourseId: freezed == studentCourseId
          ? _self.studentCourseId
          : studentCourseId // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationTime: freezed == administrationTime
          ? _self.administrationTime
          : administrationTime // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedBy: freezed == acknowledgedBy
          ? _self.acknowledgedBy
          : acknowledgedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedDateTime: freezed == acknowledgedDateTime
          ? _self.acknowledgedDateTime
          : acknowledgedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      rejectedBy: freezed == rejectedBy
          ? _self.rejectedBy
          : rejectedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectedDateTime: freezed == rejectedDateTime
          ? _self.rejectedDateTime
          : rejectedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      acknowledgeCancelBy: freezed == acknowledgeCancelBy
          ? _self.acknowledgeCancelBy
          : acknowledgeCancelBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgeCancelDateTime: freezed == acknowledgeCancelDateTime
          ? _self.acknowledgeCancelDateTime
          : acknowledgeCancelDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedBy: freezed == updatedBy
          ? _self.updatedBy
          : updatedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectRemarks: freezed == rejectRemarks
          ? _self.rejectRemarks
          : rejectRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      previousStatus: freezed == previousStatus
          ? _self.previousStatus
          : previousStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      previousUpdatedDate: freezed == previousUpdatedDate
          ? _self.previousUpdatedDate
          : previousUpdatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineFormDto].
extension MedicineFormDtoPatterns on MedicineFormDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineFormDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineFormDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineFormDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'applicationDate') DateTime? applicationDate,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'parentType') String? parentType,
            @JsonKey(name: 'parentEmail') String? parentEmail,
            @JsonKey(name: 'studentCourseId') String? studentCourseId,
            @JsonKey(name: 'administrationTime') String? administrationTime,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
            @JsonKey(name: 'acknowledgedDateTime')
            DateTime? acknowledgedDateTime,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'rejectedBy') String? rejectedBy,
            @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
            @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
            @JsonKey(name: 'acknowledgeCancelDateTime')
            DateTime? acknowledgeCancelDateTime,
            @JsonKey(name: 'updatedBy') String? updatedBy,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
            @JsonKey(name: 'previousStatus') String? previousStatus,
            @JsonKey(name: 'previousUpdatedDate')
            DateTime? previousUpdatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormDto() when $default != null:
        return $default(
            _that.medicineFormId,
            _that.applicationDate,
            _that.studentId,
            _that.parentType,
            _that.parentEmail,
            _that.studentCourseId,
            _that.administrationTime,
            _that.startDate,
            _that.endDate,
            _that.remarks,
            _that.status,
            _that.acknowledgedBy,
            _that.acknowledgedDateTime,
            _that.createdBy,
            _that.createdDate,
            _that.rejectedBy,
            _that.rejectedDateTime,
            _that.acknowledgeCancelBy,
            _that.acknowledgeCancelDateTime,
            _that.updatedBy,
            _that.updatedDate,
            _that.schoolId,
            _that.classId,
            _that.rejectRemarks,
            _that.previousStatus,
            _that.previousUpdatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'applicationDate') DateTime? applicationDate,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'parentType') String? parentType,
            @JsonKey(name: 'parentEmail') String? parentEmail,
            @JsonKey(name: 'studentCourseId') String? studentCourseId,
            @JsonKey(name: 'administrationTime') String? administrationTime,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
            @JsonKey(name: 'acknowledgedDateTime')
            DateTime? acknowledgedDateTime,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'rejectedBy') String? rejectedBy,
            @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
            @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
            @JsonKey(name: 'acknowledgeCancelDateTime')
            DateTime? acknowledgeCancelDateTime,
            @JsonKey(name: 'updatedBy') String? updatedBy,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
            @JsonKey(name: 'previousStatus') String? previousStatus,
            @JsonKey(name: 'previousUpdatedDate') DateTime? previousUpdatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormDto():
        return $default(
            _that.medicineFormId,
            _that.applicationDate,
            _that.studentId,
            _that.parentType,
            _that.parentEmail,
            _that.studentCourseId,
            _that.administrationTime,
            _that.startDate,
            _that.endDate,
            _that.remarks,
            _that.status,
            _that.acknowledgedBy,
            _that.acknowledgedDateTime,
            _that.createdBy,
            _that.createdDate,
            _that.rejectedBy,
            _that.rejectedDateTime,
            _that.acknowledgeCancelBy,
            _that.acknowledgeCancelDateTime,
            _that.updatedBy,
            _that.updatedDate,
            _that.schoolId,
            _that.classId,
            _that.rejectRemarks,
            _that.previousStatus,
            _that.previousUpdatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'applicationDate') DateTime? applicationDate,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'parentType') String? parentType,
            @JsonKey(name: 'parentEmail') String? parentEmail,
            @JsonKey(name: 'studentCourseId') String? studentCourseId,
            @JsonKey(name: 'administrationTime') String? administrationTime,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
            @JsonKey(name: 'acknowledgedDateTime')
            DateTime? acknowledgedDateTime,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'rejectedBy') String? rejectedBy,
            @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
            @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
            @JsonKey(name: 'acknowledgeCancelDateTime')
            DateTime? acknowledgeCancelDateTime,
            @JsonKey(name: 'updatedBy') String? updatedBy,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
            @JsonKey(name: 'previousStatus') String? previousStatus,
            @JsonKey(name: 'previousUpdatedDate')
            DateTime? previousUpdatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormDto() when $default != null:
        return $default(
            _that.medicineFormId,
            _that.applicationDate,
            _that.studentId,
            _that.parentType,
            _that.parentEmail,
            _that.studentCourseId,
            _that.administrationTime,
            _that.startDate,
            _that.endDate,
            _that.remarks,
            _that.status,
            _that.acknowledgedBy,
            _that.acknowledgedDateTime,
            _that.createdBy,
            _that.createdDate,
            _that.rejectedBy,
            _that.rejectedDateTime,
            _that.acknowledgeCancelBy,
            _that.acknowledgeCancelDateTime,
            _that.updatedBy,
            _that.updatedDate,
            _that.schoolId,
            _that.classId,
            _that.rejectRemarks,
            _that.previousStatus,
            _that.previousUpdatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineFormDto implements MedicineFormDto {
  _MedicineFormDto(
      {@JsonKey(name: 'medicineFormId') this.medicineFormId,
      @JsonKey(name: 'applicationDate') this.applicationDate,
      @JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'parentType') this.parentType,
      @JsonKey(name: 'parentEmail') this.parentEmail,
      @JsonKey(name: 'studentCourseId') this.studentCourseId,
      @JsonKey(name: 'administrationTime') this.administrationTime,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'acknowledgedBy') this.acknowledgedBy,
      @JsonKey(name: 'acknowledgedDateTime') this.acknowledgedDateTime,
      @JsonKey(name: 'createdBy') this.createdBy,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'rejectedBy') this.rejectedBy,
      @JsonKey(name: 'rejectedDateTime') this.rejectedDateTime,
      @JsonKey(name: 'acknowledgeCancelBy') this.acknowledgeCancelBy,
      @JsonKey(name: 'acknowledgeCancelDateTime')
      this.acknowledgeCancelDateTime,
      @JsonKey(name: 'updatedBy') this.updatedBy,
      @JsonKey(name: 'updatedDate') this.updatedDate,
      @JsonKey(name: 'schoolId') this.schoolId,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'rejectRemarks') this.rejectRemarks,
      @JsonKey(name: 'previousStatus') this.previousStatus,
      @JsonKey(name: 'previousUpdatedDate') this.previousUpdatedDate});
  factory _MedicineFormDto.fromJson(Map<String, dynamic> json) =>
      _$MedicineFormDtoFromJson(json);

  @override
  @JsonKey(name: 'medicineFormId')
  final int? medicineFormId;
  @override
  @JsonKey(name: 'applicationDate')
  final DateTime? applicationDate;
  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'parentType')
  final String? parentType;
  @override
  @JsonKey(name: 'parentEmail')
  final String? parentEmail;
  @override
  @JsonKey(name: 'studentCourseId')
  final String? studentCourseId;
  @override
  @JsonKey(name: 'administrationTime')
  final String? administrationTime;
  @override
  @JsonKey(name: 'startDate')
  final DateTime? startDate;
  @override
  @JsonKey(name: 'endDate')
  final DateTime? endDate;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'acknowledgedBy')
  final String? acknowledgedBy;
  @override
  @JsonKey(name: 'acknowledgedDateTime')
  final DateTime? acknowledgedDateTime;
  @override
  @JsonKey(name: 'createdBy')
  final String? createdBy;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'rejectedBy')
  final String? rejectedBy;
  @override
  @JsonKey(name: 'rejectedDateTime')
  final DateTime? rejectedDateTime;
  @override
  @JsonKey(name: 'acknowledgeCancelBy')
  final String? acknowledgeCancelBy;
  @override
  @JsonKey(name: 'acknowledgeCancelDateTime')
  final DateTime? acknowledgeCancelDateTime;
  @override
  @JsonKey(name: 'updatedBy')
  final String? updatedBy;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;
  @override
  @JsonKey(name: 'classId')
  final String? classId;
  @override
  @JsonKey(name: 'rejectRemarks')
  final String? rejectRemarks;
  @override
  @JsonKey(name: 'previousStatus')
  final String? previousStatus;
  @override
  @JsonKey(name: 'previousUpdatedDate')
  final DateTime? previousUpdatedDate;

  /// Create a copy of MedicineFormDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineFormDtoCopyWith<_MedicineFormDto> get copyWith =>
      __$MedicineFormDtoCopyWithImpl<_MedicineFormDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineFormDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineFormDto &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.applicationDate, applicationDate) ||
                other.applicationDate == applicationDate) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.parentType, parentType) ||
                other.parentType == parentType) &&
            (identical(other.parentEmail, parentEmail) ||
                other.parentEmail == parentEmail) &&
            (identical(other.studentCourseId, studentCourseId) ||
                other.studentCourseId == studentCourseId) &&
            (identical(other.administrationTime, administrationTime) ||
                other.administrationTime == administrationTime) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.acknowledgedBy, acknowledgedBy) ||
                other.acknowledgedBy == acknowledgedBy) &&
            (identical(other.acknowledgedDateTime, acknowledgedDateTime) ||
                other.acknowledgedDateTime == acknowledgedDateTime) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.rejectedBy, rejectedBy) ||
                other.rejectedBy == rejectedBy) &&
            (identical(other.rejectedDateTime, rejectedDateTime) ||
                other.rejectedDateTime == rejectedDateTime) &&
            (identical(other.acknowledgeCancelBy, acknowledgeCancelBy) ||
                other.acknowledgeCancelBy == acknowledgeCancelBy) &&
            (identical(other.acknowledgeCancelDateTime,
                    acknowledgeCancelDateTime) ||
                other.acknowledgeCancelDateTime == acknowledgeCancelDateTime) &&
            (identical(other.updatedBy, updatedBy) ||
                other.updatedBy == updatedBy) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.rejectRemarks, rejectRemarks) ||
                other.rejectRemarks == rejectRemarks) &&
            (identical(other.previousStatus, previousStatus) ||
                other.previousStatus == previousStatus) &&
            (identical(other.previousUpdatedDate, previousUpdatedDate) ||
                other.previousUpdatedDate == previousUpdatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        medicineFormId,
        applicationDate,
        studentId,
        parentType,
        parentEmail,
        studentCourseId,
        administrationTime,
        startDate,
        endDate,
        remarks,
        status,
        acknowledgedBy,
        acknowledgedDateTime,
        createdBy,
        createdDate,
        rejectedBy,
        rejectedDateTime,
        acknowledgeCancelBy,
        acknowledgeCancelDateTime,
        updatedBy,
        updatedDate,
        schoolId,
        classId,
        rejectRemarks,
        previousStatus,
        previousUpdatedDate
      ]);

  @override
  String toString() {
    return 'MedicineFormDto(medicineFormId: $medicineFormId, applicationDate: $applicationDate, studentId: $studentId, parentType: $parentType, parentEmail: $parentEmail, studentCourseId: $studentCourseId, administrationTime: $administrationTime, startDate: $startDate, endDate: $endDate, remarks: $remarks, status: $status, acknowledgedBy: $acknowledgedBy, acknowledgedDateTime: $acknowledgedDateTime, createdBy: $createdBy, createdDate: $createdDate, rejectedBy: $rejectedBy, rejectedDateTime: $rejectedDateTime, acknowledgeCancelBy: $acknowledgeCancelBy, acknowledgeCancelDateTime: $acknowledgeCancelDateTime, updatedBy: $updatedBy, updatedDate: $updatedDate, schoolId: $schoolId, classId: $classId, rejectRemarks: $rejectRemarks, previousStatus: $previousStatus, previousUpdatedDate: $previousUpdatedDate)';
  }
}

/// @nodoc
abstract mixin class _$MedicineFormDtoCopyWith<$Res>
    implements $MedicineFormDtoCopyWith<$Res> {
  factory _$MedicineFormDtoCopyWith(
          _MedicineFormDto value, $Res Function(_MedicineFormDto) _then) =
      __$MedicineFormDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'applicationDate') DateTime? applicationDate,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'parentType') String? parentType,
      @JsonKey(name: 'parentEmail') String? parentEmail,
      @JsonKey(name: 'studentCourseId') String? studentCourseId,
      @JsonKey(name: 'administrationTime') String? administrationTime,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
      @JsonKey(name: 'acknowledgedDateTime') DateTime? acknowledgedDateTime,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'rejectedBy') String? rejectedBy,
      @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
      @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
      @JsonKey(name: 'acknowledgeCancelDateTime')
      DateTime? acknowledgeCancelDateTime,
      @JsonKey(name: 'updatedBy') String? updatedBy,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
      @JsonKey(name: 'previousStatus') String? previousStatus,
      @JsonKey(name: 'previousUpdatedDate') DateTime? previousUpdatedDate});
}

/// @nodoc
class __$MedicineFormDtoCopyWithImpl<$Res>
    implements _$MedicineFormDtoCopyWith<$Res> {
  __$MedicineFormDtoCopyWithImpl(this._self, this._then);

  final _MedicineFormDto _self;
  final $Res Function(_MedicineFormDto) _then;

  /// Create a copy of MedicineFormDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? medicineFormId = freezed,
    Object? applicationDate = freezed,
    Object? studentId = null,
    Object? parentType = freezed,
    Object? parentEmail = freezed,
    Object? studentCourseId = freezed,
    Object? administrationTime = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? remarks = freezed,
    Object? status = freezed,
    Object? acknowledgedBy = freezed,
    Object? acknowledgedDateTime = freezed,
    Object? createdBy = freezed,
    Object? createdDate = freezed,
    Object? rejectedBy = freezed,
    Object? rejectedDateTime = freezed,
    Object? acknowledgeCancelBy = freezed,
    Object? acknowledgeCancelDateTime = freezed,
    Object? updatedBy = freezed,
    Object? updatedDate = freezed,
    Object? schoolId = freezed,
    Object? classId = freezed,
    Object? rejectRemarks = freezed,
    Object? previousStatus = freezed,
    Object? previousUpdatedDate = freezed,
  }) {
    return _then(_MedicineFormDto(
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      applicationDate: freezed == applicationDate
          ? _self.applicationDate
          : applicationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      parentType: freezed == parentType
          ? _self.parentType
          : parentType // ignore: cast_nullable_to_non_nullable
              as String?,
      parentEmail: freezed == parentEmail
          ? _self.parentEmail
          : parentEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      studentCourseId: freezed == studentCourseId
          ? _self.studentCourseId
          : studentCourseId // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationTime: freezed == administrationTime
          ? _self.administrationTime
          : administrationTime // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedBy: freezed == acknowledgedBy
          ? _self.acknowledgedBy
          : acknowledgedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedDateTime: freezed == acknowledgedDateTime
          ? _self.acknowledgedDateTime
          : acknowledgedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      rejectedBy: freezed == rejectedBy
          ? _self.rejectedBy
          : rejectedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectedDateTime: freezed == rejectedDateTime
          ? _self.rejectedDateTime
          : rejectedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      acknowledgeCancelBy: freezed == acknowledgeCancelBy
          ? _self.acknowledgeCancelBy
          : acknowledgeCancelBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgeCancelDateTime: freezed == acknowledgeCancelDateTime
          ? _self.acknowledgeCancelDateTime
          : acknowledgeCancelDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedBy: freezed == updatedBy
          ? _self.updatedBy
          : updatedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectRemarks: freezed == rejectRemarks
          ? _self.rejectRemarks
          : rejectRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      previousStatus: freezed == previousStatus
          ? _self.previousStatus
          : previousStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      previousUpdatedDate: freezed == previousUpdatedDate
          ? _self.previousUpdatedDate
          : previousUpdatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$MedicineFormFullVODto {
  @JsonKey(name: 'medicineFormId')
  int? get medicineFormId;
  @JsonKey(name: 'applicationDate')
  DateTime? get applicationDate;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'parentType')
  String? get parentType;
  @JsonKey(name: 'parentEmail')
  String? get parentEmail;
  @JsonKey(name: 'studentCourseId')
  String? get studentCourseId;
  @JsonKey(name: 'administrationTime')
  String? get administrationTime;
  @JsonKey(name: 'startDate')
  DateTime? get startDate;
  @JsonKey(name: 'endDate')
  DateTime? get endDate;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'medicineFormStatus')
  String? get medicineFormStatus;
  @JsonKey(name: 'createdBy')
  String? get createdBy;
  @JsonKey(name: 'createdByName')
  String? get createdByName;
  @JsonKey(name: 'acknowledgedBy')
  String? get acknowledgedBy;
  @JsonKey(name: 'acknowledgedByName')
  String? get acknowledgedByName;
  @JsonKey(name: 'acknowledgedDateTime')
  DateTime? get acknowledgedDateTime;
  @JsonKey(name: 'rejectedBy')
  String? get rejectedBy;
  @JsonKey(name: 'rejectedByName')
  String? get rejectedByName;
  @JsonKey(name: 'rejectedDateTime')
  DateTime? get rejectedDateTime;
  @JsonKey(name: 'acknowledgeCancelBy')
  String? get acknowledgeCancelBy;
  @JsonKey(name: 'acknowledgeCancelByName')
  String? get acknowledgeCancelByName;
  @JsonKey(name: 'acknowledgeCancelDateTime')
  DateTime? get acknowledgeCancelDateTime;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'rejectRemarks')
  String? get rejectRemarks;
  @JsonKey(name: 'medicineDetails')
  List<MedicineDetailsVODto>? get medicineDetails;
  @JsonKey(name: 'latestAudit')
  MedicineAuditWithDetailVODto? get latestAudit;
  @JsonKey(name: 'student')
  StudentBaseInfoVODto? get student;

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineFormFullVODtoCopyWith<MedicineFormFullVODto> get copyWith =>
      _$MedicineFormFullVODtoCopyWithImpl<MedicineFormFullVODto>(
          this as MedicineFormFullVODto, _$identity);

  /// Serializes this MedicineFormFullVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineFormFullVODto &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.applicationDate, applicationDate) ||
                other.applicationDate == applicationDate) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.parentType, parentType) ||
                other.parentType == parentType) &&
            (identical(other.parentEmail, parentEmail) ||
                other.parentEmail == parentEmail) &&
            (identical(other.studentCourseId, studentCourseId) ||
                other.studentCourseId == studentCourseId) &&
            (identical(other.administrationTime, administrationTime) ||
                other.administrationTime == administrationTime) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.medicineFormStatus, medicineFormStatus) ||
                other.medicineFormStatus == medicineFormStatus) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.createdByName, createdByName) ||
                other.createdByName == createdByName) &&
            (identical(other.acknowledgedBy, acknowledgedBy) ||
                other.acknowledgedBy == acknowledgedBy) &&
            (identical(other.acknowledgedByName, acknowledgedByName) ||
                other.acknowledgedByName == acknowledgedByName) &&
            (identical(other.acknowledgedDateTime, acknowledgedDateTime) ||
                other.acknowledgedDateTime == acknowledgedDateTime) &&
            (identical(other.rejectedBy, rejectedBy) ||
                other.rejectedBy == rejectedBy) &&
            (identical(other.rejectedByName, rejectedByName) ||
                other.rejectedByName == rejectedByName) &&
            (identical(other.rejectedDateTime, rejectedDateTime) ||
                other.rejectedDateTime == rejectedDateTime) &&
            (identical(other.acknowledgeCancelBy, acknowledgeCancelBy) ||
                other.acknowledgeCancelBy == acknowledgeCancelBy) &&
            (identical(
                    other.acknowledgeCancelByName, acknowledgeCancelByName) ||
                other.acknowledgeCancelByName == acknowledgeCancelByName) &&
            (identical(other.acknowledgeCancelDateTime,
                    acknowledgeCancelDateTime) ||
                other.acknowledgeCancelDateTime == acknowledgeCancelDateTime) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.rejectRemarks, rejectRemarks) ||
                other.rejectRemarks == rejectRemarks) &&
            const DeepCollectionEquality()
                .equals(other.medicineDetails, medicineDetails) &&
            (identical(other.latestAudit, latestAudit) ||
                other.latestAudit == latestAudit) &&
            (identical(other.student, student) || other.student == student));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        medicineFormId,
        applicationDate,
        studentId,
        parentType,
        parentEmail,
        studentCourseId,
        administrationTime,
        startDate,
        endDate,
        remarks,
        medicineFormStatus,
        createdBy,
        createdByName,
        acknowledgedBy,
        acknowledgedByName,
        acknowledgedDateTime,
        rejectedBy,
        rejectedByName,
        rejectedDateTime,
        acknowledgeCancelBy,
        acknowledgeCancelByName,
        acknowledgeCancelDateTime,
        createdDate,
        rejectRemarks,
        const DeepCollectionEquality().hash(medicineDetails),
        latestAudit,
        student
      ]);

  @override
  String toString() {
    return 'MedicineFormFullVODto(medicineFormId: $medicineFormId, applicationDate: $applicationDate, studentId: $studentId, parentType: $parentType, parentEmail: $parentEmail, studentCourseId: $studentCourseId, administrationTime: $administrationTime, startDate: $startDate, endDate: $endDate, remarks: $remarks, medicineFormStatus: $medicineFormStatus, createdBy: $createdBy, createdByName: $createdByName, acknowledgedBy: $acknowledgedBy, acknowledgedByName: $acknowledgedByName, acknowledgedDateTime: $acknowledgedDateTime, rejectedBy: $rejectedBy, rejectedByName: $rejectedByName, rejectedDateTime: $rejectedDateTime, acknowledgeCancelBy: $acknowledgeCancelBy, acknowledgeCancelByName: $acknowledgeCancelByName, acknowledgeCancelDateTime: $acknowledgeCancelDateTime, createdDate: $createdDate, rejectRemarks: $rejectRemarks, medicineDetails: $medicineDetails, latestAudit: $latestAudit, student: $student)';
  }
}

/// @nodoc
abstract mixin class $MedicineFormFullVODtoCopyWith<$Res> {
  factory $MedicineFormFullVODtoCopyWith(MedicineFormFullVODto value,
          $Res Function(MedicineFormFullVODto) _then) =
      _$MedicineFormFullVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'applicationDate') DateTime? applicationDate,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'parentType') String? parentType,
      @JsonKey(name: 'parentEmail') String? parentEmail,
      @JsonKey(name: 'studentCourseId') String? studentCourseId,
      @JsonKey(name: 'administrationTime') String? administrationTime,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'medicineFormStatus') String? medicineFormStatus,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'createdByName') String? createdByName,
      @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
      @JsonKey(name: 'acknowledgedByName') String? acknowledgedByName,
      @JsonKey(name: 'acknowledgedDateTime') DateTime? acknowledgedDateTime,
      @JsonKey(name: 'rejectedBy') String? rejectedBy,
      @JsonKey(name: 'rejectedByName') String? rejectedByName,
      @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
      @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
      @JsonKey(name: 'acknowledgeCancelByName') String? acknowledgeCancelByName,
      @JsonKey(name: 'acknowledgeCancelDateTime')
      DateTime? acknowledgeCancelDateTime,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
      @JsonKey(name: 'medicineDetails')
      List<MedicineDetailsVODto>? medicineDetails,
      @JsonKey(name: 'latestAudit') MedicineAuditWithDetailVODto? latestAudit,
      @JsonKey(name: 'student') StudentBaseInfoVODto? student});

  $MedicineAuditWithDetailVODtoCopyWith<$Res>? get latestAudit;
  $StudentBaseInfoVODtoCopyWith<$Res>? get student;
}

/// @nodoc
class _$MedicineFormFullVODtoCopyWithImpl<$Res>
    implements $MedicineFormFullVODtoCopyWith<$Res> {
  _$MedicineFormFullVODtoCopyWithImpl(this._self, this._then);

  final MedicineFormFullVODto _self;
  final $Res Function(MedicineFormFullVODto) _then;

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? medicineFormId = freezed,
    Object? applicationDate = freezed,
    Object? studentId = freezed,
    Object? parentType = freezed,
    Object? parentEmail = freezed,
    Object? studentCourseId = freezed,
    Object? administrationTime = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? remarks = freezed,
    Object? medicineFormStatus = freezed,
    Object? createdBy = freezed,
    Object? createdByName = freezed,
    Object? acknowledgedBy = freezed,
    Object? acknowledgedByName = freezed,
    Object? acknowledgedDateTime = freezed,
    Object? rejectedBy = freezed,
    Object? rejectedByName = freezed,
    Object? rejectedDateTime = freezed,
    Object? acknowledgeCancelBy = freezed,
    Object? acknowledgeCancelByName = freezed,
    Object? acknowledgeCancelDateTime = freezed,
    Object? createdDate = freezed,
    Object? rejectRemarks = freezed,
    Object? medicineDetails = freezed,
    Object? latestAudit = freezed,
    Object? student = freezed,
  }) {
    return _then(_self.copyWith(
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      applicationDate: freezed == applicationDate
          ? _self.applicationDate
          : applicationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      parentType: freezed == parentType
          ? _self.parentType
          : parentType // ignore: cast_nullable_to_non_nullable
              as String?,
      parentEmail: freezed == parentEmail
          ? _self.parentEmail
          : parentEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      studentCourseId: freezed == studentCourseId
          ? _self.studentCourseId
          : studentCourseId // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationTime: freezed == administrationTime
          ? _self.administrationTime
          : administrationTime // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineFormStatus: freezed == medicineFormStatus
          ? _self.medicineFormStatus
          : medicineFormStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      createdByName: freezed == createdByName
          ? _self.createdByName
          : createdByName // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedBy: freezed == acknowledgedBy
          ? _self.acknowledgedBy
          : acknowledgedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedByName: freezed == acknowledgedByName
          ? _self.acknowledgedByName
          : acknowledgedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedDateTime: freezed == acknowledgedDateTime
          ? _self.acknowledgedDateTime
          : acknowledgedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      rejectedBy: freezed == rejectedBy
          ? _self.rejectedBy
          : rejectedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectedByName: freezed == rejectedByName
          ? _self.rejectedByName
          : rejectedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectedDateTime: freezed == rejectedDateTime
          ? _self.rejectedDateTime
          : rejectedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      acknowledgeCancelBy: freezed == acknowledgeCancelBy
          ? _self.acknowledgeCancelBy
          : acknowledgeCancelBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgeCancelByName: freezed == acknowledgeCancelByName
          ? _self.acknowledgeCancelByName
          : acknowledgeCancelByName // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgeCancelDateTime: freezed == acknowledgeCancelDateTime
          ? _self.acknowledgeCancelDateTime
          : acknowledgeCancelDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      rejectRemarks: freezed == rejectRemarks
          ? _self.rejectRemarks
          : rejectRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetails: freezed == medicineDetails
          ? _self.medicineDetails
          : medicineDetails // ignore: cast_nullable_to_non_nullable
              as List<MedicineDetailsVODto>?,
      latestAudit: freezed == latestAudit
          ? _self.latestAudit
          : latestAudit // ignore: cast_nullable_to_non_nullable
              as MedicineAuditWithDetailVODto?,
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentBaseInfoVODto?,
    ));
  }

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MedicineAuditWithDetailVODtoCopyWith<$Res>? get latestAudit {
    if (_self.latestAudit == null) {
      return null;
    }

    return $MedicineAuditWithDetailVODtoCopyWith<$Res>(_self.latestAudit!,
        (value) {
      return _then(_self.copyWith(latestAudit: value));
    });
  }

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentBaseInfoVODtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentBaseInfoVODtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }
}

/// Adds pattern-matching-related methods to [MedicineFormFullVODto].
extension MedicineFormFullVODtoPatterns on MedicineFormFullVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineFormFullVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineFormFullVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineFormFullVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'applicationDate') DateTime? applicationDate,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'parentType') String? parentType,
            @JsonKey(name: 'parentEmail') String? parentEmail,
            @JsonKey(name: 'studentCourseId') String? studentCourseId,
            @JsonKey(name: 'administrationTime') String? administrationTime,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineFormStatus') String? medicineFormStatus,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
            @JsonKey(name: 'acknowledgedByName') String? acknowledgedByName,
            @JsonKey(name: 'acknowledgedDateTime')
            DateTime? acknowledgedDateTime,
            @JsonKey(name: 'rejectedBy') String? rejectedBy,
            @JsonKey(name: 'rejectedByName') String? rejectedByName,
            @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
            @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
            @JsonKey(name: 'acknowledgeCancelByName')
            String? acknowledgeCancelByName,
            @JsonKey(name: 'acknowledgeCancelDateTime')
            DateTime? acknowledgeCancelDateTime,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
            @JsonKey(name: 'medicineDetails')
            List<MedicineDetailsVODto>? medicineDetails,
            @JsonKey(name: 'latestAudit')
            MedicineAuditWithDetailVODto? latestAudit,
            @JsonKey(name: 'student') StudentBaseInfoVODto? student)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVODto() when $default != null:
        return $default(
            _that.medicineFormId,
            _that.applicationDate,
            _that.studentId,
            _that.parentType,
            _that.parentEmail,
            _that.studentCourseId,
            _that.administrationTime,
            _that.startDate,
            _that.endDate,
            _that.remarks,
            _that.medicineFormStatus,
            _that.createdBy,
            _that.createdByName,
            _that.acknowledgedBy,
            _that.acknowledgedByName,
            _that.acknowledgedDateTime,
            _that.rejectedBy,
            _that.rejectedByName,
            _that.rejectedDateTime,
            _that.acknowledgeCancelBy,
            _that.acknowledgeCancelByName,
            _that.acknowledgeCancelDateTime,
            _that.createdDate,
            _that.rejectRemarks,
            _that.medicineDetails,
            _that.latestAudit,
            _that.student);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'applicationDate') DateTime? applicationDate,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'parentType') String? parentType,
            @JsonKey(name: 'parentEmail') String? parentEmail,
            @JsonKey(name: 'studentCourseId') String? studentCourseId,
            @JsonKey(name: 'administrationTime') String? administrationTime,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineFormStatus') String? medicineFormStatus,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
            @JsonKey(name: 'acknowledgedByName') String? acknowledgedByName,
            @JsonKey(name: 'acknowledgedDateTime')
            DateTime? acknowledgedDateTime,
            @JsonKey(name: 'rejectedBy') String? rejectedBy,
            @JsonKey(name: 'rejectedByName') String? rejectedByName,
            @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
            @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
            @JsonKey(name: 'acknowledgeCancelByName')
            String? acknowledgeCancelByName,
            @JsonKey(name: 'acknowledgeCancelDateTime')
            DateTime? acknowledgeCancelDateTime,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
            @JsonKey(name: 'medicineDetails')
            List<MedicineDetailsVODto>? medicineDetails,
            @JsonKey(name: 'latestAudit')
            MedicineAuditWithDetailVODto? latestAudit,
            @JsonKey(name: 'student') StudentBaseInfoVODto? student)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVODto():
        return $default(
            _that.medicineFormId,
            _that.applicationDate,
            _that.studentId,
            _that.parentType,
            _that.parentEmail,
            _that.studentCourseId,
            _that.administrationTime,
            _that.startDate,
            _that.endDate,
            _that.remarks,
            _that.medicineFormStatus,
            _that.createdBy,
            _that.createdByName,
            _that.acknowledgedBy,
            _that.acknowledgedByName,
            _that.acknowledgedDateTime,
            _that.rejectedBy,
            _that.rejectedByName,
            _that.rejectedDateTime,
            _that.acknowledgeCancelBy,
            _that.acknowledgeCancelByName,
            _that.acknowledgeCancelDateTime,
            _that.createdDate,
            _that.rejectRemarks,
            _that.medicineDetails,
            _that.latestAudit,
            _that.student);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'medicineFormId') int? medicineFormId,
            @JsonKey(name: 'applicationDate') DateTime? applicationDate,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'parentType') String? parentType,
            @JsonKey(name: 'parentEmail') String? parentEmail,
            @JsonKey(name: 'studentCourseId') String? studentCourseId,
            @JsonKey(name: 'administrationTime') String? administrationTime,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineFormStatus') String? medicineFormStatus,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
            @JsonKey(name: 'acknowledgedByName') String? acknowledgedByName,
            @JsonKey(name: 'acknowledgedDateTime')
            DateTime? acknowledgedDateTime,
            @JsonKey(name: 'rejectedBy') String? rejectedBy,
            @JsonKey(name: 'rejectedByName') String? rejectedByName,
            @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
            @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
            @JsonKey(name: 'acknowledgeCancelByName')
            String? acknowledgeCancelByName,
            @JsonKey(name: 'acknowledgeCancelDateTime')
            DateTime? acknowledgeCancelDateTime,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
            @JsonKey(name: 'medicineDetails')
            List<MedicineDetailsVODto>? medicineDetails,
            @JsonKey(name: 'latestAudit')
            MedicineAuditWithDetailVODto? latestAudit,
            @JsonKey(name: 'student') StudentBaseInfoVODto? student)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVODto() when $default != null:
        return $default(
            _that.medicineFormId,
            _that.applicationDate,
            _that.studentId,
            _that.parentType,
            _that.parentEmail,
            _that.studentCourseId,
            _that.administrationTime,
            _that.startDate,
            _that.endDate,
            _that.remarks,
            _that.medicineFormStatus,
            _that.createdBy,
            _that.createdByName,
            _that.acknowledgedBy,
            _that.acknowledgedByName,
            _that.acknowledgedDateTime,
            _that.rejectedBy,
            _that.rejectedByName,
            _that.rejectedDateTime,
            _that.acknowledgeCancelBy,
            _that.acknowledgeCancelByName,
            _that.acknowledgeCancelDateTime,
            _that.createdDate,
            _that.rejectRemarks,
            _that.medicineDetails,
            _that.latestAudit,
            _that.student);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineFormFullVODto implements MedicineFormFullVODto {
  _MedicineFormFullVODto(
      {@JsonKey(name: 'medicineFormId') this.medicineFormId,
      @JsonKey(name: 'applicationDate') this.applicationDate,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'parentType') this.parentType,
      @JsonKey(name: 'parentEmail') this.parentEmail,
      @JsonKey(name: 'studentCourseId') this.studentCourseId,
      @JsonKey(name: 'administrationTime') this.administrationTime,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'medicineFormStatus') this.medicineFormStatus,
      @JsonKey(name: 'createdBy') this.createdBy,
      @JsonKey(name: 'createdByName') this.createdByName,
      @JsonKey(name: 'acknowledgedBy') this.acknowledgedBy,
      @JsonKey(name: 'acknowledgedByName') this.acknowledgedByName,
      @JsonKey(name: 'acknowledgedDateTime') this.acknowledgedDateTime,
      @JsonKey(name: 'rejectedBy') this.rejectedBy,
      @JsonKey(name: 'rejectedByName') this.rejectedByName,
      @JsonKey(name: 'rejectedDateTime') this.rejectedDateTime,
      @JsonKey(name: 'acknowledgeCancelBy') this.acknowledgeCancelBy,
      @JsonKey(name: 'acknowledgeCancelByName') this.acknowledgeCancelByName,
      @JsonKey(name: 'acknowledgeCancelDateTime')
      this.acknowledgeCancelDateTime,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'rejectRemarks') this.rejectRemarks,
      @JsonKey(name: 'medicineDetails')
      final List<MedicineDetailsVODto>? medicineDetails,
      @JsonKey(name: 'latestAudit') this.latestAudit,
      @JsonKey(name: 'student') this.student})
      : _medicineDetails = medicineDetails;
  factory _MedicineFormFullVODto.fromJson(Map<String, dynamic> json) =>
      _$MedicineFormFullVODtoFromJson(json);

  @override
  @JsonKey(name: 'medicineFormId')
  final int? medicineFormId;
  @override
  @JsonKey(name: 'applicationDate')
  final DateTime? applicationDate;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'parentType')
  final String? parentType;
  @override
  @JsonKey(name: 'parentEmail')
  final String? parentEmail;
  @override
  @JsonKey(name: 'studentCourseId')
  final String? studentCourseId;
  @override
  @JsonKey(name: 'administrationTime')
  final String? administrationTime;
  @override
  @JsonKey(name: 'startDate')
  final DateTime? startDate;
  @override
  @JsonKey(name: 'endDate')
  final DateTime? endDate;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'medicineFormStatus')
  final String? medicineFormStatus;
  @override
  @JsonKey(name: 'createdBy')
  final String? createdBy;
  @override
  @JsonKey(name: 'createdByName')
  final String? createdByName;
  @override
  @JsonKey(name: 'acknowledgedBy')
  final String? acknowledgedBy;
  @override
  @JsonKey(name: 'acknowledgedByName')
  final String? acknowledgedByName;
  @override
  @JsonKey(name: 'acknowledgedDateTime')
  final DateTime? acknowledgedDateTime;
  @override
  @JsonKey(name: 'rejectedBy')
  final String? rejectedBy;
  @override
  @JsonKey(name: 'rejectedByName')
  final String? rejectedByName;
  @override
  @JsonKey(name: 'rejectedDateTime')
  final DateTime? rejectedDateTime;
  @override
  @JsonKey(name: 'acknowledgeCancelBy')
  final String? acknowledgeCancelBy;
  @override
  @JsonKey(name: 'acknowledgeCancelByName')
  final String? acknowledgeCancelByName;
  @override
  @JsonKey(name: 'acknowledgeCancelDateTime')
  final DateTime? acknowledgeCancelDateTime;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'rejectRemarks')
  final String? rejectRemarks;
  final List<MedicineDetailsVODto>? _medicineDetails;
  @override
  @JsonKey(name: 'medicineDetails')
  List<MedicineDetailsVODto>? get medicineDetails {
    final value = _medicineDetails;
    if (value == null) return null;
    if (_medicineDetails is EqualUnmodifiableListView) return _medicineDetails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'latestAudit')
  final MedicineAuditWithDetailVODto? latestAudit;
  @override
  @JsonKey(name: 'student')
  final StudentBaseInfoVODto? student;

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineFormFullVODtoCopyWith<_MedicineFormFullVODto> get copyWith =>
      __$MedicineFormFullVODtoCopyWithImpl<_MedicineFormFullVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineFormFullVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineFormFullVODto &&
            (identical(other.medicineFormId, medicineFormId) ||
                other.medicineFormId == medicineFormId) &&
            (identical(other.applicationDate, applicationDate) ||
                other.applicationDate == applicationDate) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.parentType, parentType) ||
                other.parentType == parentType) &&
            (identical(other.parentEmail, parentEmail) ||
                other.parentEmail == parentEmail) &&
            (identical(other.studentCourseId, studentCourseId) ||
                other.studentCourseId == studentCourseId) &&
            (identical(other.administrationTime, administrationTime) ||
                other.administrationTime == administrationTime) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.medicineFormStatus, medicineFormStatus) ||
                other.medicineFormStatus == medicineFormStatus) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.createdByName, createdByName) ||
                other.createdByName == createdByName) &&
            (identical(other.acknowledgedBy, acknowledgedBy) ||
                other.acknowledgedBy == acknowledgedBy) &&
            (identical(other.acknowledgedByName, acknowledgedByName) ||
                other.acknowledgedByName == acknowledgedByName) &&
            (identical(other.acknowledgedDateTime, acknowledgedDateTime) ||
                other.acknowledgedDateTime == acknowledgedDateTime) &&
            (identical(other.rejectedBy, rejectedBy) ||
                other.rejectedBy == rejectedBy) &&
            (identical(other.rejectedByName, rejectedByName) ||
                other.rejectedByName == rejectedByName) &&
            (identical(other.rejectedDateTime, rejectedDateTime) ||
                other.rejectedDateTime == rejectedDateTime) &&
            (identical(other.acknowledgeCancelBy, acknowledgeCancelBy) ||
                other.acknowledgeCancelBy == acknowledgeCancelBy) &&
            (identical(
                    other.acknowledgeCancelByName, acknowledgeCancelByName) ||
                other.acknowledgeCancelByName == acknowledgeCancelByName) &&
            (identical(other.acknowledgeCancelDateTime,
                    acknowledgeCancelDateTime) ||
                other.acknowledgeCancelDateTime == acknowledgeCancelDateTime) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.rejectRemarks, rejectRemarks) ||
                other.rejectRemarks == rejectRemarks) &&
            const DeepCollectionEquality()
                .equals(other._medicineDetails, _medicineDetails) &&
            (identical(other.latestAudit, latestAudit) ||
                other.latestAudit == latestAudit) &&
            (identical(other.student, student) || other.student == student));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        medicineFormId,
        applicationDate,
        studentId,
        parentType,
        parentEmail,
        studentCourseId,
        administrationTime,
        startDate,
        endDate,
        remarks,
        medicineFormStatus,
        createdBy,
        createdByName,
        acknowledgedBy,
        acknowledgedByName,
        acknowledgedDateTime,
        rejectedBy,
        rejectedByName,
        rejectedDateTime,
        acknowledgeCancelBy,
        acknowledgeCancelByName,
        acknowledgeCancelDateTime,
        createdDate,
        rejectRemarks,
        const DeepCollectionEquality().hash(_medicineDetails),
        latestAudit,
        student
      ]);

  @override
  String toString() {
    return 'MedicineFormFullVODto(medicineFormId: $medicineFormId, applicationDate: $applicationDate, studentId: $studentId, parentType: $parentType, parentEmail: $parentEmail, studentCourseId: $studentCourseId, administrationTime: $administrationTime, startDate: $startDate, endDate: $endDate, remarks: $remarks, medicineFormStatus: $medicineFormStatus, createdBy: $createdBy, createdByName: $createdByName, acknowledgedBy: $acknowledgedBy, acknowledgedByName: $acknowledgedByName, acknowledgedDateTime: $acknowledgedDateTime, rejectedBy: $rejectedBy, rejectedByName: $rejectedByName, rejectedDateTime: $rejectedDateTime, acknowledgeCancelBy: $acknowledgeCancelBy, acknowledgeCancelByName: $acknowledgeCancelByName, acknowledgeCancelDateTime: $acknowledgeCancelDateTime, createdDate: $createdDate, rejectRemarks: $rejectRemarks, medicineDetails: $medicineDetails, latestAudit: $latestAudit, student: $student)';
  }
}

/// @nodoc
abstract mixin class _$MedicineFormFullVODtoCopyWith<$Res>
    implements $MedicineFormFullVODtoCopyWith<$Res> {
  factory _$MedicineFormFullVODtoCopyWith(_MedicineFormFullVODto value,
          $Res Function(_MedicineFormFullVODto) _then) =
      __$MedicineFormFullVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'medicineFormId') int? medicineFormId,
      @JsonKey(name: 'applicationDate') DateTime? applicationDate,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'parentType') String? parentType,
      @JsonKey(name: 'parentEmail') String? parentEmail,
      @JsonKey(name: 'studentCourseId') String? studentCourseId,
      @JsonKey(name: 'administrationTime') String? administrationTime,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'medicineFormStatus') String? medicineFormStatus,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'createdByName') String? createdByName,
      @JsonKey(name: 'acknowledgedBy') String? acknowledgedBy,
      @JsonKey(name: 'acknowledgedByName') String? acknowledgedByName,
      @JsonKey(name: 'acknowledgedDateTime') DateTime? acknowledgedDateTime,
      @JsonKey(name: 'rejectedBy') String? rejectedBy,
      @JsonKey(name: 'rejectedByName') String? rejectedByName,
      @JsonKey(name: 'rejectedDateTime') DateTime? rejectedDateTime,
      @JsonKey(name: 'acknowledgeCancelBy') String? acknowledgeCancelBy,
      @JsonKey(name: 'acknowledgeCancelByName') String? acknowledgeCancelByName,
      @JsonKey(name: 'acknowledgeCancelDateTime')
      DateTime? acknowledgeCancelDateTime,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'rejectRemarks') String? rejectRemarks,
      @JsonKey(name: 'medicineDetails')
      List<MedicineDetailsVODto>? medicineDetails,
      @JsonKey(name: 'latestAudit') MedicineAuditWithDetailVODto? latestAudit,
      @JsonKey(name: 'student') StudentBaseInfoVODto? student});

  @override
  $MedicineAuditWithDetailVODtoCopyWith<$Res>? get latestAudit;
  @override
  $StudentBaseInfoVODtoCopyWith<$Res>? get student;
}

/// @nodoc
class __$MedicineFormFullVODtoCopyWithImpl<$Res>
    implements _$MedicineFormFullVODtoCopyWith<$Res> {
  __$MedicineFormFullVODtoCopyWithImpl(this._self, this._then);

  final _MedicineFormFullVODto _self;
  final $Res Function(_MedicineFormFullVODto) _then;

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? medicineFormId = freezed,
    Object? applicationDate = freezed,
    Object? studentId = freezed,
    Object? parentType = freezed,
    Object? parentEmail = freezed,
    Object? studentCourseId = freezed,
    Object? administrationTime = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? remarks = freezed,
    Object? medicineFormStatus = freezed,
    Object? createdBy = freezed,
    Object? createdByName = freezed,
    Object? acknowledgedBy = freezed,
    Object? acknowledgedByName = freezed,
    Object? acknowledgedDateTime = freezed,
    Object? rejectedBy = freezed,
    Object? rejectedByName = freezed,
    Object? rejectedDateTime = freezed,
    Object? acknowledgeCancelBy = freezed,
    Object? acknowledgeCancelByName = freezed,
    Object? acknowledgeCancelDateTime = freezed,
    Object? createdDate = freezed,
    Object? rejectRemarks = freezed,
    Object? medicineDetails = freezed,
    Object? latestAudit = freezed,
    Object? student = freezed,
  }) {
    return _then(_MedicineFormFullVODto(
      medicineFormId: freezed == medicineFormId
          ? _self.medicineFormId
          : medicineFormId // ignore: cast_nullable_to_non_nullable
              as int?,
      applicationDate: freezed == applicationDate
          ? _self.applicationDate
          : applicationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      parentType: freezed == parentType
          ? _self.parentType
          : parentType // ignore: cast_nullable_to_non_nullable
              as String?,
      parentEmail: freezed == parentEmail
          ? _self.parentEmail
          : parentEmail // ignore: cast_nullable_to_non_nullable
              as String?,
      studentCourseId: freezed == studentCourseId
          ? _self.studentCourseId
          : studentCourseId // ignore: cast_nullable_to_non_nullable
              as String?,
      administrationTime: freezed == administrationTime
          ? _self.administrationTime
          : administrationTime // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineFormStatus: freezed == medicineFormStatus
          ? _self.medicineFormStatus
          : medicineFormStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      createdByName: freezed == createdByName
          ? _self.createdByName
          : createdByName // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedBy: freezed == acknowledgedBy
          ? _self.acknowledgedBy
          : acknowledgedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedByName: freezed == acknowledgedByName
          ? _self.acknowledgedByName
          : acknowledgedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgedDateTime: freezed == acknowledgedDateTime
          ? _self.acknowledgedDateTime
          : acknowledgedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      rejectedBy: freezed == rejectedBy
          ? _self.rejectedBy
          : rejectedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectedByName: freezed == rejectedByName
          ? _self.rejectedByName
          : rejectedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      rejectedDateTime: freezed == rejectedDateTime
          ? _self.rejectedDateTime
          : rejectedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      acknowledgeCancelBy: freezed == acknowledgeCancelBy
          ? _self.acknowledgeCancelBy
          : acknowledgeCancelBy // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgeCancelByName: freezed == acknowledgeCancelByName
          ? _self.acknowledgeCancelByName
          : acknowledgeCancelByName // ignore: cast_nullable_to_non_nullable
              as String?,
      acknowledgeCancelDateTime: freezed == acknowledgeCancelDateTime
          ? _self.acknowledgeCancelDateTime
          : acknowledgeCancelDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      rejectRemarks: freezed == rejectRemarks
          ? _self.rejectRemarks
          : rejectRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetails: freezed == medicineDetails
          ? _self._medicineDetails
          : medicineDetails // ignore: cast_nullable_to_non_nullable
              as List<MedicineDetailsVODto>?,
      latestAudit: freezed == latestAudit
          ? _self.latestAudit
          : latestAudit // ignore: cast_nullable_to_non_nullable
              as MedicineAuditWithDetailVODto?,
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentBaseInfoVODto?,
    ));
  }

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MedicineAuditWithDetailVODtoCopyWith<$Res>? get latestAudit {
    if (_self.latestAudit == null) {
      return null;
    }

    return $MedicineAuditWithDetailVODtoCopyWith<$Res>(_self.latestAudit!,
        (value) {
      return _then(_self.copyWith(latestAudit: value));
    });
  }

  /// Create a copy of MedicineFormFullVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentBaseInfoVODtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentBaseInfoVODtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }
}

/// @nodoc
mixin _$MedicineFormFullVOPaginationDto {
  @JsonKey(name: 'items')
  List<MedicineFormFullVODto>? get items;
  @JsonKey(name: 'totalRecords')
  int? get totalRecords;
  @JsonKey(name: 'currentPage')
  int? get currentPage;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalPages')
  int? get totalPages;
  @JsonKey(name: 'hasNext')
  bool? get hasNext;
  @JsonKey(name: 'hasPrevious')
  bool? get hasPrevious;

  /// Create a copy of MedicineFormFullVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineFormFullVOPaginationDtoCopyWith<MedicineFormFullVOPaginationDto>
      get copyWith => _$MedicineFormFullVOPaginationDtoCopyWithImpl<
              MedicineFormFullVOPaginationDto>(
          this as MedicineFormFullVOPaginationDto, _$identity);

  /// Serializes this MedicineFormFullVOPaginationDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineFormFullVOPaginationDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.totalRecords, totalRecords) ||
                other.totalRecords == totalRecords) &&
            (identical(other.currentPage, currentPage) ||
                other.currentPage == currentPage) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.hasNext, hasNext) || other.hasNext == hasNext) &&
            (identical(other.hasPrevious, hasPrevious) ||
                other.hasPrevious == hasPrevious));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      totalRecords,
      currentPage,
      pageSize,
      totalPages,
      hasNext,
      hasPrevious);

  @override
  String toString() {
    return 'MedicineFormFullVOPaginationDto(items: $items, totalRecords: $totalRecords, currentPage: $currentPage, pageSize: $pageSize, totalPages: $totalPages, hasNext: $hasNext, hasPrevious: $hasPrevious)';
  }
}

/// @nodoc
abstract mixin class $MedicineFormFullVOPaginationDtoCopyWith<$Res> {
  factory $MedicineFormFullVOPaginationDtoCopyWith(
          MedicineFormFullVOPaginationDto value,
          $Res Function(MedicineFormFullVOPaginationDto) _then) =
      _$MedicineFormFullVOPaginationDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<MedicineFormFullVODto>? items,
      @JsonKey(name: 'totalRecords') int? totalRecords,
      @JsonKey(name: 'currentPage') int? currentPage,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalPages') int? totalPages,
      @JsonKey(name: 'hasNext') bool? hasNext,
      @JsonKey(name: 'hasPrevious') bool? hasPrevious});
}

/// @nodoc
class _$MedicineFormFullVOPaginationDtoCopyWithImpl<$Res>
    implements $MedicineFormFullVOPaginationDtoCopyWith<$Res> {
  _$MedicineFormFullVOPaginationDtoCopyWithImpl(this._self, this._then);

  final MedicineFormFullVOPaginationDto _self;
  final $Res Function(MedicineFormFullVOPaginationDto) _then;

  /// Create a copy of MedicineFormFullVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? totalRecords = freezed,
    Object? currentPage = freezed,
    Object? pageSize = freezed,
    Object? totalPages = freezed,
    Object? hasNext = freezed,
    Object? hasPrevious = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<MedicineFormFullVODto>?,
      totalRecords: freezed == totalRecords
          ? _self.totalRecords
          : totalRecords // ignore: cast_nullable_to_non_nullable
              as int?,
      currentPage: freezed == currentPage
          ? _self.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNext: freezed == hasNext
          ? _self.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPrevious: freezed == hasPrevious
          ? _self.hasPrevious
          : hasPrevious // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineFormFullVOPaginationDto].
extension MedicineFormFullVOPaginationDtoPatterns
    on MedicineFormFullVOPaginationDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineFormFullVOPaginationDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVOPaginationDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineFormFullVOPaginationDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVOPaginationDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineFormFullVOPaginationDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVOPaginationDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<MedicineFormFullVODto>? items,
            @JsonKey(name: 'totalRecords') int? totalRecords,
            @JsonKey(name: 'currentPage') int? currentPage,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalPages') int? totalPages,
            @JsonKey(name: 'hasNext') bool? hasNext,
            @JsonKey(name: 'hasPrevious') bool? hasPrevious)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVOPaginationDto() when $default != null:
        return $default(_that.items, _that.totalRecords, _that.currentPage,
            _that.pageSize, _that.totalPages, _that.hasNext, _that.hasPrevious);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<MedicineFormFullVODto>? items,
            @JsonKey(name: 'totalRecords') int? totalRecords,
            @JsonKey(name: 'currentPage') int? currentPage,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalPages') int? totalPages,
            @JsonKey(name: 'hasNext') bool? hasNext,
            @JsonKey(name: 'hasPrevious') bool? hasPrevious)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVOPaginationDto():
        return $default(_that.items, _that.totalRecords, _that.currentPage,
            _that.pageSize, _that.totalPages, _that.hasNext, _that.hasPrevious);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<MedicineFormFullVODto>? items,
            @JsonKey(name: 'totalRecords') int? totalRecords,
            @JsonKey(name: 'currentPage') int? currentPage,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalPages') int? totalPages,
            @JsonKey(name: 'hasNext') bool? hasNext,
            @JsonKey(name: 'hasPrevious') bool? hasPrevious)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormFullVOPaginationDto() when $default != null:
        return $default(_that.items, _that.totalRecords, _that.currentPage,
            _that.pageSize, _that.totalPages, _that.hasNext, _that.hasPrevious);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineFormFullVOPaginationDto
    implements MedicineFormFullVOPaginationDto {
  _MedicineFormFullVOPaginationDto(
      {@JsonKey(name: 'items') final List<MedicineFormFullVODto>? items,
      @JsonKey(name: 'totalRecords') this.totalRecords,
      @JsonKey(name: 'currentPage') this.currentPage,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalPages') this.totalPages,
      @JsonKey(name: 'hasNext') this.hasNext,
      @JsonKey(name: 'hasPrevious') this.hasPrevious})
      : _items = items;
  factory _MedicineFormFullVOPaginationDto.fromJson(
          Map<String, dynamic> json) =>
      _$MedicineFormFullVOPaginationDtoFromJson(json);

  final List<MedicineFormFullVODto>? _items;
  @override
  @JsonKey(name: 'items')
  List<MedicineFormFullVODto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'totalRecords')
  final int? totalRecords;
  @override
  @JsonKey(name: 'currentPage')
  final int? currentPage;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;
  @override
  @JsonKey(name: 'hasNext')
  final bool? hasNext;
  @override
  @JsonKey(name: 'hasPrevious')
  final bool? hasPrevious;

  /// Create a copy of MedicineFormFullVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineFormFullVOPaginationDtoCopyWith<_MedicineFormFullVOPaginationDto>
      get copyWith => __$MedicineFormFullVOPaginationDtoCopyWithImpl<
          _MedicineFormFullVOPaginationDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineFormFullVOPaginationDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineFormFullVOPaginationDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.totalRecords, totalRecords) ||
                other.totalRecords == totalRecords) &&
            (identical(other.currentPage, currentPage) ||
                other.currentPage == currentPage) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.hasNext, hasNext) || other.hasNext == hasNext) &&
            (identical(other.hasPrevious, hasPrevious) ||
                other.hasPrevious == hasPrevious));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      totalRecords,
      currentPage,
      pageSize,
      totalPages,
      hasNext,
      hasPrevious);

  @override
  String toString() {
    return 'MedicineFormFullVOPaginationDto(items: $items, totalRecords: $totalRecords, currentPage: $currentPage, pageSize: $pageSize, totalPages: $totalPages, hasNext: $hasNext, hasPrevious: $hasPrevious)';
  }
}

/// @nodoc
abstract mixin class _$MedicineFormFullVOPaginationDtoCopyWith<$Res>
    implements $MedicineFormFullVOPaginationDtoCopyWith<$Res> {
  factory _$MedicineFormFullVOPaginationDtoCopyWith(
          _MedicineFormFullVOPaginationDto value,
          $Res Function(_MedicineFormFullVOPaginationDto) _then) =
      __$MedicineFormFullVOPaginationDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<MedicineFormFullVODto>? items,
      @JsonKey(name: 'totalRecords') int? totalRecords,
      @JsonKey(name: 'currentPage') int? currentPage,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalPages') int? totalPages,
      @JsonKey(name: 'hasNext') bool? hasNext,
      @JsonKey(name: 'hasPrevious') bool? hasPrevious});
}

/// @nodoc
class __$MedicineFormFullVOPaginationDtoCopyWithImpl<$Res>
    implements _$MedicineFormFullVOPaginationDtoCopyWith<$Res> {
  __$MedicineFormFullVOPaginationDtoCopyWithImpl(this._self, this._then);

  final _MedicineFormFullVOPaginationDto _self;
  final $Res Function(_MedicineFormFullVOPaginationDto) _then;

  /// Create a copy of MedicineFormFullVOPaginationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? totalRecords = freezed,
    Object? currentPage = freezed,
    Object? pageSize = freezed,
    Object? totalPages = freezed,
    Object? hasNext = freezed,
    Object? hasPrevious = freezed,
  }) {
    return _then(_MedicineFormFullVOPaginationDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<MedicineFormFullVODto>?,
      totalRecords: freezed == totalRecords
          ? _self.totalRecords
          : totalRecords // ignore: cast_nullable_to_non_nullable
              as int?,
      currentPage: freezed == currentPage
          ? _self.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNext: freezed == hasNext
          ? _self.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPrevious: freezed == hasPrevious
          ? _self.hasPrevious
          : hasPrevious // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$MedicineFormRejectDto {
  @JsonKey(name: 'remarks')
  String? get remarks;

  /// Create a copy of MedicineFormRejectDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineFormRejectDtoCopyWith<MedicineFormRejectDto> get copyWith =>
      _$MedicineFormRejectDtoCopyWithImpl<MedicineFormRejectDto>(
          this as MedicineFormRejectDto, _$identity);

  /// Serializes this MedicineFormRejectDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineFormRejectDto &&
            (identical(other.remarks, remarks) || other.remarks == remarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, remarks);

  @override
  String toString() {
    return 'MedicineFormRejectDto(remarks: $remarks)';
  }
}

/// @nodoc
abstract mixin class $MedicineFormRejectDtoCopyWith<$Res> {
  factory $MedicineFormRejectDtoCopyWith(MedicineFormRejectDto value,
          $Res Function(MedicineFormRejectDto) _then) =
      _$MedicineFormRejectDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'remarks') String? remarks});
}

/// @nodoc
class _$MedicineFormRejectDtoCopyWithImpl<$Res>
    implements $MedicineFormRejectDtoCopyWith<$Res> {
  _$MedicineFormRejectDtoCopyWithImpl(this._self, this._then);

  final MedicineFormRejectDto _self;
  final $Res Function(MedicineFormRejectDto) _then;

  /// Create a copy of MedicineFormRejectDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? remarks = freezed,
  }) {
    return _then(_self.copyWith(
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineFormRejectDto].
extension MedicineFormRejectDtoPatterns on MedicineFormRejectDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineFormRejectDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormRejectDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineFormRejectDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormRejectDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineFormRejectDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormRejectDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'remarks') String? remarks)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormRejectDto() when $default != null:
        return $default(_that.remarks);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'remarks') String? remarks) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormRejectDto():
        return $default(_that.remarks);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'remarks') String? remarks)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormRejectDto() when $default != null:
        return $default(_that.remarks);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineFormRejectDto implements MedicineFormRejectDto {
  _MedicineFormRejectDto({@JsonKey(name: 'remarks') this.remarks});
  factory _MedicineFormRejectDto.fromJson(Map<String, dynamic> json) =>
      _$MedicineFormRejectDtoFromJson(json);

  @override
  @JsonKey(name: 'remarks')
  final String? remarks;

  /// Create a copy of MedicineFormRejectDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineFormRejectDtoCopyWith<_MedicineFormRejectDto> get copyWith =>
      __$MedicineFormRejectDtoCopyWithImpl<_MedicineFormRejectDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineFormRejectDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineFormRejectDto &&
            (identical(other.remarks, remarks) || other.remarks == remarks));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, remarks);

  @override
  String toString() {
    return 'MedicineFormRejectDto(remarks: $remarks)';
  }
}

/// @nodoc
abstract mixin class _$MedicineFormRejectDtoCopyWith<$Res>
    implements $MedicineFormRejectDtoCopyWith<$Res> {
  factory _$MedicineFormRejectDtoCopyWith(_MedicineFormRejectDto value,
          $Res Function(_MedicineFormRejectDto) _then) =
      __$MedicineFormRejectDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'remarks') String? remarks});
}

/// @nodoc
class __$MedicineFormRejectDtoCopyWithImpl<$Res>
    implements _$MedicineFormRejectDtoCopyWith<$Res> {
  __$MedicineFormRejectDtoCopyWithImpl(this._self, this._then);

  final _MedicineFormRejectDto _self;
  final $Res Function(_MedicineFormRejectDto) _then;

  /// Create a copy of MedicineFormRejectDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? remarks = freezed,
  }) {
    return _then(_MedicineFormRejectDto(
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$MedicineFormSchoolConfigVODto {
  @JsonKey(name: 'medicationEnable')
  bool? get medicationEnable;
  @JsonKey(name: 'medicationTakePhotoEnable')
  bool? get medicationTakePhotoEnable;
  @JsonKey(name: 'medicationAcceptDays')
  int? get medicationAcceptDays;
  @JsonKey(name: 'medicationAllowBeforeHour')
  int? get medicationAllowBeforeHour;

  /// Create a copy of MedicineFormSchoolConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineFormSchoolConfigVODtoCopyWith<MedicineFormSchoolConfigVODto>
      get copyWith => _$MedicineFormSchoolConfigVODtoCopyWithImpl<
              MedicineFormSchoolConfigVODto>(
          this as MedicineFormSchoolConfigVODto, _$identity);

  /// Serializes this MedicineFormSchoolConfigVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineFormSchoolConfigVODto &&
            (identical(other.medicationEnable, medicationEnable) ||
                other.medicationEnable == medicationEnable) &&
            (identical(other.medicationTakePhotoEnable,
                    medicationTakePhotoEnable) ||
                other.medicationTakePhotoEnable == medicationTakePhotoEnable) &&
            (identical(other.medicationAcceptDays, medicationAcceptDays) ||
                other.medicationAcceptDays == medicationAcceptDays) &&
            (identical(other.medicationAllowBeforeHour,
                    medicationAllowBeforeHour) ||
                other.medicationAllowBeforeHour == medicationAllowBeforeHour));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      medicationEnable,
      medicationTakePhotoEnable,
      medicationAcceptDays,
      medicationAllowBeforeHour);

  @override
  String toString() {
    return 'MedicineFormSchoolConfigVODto(medicationEnable: $medicationEnable, medicationTakePhotoEnable: $medicationTakePhotoEnable, medicationAcceptDays: $medicationAcceptDays, medicationAllowBeforeHour: $medicationAllowBeforeHour)';
  }
}

/// @nodoc
abstract mixin class $MedicineFormSchoolConfigVODtoCopyWith<$Res> {
  factory $MedicineFormSchoolConfigVODtoCopyWith(
          MedicineFormSchoolConfigVODto value,
          $Res Function(MedicineFormSchoolConfigVODto) _then) =
      _$MedicineFormSchoolConfigVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'medicationEnable') bool? medicationEnable,
      @JsonKey(name: 'medicationTakePhotoEnable')
      bool? medicationTakePhotoEnable,
      @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
      @JsonKey(name: 'medicationAllowBeforeHour')
      int? medicationAllowBeforeHour});
}

/// @nodoc
class _$MedicineFormSchoolConfigVODtoCopyWithImpl<$Res>
    implements $MedicineFormSchoolConfigVODtoCopyWith<$Res> {
  _$MedicineFormSchoolConfigVODtoCopyWithImpl(this._self, this._then);

  final MedicineFormSchoolConfigVODto _self;
  final $Res Function(MedicineFormSchoolConfigVODto) _then;

  /// Create a copy of MedicineFormSchoolConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? medicationEnable = freezed,
    Object? medicationTakePhotoEnable = freezed,
    Object? medicationAcceptDays = freezed,
    Object? medicationAllowBeforeHour = freezed,
  }) {
    return _then(_self.copyWith(
      medicationEnable: freezed == medicationEnable
          ? _self.medicationEnable
          : medicationEnable // ignore: cast_nullable_to_non_nullable
              as bool?,
      medicationTakePhotoEnable: freezed == medicationTakePhotoEnable
          ? _self.medicationTakePhotoEnable
          : medicationTakePhotoEnable // ignore: cast_nullable_to_non_nullable
              as bool?,
      medicationAcceptDays: freezed == medicationAcceptDays
          ? _self.medicationAcceptDays
          : medicationAcceptDays // ignore: cast_nullable_to_non_nullable
              as int?,
      medicationAllowBeforeHour: freezed == medicationAllowBeforeHour
          ? _self.medicationAllowBeforeHour
          : medicationAllowBeforeHour // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineFormSchoolConfigVODto].
extension MedicineFormSchoolConfigVODtoPatterns
    on MedicineFormSchoolConfigVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineFormSchoolConfigVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormSchoolConfigVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineFormSchoolConfigVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormSchoolConfigVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineFormSchoolConfigVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormSchoolConfigVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicationEnable') bool? medicationEnable,
            @JsonKey(name: 'medicationTakePhotoEnable')
            bool? medicationTakePhotoEnable,
            @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
            @JsonKey(name: 'medicationAllowBeforeHour')
            int? medicationAllowBeforeHour)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormSchoolConfigVODto() when $default != null:
        return $default(_that.medicationEnable, _that.medicationTakePhotoEnable,
            _that.medicationAcceptDays, _that.medicationAllowBeforeHour);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'medicationEnable') bool? medicationEnable,
            @JsonKey(name: 'medicationTakePhotoEnable')
            bool? medicationTakePhotoEnable,
            @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
            @JsonKey(name: 'medicationAllowBeforeHour')
            int? medicationAllowBeforeHour)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormSchoolConfigVODto():
        return $default(_that.medicationEnable, _that.medicationTakePhotoEnable,
            _that.medicationAcceptDays, _that.medicationAllowBeforeHour);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'medicationEnable') bool? medicationEnable,
            @JsonKey(name: 'medicationTakePhotoEnable')
            bool? medicationTakePhotoEnable,
            @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
            @JsonKey(name: 'medicationAllowBeforeHour')
            int? medicationAllowBeforeHour)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormSchoolConfigVODto() when $default != null:
        return $default(_that.medicationEnable, _that.medicationTakePhotoEnable,
            _that.medicationAcceptDays, _that.medicationAllowBeforeHour);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineFormSchoolConfigVODto implements MedicineFormSchoolConfigVODto {
  _MedicineFormSchoolConfigVODto(
      {@JsonKey(name: 'medicationEnable') this.medicationEnable,
      @JsonKey(name: 'medicationTakePhotoEnable')
      this.medicationTakePhotoEnable,
      @JsonKey(name: 'medicationAcceptDays') this.medicationAcceptDays,
      @JsonKey(name: 'medicationAllowBeforeHour')
      this.medicationAllowBeforeHour});
  factory _MedicineFormSchoolConfigVODto.fromJson(Map<String, dynamic> json) =>
      _$MedicineFormSchoolConfigVODtoFromJson(json);

  @override
  @JsonKey(name: 'medicationEnable')
  final bool? medicationEnable;
  @override
  @JsonKey(name: 'medicationTakePhotoEnable')
  final bool? medicationTakePhotoEnable;
  @override
  @JsonKey(name: 'medicationAcceptDays')
  final int? medicationAcceptDays;
  @override
  @JsonKey(name: 'medicationAllowBeforeHour')
  final int? medicationAllowBeforeHour;

  /// Create a copy of MedicineFormSchoolConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineFormSchoolConfigVODtoCopyWith<_MedicineFormSchoolConfigVODto>
      get copyWith => __$MedicineFormSchoolConfigVODtoCopyWithImpl<
          _MedicineFormSchoolConfigVODto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineFormSchoolConfigVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineFormSchoolConfigVODto &&
            (identical(other.medicationEnable, medicationEnable) ||
                other.medicationEnable == medicationEnable) &&
            (identical(other.medicationTakePhotoEnable,
                    medicationTakePhotoEnable) ||
                other.medicationTakePhotoEnable == medicationTakePhotoEnable) &&
            (identical(other.medicationAcceptDays, medicationAcceptDays) ||
                other.medicationAcceptDays == medicationAcceptDays) &&
            (identical(other.medicationAllowBeforeHour,
                    medicationAllowBeforeHour) ||
                other.medicationAllowBeforeHour == medicationAllowBeforeHour));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      medicationEnable,
      medicationTakePhotoEnable,
      medicationAcceptDays,
      medicationAllowBeforeHour);

  @override
  String toString() {
    return 'MedicineFormSchoolConfigVODto(medicationEnable: $medicationEnable, medicationTakePhotoEnable: $medicationTakePhotoEnable, medicationAcceptDays: $medicationAcceptDays, medicationAllowBeforeHour: $medicationAllowBeforeHour)';
  }
}

/// @nodoc
abstract mixin class _$MedicineFormSchoolConfigVODtoCopyWith<$Res>
    implements $MedicineFormSchoolConfigVODtoCopyWith<$Res> {
  factory _$MedicineFormSchoolConfigVODtoCopyWith(
          _MedicineFormSchoolConfigVODto value,
          $Res Function(_MedicineFormSchoolConfigVODto) _then) =
      __$MedicineFormSchoolConfigVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'medicationEnable') bool? medicationEnable,
      @JsonKey(name: 'medicationTakePhotoEnable')
      bool? medicationTakePhotoEnable,
      @JsonKey(name: 'medicationAcceptDays') int? medicationAcceptDays,
      @JsonKey(name: 'medicationAllowBeforeHour')
      int? medicationAllowBeforeHour});
}

/// @nodoc
class __$MedicineFormSchoolConfigVODtoCopyWithImpl<$Res>
    implements _$MedicineFormSchoolConfigVODtoCopyWith<$Res> {
  __$MedicineFormSchoolConfigVODtoCopyWithImpl(this._self, this._then);

  final _MedicineFormSchoolConfigVODto _self;
  final $Res Function(_MedicineFormSchoolConfigVODto) _then;

  /// Create a copy of MedicineFormSchoolConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? medicationEnable = freezed,
    Object? medicationTakePhotoEnable = freezed,
    Object? medicationAcceptDays = freezed,
    Object? medicationAllowBeforeHour = freezed,
  }) {
    return _then(_MedicineFormSchoolConfigVODto(
      medicationEnable: freezed == medicationEnable
          ? _self.medicationEnable
          : medicationEnable // ignore: cast_nullable_to_non_nullable
              as bool?,
      medicationTakePhotoEnable: freezed == medicationTakePhotoEnable
          ? _self.medicationTakePhotoEnable
          : medicationTakePhotoEnable // ignore: cast_nullable_to_non_nullable
              as bool?,
      medicationAcceptDays: freezed == medicationAcceptDays
          ? _self.medicationAcceptDays
          : medicationAcceptDays // ignore: cast_nullable_to_non_nullable
              as int?,
      medicationAllowBeforeHour: freezed == medicationAllowBeforeHour
          ? _self.medicationAllowBeforeHour
          : medicationAllowBeforeHour // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$MedicineFormUpdateDto {
  @JsonKey(name: 'administrationTime')
  String get administrationTime;
  @JsonKey(name: 'startDate')
  DateTime get startDate;
  @JsonKey(name: 'endDate')
  DateTime? get endDate;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'medicineDetails')
  List<MedicineDetailsDto>? get medicineDetails;

  /// Create a copy of MedicineFormUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MedicineFormUpdateDtoCopyWith<MedicineFormUpdateDto> get copyWith =>
      _$MedicineFormUpdateDtoCopyWithImpl<MedicineFormUpdateDto>(
          this as MedicineFormUpdateDto, _$identity);

  /// Serializes this MedicineFormUpdateDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MedicineFormUpdateDto &&
            (identical(other.administrationTime, administrationTime) ||
                other.administrationTime == administrationTime) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            const DeepCollectionEquality()
                .equals(other.medicineDetails, medicineDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, administrationTime, startDate,
      endDate, remarks, const DeepCollectionEquality().hash(medicineDetails));

  @override
  String toString() {
    return 'MedicineFormUpdateDto(administrationTime: $administrationTime, startDate: $startDate, endDate: $endDate, remarks: $remarks, medicineDetails: $medicineDetails)';
  }
}

/// @nodoc
abstract mixin class $MedicineFormUpdateDtoCopyWith<$Res> {
  factory $MedicineFormUpdateDtoCopyWith(MedicineFormUpdateDto value,
          $Res Function(MedicineFormUpdateDto) _then) =
      _$MedicineFormUpdateDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'administrationTime') String administrationTime,
      @JsonKey(name: 'startDate') DateTime startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'medicineDetails')
      List<MedicineDetailsDto>? medicineDetails});
}

/// @nodoc
class _$MedicineFormUpdateDtoCopyWithImpl<$Res>
    implements $MedicineFormUpdateDtoCopyWith<$Res> {
  _$MedicineFormUpdateDtoCopyWithImpl(this._self, this._then);

  final MedicineFormUpdateDto _self;
  final $Res Function(MedicineFormUpdateDto) _then;

  /// Create a copy of MedicineFormUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? administrationTime = null,
    Object? startDate = null,
    Object? endDate = freezed,
    Object? remarks = freezed,
    Object? medicineDetails = freezed,
  }) {
    return _then(_self.copyWith(
      administrationTime: null == administrationTime
          ? _self.administrationTime
          : administrationTime // ignore: cast_nullable_to_non_nullable
              as String,
      startDate: null == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetails: freezed == medicineDetails
          ? _self.medicineDetails
          : medicineDetails // ignore: cast_nullable_to_non_nullable
              as List<MedicineDetailsDto>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MedicineFormUpdateDto].
extension MedicineFormUpdateDtoPatterns on MedicineFormUpdateDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MedicineFormUpdateDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormUpdateDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MedicineFormUpdateDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormUpdateDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MedicineFormUpdateDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormUpdateDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'administrationTime') String administrationTime,
            @JsonKey(name: 'startDate') DateTime startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineDetails')
            List<MedicineDetailsDto>? medicineDetails)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MedicineFormUpdateDto() when $default != null:
        return $default(_that.administrationTime, _that.startDate,
            _that.endDate, _that.remarks, _that.medicineDetails);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'administrationTime') String administrationTime,
            @JsonKey(name: 'startDate') DateTime startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineDetails')
            List<MedicineDetailsDto>? medicineDetails)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormUpdateDto():
        return $default(_that.administrationTime, _that.startDate,
            _that.endDate, _that.remarks, _that.medicineDetails);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'administrationTime') String administrationTime,
            @JsonKey(name: 'startDate') DateTime startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'medicineDetails')
            List<MedicineDetailsDto>? medicineDetails)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MedicineFormUpdateDto() when $default != null:
        return $default(_that.administrationTime, _that.startDate,
            _that.endDate, _that.remarks, _that.medicineDetails);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MedicineFormUpdateDto implements MedicineFormUpdateDto {
  _MedicineFormUpdateDto(
      {@JsonKey(name: 'administrationTime') required this.administrationTime,
      @JsonKey(name: 'startDate') required this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'medicineDetails')
      final List<MedicineDetailsDto>? medicineDetails})
      : _medicineDetails = medicineDetails;
  factory _MedicineFormUpdateDto.fromJson(Map<String, dynamic> json) =>
      _$MedicineFormUpdateDtoFromJson(json);

  @override
  @JsonKey(name: 'administrationTime')
  final String administrationTime;
  @override
  @JsonKey(name: 'startDate')
  final DateTime startDate;
  @override
  @JsonKey(name: 'endDate')
  final DateTime? endDate;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  final List<MedicineDetailsDto>? _medicineDetails;
  @override
  @JsonKey(name: 'medicineDetails')
  List<MedicineDetailsDto>? get medicineDetails {
    final value = _medicineDetails;
    if (value == null) return null;
    if (_medicineDetails is EqualUnmodifiableListView) return _medicineDetails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of MedicineFormUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MedicineFormUpdateDtoCopyWith<_MedicineFormUpdateDto> get copyWith =>
      __$MedicineFormUpdateDtoCopyWithImpl<_MedicineFormUpdateDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MedicineFormUpdateDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MedicineFormUpdateDto &&
            (identical(other.administrationTime, administrationTime) ||
                other.administrationTime == administrationTime) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            const DeepCollectionEquality()
                .equals(other._medicineDetails, _medicineDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, administrationTime, startDate,
      endDate, remarks, const DeepCollectionEquality().hash(_medicineDetails));

  @override
  String toString() {
    return 'MedicineFormUpdateDto(administrationTime: $administrationTime, startDate: $startDate, endDate: $endDate, remarks: $remarks, medicineDetails: $medicineDetails)';
  }
}

/// @nodoc
abstract mixin class _$MedicineFormUpdateDtoCopyWith<$Res>
    implements $MedicineFormUpdateDtoCopyWith<$Res> {
  factory _$MedicineFormUpdateDtoCopyWith(_MedicineFormUpdateDto value,
          $Res Function(_MedicineFormUpdateDto) _then) =
      __$MedicineFormUpdateDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'administrationTime') String administrationTime,
      @JsonKey(name: 'startDate') DateTime startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'medicineDetails')
      List<MedicineDetailsDto>? medicineDetails});
}

/// @nodoc
class __$MedicineFormUpdateDtoCopyWithImpl<$Res>
    implements _$MedicineFormUpdateDtoCopyWith<$Res> {
  __$MedicineFormUpdateDtoCopyWithImpl(this._self, this._then);

  final _MedicineFormUpdateDto _self;
  final $Res Function(_MedicineFormUpdateDto) _then;

  /// Create a copy of MedicineFormUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? administrationTime = null,
    Object? startDate = null,
    Object? endDate = freezed,
    Object? remarks = freezed,
    Object? medicineDetails = freezed,
  }) {
    return _then(_MedicineFormUpdateDto(
      administrationTime: null == administrationTime
          ? _self.administrationTime
          : administrationTime // ignore: cast_nullable_to_non_nullable
              as String,
      startDate: null == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      medicineDetails: freezed == medicineDetails
          ? _self._medicineDetails
          : medicineDetails // ignore: cast_nullable_to_non_nullable
              as List<MedicineDetailsDto>?,
    ));
  }
}

/// @nodoc
mixin _$OTPParameterDto {
  @JsonKey(name: 'emailAddress')
  String? get emailAddress;

  /// Create a copy of OTPParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $OTPParameterDtoCopyWith<OTPParameterDto> get copyWith =>
      _$OTPParameterDtoCopyWithImpl<OTPParameterDto>(
          this as OTPParameterDto, _$identity);

  /// Serializes this OTPParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OTPParameterDto &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, emailAddress);

  @override
  String toString() {
    return 'OTPParameterDto(emailAddress: $emailAddress)';
  }
}

/// @nodoc
abstract mixin class $OTPParameterDtoCopyWith<$Res> {
  factory $OTPParameterDtoCopyWith(
          OTPParameterDto value, $Res Function(OTPParameterDto) _then) =
      _$OTPParameterDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'emailAddress') String? emailAddress});
}

/// @nodoc
class _$OTPParameterDtoCopyWithImpl<$Res>
    implements $OTPParameterDtoCopyWith<$Res> {
  _$OTPParameterDtoCopyWithImpl(this._self, this._then);

  final OTPParameterDto _self;
  final $Res Function(OTPParameterDto) _then;

  /// Create a copy of OTPParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? emailAddress = freezed,
  }) {
    return _then(_self.copyWith(
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [OTPParameterDto].
extension OTPParameterDtoPatterns on OTPParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_OTPParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _OTPParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_OTPParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_OTPParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'emailAddress') String? emailAddress)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _OTPParameterDto() when $default != null:
        return $default(_that.emailAddress);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'emailAddress') String? emailAddress)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPParameterDto():
        return $default(_that.emailAddress);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'emailAddress') String? emailAddress)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPParameterDto() when $default != null:
        return $default(_that.emailAddress);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _OTPParameterDto implements OTPParameterDto {
  _OTPParameterDto({@JsonKey(name: 'emailAddress') this.emailAddress});
  factory _OTPParameterDto.fromJson(Map<String, dynamic> json) =>
      _$OTPParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'emailAddress')
  final String? emailAddress;

  /// Create a copy of OTPParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$OTPParameterDtoCopyWith<_OTPParameterDto> get copyWith =>
      __$OTPParameterDtoCopyWithImpl<_OTPParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$OTPParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OTPParameterDto &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, emailAddress);

  @override
  String toString() {
    return 'OTPParameterDto(emailAddress: $emailAddress)';
  }
}

/// @nodoc
abstract mixin class _$OTPParameterDtoCopyWith<$Res>
    implements $OTPParameterDtoCopyWith<$Res> {
  factory _$OTPParameterDtoCopyWith(
          _OTPParameterDto value, $Res Function(_OTPParameterDto) _then) =
      __$OTPParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'emailAddress') String? emailAddress});
}

/// @nodoc
class __$OTPParameterDtoCopyWithImpl<$Res>
    implements _$OTPParameterDtoCopyWith<$Res> {
  __$OTPParameterDtoCopyWithImpl(this._self, this._then);

  final _OTPParameterDto _self;
  final $Res Function(_OTPParameterDto) _then;

  /// Create a copy of OTPParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? emailAddress = freezed,
  }) {
    return _then(_OTPParameterDto(
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$OTPValidateParameterDto {
  @JsonKey(name: 'otpNumber')
  String? get otpNumber;
  @JsonKey(name: 'emailAddress')
  String? get emailAddress;

  /// Create a copy of OTPValidateParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $OTPValidateParameterDtoCopyWith<OTPValidateParameterDto> get copyWith =>
      _$OTPValidateParameterDtoCopyWithImpl<OTPValidateParameterDto>(
          this as OTPValidateParameterDto, _$identity);

  /// Serializes this OTPValidateParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OTPValidateParameterDto &&
            (identical(other.otpNumber, otpNumber) ||
                other.otpNumber == otpNumber) &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, otpNumber, emailAddress);

  @override
  String toString() {
    return 'OTPValidateParameterDto(otpNumber: $otpNumber, emailAddress: $emailAddress)';
  }
}

/// @nodoc
abstract mixin class $OTPValidateParameterDtoCopyWith<$Res> {
  factory $OTPValidateParameterDtoCopyWith(OTPValidateParameterDto value,
          $Res Function(OTPValidateParameterDto) _then) =
      _$OTPValidateParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'otpNumber') String? otpNumber,
      @JsonKey(name: 'emailAddress') String? emailAddress});
}

/// @nodoc
class _$OTPValidateParameterDtoCopyWithImpl<$Res>
    implements $OTPValidateParameterDtoCopyWith<$Res> {
  _$OTPValidateParameterDtoCopyWithImpl(this._self, this._then);

  final OTPValidateParameterDto _self;
  final $Res Function(OTPValidateParameterDto) _then;

  /// Create a copy of OTPValidateParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? otpNumber = freezed,
    Object? emailAddress = freezed,
  }) {
    return _then(_self.copyWith(
      otpNumber: freezed == otpNumber
          ? _self.otpNumber
          : otpNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [OTPValidateParameterDto].
extension OTPValidateParameterDtoPatterns on OTPValidateParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_OTPValidateParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _OTPValidateParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_OTPValidateParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPValidateParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_OTPValidateParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPValidateParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'otpNumber') String? otpNumber,
            @JsonKey(name: 'emailAddress') String? emailAddress)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _OTPValidateParameterDto() when $default != null:
        return $default(_that.otpNumber, _that.emailAddress);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'otpNumber') String? otpNumber,
            @JsonKey(name: 'emailAddress') String? emailAddress)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPValidateParameterDto():
        return $default(_that.otpNumber, _that.emailAddress);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'otpNumber') String? otpNumber,
            @JsonKey(name: 'emailAddress') String? emailAddress)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _OTPValidateParameterDto() when $default != null:
        return $default(_that.otpNumber, _that.emailAddress);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _OTPValidateParameterDto implements OTPValidateParameterDto {
  _OTPValidateParameterDto(
      {@JsonKey(name: 'otpNumber') this.otpNumber,
      @JsonKey(name: 'emailAddress') this.emailAddress});
  factory _OTPValidateParameterDto.fromJson(Map<String, dynamic> json) =>
      _$OTPValidateParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'otpNumber')
  final String? otpNumber;
  @override
  @JsonKey(name: 'emailAddress')
  final String? emailAddress;

  /// Create a copy of OTPValidateParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$OTPValidateParameterDtoCopyWith<_OTPValidateParameterDto> get copyWith =>
      __$OTPValidateParameterDtoCopyWithImpl<_OTPValidateParameterDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$OTPValidateParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OTPValidateParameterDto &&
            (identical(other.otpNumber, otpNumber) ||
                other.otpNumber == otpNumber) &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, otpNumber, emailAddress);

  @override
  String toString() {
    return 'OTPValidateParameterDto(otpNumber: $otpNumber, emailAddress: $emailAddress)';
  }
}

/// @nodoc
abstract mixin class _$OTPValidateParameterDtoCopyWith<$Res>
    implements $OTPValidateParameterDtoCopyWith<$Res> {
  factory _$OTPValidateParameterDtoCopyWith(_OTPValidateParameterDto value,
          $Res Function(_OTPValidateParameterDto) _then) =
      __$OTPValidateParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'otpNumber') String? otpNumber,
      @JsonKey(name: 'emailAddress') String? emailAddress});
}

/// @nodoc
class __$OTPValidateParameterDtoCopyWithImpl<$Res>
    implements _$OTPValidateParameterDtoCopyWith<$Res> {
  __$OTPValidateParameterDtoCopyWithImpl(this._self, this._then);

  final _OTPValidateParameterDto _self;
  final $Res Function(_OTPValidateParameterDto) _then;

  /// Create a copy of OTPValidateParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? otpNumber = freezed,
    Object? emailAddress = freezed,
  }) {
    return _then(_OTPValidateParameterDto(
      otpNumber: freezed == otpNumber
          ? _self.otpNumber
          : otpNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PersonalInfoDto {
  @JsonKey(name: 'accountId')
  String get accountId;
  @JsonKey(name: 'firstName')
  String? get firstName;
  @JsonKey(name: 'displayName')
  String? get displayName;
  @JsonKey(name: 'lastName')
  String? get lastName;
  @JsonKey(name: 'firstNameOther')
  String? get firstNameOther;
  @JsonKey(name: 'lastNameOther')
  String? get lastNameOther;
  @JsonKey(name: 'dob')
  DateTime? get dob;
  @JsonKey(name: 'idType')
  String? get idType;
  @JsonKey(name: 'idExpiryDate')
  DateTime? get idExpiryDate;
  @JsonKey(name: 'nationality')
  String? get nationality;
  @JsonKey(name: 'photoURL')
  String? get photoURL;

  /// Create a copy of PersonalInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PersonalInfoDtoCopyWith<PersonalInfoDto> get copyWith =>
      _$PersonalInfoDtoCopyWithImpl<PersonalInfoDto>(
          this as PersonalInfoDto, _$identity);

  /// Serializes this PersonalInfoDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PersonalInfoDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.firstName, firstName) ||
                other.firstName == firstName) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.lastName, lastName) ||
                other.lastName == lastName) &&
            (identical(other.firstNameOther, firstNameOther) ||
                other.firstNameOther == firstNameOther) &&
            (identical(other.lastNameOther, lastNameOther) ||
                other.lastNameOther == lastNameOther) &&
            (identical(other.dob, dob) || other.dob == dob) &&
            (identical(other.idType, idType) || other.idType == idType) &&
            (identical(other.idExpiryDate, idExpiryDate) ||
                other.idExpiryDate == idExpiryDate) &&
            (identical(other.nationality, nationality) ||
                other.nationality == nationality) &&
            (identical(other.photoURL, photoURL) ||
                other.photoURL == photoURL));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      firstName,
      displayName,
      lastName,
      firstNameOther,
      lastNameOther,
      dob,
      idType,
      idExpiryDate,
      nationality,
      photoURL);

  @override
  String toString() {
    return 'PersonalInfoDto(accountId: $accountId, firstName: $firstName, displayName: $displayName, lastName: $lastName, firstNameOther: $firstNameOther, lastNameOther: $lastNameOther, dob: $dob, idType: $idType, idExpiryDate: $idExpiryDate, nationality: $nationality, photoURL: $photoURL)';
  }
}

/// @nodoc
abstract mixin class $PersonalInfoDtoCopyWith<$Res> {
  factory $PersonalInfoDtoCopyWith(
          PersonalInfoDto value, $Res Function(PersonalInfoDto) _then) =
      _$PersonalInfoDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') String accountId,
      @JsonKey(name: 'firstName') String? firstName,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'lastName') String? lastName,
      @JsonKey(name: 'firstNameOther') String? firstNameOther,
      @JsonKey(name: 'lastNameOther') String? lastNameOther,
      @JsonKey(name: 'dob') DateTime? dob,
      @JsonKey(name: 'idType') String? idType,
      @JsonKey(name: 'idExpiryDate') DateTime? idExpiryDate,
      @JsonKey(name: 'nationality') String? nationality,
      @JsonKey(name: 'photoURL') String? photoURL});
}

/// @nodoc
class _$PersonalInfoDtoCopyWithImpl<$Res>
    implements $PersonalInfoDtoCopyWith<$Res> {
  _$PersonalInfoDtoCopyWithImpl(this._self, this._then);

  final PersonalInfoDto _self;
  final $Res Function(PersonalInfoDto) _then;

  /// Create a copy of PersonalInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountId = null,
    Object? firstName = freezed,
    Object? displayName = freezed,
    Object? lastName = freezed,
    Object? firstNameOther = freezed,
    Object? lastNameOther = freezed,
    Object? dob = freezed,
    Object? idType = freezed,
    Object? idExpiryDate = freezed,
    Object? nationality = freezed,
    Object? photoURL = freezed,
  }) {
    return _then(_self.copyWith(
      accountId: null == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String,
      firstName: freezed == firstName
          ? _self.firstName
          : firstName // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      lastName: freezed == lastName
          ? _self.lastName
          : lastName // ignore: cast_nullable_to_non_nullable
              as String?,
      firstNameOther: freezed == firstNameOther
          ? _self.firstNameOther
          : firstNameOther // ignore: cast_nullable_to_non_nullable
              as String?,
      lastNameOther: freezed == lastNameOther
          ? _self.lastNameOther
          : lastNameOther // ignore: cast_nullable_to_non_nullable
              as String?,
      dob: freezed == dob
          ? _self.dob
          : dob // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      idType: freezed == idType
          ? _self.idType
          : idType // ignore: cast_nullable_to_non_nullable
              as String?,
      idExpiryDate: freezed == idExpiryDate
          ? _self.idExpiryDate
          : idExpiryDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nationality: freezed == nationality
          ? _self.nationality
          : nationality // ignore: cast_nullable_to_non_nullable
              as String?,
      photoURL: freezed == photoURL
          ? _self.photoURL
          : photoURL // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PersonalInfoDto].
extension PersonalInfoDtoPatterns on PersonalInfoDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PersonalInfoDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PersonalInfoDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PersonalInfoDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PersonalInfoDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PersonalInfoDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PersonalInfoDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') String accountId,
            @JsonKey(name: 'firstName') String? firstName,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'lastName') String? lastName,
            @JsonKey(name: 'firstNameOther') String? firstNameOther,
            @JsonKey(name: 'lastNameOther') String? lastNameOther,
            @JsonKey(name: 'dob') DateTime? dob,
            @JsonKey(name: 'idType') String? idType,
            @JsonKey(name: 'idExpiryDate') DateTime? idExpiryDate,
            @JsonKey(name: 'nationality') String? nationality,
            @JsonKey(name: 'photoURL') String? photoURL)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PersonalInfoDto() when $default != null:
        return $default(
            _that.accountId,
            _that.firstName,
            _that.displayName,
            _that.lastName,
            _that.firstNameOther,
            _that.lastNameOther,
            _that.dob,
            _that.idType,
            _that.idExpiryDate,
            _that.nationality,
            _that.photoURL);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') String accountId,
            @JsonKey(name: 'firstName') String? firstName,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'lastName') String? lastName,
            @JsonKey(name: 'firstNameOther') String? firstNameOther,
            @JsonKey(name: 'lastNameOther') String? lastNameOther,
            @JsonKey(name: 'dob') DateTime? dob,
            @JsonKey(name: 'idType') String? idType,
            @JsonKey(name: 'idExpiryDate') DateTime? idExpiryDate,
            @JsonKey(name: 'nationality') String? nationality,
            @JsonKey(name: 'photoURL') String? photoURL)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PersonalInfoDto():
        return $default(
            _that.accountId,
            _that.firstName,
            _that.displayName,
            _that.lastName,
            _that.firstNameOther,
            _that.lastNameOther,
            _that.dob,
            _that.idType,
            _that.idExpiryDate,
            _that.nationality,
            _that.photoURL);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'accountId') String accountId,
            @JsonKey(name: 'firstName') String? firstName,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'lastName') String? lastName,
            @JsonKey(name: 'firstNameOther') String? firstNameOther,
            @JsonKey(name: 'lastNameOther') String? lastNameOther,
            @JsonKey(name: 'dob') DateTime? dob,
            @JsonKey(name: 'idType') String? idType,
            @JsonKey(name: 'idExpiryDate') DateTime? idExpiryDate,
            @JsonKey(name: 'nationality') String? nationality,
            @JsonKey(name: 'photoURL') String? photoURL)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PersonalInfoDto() when $default != null:
        return $default(
            _that.accountId,
            _that.firstName,
            _that.displayName,
            _that.lastName,
            _that.firstNameOther,
            _that.lastNameOther,
            _that.dob,
            _that.idType,
            _that.idExpiryDate,
            _that.nationality,
            _that.photoURL);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PersonalInfoDto implements PersonalInfoDto {
  _PersonalInfoDto(
      {@JsonKey(name: 'accountId') required this.accountId,
      @JsonKey(name: 'firstName') this.firstName,
      @JsonKey(name: 'displayName') this.displayName,
      @JsonKey(name: 'lastName') this.lastName,
      @JsonKey(name: 'firstNameOther') this.firstNameOther,
      @JsonKey(name: 'lastNameOther') this.lastNameOther,
      @JsonKey(name: 'dob') this.dob,
      @JsonKey(name: 'idType') this.idType,
      @JsonKey(name: 'idExpiryDate') this.idExpiryDate,
      @JsonKey(name: 'nationality') this.nationality,
      @JsonKey(name: 'photoURL') this.photoURL});
  factory _PersonalInfoDto.fromJson(Map<String, dynamic> json) =>
      _$PersonalInfoDtoFromJson(json);

  @override
  @JsonKey(name: 'accountId')
  final String accountId;
  @override
  @JsonKey(name: 'firstName')
  final String? firstName;
  @override
  @JsonKey(name: 'displayName')
  final String? displayName;
  @override
  @JsonKey(name: 'lastName')
  final String? lastName;
  @override
  @JsonKey(name: 'firstNameOther')
  final String? firstNameOther;
  @override
  @JsonKey(name: 'lastNameOther')
  final String? lastNameOther;
  @override
  @JsonKey(name: 'dob')
  final DateTime? dob;
  @override
  @JsonKey(name: 'idType')
  final String? idType;
  @override
  @JsonKey(name: 'idExpiryDate')
  final DateTime? idExpiryDate;
  @override
  @JsonKey(name: 'nationality')
  final String? nationality;
  @override
  @JsonKey(name: 'photoURL')
  final String? photoURL;

  /// Create a copy of PersonalInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PersonalInfoDtoCopyWith<_PersonalInfoDto> get copyWith =>
      __$PersonalInfoDtoCopyWithImpl<_PersonalInfoDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PersonalInfoDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PersonalInfoDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.firstName, firstName) ||
                other.firstName == firstName) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.lastName, lastName) ||
                other.lastName == lastName) &&
            (identical(other.firstNameOther, firstNameOther) ||
                other.firstNameOther == firstNameOther) &&
            (identical(other.lastNameOther, lastNameOther) ||
                other.lastNameOther == lastNameOther) &&
            (identical(other.dob, dob) || other.dob == dob) &&
            (identical(other.idType, idType) || other.idType == idType) &&
            (identical(other.idExpiryDate, idExpiryDate) ||
                other.idExpiryDate == idExpiryDate) &&
            (identical(other.nationality, nationality) ||
                other.nationality == nationality) &&
            (identical(other.photoURL, photoURL) ||
                other.photoURL == photoURL));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      firstName,
      displayName,
      lastName,
      firstNameOther,
      lastNameOther,
      dob,
      idType,
      idExpiryDate,
      nationality,
      photoURL);

  @override
  String toString() {
    return 'PersonalInfoDto(accountId: $accountId, firstName: $firstName, displayName: $displayName, lastName: $lastName, firstNameOther: $firstNameOther, lastNameOther: $lastNameOther, dob: $dob, idType: $idType, idExpiryDate: $idExpiryDate, nationality: $nationality, photoURL: $photoURL)';
  }
}

/// @nodoc
abstract mixin class _$PersonalInfoDtoCopyWith<$Res>
    implements $PersonalInfoDtoCopyWith<$Res> {
  factory _$PersonalInfoDtoCopyWith(
          _PersonalInfoDto value, $Res Function(_PersonalInfoDto) _then) =
      __$PersonalInfoDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') String accountId,
      @JsonKey(name: 'firstName') String? firstName,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'lastName') String? lastName,
      @JsonKey(name: 'firstNameOther') String? firstNameOther,
      @JsonKey(name: 'lastNameOther') String? lastNameOther,
      @JsonKey(name: 'dob') DateTime? dob,
      @JsonKey(name: 'idType') String? idType,
      @JsonKey(name: 'idExpiryDate') DateTime? idExpiryDate,
      @JsonKey(name: 'nationality') String? nationality,
      @JsonKey(name: 'photoURL') String? photoURL});
}

/// @nodoc
class __$PersonalInfoDtoCopyWithImpl<$Res>
    implements _$PersonalInfoDtoCopyWith<$Res> {
  __$PersonalInfoDtoCopyWithImpl(this._self, this._then);

  final _PersonalInfoDto _self;
  final $Res Function(_PersonalInfoDto) _then;

  /// Create a copy of PersonalInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? accountId = null,
    Object? firstName = freezed,
    Object? displayName = freezed,
    Object? lastName = freezed,
    Object? firstNameOther = freezed,
    Object? lastNameOther = freezed,
    Object? dob = freezed,
    Object? idType = freezed,
    Object? idExpiryDate = freezed,
    Object? nationality = freezed,
    Object? photoURL = freezed,
  }) {
    return _then(_PersonalInfoDto(
      accountId: null == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String,
      firstName: freezed == firstName
          ? _self.firstName
          : firstName // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      lastName: freezed == lastName
          ? _self.lastName
          : lastName // ignore: cast_nullable_to_non_nullable
              as String?,
      firstNameOther: freezed == firstNameOther
          ? _self.firstNameOther
          : firstNameOther // ignore: cast_nullable_to_non_nullable
              as String?,
      lastNameOther: freezed == lastNameOther
          ? _self.lastNameOther
          : lastNameOther // ignore: cast_nullable_to_non_nullable
              as String?,
      dob: freezed == dob
          ? _self.dob
          : dob // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      idType: freezed == idType
          ? _self.idType
          : idType // ignore: cast_nullable_to_non_nullable
              as String?,
      idExpiryDate: freezed == idExpiryDate
          ? _self.idExpiryDate
          : idExpiryDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nationality: freezed == nationality
          ? _self.nationality
          : nationality // ignore: cast_nullable_to_non_nullable
              as String?,
      photoURL: freezed == photoURL
          ? _self.photoURL
          : photoURL // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostDto {
  @JsonKey(name: 'createdById')
  String? get createdById;
  @JsonKey(name: 'createdDateTime')
  DateTime? get createdDateTime;
  @JsonKey(name: 'lastModifiedById')
  String? get lastModifiedById;
  @JsonKey(name: 'lastModifiedDateTime')
  DateTime? get lastModifiedDateTime;
  @JsonKey(name: 'lastModifiedByName')
  String? get lastModifiedByName;
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postType')
  String get postType;
  @JsonKey(name: 'status')
  String get status;
  @JsonKey(name: 'publishDate')
  DateTime get publishDate;
  @JsonKey(name: 'academicYearId')
  String? get academicYearId;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'isAllClass')
  bool? get isAllClass;
  @JsonKey(name: 'isAllLevel')
  bool? get isAllLevel;
  @JsonKey(name: 'postTags')
  List<PostTagDto>? get postTags;
  @JsonKey(name: 'files')
  List<PostFileDto>? get files;
  @JsonKey(name: 'postAssociatedWithStudents')
  List<PostAssociatedWithStudentsDto>? get postAssociatedWithStudents;
  @JsonKey(name: 'postStudents')
  List<PostStudentDto>? get postStudents;
  @JsonKey(name: 'postClasses')
  List<PostClassDto>? get postClasses;
  @JsonKey(name: 'postCourses')
  List<PostCourseDto>? get postCourses;
  @JsonKey(name: 'postGoals')
  List<PostGoalDto>? get postGoals;
  @JsonKey(name: 'postReactions')
  List<PostReactionDto>? get postReactions;
  @JsonKey(name: 'postClassString')
  String? get postClassString;
  @JsonKey(name: 'postStudentString')
  String? get postStudentString;
  @JsonKey(name: 'allowComment')
  bool? get allowComment;
  @JsonKey(name: 'viewCount')
  int? get viewCount;
  @JsonKey(name: 'createdByName')
  String? get createdByName;
  @JsonKey(name: 'markedDate')
  DateTime? get markedDate;
  @JsonKey(name: 'schoolId')
  String? get schoolId;
  @JsonKey(name: 'homeSchool')
  String? get homeSchool;
  @JsonKey(name: 'literacy')
  String? get literacy;
  @JsonKey(name: 'numeracy')
  String? get numeracy;
  @JsonKey(name: 'observation')
  String? get observation;

  /// Create a copy of PostDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostDtoCopyWith<PostDto> get copyWith =>
      _$PostDtoCopyWithImpl<PostDto>(this as PostDto, _$identity);

  /// Serializes this PostDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostDto &&
            (identical(other.createdById, createdById) ||
                other.createdById == createdById) &&
            (identical(other.createdDateTime, createdDateTime) ||
                other.createdDateTime == createdDateTime) &&
            (identical(other.lastModifiedById, lastModifiedById) ||
                other.lastModifiedById == lastModifiedById) &&
            (identical(other.lastModifiedDateTime, lastModifiedDateTime) ||
                other.lastModifiedDateTime == lastModifiedDateTime) &&
            (identical(other.lastModifiedByName, lastModifiedByName) ||
                other.lastModifiedByName == lastModifiedByName) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postType, postType) ||
                other.postType == postType) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.publishDate, publishDate) ||
                other.publishDate == publishDate) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.isAllClass, isAllClass) ||
                other.isAllClass == isAllClass) &&
            (identical(other.isAllLevel, isAllLevel) ||
                other.isAllLevel == isAllLevel) &&
            const DeepCollectionEquality().equals(other.postTags, postTags) &&
            const DeepCollectionEquality().equals(other.files, files) &&
            const DeepCollectionEquality().equals(
                other.postAssociatedWithStudents, postAssociatedWithStudents) &&
            const DeepCollectionEquality()
                .equals(other.postStudents, postStudents) &&
            const DeepCollectionEquality()
                .equals(other.postClasses, postClasses) &&
            const DeepCollectionEquality()
                .equals(other.postCourses, postCourses) &&
            const DeepCollectionEquality().equals(other.postGoals, postGoals) &&
            const DeepCollectionEquality()
                .equals(other.postReactions, postReactions) &&
            (identical(other.postClassString, postClassString) ||
                other.postClassString == postClassString) &&
            (identical(other.postStudentString, postStudentString) ||
                other.postStudentString == postStudentString) &&
            (identical(other.allowComment, allowComment) ||
                other.allowComment == allowComment) &&
            (identical(other.viewCount, viewCount) ||
                other.viewCount == viewCount) &&
            (identical(other.createdByName, createdByName) ||
                other.createdByName == createdByName) &&
            (identical(other.markedDate, markedDate) ||
                other.markedDate == markedDate) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.homeSchool, homeSchool) ||
                other.homeSchool == homeSchool) &&
            (identical(other.literacy, literacy) ||
                other.literacy == literacy) &&
            (identical(other.numeracy, numeracy) ||
                other.numeracy == numeracy) &&
            (identical(other.observation, observation) ||
                other.observation == observation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        createdById,
        createdDateTime,
        lastModifiedById,
        lastModifiedDateTime,
        lastModifiedByName,
        id,
        postType,
        status,
        publishDate,
        academicYearId,
        description,
        title,
        isAllClass,
        isAllLevel,
        const DeepCollectionEquality().hash(postTags),
        const DeepCollectionEquality().hash(files),
        const DeepCollectionEquality().hash(postAssociatedWithStudents),
        const DeepCollectionEquality().hash(postStudents),
        const DeepCollectionEquality().hash(postClasses),
        const DeepCollectionEquality().hash(postCourses),
        const DeepCollectionEquality().hash(postGoals),
        const DeepCollectionEquality().hash(postReactions),
        postClassString,
        postStudentString,
        allowComment,
        viewCount,
        createdByName,
        markedDate,
        schoolId,
        homeSchool,
        literacy,
        numeracy,
        observation
      ]);

  @override
  String toString() {
    return 'PostDto(createdById: $createdById, createdDateTime: $createdDateTime, lastModifiedById: $lastModifiedById, lastModifiedDateTime: $lastModifiedDateTime, lastModifiedByName: $lastModifiedByName, id: $id, postType: $postType, status: $status, publishDate: $publishDate, academicYearId: $academicYearId, description: $description, title: $title, isAllClass: $isAllClass, isAllLevel: $isAllLevel, postTags: $postTags, files: $files, postAssociatedWithStudents: $postAssociatedWithStudents, postStudents: $postStudents, postClasses: $postClasses, postCourses: $postCourses, postGoals: $postGoals, postReactions: $postReactions, postClassString: $postClassString, postStudentString: $postStudentString, allowComment: $allowComment, viewCount: $viewCount, createdByName: $createdByName, markedDate: $markedDate, schoolId: $schoolId, homeSchool: $homeSchool, literacy: $literacy, numeracy: $numeracy, observation: $observation)';
  }
}

/// @nodoc
abstract mixin class $PostDtoCopyWith<$Res> {
  factory $PostDtoCopyWith(PostDto value, $Res Function(PostDto) _then) =
      _$PostDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'createdById') String? createdById,
      @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
      @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
      @JsonKey(name: 'lastModifiedDateTime') DateTime? lastModifiedDateTime,
      @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
      @JsonKey(name: 'id') String id,
      @JsonKey(name: 'postType') String postType,
      @JsonKey(name: 'status') String status,
      @JsonKey(name: 'publishDate') DateTime publishDate,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'isAllClass') bool? isAllClass,
      @JsonKey(name: 'isAllLevel') bool? isAllLevel,
      @JsonKey(name: 'postTags') List<PostTagDto>? postTags,
      @JsonKey(name: 'files') List<PostFileDto>? files,
      @JsonKey(name: 'postAssociatedWithStudents')
      List<PostAssociatedWithStudentsDto>? postAssociatedWithStudents,
      @JsonKey(name: 'postStudents') List<PostStudentDto>? postStudents,
      @JsonKey(name: 'postClasses') List<PostClassDto>? postClasses,
      @JsonKey(name: 'postCourses') List<PostCourseDto>? postCourses,
      @JsonKey(name: 'postGoals') List<PostGoalDto>? postGoals,
      @JsonKey(name: 'postReactions') List<PostReactionDto>? postReactions,
      @JsonKey(name: 'postClassString') String? postClassString,
      @JsonKey(name: 'postStudentString') String? postStudentString,
      @JsonKey(name: 'allowComment') bool? allowComment,
      @JsonKey(name: 'viewCount') int? viewCount,
      @JsonKey(name: 'createdByName') String? createdByName,
      @JsonKey(name: 'markedDate') DateTime? markedDate,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'homeSchool') String? homeSchool,
      @JsonKey(name: 'literacy') String? literacy,
      @JsonKey(name: 'numeracy') String? numeracy,
      @JsonKey(name: 'observation') String? observation});
}

/// @nodoc
class _$PostDtoCopyWithImpl<$Res> implements $PostDtoCopyWith<$Res> {
  _$PostDtoCopyWithImpl(this._self, this._then);

  final PostDto _self;
  final $Res Function(PostDto) _then;

  /// Create a copy of PostDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? createdById = freezed,
    Object? createdDateTime = freezed,
    Object? lastModifiedById = freezed,
    Object? lastModifiedDateTime = freezed,
    Object? lastModifiedByName = freezed,
    Object? id = null,
    Object? postType = null,
    Object? status = null,
    Object? publishDate = null,
    Object? academicYearId = freezed,
    Object? description = freezed,
    Object? title = freezed,
    Object? isAllClass = freezed,
    Object? isAllLevel = freezed,
    Object? postTags = freezed,
    Object? files = freezed,
    Object? postAssociatedWithStudents = freezed,
    Object? postStudents = freezed,
    Object? postClasses = freezed,
    Object? postCourses = freezed,
    Object? postGoals = freezed,
    Object? postReactions = freezed,
    Object? postClassString = freezed,
    Object? postStudentString = freezed,
    Object? allowComment = freezed,
    Object? viewCount = freezed,
    Object? createdByName = freezed,
    Object? markedDate = freezed,
    Object? schoolId = freezed,
    Object? homeSchool = freezed,
    Object? literacy = freezed,
    Object? numeracy = freezed,
    Object? observation = freezed,
  }) {
    return _then(_self.copyWith(
      createdById: freezed == createdById
          ? _self.createdById
          : createdById // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDateTime: freezed == createdDateTime
          ? _self.createdDateTime
          : createdDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastModifiedById: freezed == lastModifiedById
          ? _self.lastModifiedById
          : lastModifiedById // ignore: cast_nullable_to_non_nullable
              as String?,
      lastModifiedDateTime: freezed == lastModifiedDateTime
          ? _self.lastModifiedDateTime
          : lastModifiedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastModifiedByName: freezed == lastModifiedByName
          ? _self.lastModifiedByName
          : lastModifiedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postType: null == postType
          ? _self.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      publishDate: null == publishDate
          ? _self.publishDate
          : publishDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      isAllClass: freezed == isAllClass
          ? _self.isAllClass
          : isAllClass // ignore: cast_nullable_to_non_nullable
              as bool?,
      isAllLevel: freezed == isAllLevel
          ? _self.isAllLevel
          : isAllLevel // ignore: cast_nullable_to_non_nullable
              as bool?,
      postTags: freezed == postTags
          ? _self.postTags
          : postTags // ignore: cast_nullable_to_non_nullable
              as List<PostTagDto>?,
      files: freezed == files
          ? _self.files
          : files // ignore: cast_nullable_to_non_nullable
              as List<PostFileDto>?,
      postAssociatedWithStudents: freezed == postAssociatedWithStudents
          ? _self.postAssociatedWithStudents
          : postAssociatedWithStudents // ignore: cast_nullable_to_non_nullable
              as List<PostAssociatedWithStudentsDto>?,
      postStudents: freezed == postStudents
          ? _self.postStudents
          : postStudents // ignore: cast_nullable_to_non_nullable
              as List<PostStudentDto>?,
      postClasses: freezed == postClasses
          ? _self.postClasses
          : postClasses // ignore: cast_nullable_to_non_nullable
              as List<PostClassDto>?,
      postCourses: freezed == postCourses
          ? _self.postCourses
          : postCourses // ignore: cast_nullable_to_non_nullable
              as List<PostCourseDto>?,
      postGoals: freezed == postGoals
          ? _self.postGoals
          : postGoals // ignore: cast_nullable_to_non_nullable
              as List<PostGoalDto>?,
      postReactions: freezed == postReactions
          ? _self.postReactions
          : postReactions // ignore: cast_nullable_to_non_nullable
              as List<PostReactionDto>?,
      postClassString: freezed == postClassString
          ? _self.postClassString
          : postClassString // ignore: cast_nullable_to_non_nullable
              as String?,
      postStudentString: freezed == postStudentString
          ? _self.postStudentString
          : postStudentString // ignore: cast_nullable_to_non_nullable
              as String?,
      allowComment: freezed == allowComment
          ? _self.allowComment
          : allowComment // ignore: cast_nullable_to_non_nullable
              as bool?,
      viewCount: freezed == viewCount
          ? _self.viewCount
          : viewCount // ignore: cast_nullable_to_non_nullable
              as int?,
      createdByName: freezed == createdByName
          ? _self.createdByName
          : createdByName // ignore: cast_nullable_to_non_nullable
              as String?,
      markedDate: freezed == markedDate
          ? _self.markedDate
          : markedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      homeSchool: freezed == homeSchool
          ? _self.homeSchool
          : homeSchool // ignore: cast_nullable_to_non_nullable
              as String?,
      literacy: freezed == literacy
          ? _self.literacy
          : literacy // ignore: cast_nullable_to_non_nullable
              as String?,
      numeracy: freezed == numeracy
          ? _self.numeracy
          : numeracy // ignore: cast_nullable_to_non_nullable
              as String?,
      observation: freezed == observation
          ? _self.observation
          : observation // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostDto].
extension PostDtoPatterns on PostDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'createdById') String? createdById,
            @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
            @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
            @JsonKey(name: 'lastModifiedDateTime')
            DateTime? lastModifiedDateTime,
            @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postType') String postType,
            @JsonKey(name: 'status') String status,
            @JsonKey(name: 'publishDate') DateTime publishDate,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'isAllClass') bool? isAllClass,
            @JsonKey(name: 'isAllLevel') bool? isAllLevel,
            @JsonKey(name: 'postTags') List<PostTagDto>? postTags,
            @JsonKey(name: 'files') List<PostFileDto>? files,
            @JsonKey(name: 'postAssociatedWithStudents')
            List<PostAssociatedWithStudentsDto>? postAssociatedWithStudents,
            @JsonKey(name: 'postStudents') List<PostStudentDto>? postStudents,
            @JsonKey(name: 'postClasses') List<PostClassDto>? postClasses,
            @JsonKey(name: 'postCourses') List<PostCourseDto>? postCourses,
            @JsonKey(name: 'postGoals') List<PostGoalDto>? postGoals,
            @JsonKey(name: 'postReactions')
            List<PostReactionDto>? postReactions,
            @JsonKey(name: 'postClassString') String? postClassString,
            @JsonKey(name: 'postStudentString') String? postStudentString,
            @JsonKey(name: 'allowComment') bool? allowComment,
            @JsonKey(name: 'viewCount') int? viewCount,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'markedDate') DateTime? markedDate,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'homeSchool') String? homeSchool,
            @JsonKey(name: 'literacy') String? literacy,
            @JsonKey(name: 'numeracy') String? numeracy,
            @JsonKey(name: 'observation') String? observation)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostDto() when $default != null:
        return $default(
            _that.createdById,
            _that.createdDateTime,
            _that.lastModifiedById,
            _that.lastModifiedDateTime,
            _that.lastModifiedByName,
            _that.id,
            _that.postType,
            _that.status,
            _that.publishDate,
            _that.academicYearId,
            _that.description,
            _that.title,
            _that.isAllClass,
            _that.isAllLevel,
            _that.postTags,
            _that.files,
            _that.postAssociatedWithStudents,
            _that.postStudents,
            _that.postClasses,
            _that.postCourses,
            _that.postGoals,
            _that.postReactions,
            _that.postClassString,
            _that.postStudentString,
            _that.allowComment,
            _that.viewCount,
            _that.createdByName,
            _that.markedDate,
            _that.schoolId,
            _that.homeSchool,
            _that.literacy,
            _that.numeracy,
            _that.observation);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'createdById') String? createdById,
            @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
            @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
            @JsonKey(name: 'lastModifiedDateTime')
            DateTime? lastModifiedDateTime,
            @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postType') String postType,
            @JsonKey(name: 'status') String status,
            @JsonKey(name: 'publishDate') DateTime publishDate,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'isAllClass') bool? isAllClass,
            @JsonKey(name: 'isAllLevel') bool? isAllLevel,
            @JsonKey(name: 'postTags') List<PostTagDto>? postTags,
            @JsonKey(name: 'files') List<PostFileDto>? files,
            @JsonKey(name: 'postAssociatedWithStudents')
            List<PostAssociatedWithStudentsDto>? postAssociatedWithStudents,
            @JsonKey(name: 'postStudents') List<PostStudentDto>? postStudents,
            @JsonKey(name: 'postClasses') List<PostClassDto>? postClasses,
            @JsonKey(name: 'postCourses') List<PostCourseDto>? postCourses,
            @JsonKey(name: 'postGoals') List<PostGoalDto>? postGoals,
            @JsonKey(name: 'postReactions')
            List<PostReactionDto>? postReactions,
            @JsonKey(name: 'postClassString') String? postClassString,
            @JsonKey(name: 'postStudentString') String? postStudentString,
            @JsonKey(name: 'allowComment') bool? allowComment,
            @JsonKey(name: 'viewCount') int? viewCount,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'markedDate') DateTime? markedDate,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'homeSchool') String? homeSchool,
            @JsonKey(name: 'literacy') String? literacy,
            @JsonKey(name: 'numeracy') String? numeracy,
            @JsonKey(name: 'observation') String? observation)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostDto():
        return $default(
            _that.createdById,
            _that.createdDateTime,
            _that.lastModifiedById,
            _that.lastModifiedDateTime,
            _that.lastModifiedByName,
            _that.id,
            _that.postType,
            _that.status,
            _that.publishDate,
            _that.academicYearId,
            _that.description,
            _that.title,
            _that.isAllClass,
            _that.isAllLevel,
            _that.postTags,
            _that.files,
            _that.postAssociatedWithStudents,
            _that.postStudents,
            _that.postClasses,
            _that.postCourses,
            _that.postGoals,
            _that.postReactions,
            _that.postClassString,
            _that.postStudentString,
            _that.allowComment,
            _that.viewCount,
            _that.createdByName,
            _that.markedDate,
            _that.schoolId,
            _that.homeSchool,
            _that.literacy,
            _that.numeracy,
            _that.observation);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'createdById') String? createdById,
            @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
            @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
            @JsonKey(name: 'lastModifiedDateTime')
            DateTime? lastModifiedDateTime,
            @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postType') String postType,
            @JsonKey(name: 'status') String status,
            @JsonKey(name: 'publishDate') DateTime publishDate,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'isAllClass') bool? isAllClass,
            @JsonKey(name: 'isAllLevel') bool? isAllLevel,
            @JsonKey(name: 'postTags') List<PostTagDto>? postTags,
            @JsonKey(name: 'files') List<PostFileDto>? files,
            @JsonKey(name: 'postAssociatedWithStudents')
            List<PostAssociatedWithStudentsDto>? postAssociatedWithStudents,
            @JsonKey(name: 'postStudents') List<PostStudentDto>? postStudents,
            @JsonKey(name: 'postClasses') List<PostClassDto>? postClasses,
            @JsonKey(name: 'postCourses') List<PostCourseDto>? postCourses,
            @JsonKey(name: 'postGoals') List<PostGoalDto>? postGoals,
            @JsonKey(name: 'postReactions')
            List<PostReactionDto>? postReactions,
            @JsonKey(name: 'postClassString') String? postClassString,
            @JsonKey(name: 'postStudentString') String? postStudentString,
            @JsonKey(name: 'allowComment') bool? allowComment,
            @JsonKey(name: 'viewCount') int? viewCount,
            @JsonKey(name: 'createdByName') String? createdByName,
            @JsonKey(name: 'markedDate') DateTime? markedDate,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'homeSchool') String? homeSchool,
            @JsonKey(name: 'literacy') String? literacy,
            @JsonKey(name: 'numeracy') String? numeracy,
            @JsonKey(name: 'observation') String? observation)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostDto() when $default != null:
        return $default(
            _that.createdById,
            _that.createdDateTime,
            _that.lastModifiedById,
            _that.lastModifiedDateTime,
            _that.lastModifiedByName,
            _that.id,
            _that.postType,
            _that.status,
            _that.publishDate,
            _that.academicYearId,
            _that.description,
            _that.title,
            _that.isAllClass,
            _that.isAllLevel,
            _that.postTags,
            _that.files,
            _that.postAssociatedWithStudents,
            _that.postStudents,
            _that.postClasses,
            _that.postCourses,
            _that.postGoals,
            _that.postReactions,
            _that.postClassString,
            _that.postStudentString,
            _that.allowComment,
            _that.viewCount,
            _that.createdByName,
            _that.markedDate,
            _that.schoolId,
            _that.homeSchool,
            _that.literacy,
            _that.numeracy,
            _that.observation);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostDto implements PostDto {
  _PostDto(
      {@JsonKey(name: 'createdById') this.createdById,
      @JsonKey(name: 'createdDateTime') this.createdDateTime,
      @JsonKey(name: 'lastModifiedById') this.lastModifiedById,
      @JsonKey(name: 'lastModifiedDateTime') this.lastModifiedDateTime,
      @JsonKey(name: 'lastModifiedByName') this.lastModifiedByName,
      @JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postType') required this.postType,
      @JsonKey(name: 'status') required this.status,
      @JsonKey(name: 'publishDate') required this.publishDate,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'isAllClass') this.isAllClass,
      @JsonKey(name: 'isAllLevel') this.isAllLevel,
      @JsonKey(name: 'postTags') final List<PostTagDto>? postTags,
      @JsonKey(name: 'files') final List<PostFileDto>? files,
      @JsonKey(name: 'postAssociatedWithStudents')
      final List<PostAssociatedWithStudentsDto>? postAssociatedWithStudents,
      @JsonKey(name: 'postStudents') final List<PostStudentDto>? postStudents,
      @JsonKey(name: 'postClasses') final List<PostClassDto>? postClasses,
      @JsonKey(name: 'postCourses') final List<PostCourseDto>? postCourses,
      @JsonKey(name: 'postGoals') final List<PostGoalDto>? postGoals,
      @JsonKey(name: 'postReactions')
      final List<PostReactionDto>? postReactions,
      @JsonKey(name: 'postClassString') this.postClassString,
      @JsonKey(name: 'postStudentString') this.postStudentString,
      @JsonKey(name: 'allowComment') this.allowComment,
      @JsonKey(name: 'viewCount') this.viewCount,
      @JsonKey(name: 'createdByName') this.createdByName,
      @JsonKey(name: 'markedDate') this.markedDate,
      @JsonKey(name: 'schoolId') this.schoolId,
      @JsonKey(name: 'homeSchool') this.homeSchool,
      @JsonKey(name: 'literacy') this.literacy,
      @JsonKey(name: 'numeracy') this.numeracy,
      @JsonKey(name: 'observation') this.observation})
      : _postTags = postTags,
        _files = files,
        _postAssociatedWithStudents = postAssociatedWithStudents,
        _postStudents = postStudents,
        _postClasses = postClasses,
        _postCourses = postCourses,
        _postGoals = postGoals,
        _postReactions = postReactions;
  factory _PostDto.fromJson(Map<String, dynamic> json) =>
      _$PostDtoFromJson(json);

  @override
  @JsonKey(name: 'createdById')
  final String? createdById;
  @override
  @JsonKey(name: 'createdDateTime')
  final DateTime? createdDateTime;
  @override
  @JsonKey(name: 'lastModifiedById')
  final String? lastModifiedById;
  @override
  @JsonKey(name: 'lastModifiedDateTime')
  final DateTime? lastModifiedDateTime;
  @override
  @JsonKey(name: 'lastModifiedByName')
  final String? lastModifiedByName;
  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postType')
  final String postType;
  @override
  @JsonKey(name: 'status')
  final String status;
  @override
  @JsonKey(name: 'publishDate')
  final DateTime publishDate;
  @override
  @JsonKey(name: 'academicYearId')
  final String? academicYearId;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'isAllClass')
  final bool? isAllClass;
  @override
  @JsonKey(name: 'isAllLevel')
  final bool? isAllLevel;
  final List<PostTagDto>? _postTags;
  @override
  @JsonKey(name: 'postTags')
  List<PostTagDto>? get postTags {
    final value = _postTags;
    if (value == null) return null;
    if (_postTags is EqualUnmodifiableListView) return _postTags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<PostFileDto>? _files;
  @override
  @JsonKey(name: 'files')
  List<PostFileDto>? get files {
    final value = _files;
    if (value == null) return null;
    if (_files is EqualUnmodifiableListView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<PostAssociatedWithStudentsDto>? _postAssociatedWithStudents;
  @override
  @JsonKey(name: 'postAssociatedWithStudents')
  List<PostAssociatedWithStudentsDto>? get postAssociatedWithStudents {
    final value = _postAssociatedWithStudents;
    if (value == null) return null;
    if (_postAssociatedWithStudents is EqualUnmodifiableListView)
      return _postAssociatedWithStudents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<PostStudentDto>? _postStudents;
  @override
  @JsonKey(name: 'postStudents')
  List<PostStudentDto>? get postStudents {
    final value = _postStudents;
    if (value == null) return null;
    if (_postStudents is EqualUnmodifiableListView) return _postStudents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<PostClassDto>? _postClasses;
  @override
  @JsonKey(name: 'postClasses')
  List<PostClassDto>? get postClasses {
    final value = _postClasses;
    if (value == null) return null;
    if (_postClasses is EqualUnmodifiableListView) return _postClasses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<PostCourseDto>? _postCourses;
  @override
  @JsonKey(name: 'postCourses')
  List<PostCourseDto>? get postCourses {
    final value = _postCourses;
    if (value == null) return null;
    if (_postCourses is EqualUnmodifiableListView) return _postCourses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<PostGoalDto>? _postGoals;
  @override
  @JsonKey(name: 'postGoals')
  List<PostGoalDto>? get postGoals {
    final value = _postGoals;
    if (value == null) return null;
    if (_postGoals is EqualUnmodifiableListView) return _postGoals;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<PostReactionDto>? _postReactions;
  @override
  @JsonKey(name: 'postReactions')
  List<PostReactionDto>? get postReactions {
    final value = _postReactions;
    if (value == null) return null;
    if (_postReactions is EqualUnmodifiableListView) return _postReactions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'postClassString')
  final String? postClassString;
  @override
  @JsonKey(name: 'postStudentString')
  final String? postStudentString;
  @override
  @JsonKey(name: 'allowComment')
  final bool? allowComment;
  @override
  @JsonKey(name: 'viewCount')
  final int? viewCount;
  @override
  @JsonKey(name: 'createdByName')
  final String? createdByName;
  @override
  @JsonKey(name: 'markedDate')
  final DateTime? markedDate;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;
  @override
  @JsonKey(name: 'homeSchool')
  final String? homeSchool;
  @override
  @JsonKey(name: 'literacy')
  final String? literacy;
  @override
  @JsonKey(name: 'numeracy')
  final String? numeracy;
  @override
  @JsonKey(name: 'observation')
  final String? observation;

  /// Create a copy of PostDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostDtoCopyWith<_PostDto> get copyWith =>
      __$PostDtoCopyWithImpl<_PostDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostDto &&
            (identical(other.createdById, createdById) ||
                other.createdById == createdById) &&
            (identical(other.createdDateTime, createdDateTime) ||
                other.createdDateTime == createdDateTime) &&
            (identical(other.lastModifiedById, lastModifiedById) ||
                other.lastModifiedById == lastModifiedById) &&
            (identical(other.lastModifiedDateTime, lastModifiedDateTime) ||
                other.lastModifiedDateTime == lastModifiedDateTime) &&
            (identical(other.lastModifiedByName, lastModifiedByName) ||
                other.lastModifiedByName == lastModifiedByName) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postType, postType) ||
                other.postType == postType) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.publishDate, publishDate) ||
                other.publishDate == publishDate) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.isAllClass, isAllClass) ||
                other.isAllClass == isAllClass) &&
            (identical(other.isAllLevel, isAllLevel) ||
                other.isAllLevel == isAllLevel) &&
            const DeepCollectionEquality().equals(other._postTags, _postTags) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            const DeepCollectionEquality().equals(
                other._postAssociatedWithStudents,
                _postAssociatedWithStudents) &&
            const DeepCollectionEquality()
                .equals(other._postStudents, _postStudents) &&
            const DeepCollectionEquality()
                .equals(other._postClasses, _postClasses) &&
            const DeepCollectionEquality()
                .equals(other._postCourses, _postCourses) &&
            const DeepCollectionEquality()
                .equals(other._postGoals, _postGoals) &&
            const DeepCollectionEquality()
                .equals(other._postReactions, _postReactions) &&
            (identical(other.postClassString, postClassString) ||
                other.postClassString == postClassString) &&
            (identical(other.postStudentString, postStudentString) ||
                other.postStudentString == postStudentString) &&
            (identical(other.allowComment, allowComment) ||
                other.allowComment == allowComment) &&
            (identical(other.viewCount, viewCount) ||
                other.viewCount == viewCount) &&
            (identical(other.createdByName, createdByName) ||
                other.createdByName == createdByName) &&
            (identical(other.markedDate, markedDate) ||
                other.markedDate == markedDate) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.homeSchool, homeSchool) ||
                other.homeSchool == homeSchool) &&
            (identical(other.literacy, literacy) ||
                other.literacy == literacy) &&
            (identical(other.numeracy, numeracy) ||
                other.numeracy == numeracy) &&
            (identical(other.observation, observation) ||
                other.observation == observation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        createdById,
        createdDateTime,
        lastModifiedById,
        lastModifiedDateTime,
        lastModifiedByName,
        id,
        postType,
        status,
        publishDate,
        academicYearId,
        description,
        title,
        isAllClass,
        isAllLevel,
        const DeepCollectionEquality().hash(_postTags),
        const DeepCollectionEquality().hash(_files),
        const DeepCollectionEquality().hash(_postAssociatedWithStudents),
        const DeepCollectionEquality().hash(_postStudents),
        const DeepCollectionEquality().hash(_postClasses),
        const DeepCollectionEquality().hash(_postCourses),
        const DeepCollectionEquality().hash(_postGoals),
        const DeepCollectionEquality().hash(_postReactions),
        postClassString,
        postStudentString,
        allowComment,
        viewCount,
        createdByName,
        markedDate,
        schoolId,
        homeSchool,
        literacy,
        numeracy,
        observation
      ]);

  @override
  String toString() {
    return 'PostDto(createdById: $createdById, createdDateTime: $createdDateTime, lastModifiedById: $lastModifiedById, lastModifiedDateTime: $lastModifiedDateTime, lastModifiedByName: $lastModifiedByName, id: $id, postType: $postType, status: $status, publishDate: $publishDate, academicYearId: $academicYearId, description: $description, title: $title, isAllClass: $isAllClass, isAllLevel: $isAllLevel, postTags: $postTags, files: $files, postAssociatedWithStudents: $postAssociatedWithStudents, postStudents: $postStudents, postClasses: $postClasses, postCourses: $postCourses, postGoals: $postGoals, postReactions: $postReactions, postClassString: $postClassString, postStudentString: $postStudentString, allowComment: $allowComment, viewCount: $viewCount, createdByName: $createdByName, markedDate: $markedDate, schoolId: $schoolId, homeSchool: $homeSchool, literacy: $literacy, numeracy: $numeracy, observation: $observation)';
  }
}

/// @nodoc
abstract mixin class _$PostDtoCopyWith<$Res> implements $PostDtoCopyWith<$Res> {
  factory _$PostDtoCopyWith(_PostDto value, $Res Function(_PostDto) _then) =
      __$PostDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'createdById') String? createdById,
      @JsonKey(name: 'createdDateTime') DateTime? createdDateTime,
      @JsonKey(name: 'lastModifiedById') String? lastModifiedById,
      @JsonKey(name: 'lastModifiedDateTime') DateTime? lastModifiedDateTime,
      @JsonKey(name: 'lastModifiedByName') String? lastModifiedByName,
      @JsonKey(name: 'id') String id,
      @JsonKey(name: 'postType') String postType,
      @JsonKey(name: 'status') String status,
      @JsonKey(name: 'publishDate') DateTime publishDate,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'isAllClass') bool? isAllClass,
      @JsonKey(name: 'isAllLevel') bool? isAllLevel,
      @JsonKey(name: 'postTags') List<PostTagDto>? postTags,
      @JsonKey(name: 'files') List<PostFileDto>? files,
      @JsonKey(name: 'postAssociatedWithStudents')
      List<PostAssociatedWithStudentsDto>? postAssociatedWithStudents,
      @JsonKey(name: 'postStudents') List<PostStudentDto>? postStudents,
      @JsonKey(name: 'postClasses') List<PostClassDto>? postClasses,
      @JsonKey(name: 'postCourses') List<PostCourseDto>? postCourses,
      @JsonKey(name: 'postGoals') List<PostGoalDto>? postGoals,
      @JsonKey(name: 'postReactions') List<PostReactionDto>? postReactions,
      @JsonKey(name: 'postClassString') String? postClassString,
      @JsonKey(name: 'postStudentString') String? postStudentString,
      @JsonKey(name: 'allowComment') bool? allowComment,
      @JsonKey(name: 'viewCount') int? viewCount,
      @JsonKey(name: 'createdByName') String? createdByName,
      @JsonKey(name: 'markedDate') DateTime? markedDate,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'homeSchool') String? homeSchool,
      @JsonKey(name: 'literacy') String? literacy,
      @JsonKey(name: 'numeracy') String? numeracy,
      @JsonKey(name: 'observation') String? observation});
}

/// @nodoc
class __$PostDtoCopyWithImpl<$Res> implements _$PostDtoCopyWith<$Res> {
  __$PostDtoCopyWithImpl(this._self, this._then);

  final _PostDto _self;
  final $Res Function(_PostDto) _then;

  /// Create a copy of PostDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? createdById = freezed,
    Object? createdDateTime = freezed,
    Object? lastModifiedById = freezed,
    Object? lastModifiedDateTime = freezed,
    Object? lastModifiedByName = freezed,
    Object? id = null,
    Object? postType = null,
    Object? status = null,
    Object? publishDate = null,
    Object? academicYearId = freezed,
    Object? description = freezed,
    Object? title = freezed,
    Object? isAllClass = freezed,
    Object? isAllLevel = freezed,
    Object? postTags = freezed,
    Object? files = freezed,
    Object? postAssociatedWithStudents = freezed,
    Object? postStudents = freezed,
    Object? postClasses = freezed,
    Object? postCourses = freezed,
    Object? postGoals = freezed,
    Object? postReactions = freezed,
    Object? postClassString = freezed,
    Object? postStudentString = freezed,
    Object? allowComment = freezed,
    Object? viewCount = freezed,
    Object? createdByName = freezed,
    Object? markedDate = freezed,
    Object? schoolId = freezed,
    Object? homeSchool = freezed,
    Object? literacy = freezed,
    Object? numeracy = freezed,
    Object? observation = freezed,
  }) {
    return _then(_PostDto(
      createdById: freezed == createdById
          ? _self.createdById
          : createdById // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDateTime: freezed == createdDateTime
          ? _self.createdDateTime
          : createdDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastModifiedById: freezed == lastModifiedById
          ? _self.lastModifiedById
          : lastModifiedById // ignore: cast_nullable_to_non_nullable
              as String?,
      lastModifiedDateTime: freezed == lastModifiedDateTime
          ? _self.lastModifiedDateTime
          : lastModifiedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastModifiedByName: freezed == lastModifiedByName
          ? _self.lastModifiedByName
          : lastModifiedByName // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postType: null == postType
          ? _self.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      publishDate: null == publishDate
          ? _self.publishDate
          : publishDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      isAllClass: freezed == isAllClass
          ? _self.isAllClass
          : isAllClass // ignore: cast_nullable_to_non_nullable
              as bool?,
      isAllLevel: freezed == isAllLevel
          ? _self.isAllLevel
          : isAllLevel // ignore: cast_nullable_to_non_nullable
              as bool?,
      postTags: freezed == postTags
          ? _self._postTags
          : postTags // ignore: cast_nullable_to_non_nullable
              as List<PostTagDto>?,
      files: freezed == files
          ? _self._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<PostFileDto>?,
      postAssociatedWithStudents: freezed == postAssociatedWithStudents
          ? _self._postAssociatedWithStudents
          : postAssociatedWithStudents // ignore: cast_nullable_to_non_nullable
              as List<PostAssociatedWithStudentsDto>?,
      postStudents: freezed == postStudents
          ? _self._postStudents
          : postStudents // ignore: cast_nullable_to_non_nullable
              as List<PostStudentDto>?,
      postClasses: freezed == postClasses
          ? _self._postClasses
          : postClasses // ignore: cast_nullable_to_non_nullable
              as List<PostClassDto>?,
      postCourses: freezed == postCourses
          ? _self._postCourses
          : postCourses // ignore: cast_nullable_to_non_nullable
              as List<PostCourseDto>?,
      postGoals: freezed == postGoals
          ? _self._postGoals
          : postGoals // ignore: cast_nullable_to_non_nullable
              as List<PostGoalDto>?,
      postReactions: freezed == postReactions
          ? _self._postReactions
          : postReactions // ignore: cast_nullable_to_non_nullable
              as List<PostReactionDto>?,
      postClassString: freezed == postClassString
          ? _self.postClassString
          : postClassString // ignore: cast_nullable_to_non_nullable
              as String?,
      postStudentString: freezed == postStudentString
          ? _self.postStudentString
          : postStudentString // ignore: cast_nullable_to_non_nullable
              as String?,
      allowComment: freezed == allowComment
          ? _self.allowComment
          : allowComment // ignore: cast_nullable_to_non_nullable
              as bool?,
      viewCount: freezed == viewCount
          ? _self.viewCount
          : viewCount // ignore: cast_nullable_to_non_nullable
              as int?,
      createdByName: freezed == createdByName
          ? _self.createdByName
          : createdByName // ignore: cast_nullable_to_non_nullable
              as String?,
      markedDate: freezed == markedDate
          ? _self.markedDate
          : markedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      homeSchool: freezed == homeSchool
          ? _self.homeSchool
          : homeSchool // ignore: cast_nullable_to_non_nullable
              as String?,
      literacy: freezed == literacy
          ? _self.literacy
          : literacy // ignore: cast_nullable_to_non_nullable
              as String?,
      numeracy: freezed == numeracy
          ? _self.numeracy
          : numeracy // ignore: cast_nullable_to_non_nullable
              as String?,
      observation: freezed == observation
          ? _self.observation
          : observation // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostAssociatedWithStudentsDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postId')
  String get postId;
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'academicYearId')
  String get academicYearId;
  @JsonKey(name: 'courseId')
  String get courseId;
  @JsonKey(name: 'classId')
  String get classId;
  @JsonKey(name: 'studentName')
  String? get studentName;

  /// Create a copy of PostAssociatedWithStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostAssociatedWithStudentsDtoCopyWith<PostAssociatedWithStudentsDto>
      get copyWith => _$PostAssociatedWithStudentsDtoCopyWithImpl<
              PostAssociatedWithStudentsDto>(
          this as PostAssociatedWithStudentsDto, _$identity);

  /// Serializes this PostAssociatedWithStudentsDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostAssociatedWithStudentsDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, postId, studentId,
      academicYearId, courseId, classId, studentName);

  @override
  String toString() {
    return 'PostAssociatedWithStudentsDto(id: $id, postId: $postId, studentId: $studentId, academicYearId: $academicYearId, courseId: $courseId, classId: $classId, studentName: $studentName)';
  }
}

/// @nodoc
abstract mixin class $PostAssociatedWithStudentsDtoCopyWith<$Res> {
  factory $PostAssociatedWithStudentsDtoCopyWith(
          PostAssociatedWithStudentsDto value,
          $Res Function(PostAssociatedWithStudentsDto) _then) =
      _$PostAssociatedWithStudentsDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'academicYearId') String academicYearId,
      @JsonKey(name: 'courseId') String courseId,
      @JsonKey(name: 'classId') String classId,
      @JsonKey(name: 'studentName') String? studentName});
}

/// @nodoc
class _$PostAssociatedWithStudentsDtoCopyWithImpl<$Res>
    implements $PostAssociatedWithStudentsDtoCopyWith<$Res> {
  _$PostAssociatedWithStudentsDtoCopyWithImpl(this._self, this._then);

  final PostAssociatedWithStudentsDto _self;
  final $Res Function(PostAssociatedWithStudentsDto) _then;

  /// Create a copy of PostAssociatedWithStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? studentId = null,
    Object? academicYearId = null,
    Object? courseId = null,
    Object? classId = null,
    Object? studentName = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: null == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String,
      courseId: null == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String,
      classId: null == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostAssociatedWithStudentsDto].
extension PostAssociatedWithStudentsDtoPatterns
    on PostAssociatedWithStudentsDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostAssociatedWithStudentsDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostAssociatedWithStudentsDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostAssociatedWithStudentsDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostAssociatedWithStudentsDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostAssociatedWithStudentsDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostAssociatedWithStudentsDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'courseId') String courseId,
            @JsonKey(name: 'classId') String classId,
            @JsonKey(name: 'studentName') String? studentName)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostAssociatedWithStudentsDto() when $default != null:
        return $default(
            _that.id,
            _that.postId,
            _that.studentId,
            _that.academicYearId,
            _that.courseId,
            _that.classId,
            _that.studentName);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'courseId') String courseId,
            @JsonKey(name: 'classId') String classId,
            @JsonKey(name: 'studentName') String? studentName)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostAssociatedWithStudentsDto():
        return $default(
            _that.id,
            _that.postId,
            _that.studentId,
            _that.academicYearId,
            _that.courseId,
            _that.classId,
            _that.studentName);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'courseId') String courseId,
            @JsonKey(name: 'classId') String classId,
            @JsonKey(name: 'studentName') String? studentName)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostAssociatedWithStudentsDto() when $default != null:
        return $default(
            _that.id,
            _that.postId,
            _that.studentId,
            _that.academicYearId,
            _that.courseId,
            _that.classId,
            _that.studentName);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostAssociatedWithStudentsDto implements PostAssociatedWithStudentsDto {
  _PostAssociatedWithStudentsDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postId') required this.postId,
      @JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'academicYearId') required this.academicYearId,
      @JsonKey(name: 'courseId') required this.courseId,
      @JsonKey(name: 'classId') required this.classId,
      @JsonKey(name: 'studentName') this.studentName});
  factory _PostAssociatedWithStudentsDto.fromJson(Map<String, dynamic> json) =>
      _$PostAssociatedWithStudentsDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postId')
  final String postId;
  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'academicYearId')
  final String academicYearId;
  @override
  @JsonKey(name: 'courseId')
  final String courseId;
  @override
  @JsonKey(name: 'classId')
  final String classId;
  @override
  @JsonKey(name: 'studentName')
  final String? studentName;

  /// Create a copy of PostAssociatedWithStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostAssociatedWithStudentsDtoCopyWith<_PostAssociatedWithStudentsDto>
      get copyWith => __$PostAssociatedWithStudentsDtoCopyWithImpl<
          _PostAssociatedWithStudentsDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostAssociatedWithStudentsDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostAssociatedWithStudentsDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, postId, studentId,
      academicYearId, courseId, classId, studentName);

  @override
  String toString() {
    return 'PostAssociatedWithStudentsDto(id: $id, postId: $postId, studentId: $studentId, academicYearId: $academicYearId, courseId: $courseId, classId: $classId, studentName: $studentName)';
  }
}

/// @nodoc
abstract mixin class _$PostAssociatedWithStudentsDtoCopyWith<$Res>
    implements $PostAssociatedWithStudentsDtoCopyWith<$Res> {
  factory _$PostAssociatedWithStudentsDtoCopyWith(
          _PostAssociatedWithStudentsDto value,
          $Res Function(_PostAssociatedWithStudentsDto) _then) =
      __$PostAssociatedWithStudentsDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'academicYearId') String academicYearId,
      @JsonKey(name: 'courseId') String courseId,
      @JsonKey(name: 'classId') String classId,
      @JsonKey(name: 'studentName') String? studentName});
}

/// @nodoc
class __$PostAssociatedWithStudentsDtoCopyWithImpl<$Res>
    implements _$PostAssociatedWithStudentsDtoCopyWith<$Res> {
  __$PostAssociatedWithStudentsDtoCopyWithImpl(this._self, this._then);

  final _PostAssociatedWithStudentsDto _self;
  final $Res Function(_PostAssociatedWithStudentsDto) _then;

  /// Create a copy of PostAssociatedWithStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? studentId = null,
    Object? academicYearId = null,
    Object? courseId = null,
    Object? classId = null,
    Object? studentName = freezed,
  }) {
    return _then(_PostAssociatedWithStudentsDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: null == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String,
      courseId: null == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String,
      classId: null == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostClassDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postId')
  String get postId;
  @JsonKey(name: 'classId')
  String get classId;
  @JsonKey(name: 'classname')
  String? get classname;

  /// Create a copy of PostClassDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostClassDtoCopyWith<PostClassDto> get copyWith =>
      _$PostClassDtoCopyWithImpl<PostClassDto>(
          this as PostClassDto, _$identity);

  /// Serializes this PostClassDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostClassDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.classname, classname) ||
                other.classname == classname));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, postId, classId, classname);

  @override
  String toString() {
    return 'PostClassDto(id: $id, postId: $postId, classId: $classId, classname: $classname)';
  }
}

/// @nodoc
abstract mixin class $PostClassDtoCopyWith<$Res> {
  factory $PostClassDtoCopyWith(
          PostClassDto value, $Res Function(PostClassDto) _then) =
      _$PostClassDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'classId') String classId,
      @JsonKey(name: 'classname') String? classname});
}

/// @nodoc
class _$PostClassDtoCopyWithImpl<$Res> implements $PostClassDtoCopyWith<$Res> {
  _$PostClassDtoCopyWithImpl(this._self, this._then);

  final PostClassDto _self;
  final $Res Function(PostClassDto) _then;

  /// Create a copy of PostClassDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? classId = null,
    Object? classname = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      classId: null == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String,
      classname: freezed == classname
          ? _self.classname
          : classname // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostClassDto].
extension PostClassDtoPatterns on PostClassDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostClassDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostClassDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostClassDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostClassDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostClassDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostClassDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'classId') String classId,
            @JsonKey(name: 'classname') String? classname)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostClassDto() when $default != null:
        return $default(_that.id, _that.postId, _that.classId, _that.classname);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'classId') String classId,
            @JsonKey(name: 'classname') String? classname)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostClassDto():
        return $default(_that.id, _that.postId, _that.classId, _that.classname);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'classId') String classId,
            @JsonKey(name: 'classname') String? classname)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostClassDto() when $default != null:
        return $default(_that.id, _that.postId, _that.classId, _that.classname);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostClassDto implements PostClassDto {
  _PostClassDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postId') required this.postId,
      @JsonKey(name: 'classId') required this.classId,
      @JsonKey(name: 'classname') this.classname});
  factory _PostClassDto.fromJson(Map<String, dynamic> json) =>
      _$PostClassDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postId')
  final String postId;
  @override
  @JsonKey(name: 'classId')
  final String classId;
  @override
  @JsonKey(name: 'classname')
  final String? classname;

  /// Create a copy of PostClassDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostClassDtoCopyWith<_PostClassDto> get copyWith =>
      __$PostClassDtoCopyWithImpl<_PostClassDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostClassDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostClassDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.classname, classname) ||
                other.classname == classname));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, postId, classId, classname);

  @override
  String toString() {
    return 'PostClassDto(id: $id, postId: $postId, classId: $classId, classname: $classname)';
  }
}

/// @nodoc
abstract mixin class _$PostClassDtoCopyWith<$Res>
    implements $PostClassDtoCopyWith<$Res> {
  factory _$PostClassDtoCopyWith(
          _PostClassDto value, $Res Function(_PostClassDto) _then) =
      __$PostClassDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'classId') String classId,
      @JsonKey(name: 'classname') String? classname});
}

/// @nodoc
class __$PostClassDtoCopyWithImpl<$Res>
    implements _$PostClassDtoCopyWith<$Res> {
  __$PostClassDtoCopyWithImpl(this._self, this._then);

  final _PostClassDto _self;
  final $Res Function(_PostClassDto) _then;

  /// Create a copy of PostClassDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? classId = null,
    Object? classname = freezed,
  }) {
    return _then(_PostClassDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      classId: null == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String,
      classname: freezed == classname
          ? _self.classname
          : classname // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostCommentDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postId')
  String get postId;
  @JsonKey(name: 'content')
  String get content;
  @JsonKey(name: 'publishedDate')
  DateTime get publishedDate;
  @JsonKey(name: 'commentBy')
  String get commentBy;
  @JsonKey(name: 'threadId')
  String? get threadId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'replies')
  List<PostCommentDto>? get replies;
  @JsonKey(name: 'displayName')
  String? get displayName;

  /// Create a copy of PostCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostCommentDtoCopyWith<PostCommentDto> get copyWith =>
      _$PostCommentDtoCopyWithImpl<PostCommentDto>(
          this as PostCommentDto, _$identity);

  /// Serializes this PostCommentDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostCommentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.publishedDate, publishedDate) ||
                other.publishedDate == publishedDate) &&
            (identical(other.commentBy, commentBy) ||
                other.commentBy == commentBy) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(other.replies, replies) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      postId,
      content,
      publishedDate,
      commentBy,
      threadId,
      updatedDate,
      status,
      const DeepCollectionEquality().hash(replies),
      displayName);

  @override
  String toString() {
    return 'PostCommentDto(id: $id, postId: $postId, content: $content, publishedDate: $publishedDate, commentBy: $commentBy, threadId: $threadId, updatedDate: $updatedDate, status: $status, replies: $replies, displayName: $displayName)';
  }
}

/// @nodoc
abstract mixin class $PostCommentDtoCopyWith<$Res> {
  factory $PostCommentDtoCopyWith(
          PostCommentDto value, $Res Function(PostCommentDto) _then) =
      _$PostCommentDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'content') String content,
      @JsonKey(name: 'publishedDate') DateTime publishedDate,
      @JsonKey(name: 'commentBy') String commentBy,
      @JsonKey(name: 'threadId') String? threadId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'replies') List<PostCommentDto>? replies,
      @JsonKey(name: 'displayName') String? displayName});
}

/// @nodoc
class _$PostCommentDtoCopyWithImpl<$Res>
    implements $PostCommentDtoCopyWith<$Res> {
  _$PostCommentDtoCopyWithImpl(this._self, this._then);

  final PostCommentDto _self;
  final $Res Function(PostCommentDto) _then;

  /// Create a copy of PostCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? content = null,
    Object? publishedDate = null,
    Object? commentBy = null,
    Object? threadId = freezed,
    Object? updatedDate = freezed,
    Object? status = freezed,
    Object? replies = freezed,
    Object? displayName = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      publishedDate: null == publishedDate
          ? _self.publishedDate
          : publishedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      commentBy: null == commentBy
          ? _self.commentBy
          : commentBy // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: freezed == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      replies: freezed == replies
          ? _self.replies
          : replies // ignore: cast_nullable_to_non_nullable
              as List<PostCommentDto>?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostCommentDto].
extension PostCommentDtoPatterns on PostCommentDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostCommentDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostCommentDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostCommentDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCommentDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostCommentDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCommentDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'publishedDate') DateTime publishedDate,
            @JsonKey(name: 'commentBy') String commentBy,
            @JsonKey(name: 'threadId') String? threadId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'replies') List<PostCommentDto>? replies,
            @JsonKey(name: 'displayName') String? displayName)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostCommentDto() when $default != null:
        return $default(
            _that.id,
            _that.postId,
            _that.content,
            _that.publishedDate,
            _that.commentBy,
            _that.threadId,
            _that.updatedDate,
            _that.status,
            _that.replies,
            _that.displayName);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'publishedDate') DateTime publishedDate,
            @JsonKey(name: 'commentBy') String commentBy,
            @JsonKey(name: 'threadId') String? threadId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'replies') List<PostCommentDto>? replies,
            @JsonKey(name: 'displayName') String? displayName)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCommentDto():
        return $default(
            _that.id,
            _that.postId,
            _that.content,
            _that.publishedDate,
            _that.commentBy,
            _that.threadId,
            _that.updatedDate,
            _that.status,
            _that.replies,
            _that.displayName);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'publishedDate') DateTime publishedDate,
            @JsonKey(name: 'commentBy') String commentBy,
            @JsonKey(name: 'threadId') String? threadId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'replies') List<PostCommentDto>? replies,
            @JsonKey(name: 'displayName') String? displayName)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCommentDto() when $default != null:
        return $default(
            _that.id,
            _that.postId,
            _that.content,
            _that.publishedDate,
            _that.commentBy,
            _that.threadId,
            _that.updatedDate,
            _that.status,
            _that.replies,
            _that.displayName);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostCommentDto implements PostCommentDto {
  _PostCommentDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postId') required this.postId,
      @JsonKey(name: 'content') required this.content,
      @JsonKey(name: 'publishedDate') required this.publishedDate,
      @JsonKey(name: 'commentBy') required this.commentBy,
      @JsonKey(name: 'threadId') this.threadId,
      @JsonKey(name: 'updatedDate') this.updatedDate,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'replies') final List<PostCommentDto>? replies,
      @JsonKey(name: 'displayName') this.displayName})
      : _replies = replies;
  factory _PostCommentDto.fromJson(Map<String, dynamic> json) =>
      _$PostCommentDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postId')
  final String postId;
  @override
  @JsonKey(name: 'content')
  final String content;
  @override
  @JsonKey(name: 'publishedDate')
  final DateTime publishedDate;
  @override
  @JsonKey(name: 'commentBy')
  final String commentBy;
  @override
  @JsonKey(name: 'threadId')
  final String? threadId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;
  @override
  @JsonKey(name: 'status')
  final String? status;
  final List<PostCommentDto>? _replies;
  @override
  @JsonKey(name: 'replies')
  List<PostCommentDto>? get replies {
    final value = _replies;
    if (value == null) return null;
    if (_replies is EqualUnmodifiableListView) return _replies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'displayName')
  final String? displayName;

  /// Create a copy of PostCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostCommentDtoCopyWith<_PostCommentDto> get copyWith =>
      __$PostCommentDtoCopyWithImpl<_PostCommentDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostCommentDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostCommentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.publishedDate, publishedDate) ||
                other.publishedDate == publishedDate) &&
            (identical(other.commentBy, commentBy) ||
                other.commentBy == commentBy) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(other._replies, _replies) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      postId,
      content,
      publishedDate,
      commentBy,
      threadId,
      updatedDate,
      status,
      const DeepCollectionEquality().hash(_replies),
      displayName);

  @override
  String toString() {
    return 'PostCommentDto(id: $id, postId: $postId, content: $content, publishedDate: $publishedDate, commentBy: $commentBy, threadId: $threadId, updatedDate: $updatedDate, status: $status, replies: $replies, displayName: $displayName)';
  }
}

/// @nodoc
abstract mixin class _$PostCommentDtoCopyWith<$Res>
    implements $PostCommentDtoCopyWith<$Res> {
  factory _$PostCommentDtoCopyWith(
          _PostCommentDto value, $Res Function(_PostCommentDto) _then) =
      __$PostCommentDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'content') String content,
      @JsonKey(name: 'publishedDate') DateTime publishedDate,
      @JsonKey(name: 'commentBy') String commentBy,
      @JsonKey(name: 'threadId') String? threadId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'replies') List<PostCommentDto>? replies,
      @JsonKey(name: 'displayName') String? displayName});
}

/// @nodoc
class __$PostCommentDtoCopyWithImpl<$Res>
    implements _$PostCommentDtoCopyWith<$Res> {
  __$PostCommentDtoCopyWithImpl(this._self, this._then);

  final _PostCommentDto _self;
  final $Res Function(_PostCommentDto) _then;

  /// Create a copy of PostCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? content = null,
    Object? publishedDate = null,
    Object? commentBy = null,
    Object? threadId = freezed,
    Object? updatedDate = freezed,
    Object? status = freezed,
    Object? replies = freezed,
    Object? displayName = freezed,
  }) {
    return _then(_PostCommentDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      publishedDate: null == publishedDate
          ? _self.publishedDate
          : publishedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      commentBy: null == commentBy
          ? _self.commentBy
          : commentBy // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: freezed == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      replies: freezed == replies
          ? _self._replies
          : replies // ignore: cast_nullable_to_non_nullable
              as List<PostCommentDto>?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostCourseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postId')
  String get postId;
  @JsonKey(name: 'courseId')
  String get courseId;
  @JsonKey(name: 'schoolId')
  String get schoolId;
  @JsonKey(name: 'academicYearId')
  String get academicYearId;
  @JsonKey(name: 'courseName')
  String? get courseName;

  /// Create a copy of PostCourseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostCourseDtoCopyWith<PostCourseDto> get copyWith =>
      _$PostCourseDtoCopyWithImpl<PostCourseDto>(
          this as PostCourseDto, _$identity);

  /// Serializes this PostCourseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostCourseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.courseName, courseName) ||
                other.courseName == courseName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, courseId, schoolId, academicYearId, courseName);

  @override
  String toString() {
    return 'PostCourseDto(id: $id, postId: $postId, courseId: $courseId, schoolId: $schoolId, academicYearId: $academicYearId, courseName: $courseName)';
  }
}

/// @nodoc
abstract mixin class $PostCourseDtoCopyWith<$Res> {
  factory $PostCourseDtoCopyWith(
          PostCourseDto value, $Res Function(PostCourseDto) _then) =
      _$PostCourseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'courseId') String courseId,
      @JsonKey(name: 'schoolId') String schoolId,
      @JsonKey(name: 'academicYearId') String academicYearId,
      @JsonKey(name: 'courseName') String? courseName});
}

/// @nodoc
class _$PostCourseDtoCopyWithImpl<$Res>
    implements $PostCourseDtoCopyWith<$Res> {
  _$PostCourseDtoCopyWithImpl(this._self, this._then);

  final PostCourseDto _self;
  final $Res Function(PostCourseDto) _then;

  /// Create a copy of PostCourseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? courseId = null,
    Object? schoolId = null,
    Object? academicYearId = null,
    Object? courseName = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      courseId: null == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String,
      schoolId: null == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: null == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String,
      courseName: freezed == courseName
          ? _self.courseName
          : courseName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostCourseDto].
extension PostCourseDtoPatterns on PostCourseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostCourseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostCourseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostCourseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCourseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostCourseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCourseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'courseId') String courseId,
            @JsonKey(name: 'schoolId') String schoolId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'courseName') String? courseName)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostCourseDto() when $default != null:
        return $default(_that.id, _that.postId, _that.courseId, _that.schoolId,
            _that.academicYearId, _that.courseName);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'courseId') String courseId,
            @JsonKey(name: 'schoolId') String schoolId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'courseName') String? courseName)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCourseDto():
        return $default(_that.id, _that.postId, _that.courseId, _that.schoolId,
            _that.academicYearId, _that.courseName);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'courseId') String courseId,
            @JsonKey(name: 'schoolId') String schoolId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'courseName') String? courseName)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostCourseDto() when $default != null:
        return $default(_that.id, _that.postId, _that.courseId, _that.schoolId,
            _that.academicYearId, _that.courseName);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostCourseDto implements PostCourseDto {
  _PostCourseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postId') required this.postId,
      @JsonKey(name: 'courseId') required this.courseId,
      @JsonKey(name: 'schoolId') required this.schoolId,
      @JsonKey(name: 'academicYearId') required this.academicYearId,
      @JsonKey(name: 'courseName') this.courseName});
  factory _PostCourseDto.fromJson(Map<String, dynamic> json) =>
      _$PostCourseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postId')
  final String postId;
  @override
  @JsonKey(name: 'courseId')
  final String courseId;
  @override
  @JsonKey(name: 'schoolId')
  final String schoolId;
  @override
  @JsonKey(name: 'academicYearId')
  final String academicYearId;
  @override
  @JsonKey(name: 'courseName')
  final String? courseName;

  /// Create a copy of PostCourseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostCourseDtoCopyWith<_PostCourseDto> get copyWith =>
      __$PostCourseDtoCopyWithImpl<_PostCourseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostCourseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostCourseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.courseName, courseName) ||
                other.courseName == courseName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, courseId, schoolId, academicYearId, courseName);

  @override
  String toString() {
    return 'PostCourseDto(id: $id, postId: $postId, courseId: $courseId, schoolId: $schoolId, academicYearId: $academicYearId, courseName: $courseName)';
  }
}

/// @nodoc
abstract mixin class _$PostCourseDtoCopyWith<$Res>
    implements $PostCourseDtoCopyWith<$Res> {
  factory _$PostCourseDtoCopyWith(
          _PostCourseDto value, $Res Function(_PostCourseDto) _then) =
      __$PostCourseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'courseId') String courseId,
      @JsonKey(name: 'schoolId') String schoolId,
      @JsonKey(name: 'academicYearId') String academicYearId,
      @JsonKey(name: 'courseName') String? courseName});
}

/// @nodoc
class __$PostCourseDtoCopyWithImpl<$Res>
    implements _$PostCourseDtoCopyWith<$Res> {
  __$PostCourseDtoCopyWithImpl(this._self, this._then);

  final _PostCourseDto _self;
  final $Res Function(_PostCourseDto) _then;

  /// Create a copy of PostCourseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? courseId = null,
    Object? schoolId = null,
    Object? academicYearId = null,
    Object? courseName = freezed,
  }) {
    return _then(_PostCourseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      courseId: null == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String,
      schoolId: null == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: null == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String,
      courseName: freezed == courseName
          ? _self.courseName
          : courseName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostFileDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'postId')
  String? get postId;
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'contentType')
  String? get contentType;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'thumbnailUrl')
  String? get thumbnailUrl;
  @JsonKey(name: 'sequenceNo')
  int? get sequenceNo;

  /// Create a copy of PostFileDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostFileDtoCopyWith<PostFileDto> get copyWith =>
      _$PostFileDtoCopyWithImpl<PostFileDto>(this as PostFileDto, _$identity);

  /// Serializes this PostFileDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostFileDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.sequenceNo, sequenceNo) ||
                other.sequenceNo == sequenceNo));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, postId, fileName,
      contentType, fileUrl, thumbnailUrl, sequenceNo);

  @override
  String toString() {
    return 'PostFileDto(id: $id, postId: $postId, fileName: $fileName, contentType: $contentType, fileUrl: $fileUrl, thumbnailUrl: $thumbnailUrl, sequenceNo: $sequenceNo)';
  }
}

/// @nodoc
abstract mixin class $PostFileDtoCopyWith<$Res> {
  factory $PostFileDtoCopyWith(
          PostFileDto value, $Res Function(PostFileDto) _then) =
      _$PostFileDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'postId') String? postId,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'contentType') String? contentType,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'sequenceNo') int? sequenceNo});
}

/// @nodoc
class _$PostFileDtoCopyWithImpl<$Res> implements $PostFileDtoCopyWith<$Res> {
  _$PostFileDtoCopyWithImpl(this._self, this._then);

  final PostFileDto _self;
  final $Res Function(PostFileDto) _then;

  /// Create a copy of PostFileDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? postId = freezed,
    Object? fileName = freezed,
    Object? contentType = freezed,
    Object? fileUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? sequenceNo = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      postId: freezed == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      sequenceNo: freezed == sequenceNo
          ? _self.sequenceNo
          : sequenceNo // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostFileDto].
extension PostFileDtoPatterns on PostFileDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostFileDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostFileDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostFileDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostFileDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostFileDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostFileDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'postId') String? postId,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'contentType') String? contentType,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'sequenceNo') int? sequenceNo)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostFileDto() when $default != null:
        return $default(
            _that.id,
            _that.postId,
            _that.fileName,
            _that.contentType,
            _that.fileUrl,
            _that.thumbnailUrl,
            _that.sequenceNo);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'postId') String? postId,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'contentType') String? contentType,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'sequenceNo') int? sequenceNo)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostFileDto():
        return $default(
            _that.id,
            _that.postId,
            _that.fileName,
            _that.contentType,
            _that.fileUrl,
            _that.thumbnailUrl,
            _that.sequenceNo);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'postId') String? postId,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'contentType') String? contentType,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'sequenceNo') int? sequenceNo)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostFileDto() when $default != null:
        return $default(
            _that.id,
            _that.postId,
            _that.fileName,
            _that.contentType,
            _that.fileUrl,
            _that.thumbnailUrl,
            _that.sequenceNo);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostFileDto implements PostFileDto {
  _PostFileDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'postId') this.postId,
      @JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'contentType') this.contentType,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'thumbnailUrl') this.thumbnailUrl,
      @JsonKey(name: 'sequenceNo') this.sequenceNo});
  factory _PostFileDto.fromJson(Map<String, dynamic> json) =>
      _$PostFileDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'postId')
  final String? postId;
  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'contentType')
  final String? contentType;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'thumbnailUrl')
  final String? thumbnailUrl;
  @override
  @JsonKey(name: 'sequenceNo')
  final int? sequenceNo;

  /// Create a copy of PostFileDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostFileDtoCopyWith<_PostFileDto> get copyWith =>
      __$PostFileDtoCopyWithImpl<_PostFileDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostFileDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostFileDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.sequenceNo, sequenceNo) ||
                other.sequenceNo == sequenceNo));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, postId, fileName,
      contentType, fileUrl, thumbnailUrl, sequenceNo);

  @override
  String toString() {
    return 'PostFileDto(id: $id, postId: $postId, fileName: $fileName, contentType: $contentType, fileUrl: $fileUrl, thumbnailUrl: $thumbnailUrl, sequenceNo: $sequenceNo)';
  }
}

/// @nodoc
abstract mixin class _$PostFileDtoCopyWith<$Res>
    implements $PostFileDtoCopyWith<$Res> {
  factory _$PostFileDtoCopyWith(
          _PostFileDto value, $Res Function(_PostFileDto) _then) =
      __$PostFileDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'postId') String? postId,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'contentType') String? contentType,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'sequenceNo') int? sequenceNo});
}

/// @nodoc
class __$PostFileDtoCopyWithImpl<$Res> implements _$PostFileDtoCopyWith<$Res> {
  __$PostFileDtoCopyWithImpl(this._self, this._then);

  final _PostFileDto _self;
  final $Res Function(_PostFileDto) _then;

  /// Create a copy of PostFileDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? postId = freezed,
    Object? fileName = freezed,
    Object? contentType = freezed,
    Object? fileUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? sequenceNo = freezed,
  }) {
    return _then(_PostFileDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      postId: freezed == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      sequenceNo: freezed == sequenceNo
          ? _self.sequenceNo
          : sequenceNo // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PostGoalDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postId')
  String get postId;
  @JsonKey(name: 'domain')
  String? get domain;
  @JsonKey(name: 'goal')
  String? get goal;
  @JsonKey(name: 'indicator')
  String? get indicator;
  @JsonKey(name: 'masId')
  String? get masId;
  @JsonKey(name: 'masOrder')
  String? get masOrder;

  /// Create a copy of PostGoalDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostGoalDtoCopyWith<PostGoalDto> get copyWith =>
      _$PostGoalDtoCopyWithImpl<PostGoalDto>(this as PostGoalDto, _$identity);

  /// Serializes this PostGoalDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostGoalDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            (identical(other.goal, goal) || other.goal == goal) &&
            (identical(other.indicator, indicator) ||
                other.indicator == indicator) &&
            (identical(other.masId, masId) || other.masId == masId) &&
            (identical(other.masOrder, masOrder) ||
                other.masOrder == masOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, domain, goal, indicator, masId, masOrder);

  @override
  String toString() {
    return 'PostGoalDto(id: $id, postId: $postId, domain: $domain, goal: $goal, indicator: $indicator, masId: $masId, masOrder: $masOrder)';
  }
}

/// @nodoc
abstract mixin class $PostGoalDtoCopyWith<$Res> {
  factory $PostGoalDtoCopyWith(
          PostGoalDto value, $Res Function(PostGoalDto) _then) =
      _$PostGoalDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'domain') String? domain,
      @JsonKey(name: 'goal') String? goal,
      @JsonKey(name: 'indicator') String? indicator,
      @JsonKey(name: 'masId') String? masId,
      @JsonKey(name: 'masOrder') String? masOrder});
}

/// @nodoc
class _$PostGoalDtoCopyWithImpl<$Res> implements $PostGoalDtoCopyWith<$Res> {
  _$PostGoalDtoCopyWithImpl(this._self, this._then);

  final PostGoalDto _self;
  final $Res Function(PostGoalDto) _then;

  /// Create a copy of PostGoalDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? domain = freezed,
    Object? goal = freezed,
    Object? indicator = freezed,
    Object? masId = freezed,
    Object? masOrder = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      domain: freezed == domain
          ? _self.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as String?,
      goal: freezed == goal
          ? _self.goal
          : goal // ignore: cast_nullable_to_non_nullable
              as String?,
      indicator: freezed == indicator
          ? _self.indicator
          : indicator // ignore: cast_nullable_to_non_nullable
              as String?,
      masId: freezed == masId
          ? _self.masId
          : masId // ignore: cast_nullable_to_non_nullable
              as String?,
      masOrder: freezed == masOrder
          ? _self.masOrder
          : masOrder // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostGoalDto].
extension PostGoalDtoPatterns on PostGoalDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostGoalDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostGoalDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostGoalDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostGoalDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostGoalDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostGoalDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'domain') String? domain,
            @JsonKey(name: 'goal') String? goal,
            @JsonKey(name: 'indicator') String? indicator,
            @JsonKey(name: 'masId') String? masId,
            @JsonKey(name: 'masOrder') String? masOrder)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostGoalDto() when $default != null:
        return $default(_that.id, _that.postId, _that.domain, _that.goal,
            _that.indicator, _that.masId, _that.masOrder);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'domain') String? domain,
            @JsonKey(name: 'goal') String? goal,
            @JsonKey(name: 'indicator') String? indicator,
            @JsonKey(name: 'masId') String? masId,
            @JsonKey(name: 'masOrder') String? masOrder)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostGoalDto():
        return $default(_that.id, _that.postId, _that.domain, _that.goal,
            _that.indicator, _that.masId, _that.masOrder);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'domain') String? domain,
            @JsonKey(name: 'goal') String? goal,
            @JsonKey(name: 'indicator') String? indicator,
            @JsonKey(name: 'masId') String? masId,
            @JsonKey(name: 'masOrder') String? masOrder)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostGoalDto() when $default != null:
        return $default(_that.id, _that.postId, _that.domain, _that.goal,
            _that.indicator, _that.masId, _that.masOrder);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostGoalDto implements PostGoalDto {
  _PostGoalDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postId') required this.postId,
      @JsonKey(name: 'domain') this.domain,
      @JsonKey(name: 'goal') this.goal,
      @JsonKey(name: 'indicator') this.indicator,
      @JsonKey(name: 'masId') this.masId,
      @JsonKey(name: 'masOrder') this.masOrder});
  factory _PostGoalDto.fromJson(Map<String, dynamic> json) =>
      _$PostGoalDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postId')
  final String postId;
  @override
  @JsonKey(name: 'domain')
  final String? domain;
  @override
  @JsonKey(name: 'goal')
  final String? goal;
  @override
  @JsonKey(name: 'indicator')
  final String? indicator;
  @override
  @JsonKey(name: 'masId')
  final String? masId;
  @override
  @JsonKey(name: 'masOrder')
  final String? masOrder;

  /// Create a copy of PostGoalDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostGoalDtoCopyWith<_PostGoalDto> get copyWith =>
      __$PostGoalDtoCopyWithImpl<_PostGoalDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostGoalDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostGoalDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            (identical(other.goal, goal) || other.goal == goal) &&
            (identical(other.indicator, indicator) ||
                other.indicator == indicator) &&
            (identical(other.masId, masId) || other.masId == masId) &&
            (identical(other.masOrder, masOrder) ||
                other.masOrder == masOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, domain, goal, indicator, masId, masOrder);

  @override
  String toString() {
    return 'PostGoalDto(id: $id, postId: $postId, domain: $domain, goal: $goal, indicator: $indicator, masId: $masId, masOrder: $masOrder)';
  }
}

/// @nodoc
abstract mixin class _$PostGoalDtoCopyWith<$Res>
    implements $PostGoalDtoCopyWith<$Res> {
  factory _$PostGoalDtoCopyWith(
          _PostGoalDto value, $Res Function(_PostGoalDto) _then) =
      __$PostGoalDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'domain') String? domain,
      @JsonKey(name: 'goal') String? goal,
      @JsonKey(name: 'indicator') String? indicator,
      @JsonKey(name: 'masId') String? masId,
      @JsonKey(name: 'masOrder') String? masOrder});
}

/// @nodoc
class __$PostGoalDtoCopyWithImpl<$Res> implements _$PostGoalDtoCopyWith<$Res> {
  __$PostGoalDtoCopyWithImpl(this._self, this._then);

  final _PostGoalDto _self;
  final $Res Function(_PostGoalDto) _then;

  /// Create a copy of PostGoalDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? domain = freezed,
    Object? goal = freezed,
    Object? indicator = freezed,
    Object? masId = freezed,
    Object? masOrder = freezed,
  }) {
    return _then(_PostGoalDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      domain: freezed == domain
          ? _self.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as String?,
      goal: freezed == goal
          ? _self.goal
          : goal // ignore: cast_nullable_to_non_nullable
              as String?,
      indicator: freezed == indicator
          ? _self.indicator
          : indicator // ignore: cast_nullable_to_non_nullable
              as String?,
      masId: freezed == masId
          ? _self.masId
          : masId // ignore: cast_nullable_to_non_nullable
              as String?,
      masOrder: freezed == masOrder
          ? _self.masOrder
          : masOrder // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostQueryStringParametersDto {
  @JsonKey(name: 'pageNumber')
  int? get pageNumber;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'schoolId')
  String? get schoolId;
  @JsonKey(name: 'academicYearId')
  String? get academicYearId;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'postType')
  String? get postType;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'courseId')
  String? get courseId;
  @JsonKey(name: 'classId')
  String? get classId;
  @JsonKey(name: 'teacherId')
  String? get teacherId;
  @JsonKey(name: 'startDate_yyyMMdd')
  String? get startDateYyyMMdd;
  @JsonKey(name: 'endDate_yyyMMdd')
  String? get endDateYyyMMdd;
  @JsonKey(name: 'searchString')
  String? get searchString;
  @JsonKey(name: 'getMarkedDays')
  String? get getMarkedDays;
  @JsonKey(name: 'teacherIdFilter')
  String? get teacherIdFilter;
  @JsonKey(name: 'isFilterSearch')
  bool? get isFilterSearch;

  /// Create a copy of PostQueryStringParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostQueryStringParametersDtoCopyWith<PostQueryStringParametersDto>
      get copyWith => _$PostQueryStringParametersDtoCopyWithImpl<
              PostQueryStringParametersDto>(
          this as PostQueryStringParametersDto, _$identity);

  /// Serializes this PostQueryStringParametersDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostQueryStringParametersDto &&
            (identical(other.pageNumber, pageNumber) ||
                other.pageNumber == pageNumber) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.postType, postType) ||
                other.postType == postType) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.startDateYyyMMdd, startDateYyyMMdd) ||
                other.startDateYyyMMdd == startDateYyyMMdd) &&
            (identical(other.endDateYyyMMdd, endDateYyyMMdd) ||
                other.endDateYyyMMdd == endDateYyyMMdd) &&
            (identical(other.searchString, searchString) ||
                other.searchString == searchString) &&
            (identical(other.getMarkedDays, getMarkedDays) ||
                other.getMarkedDays == getMarkedDays) &&
            (identical(other.teacherIdFilter, teacherIdFilter) ||
                other.teacherIdFilter == teacherIdFilter) &&
            (identical(other.isFilterSearch, isFilterSearch) ||
                other.isFilterSearch == isFilterSearch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      pageNumber,
      pageSize,
      schoolId,
      academicYearId,
      studentId,
      postType,
      status,
      courseId,
      classId,
      teacherId,
      startDateYyyMMdd,
      endDateYyyMMdd,
      searchString,
      getMarkedDays,
      teacherIdFilter,
      isFilterSearch);

  @override
  String toString() {
    return 'PostQueryStringParametersDto(pageNumber: $pageNumber, pageSize: $pageSize, schoolId: $schoolId, academicYearId: $academicYearId, studentId: $studentId, postType: $postType, status: $status, courseId: $courseId, classId: $classId, teacherId: $teacherId, startDateYyyMMdd: $startDateYyyMMdd, endDateYyyMMdd: $endDateYyyMMdd, searchString: $searchString, getMarkedDays: $getMarkedDays, teacherIdFilter: $teacherIdFilter, isFilterSearch: $isFilterSearch)';
  }
}

/// @nodoc
abstract mixin class $PostQueryStringParametersDtoCopyWith<$Res> {
  factory $PostQueryStringParametersDtoCopyWith(
          PostQueryStringParametersDto value,
          $Res Function(PostQueryStringParametersDto) _then) =
      _$PostQueryStringParametersDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'pageNumber') int? pageNumber,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'postType') String? postType,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'courseId') String? courseId,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'startDate_yyyMMdd') String? startDateYyyMMdd,
      @JsonKey(name: 'endDate_yyyMMdd') String? endDateYyyMMdd,
      @JsonKey(name: 'searchString') String? searchString,
      @JsonKey(name: 'getMarkedDays') String? getMarkedDays,
      @JsonKey(name: 'teacherIdFilter') String? teacherIdFilter,
      @JsonKey(name: 'isFilterSearch') bool? isFilterSearch});
}

/// @nodoc
class _$PostQueryStringParametersDtoCopyWithImpl<$Res>
    implements $PostQueryStringParametersDtoCopyWith<$Res> {
  _$PostQueryStringParametersDtoCopyWithImpl(this._self, this._then);

  final PostQueryStringParametersDto _self;
  final $Res Function(PostQueryStringParametersDto) _then;

  /// Create a copy of PostQueryStringParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageNumber = freezed,
    Object? pageSize = freezed,
    Object? schoolId = freezed,
    Object? academicYearId = freezed,
    Object? studentId = freezed,
    Object? postType = freezed,
    Object? status = freezed,
    Object? courseId = freezed,
    Object? classId = freezed,
    Object? teacherId = freezed,
    Object? startDateYyyMMdd = freezed,
    Object? endDateYyyMMdd = freezed,
    Object? searchString = freezed,
    Object? getMarkedDays = freezed,
    Object? teacherIdFilter = freezed,
    Object? isFilterSearch = freezed,
  }) {
    return _then(_self.copyWith(
      pageNumber: freezed == pageNumber
          ? _self.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      postType: freezed == postType
          ? _self.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      courseId: freezed == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      startDateYyyMMdd: freezed == startDateYyyMMdd
          ? _self.startDateYyyMMdd
          : startDateYyyMMdd // ignore: cast_nullable_to_non_nullable
              as String?,
      endDateYyyMMdd: freezed == endDateYyyMMdd
          ? _self.endDateYyyMMdd
          : endDateYyyMMdd // ignore: cast_nullable_to_non_nullable
              as String?,
      searchString: freezed == searchString
          ? _self.searchString
          : searchString // ignore: cast_nullable_to_non_nullable
              as String?,
      getMarkedDays: freezed == getMarkedDays
          ? _self.getMarkedDays
          : getMarkedDays // ignore: cast_nullable_to_non_nullable
              as String?,
      teacherIdFilter: freezed == teacherIdFilter
          ? _self.teacherIdFilter
          : teacherIdFilter // ignore: cast_nullable_to_non_nullable
              as String?,
      isFilterSearch: freezed == isFilterSearch
          ? _self.isFilterSearch
          : isFilterSearch // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostQueryStringParametersDto].
extension PostQueryStringParametersDtoPatterns on PostQueryStringParametersDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostQueryStringParametersDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostQueryStringParametersDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostQueryStringParametersDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostQueryStringParametersDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostQueryStringParametersDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostQueryStringParametersDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'pageNumber') int? pageNumber,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'postType') String? postType,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'courseId') String? courseId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'startDate_yyyMMdd') String? startDateYyyMMdd,
            @JsonKey(name: 'endDate_yyyMMdd') String? endDateYyyMMdd,
            @JsonKey(name: 'searchString') String? searchString,
            @JsonKey(name: 'getMarkedDays') String? getMarkedDays,
            @JsonKey(name: 'teacherIdFilter') String? teacherIdFilter,
            @JsonKey(name: 'isFilterSearch') bool? isFilterSearch)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostQueryStringParametersDto() when $default != null:
        return $default(
            _that.pageNumber,
            _that.pageSize,
            _that.schoolId,
            _that.academicYearId,
            _that.studentId,
            _that.postType,
            _that.status,
            _that.courseId,
            _that.classId,
            _that.teacherId,
            _that.startDateYyyMMdd,
            _that.endDateYyyMMdd,
            _that.searchString,
            _that.getMarkedDays,
            _that.teacherIdFilter,
            _that.isFilterSearch);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'pageNumber') int? pageNumber,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'postType') String? postType,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'courseId') String? courseId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'startDate_yyyMMdd') String? startDateYyyMMdd,
            @JsonKey(name: 'endDate_yyyMMdd') String? endDateYyyMMdd,
            @JsonKey(name: 'searchString') String? searchString,
            @JsonKey(name: 'getMarkedDays') String? getMarkedDays,
            @JsonKey(name: 'teacherIdFilter') String? teacherIdFilter,
            @JsonKey(name: 'isFilterSearch') bool? isFilterSearch)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostQueryStringParametersDto():
        return $default(
            _that.pageNumber,
            _that.pageSize,
            _that.schoolId,
            _that.academicYearId,
            _that.studentId,
            _that.postType,
            _that.status,
            _that.courseId,
            _that.classId,
            _that.teacherId,
            _that.startDateYyyMMdd,
            _that.endDateYyyMMdd,
            _that.searchString,
            _that.getMarkedDays,
            _that.teacherIdFilter,
            _that.isFilterSearch);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'pageNumber') int? pageNumber,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'postType') String? postType,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'courseId') String? courseId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'startDate_yyyMMdd') String? startDateYyyMMdd,
            @JsonKey(name: 'endDate_yyyMMdd') String? endDateYyyMMdd,
            @JsonKey(name: 'searchString') String? searchString,
            @JsonKey(name: 'getMarkedDays') String? getMarkedDays,
            @JsonKey(name: 'teacherIdFilter') String? teacherIdFilter,
            @JsonKey(name: 'isFilterSearch') bool? isFilterSearch)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostQueryStringParametersDto() when $default != null:
        return $default(
            _that.pageNumber,
            _that.pageSize,
            _that.schoolId,
            _that.academicYearId,
            _that.studentId,
            _that.postType,
            _that.status,
            _that.courseId,
            _that.classId,
            _that.teacherId,
            _that.startDateYyyMMdd,
            _that.endDateYyyMMdd,
            _that.searchString,
            _that.getMarkedDays,
            _that.teacherIdFilter,
            _that.isFilterSearch);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostQueryStringParametersDto implements PostQueryStringParametersDto {
  _PostQueryStringParametersDto(
      {@JsonKey(name: 'pageNumber') this.pageNumber,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'schoolId') this.schoolId,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'postType') this.postType,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'courseId') this.courseId,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'startDate_yyyMMdd') this.startDateYyyMMdd,
      @JsonKey(name: 'endDate_yyyMMdd') this.endDateYyyMMdd,
      @JsonKey(name: 'searchString') this.searchString,
      @JsonKey(name: 'getMarkedDays') this.getMarkedDays,
      @JsonKey(name: 'teacherIdFilter') this.teacherIdFilter,
      @JsonKey(name: 'isFilterSearch') this.isFilterSearch});
  factory _PostQueryStringParametersDto.fromJson(Map<String, dynamic> json) =>
      _$PostQueryStringParametersDtoFromJson(json);

  @override
  @JsonKey(name: 'pageNumber')
  final int? pageNumber;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;
  @override
  @JsonKey(name: 'academicYearId')
  final String? academicYearId;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'postType')
  final String? postType;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'courseId')
  final String? courseId;
  @override
  @JsonKey(name: 'classId')
  final String? classId;
  @override
  @JsonKey(name: 'teacherId')
  final String? teacherId;
  @override
  @JsonKey(name: 'startDate_yyyMMdd')
  final String? startDateYyyMMdd;
  @override
  @JsonKey(name: 'endDate_yyyMMdd')
  final String? endDateYyyMMdd;
  @override
  @JsonKey(name: 'searchString')
  final String? searchString;
  @override
  @JsonKey(name: 'getMarkedDays')
  final String? getMarkedDays;
  @override
  @JsonKey(name: 'teacherIdFilter')
  final String? teacherIdFilter;
  @override
  @JsonKey(name: 'isFilterSearch')
  final bool? isFilterSearch;

  /// Create a copy of PostQueryStringParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostQueryStringParametersDtoCopyWith<_PostQueryStringParametersDto>
      get copyWith => __$PostQueryStringParametersDtoCopyWithImpl<
          _PostQueryStringParametersDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostQueryStringParametersDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostQueryStringParametersDto &&
            (identical(other.pageNumber, pageNumber) ||
                other.pageNumber == pageNumber) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.postType, postType) ||
                other.postType == postType) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.startDateYyyMMdd, startDateYyyMMdd) ||
                other.startDateYyyMMdd == startDateYyyMMdd) &&
            (identical(other.endDateYyyMMdd, endDateYyyMMdd) ||
                other.endDateYyyMMdd == endDateYyyMMdd) &&
            (identical(other.searchString, searchString) ||
                other.searchString == searchString) &&
            (identical(other.getMarkedDays, getMarkedDays) ||
                other.getMarkedDays == getMarkedDays) &&
            (identical(other.teacherIdFilter, teacherIdFilter) ||
                other.teacherIdFilter == teacherIdFilter) &&
            (identical(other.isFilterSearch, isFilterSearch) ||
                other.isFilterSearch == isFilterSearch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      pageNumber,
      pageSize,
      schoolId,
      academicYearId,
      studentId,
      postType,
      status,
      courseId,
      classId,
      teacherId,
      startDateYyyMMdd,
      endDateYyyMMdd,
      searchString,
      getMarkedDays,
      teacherIdFilter,
      isFilterSearch);

  @override
  String toString() {
    return 'PostQueryStringParametersDto(pageNumber: $pageNumber, pageSize: $pageSize, schoolId: $schoolId, academicYearId: $academicYearId, studentId: $studentId, postType: $postType, status: $status, courseId: $courseId, classId: $classId, teacherId: $teacherId, startDateYyyMMdd: $startDateYyyMMdd, endDateYyyMMdd: $endDateYyyMMdd, searchString: $searchString, getMarkedDays: $getMarkedDays, teacherIdFilter: $teacherIdFilter, isFilterSearch: $isFilterSearch)';
  }
}

/// @nodoc
abstract mixin class _$PostQueryStringParametersDtoCopyWith<$Res>
    implements $PostQueryStringParametersDtoCopyWith<$Res> {
  factory _$PostQueryStringParametersDtoCopyWith(
          _PostQueryStringParametersDto value,
          $Res Function(_PostQueryStringParametersDto) _then) =
      __$PostQueryStringParametersDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'pageNumber') int? pageNumber,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'postType') String? postType,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'courseId') String? courseId,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'startDate_yyyMMdd') String? startDateYyyMMdd,
      @JsonKey(name: 'endDate_yyyMMdd') String? endDateYyyMMdd,
      @JsonKey(name: 'searchString') String? searchString,
      @JsonKey(name: 'getMarkedDays') String? getMarkedDays,
      @JsonKey(name: 'teacherIdFilter') String? teacherIdFilter,
      @JsonKey(name: 'isFilterSearch') bool? isFilterSearch});
}

/// @nodoc
class __$PostQueryStringParametersDtoCopyWithImpl<$Res>
    implements _$PostQueryStringParametersDtoCopyWith<$Res> {
  __$PostQueryStringParametersDtoCopyWithImpl(this._self, this._then);

  final _PostQueryStringParametersDto _self;
  final $Res Function(_PostQueryStringParametersDto) _then;

  /// Create a copy of PostQueryStringParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? pageNumber = freezed,
    Object? pageSize = freezed,
    Object? schoolId = freezed,
    Object? academicYearId = freezed,
    Object? studentId = freezed,
    Object? postType = freezed,
    Object? status = freezed,
    Object? courseId = freezed,
    Object? classId = freezed,
    Object? teacherId = freezed,
    Object? startDateYyyMMdd = freezed,
    Object? endDateYyyMMdd = freezed,
    Object? searchString = freezed,
    Object? getMarkedDays = freezed,
    Object? teacherIdFilter = freezed,
    Object? isFilterSearch = freezed,
  }) {
    return _then(_PostQueryStringParametersDto(
      pageNumber: freezed == pageNumber
          ? _self.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      postType: freezed == postType
          ? _self.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      courseId: freezed == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      startDateYyyMMdd: freezed == startDateYyyMMdd
          ? _self.startDateYyyMMdd
          : startDateYyyMMdd // ignore: cast_nullable_to_non_nullable
              as String?,
      endDateYyyMMdd: freezed == endDateYyyMMdd
          ? _self.endDateYyyMMdd
          : endDateYyyMMdd // ignore: cast_nullable_to_non_nullable
              as String?,
      searchString: freezed == searchString
          ? _self.searchString
          : searchString // ignore: cast_nullable_to_non_nullable
              as String?,
      getMarkedDays: freezed == getMarkedDays
          ? _self.getMarkedDays
          : getMarkedDays // ignore: cast_nullable_to_non_nullable
              as String?,
      teacherIdFilter: freezed == teacherIdFilter
          ? _self.teacherIdFilter
          : teacherIdFilter // ignore: cast_nullable_to_non_nullable
              as String?,
      isFilterSearch: freezed == isFilterSearch
          ? _self.isFilterSearch
          : isFilterSearch // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$PostReactionDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postId')
  String get postId;
  @JsonKey(name: 'reactionType')
  String? get reactionType;
  @JsonKey(name: 'reactionUserId')
  String? get reactionUserId;
  @JsonKey(name: 'reactionUserName')
  String? get reactionUserName;

  /// Create a copy of PostReactionDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostReactionDtoCopyWith<PostReactionDto> get copyWith =>
      _$PostReactionDtoCopyWithImpl<PostReactionDto>(
          this as PostReactionDto, _$identity);

  /// Serializes this PostReactionDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostReactionDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.reactionType, reactionType) ||
                other.reactionType == reactionType) &&
            (identical(other.reactionUserId, reactionUserId) ||
                other.reactionUserId == reactionUserId) &&
            (identical(other.reactionUserName, reactionUserName) ||
                other.reactionUserName == reactionUserName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, reactionType, reactionUserId, reactionUserName);

  @override
  String toString() {
    return 'PostReactionDto(id: $id, postId: $postId, reactionType: $reactionType, reactionUserId: $reactionUserId, reactionUserName: $reactionUserName)';
  }
}

/// @nodoc
abstract mixin class $PostReactionDtoCopyWith<$Res> {
  factory $PostReactionDtoCopyWith(
          PostReactionDto value, $Res Function(PostReactionDto) _then) =
      _$PostReactionDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'reactionType') String? reactionType,
      @JsonKey(name: 'reactionUserId') String? reactionUserId,
      @JsonKey(name: 'reactionUserName') String? reactionUserName});
}

/// @nodoc
class _$PostReactionDtoCopyWithImpl<$Res>
    implements $PostReactionDtoCopyWith<$Res> {
  _$PostReactionDtoCopyWithImpl(this._self, this._then);

  final PostReactionDto _self;
  final $Res Function(PostReactionDto) _then;

  /// Create a copy of PostReactionDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? reactionType = freezed,
    Object? reactionUserId = freezed,
    Object? reactionUserName = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      reactionType: freezed == reactionType
          ? _self.reactionType
          : reactionType // ignore: cast_nullable_to_non_nullable
              as String?,
      reactionUserId: freezed == reactionUserId
          ? _self.reactionUserId
          : reactionUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      reactionUserName: freezed == reactionUserName
          ? _self.reactionUserName
          : reactionUserName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostReactionDto].
extension PostReactionDtoPatterns on PostReactionDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostReactionDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostReactionDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostReactionDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostReactionDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostReactionDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostReactionDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'reactionType') String? reactionType,
            @JsonKey(name: 'reactionUserId') String? reactionUserId,
            @JsonKey(name: 'reactionUserName') String? reactionUserName)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostReactionDto() when $default != null:
        return $default(_that.id, _that.postId, _that.reactionType,
            _that.reactionUserId, _that.reactionUserName);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'reactionType') String? reactionType,
            @JsonKey(name: 'reactionUserId') String? reactionUserId,
            @JsonKey(name: 'reactionUserName') String? reactionUserName)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostReactionDto():
        return $default(_that.id, _that.postId, _that.reactionType,
            _that.reactionUserId, _that.reactionUserName);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'reactionType') String? reactionType,
            @JsonKey(name: 'reactionUserId') String? reactionUserId,
            @JsonKey(name: 'reactionUserName') String? reactionUserName)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostReactionDto() when $default != null:
        return $default(_that.id, _that.postId, _that.reactionType,
            _that.reactionUserId, _that.reactionUserName);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostReactionDto implements PostReactionDto {
  _PostReactionDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postId') required this.postId,
      @JsonKey(name: 'reactionType') this.reactionType,
      @JsonKey(name: 'reactionUserId') this.reactionUserId,
      @JsonKey(name: 'reactionUserName') this.reactionUserName});
  factory _PostReactionDto.fromJson(Map<String, dynamic> json) =>
      _$PostReactionDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postId')
  final String postId;
  @override
  @JsonKey(name: 'reactionType')
  final String? reactionType;
  @override
  @JsonKey(name: 'reactionUserId')
  final String? reactionUserId;
  @override
  @JsonKey(name: 'reactionUserName')
  final String? reactionUserName;

  /// Create a copy of PostReactionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostReactionDtoCopyWith<_PostReactionDto> get copyWith =>
      __$PostReactionDtoCopyWithImpl<_PostReactionDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostReactionDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostReactionDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.reactionType, reactionType) ||
                other.reactionType == reactionType) &&
            (identical(other.reactionUserId, reactionUserId) ||
                other.reactionUserId == reactionUserId) &&
            (identical(other.reactionUserName, reactionUserName) ||
                other.reactionUserName == reactionUserName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, reactionType, reactionUserId, reactionUserName);

  @override
  String toString() {
    return 'PostReactionDto(id: $id, postId: $postId, reactionType: $reactionType, reactionUserId: $reactionUserId, reactionUserName: $reactionUserName)';
  }
}

/// @nodoc
abstract mixin class _$PostReactionDtoCopyWith<$Res>
    implements $PostReactionDtoCopyWith<$Res> {
  factory _$PostReactionDtoCopyWith(
          _PostReactionDto value, $Res Function(_PostReactionDto) _then) =
      __$PostReactionDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'reactionType') String? reactionType,
      @JsonKey(name: 'reactionUserId') String? reactionUserId,
      @JsonKey(name: 'reactionUserName') String? reactionUserName});
}

/// @nodoc
class __$PostReactionDtoCopyWithImpl<$Res>
    implements _$PostReactionDtoCopyWith<$Res> {
  __$PostReactionDtoCopyWithImpl(this._self, this._then);

  final _PostReactionDto _self;
  final $Res Function(_PostReactionDto) _then;

  /// Create a copy of PostReactionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? reactionType = freezed,
    Object? reactionUserId = freezed,
    Object? reactionUserName = freezed,
  }) {
    return _then(_PostReactionDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      reactionType: freezed == reactionType
          ? _self.reactionType
          : reactionType // ignore: cast_nullable_to_non_nullable
              as String?,
      reactionUserId: freezed == reactionUserId
          ? _self.reactionUserId
          : reactionUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      reactionUserName: freezed == reactionUserName
          ? _self.reactionUserName
          : reactionUserName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostStudentDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'postId')
  String get postId;
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'academicYearId')
  String get academicYearId;
  @JsonKey(name: 'studentName')
  String? get studentName;

  /// Create a copy of PostStudentDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostStudentDtoCopyWith<PostStudentDto> get copyWith =>
      _$PostStudentDtoCopyWithImpl<PostStudentDto>(
          this as PostStudentDto, _$identity);

  /// Serializes this PostStudentDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostStudentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, studentId, academicYearId, studentName);

  @override
  String toString() {
    return 'PostStudentDto(id: $id, postId: $postId, studentId: $studentId, academicYearId: $academicYearId, studentName: $studentName)';
  }
}

/// @nodoc
abstract mixin class $PostStudentDtoCopyWith<$Res> {
  factory $PostStudentDtoCopyWith(
          PostStudentDto value, $Res Function(PostStudentDto) _then) =
      _$PostStudentDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'academicYearId') String academicYearId,
      @JsonKey(name: 'studentName') String? studentName});
}

/// @nodoc
class _$PostStudentDtoCopyWithImpl<$Res>
    implements $PostStudentDtoCopyWith<$Res> {
  _$PostStudentDtoCopyWithImpl(this._self, this._then);

  final PostStudentDto _self;
  final $Res Function(PostStudentDto) _then;

  /// Create a copy of PostStudentDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? studentId = null,
    Object? academicYearId = null,
    Object? studentName = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: null == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostStudentDto].
extension PostStudentDtoPatterns on PostStudentDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostStudentDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostStudentDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostStudentDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostStudentDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostStudentDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostStudentDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'studentName') String? studentName)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostStudentDto() when $default != null:
        return $default(_that.id, _that.postId, _that.studentId,
            _that.academicYearId, _that.studentName);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'studentName') String? studentName)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostStudentDto():
        return $default(_that.id, _that.postId, _that.studentId,
            _that.academicYearId, _that.studentName);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'postId') String postId,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'academicYearId') String academicYearId,
            @JsonKey(name: 'studentName') String? studentName)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostStudentDto() when $default != null:
        return $default(_that.id, _that.postId, _that.studentId,
            _that.academicYearId, _that.studentName);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostStudentDto implements PostStudentDto {
  _PostStudentDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'postId') required this.postId,
      @JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'academicYearId') required this.academicYearId,
      @JsonKey(name: 'studentName') this.studentName});
  factory _PostStudentDto.fromJson(Map<String, dynamic> json) =>
      _$PostStudentDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'postId')
  final String postId;
  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'academicYearId')
  final String academicYearId;
  @override
  @JsonKey(name: 'studentName')
  final String? studentName;

  /// Create a copy of PostStudentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostStudentDtoCopyWith<_PostStudentDto> get copyWith =>
      __$PostStudentDtoCopyWithImpl<_PostStudentDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostStudentDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostStudentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.postId, postId) || other.postId == postId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, postId, studentId, academicYearId, studentName);

  @override
  String toString() {
    return 'PostStudentDto(id: $id, postId: $postId, studentId: $studentId, academicYearId: $academicYearId, studentName: $studentName)';
  }
}

/// @nodoc
abstract mixin class _$PostStudentDtoCopyWith<$Res>
    implements $PostStudentDtoCopyWith<$Res> {
  factory _$PostStudentDtoCopyWith(
          _PostStudentDto value, $Res Function(_PostStudentDto) _then) =
      __$PostStudentDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'postId') String postId,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'academicYearId') String academicYearId,
      @JsonKey(name: 'studentName') String? studentName});
}

/// @nodoc
class __$PostStudentDtoCopyWithImpl<$Res>
    implements _$PostStudentDtoCopyWith<$Res> {
  __$PostStudentDtoCopyWithImpl(this._self, this._then);

  final _PostStudentDto _self;
  final $Res Function(_PostStudentDto) _then;

  /// Create a copy of PostStudentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? postId = null,
    Object? studentId = null,
    Object? academicYearId = null,
    Object? studentName = freezed,
  }) {
    return _then(_PostStudentDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      postId: null == postId
          ? _self.postId
          : postId // ignore: cast_nullable_to_non_nullable
              as String,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: null == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostTagDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'tag')
  String? get tag;

  /// Create a copy of PostTagDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostTagDtoCopyWith<PostTagDto> get copyWith =>
      _$PostTagDtoCopyWithImpl<PostTagDto>(this as PostTagDto, _$identity);

  /// Serializes this PostTagDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostTagDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.tag, tag) || other.tag == tag));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, tag);

  @override
  String toString() {
    return 'PostTagDto(id: $id, tag: $tag)';
  }
}

/// @nodoc
abstract mixin class $PostTagDtoCopyWith<$Res> {
  factory $PostTagDtoCopyWith(
          PostTagDto value, $Res Function(PostTagDto) _then) =
      _$PostTagDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id, @JsonKey(name: 'tag') String? tag});
}

/// @nodoc
class _$PostTagDtoCopyWithImpl<$Res> implements $PostTagDtoCopyWith<$Res> {
  _$PostTagDtoCopyWithImpl(this._self, this._then);

  final PostTagDto _self;
  final $Res Function(PostTagDto) _then;

  /// Create a copy of PostTagDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? tag = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      tag: freezed == tag
          ? _self.tag
          : tag // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostTagDto].
extension PostTagDtoPatterns on PostTagDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostTagDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostTagDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostTagDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostTagDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostTagDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostTagDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id, @JsonKey(name: 'tag') String? tag)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostTagDto() when $default != null:
        return $default(_that.id, _that.tag);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id, @JsonKey(name: 'tag') String? tag)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostTagDto():
        return $default(_that.id, _that.tag);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id, @JsonKey(name: 'tag') String? tag)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostTagDto() when $default != null:
        return $default(_that.id, _that.tag);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostTagDto implements PostTagDto {
  _PostTagDto({@JsonKey(name: 'id') this.id, @JsonKey(name: 'tag') this.tag});
  factory _PostTagDto.fromJson(Map<String, dynamic> json) =>
      _$PostTagDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'tag')
  final String? tag;

  /// Create a copy of PostTagDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostTagDtoCopyWith<_PostTagDto> get copyWith =>
      __$PostTagDtoCopyWithImpl<_PostTagDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostTagDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostTagDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.tag, tag) || other.tag == tag));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, tag);

  @override
  String toString() {
    return 'PostTagDto(id: $id, tag: $tag)';
  }
}

/// @nodoc
abstract mixin class _$PostTagDtoCopyWith<$Res>
    implements $PostTagDtoCopyWith<$Res> {
  factory _$PostTagDtoCopyWith(
          _PostTagDto value, $Res Function(_PostTagDto) _then) =
      __$PostTagDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id, @JsonKey(name: 'tag') String? tag});
}

/// @nodoc
class __$PostTagDtoCopyWithImpl<$Res> implements _$PostTagDtoCopyWith<$Res> {
  __$PostTagDtoCopyWithImpl(this._self, this._then);

  final _PostTagDto _self;
  final $Res Function(_PostTagDto) _then;

  /// Create a copy of PostTagDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? tag = freezed,
  }) {
    return _then(_PostTagDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      tag: freezed == tag
          ? _self.tag
          : tag // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PostToPDFParametersDto {
  @JsonKey(name: 'schoolId')
  String get schoolId;
  @JsonKey(name: 'academicYearId')
  String? get academicYearId;
  @JsonKey(name: 'studentIds')
  List<String>? get studentIds;
  @JsonKey(name: 'postType')
  String? get postType;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'courseId')
  String? get courseId;
  @JsonKey(name: 'classId')
  String? get classId;
  @JsonKey(name: 'startDate')
  DateTime? get startDate;
  @JsonKey(name: 'endDate')
  DateTime? get endDate;
  @JsonKey(name: 'separateFilePerStudent')
  bool? get separateFilePerStudent;

  /// Create a copy of PostToPDFParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PostToPDFParametersDtoCopyWith<PostToPDFParametersDto> get copyWith =>
      _$PostToPDFParametersDtoCopyWithImpl<PostToPDFParametersDto>(
          this as PostToPDFParametersDto, _$identity);

  /// Serializes this PostToPDFParametersDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PostToPDFParametersDto &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            const DeepCollectionEquality()
                .equals(other.studentIds, studentIds) &&
            (identical(other.postType, postType) ||
                other.postType == postType) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.separateFilePerStudent, separateFilePerStudent) ||
                other.separateFilePerStudent == separateFilePerStudent));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      schoolId,
      academicYearId,
      const DeepCollectionEquality().hash(studentIds),
      postType,
      status,
      courseId,
      classId,
      startDate,
      endDate,
      separateFilePerStudent);

  @override
  String toString() {
    return 'PostToPDFParametersDto(schoolId: $schoolId, academicYearId: $academicYearId, studentIds: $studentIds, postType: $postType, status: $status, courseId: $courseId, classId: $classId, startDate: $startDate, endDate: $endDate, separateFilePerStudent: $separateFilePerStudent)';
  }
}

/// @nodoc
abstract mixin class $PostToPDFParametersDtoCopyWith<$Res> {
  factory $PostToPDFParametersDtoCopyWith(PostToPDFParametersDto value,
          $Res Function(PostToPDFParametersDto) _then) =
      _$PostToPDFParametersDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'schoolId') String schoolId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'studentIds') List<String>? studentIds,
      @JsonKey(name: 'postType') String? postType,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'courseId') String? courseId,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'separateFilePerStudent') bool? separateFilePerStudent});
}

/// @nodoc
class _$PostToPDFParametersDtoCopyWithImpl<$Res>
    implements $PostToPDFParametersDtoCopyWith<$Res> {
  _$PostToPDFParametersDtoCopyWithImpl(this._self, this._then);

  final PostToPDFParametersDto _self;
  final $Res Function(PostToPDFParametersDto) _then;

  /// Create a copy of PostToPDFParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schoolId = null,
    Object? academicYearId = freezed,
    Object? studentIds = freezed,
    Object? postType = freezed,
    Object? status = freezed,
    Object? courseId = freezed,
    Object? classId = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? separateFilePerStudent = freezed,
  }) {
    return _then(_self.copyWith(
      schoolId: null == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentIds: freezed == studentIds
          ? _self.studentIds
          : studentIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      postType: freezed == postType
          ? _self.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      courseId: freezed == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      separateFilePerStudent: freezed == separateFilePerStudent
          ? _self.separateFilePerStudent
          : separateFilePerStudent // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PostToPDFParametersDto].
extension PostToPDFParametersDtoPatterns on PostToPDFParametersDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PostToPDFParametersDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostToPDFParametersDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PostToPDFParametersDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostToPDFParametersDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PostToPDFParametersDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostToPDFParametersDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'schoolId') String schoolId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentIds') List<String>? studentIds,
            @JsonKey(name: 'postType') String? postType,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'courseId') String? courseId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'separateFilePerStudent')
            bool? separateFilePerStudent)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PostToPDFParametersDto() when $default != null:
        return $default(
            _that.schoolId,
            _that.academicYearId,
            _that.studentIds,
            _that.postType,
            _that.status,
            _that.courseId,
            _that.classId,
            _that.startDate,
            _that.endDate,
            _that.separateFilePerStudent);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'schoolId') String schoolId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentIds') List<String>? studentIds,
            @JsonKey(name: 'postType') String? postType,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'courseId') String? courseId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'separateFilePerStudent')
            bool? separateFilePerStudent)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostToPDFParametersDto():
        return $default(
            _that.schoolId,
            _that.academicYearId,
            _that.studentIds,
            _that.postType,
            _that.status,
            _that.courseId,
            _that.classId,
            _that.startDate,
            _that.endDate,
            _that.separateFilePerStudent);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'schoolId') String schoolId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'studentIds') List<String>? studentIds,
            @JsonKey(name: 'postType') String? postType,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'courseId') String? courseId,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'startDate') DateTime? startDate,
            @JsonKey(name: 'endDate') DateTime? endDate,
            @JsonKey(name: 'separateFilePerStudent')
            bool? separateFilePerStudent)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PostToPDFParametersDto() when $default != null:
        return $default(
            _that.schoolId,
            _that.academicYearId,
            _that.studentIds,
            _that.postType,
            _that.status,
            _that.courseId,
            _that.classId,
            _that.startDate,
            _that.endDate,
            _that.separateFilePerStudent);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PostToPDFParametersDto implements PostToPDFParametersDto {
  _PostToPDFParametersDto(
      {@JsonKey(name: 'schoolId') required this.schoolId,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'studentIds') final List<String>? studentIds,
      @JsonKey(name: 'postType') this.postType,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'courseId') this.courseId,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'separateFilePerStudent') this.separateFilePerStudent})
      : _studentIds = studentIds;
  factory _PostToPDFParametersDto.fromJson(Map<String, dynamic> json) =>
      _$PostToPDFParametersDtoFromJson(json);

  @override
  @JsonKey(name: 'schoolId')
  final String schoolId;
  @override
  @JsonKey(name: 'academicYearId')
  final String? academicYearId;
  final List<String>? _studentIds;
  @override
  @JsonKey(name: 'studentIds')
  List<String>? get studentIds {
    final value = _studentIds;
    if (value == null) return null;
    if (_studentIds is EqualUnmodifiableListView) return _studentIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'postType')
  final String? postType;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'courseId')
  final String? courseId;
  @override
  @JsonKey(name: 'classId')
  final String? classId;
  @override
  @JsonKey(name: 'startDate')
  final DateTime? startDate;
  @override
  @JsonKey(name: 'endDate')
  final DateTime? endDate;
  @override
  @JsonKey(name: 'separateFilePerStudent')
  final bool? separateFilePerStudent;

  /// Create a copy of PostToPDFParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PostToPDFParametersDtoCopyWith<_PostToPDFParametersDto> get copyWith =>
      __$PostToPDFParametersDtoCopyWithImpl<_PostToPDFParametersDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PostToPDFParametersDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PostToPDFParametersDto &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            const DeepCollectionEquality()
                .equals(other._studentIds, _studentIds) &&
            (identical(other.postType, postType) ||
                other.postType == postType) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.courseId, courseId) ||
                other.courseId == courseId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.separateFilePerStudent, separateFilePerStudent) ||
                other.separateFilePerStudent == separateFilePerStudent));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      schoolId,
      academicYearId,
      const DeepCollectionEquality().hash(_studentIds),
      postType,
      status,
      courseId,
      classId,
      startDate,
      endDate,
      separateFilePerStudent);

  @override
  String toString() {
    return 'PostToPDFParametersDto(schoolId: $schoolId, academicYearId: $academicYearId, studentIds: $studentIds, postType: $postType, status: $status, courseId: $courseId, classId: $classId, startDate: $startDate, endDate: $endDate, separateFilePerStudent: $separateFilePerStudent)';
  }
}

/// @nodoc
abstract mixin class _$PostToPDFParametersDtoCopyWith<$Res>
    implements $PostToPDFParametersDtoCopyWith<$Res> {
  factory _$PostToPDFParametersDtoCopyWith(_PostToPDFParametersDto value,
          $Res Function(_PostToPDFParametersDto) _then) =
      __$PostToPDFParametersDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'schoolId') String schoolId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'studentIds') List<String>? studentIds,
      @JsonKey(name: 'postType') String? postType,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'courseId') String? courseId,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'startDate') DateTime? startDate,
      @JsonKey(name: 'endDate') DateTime? endDate,
      @JsonKey(name: 'separateFilePerStudent') bool? separateFilePerStudent});
}

/// @nodoc
class __$PostToPDFParametersDtoCopyWithImpl<$Res>
    implements _$PostToPDFParametersDtoCopyWith<$Res> {
  __$PostToPDFParametersDtoCopyWithImpl(this._self, this._then);

  final _PostToPDFParametersDto _self;
  final $Res Function(_PostToPDFParametersDto) _then;

  /// Create a copy of PostToPDFParametersDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? schoolId = null,
    Object? academicYearId = freezed,
    Object? studentIds = freezed,
    Object? postType = freezed,
    Object? status = freezed,
    Object? courseId = freezed,
    Object? classId = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? separateFilePerStudent = freezed,
  }) {
    return _then(_PostToPDFParametersDto(
      schoolId: null == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentIds: freezed == studentIds
          ? _self._studentIds
          : studentIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      postType: freezed == postType
          ? _self.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      courseId: freezed == courseId
          ? _self.courseId
          : courseId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      separateFilePerStudent: freezed == separateFilePerStudent
          ? _self.separateFilePerStudent
          : separateFilePerStudent // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$RefreshTokenParameterDto {
  @JsonKey(name: 'token')
  String get token;
  @JsonKey(name: 'refreshToken')
  String get refreshToken;

  /// Create a copy of RefreshTokenParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RefreshTokenParameterDtoCopyWith<RefreshTokenParameterDto> get copyWith =>
      _$RefreshTokenParameterDtoCopyWithImpl<RefreshTokenParameterDto>(
          this as RefreshTokenParameterDto, _$identity);

  /// Serializes this RefreshTokenParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RefreshTokenParameterDto &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.refreshToken, refreshToken) ||
                other.refreshToken == refreshToken));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, token, refreshToken);

  @override
  String toString() {
    return 'RefreshTokenParameterDto(token: $token, refreshToken: $refreshToken)';
  }
}

/// @nodoc
abstract mixin class $RefreshTokenParameterDtoCopyWith<$Res> {
  factory $RefreshTokenParameterDtoCopyWith(RefreshTokenParameterDto value,
          $Res Function(RefreshTokenParameterDto) _then) =
      _$RefreshTokenParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'token') String token,
      @JsonKey(name: 'refreshToken') String refreshToken});
}

/// @nodoc
class _$RefreshTokenParameterDtoCopyWithImpl<$Res>
    implements $RefreshTokenParameterDtoCopyWith<$Res> {
  _$RefreshTokenParameterDtoCopyWithImpl(this._self, this._then);

  final RefreshTokenParameterDto _self;
  final $Res Function(RefreshTokenParameterDto) _then;

  /// Create a copy of RefreshTokenParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? refreshToken = null,
  }) {
    return _then(_self.copyWith(
      token: null == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      refreshToken: null == refreshToken
          ? _self.refreshToken
          : refreshToken // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RefreshTokenParameterDto].
extension RefreshTokenParameterDtoPatterns on RefreshTokenParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RefreshTokenParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RefreshTokenParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RefreshTokenParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RefreshTokenParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RefreshTokenParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RefreshTokenParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'token') String token,
            @JsonKey(name: 'refreshToken') String refreshToken)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RefreshTokenParameterDto() when $default != null:
        return $default(_that.token, _that.refreshToken);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'token') String token,
            @JsonKey(name: 'refreshToken') String refreshToken)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RefreshTokenParameterDto():
        return $default(_that.token, _that.refreshToken);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'token') String token,
            @JsonKey(name: 'refreshToken') String refreshToken)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RefreshTokenParameterDto() when $default != null:
        return $default(_that.token, _that.refreshToken);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RefreshTokenParameterDto implements RefreshTokenParameterDto {
  _RefreshTokenParameterDto(
      {@JsonKey(name: 'token') required this.token,
      @JsonKey(name: 'refreshToken') required this.refreshToken});
  factory _RefreshTokenParameterDto.fromJson(Map<String, dynamic> json) =>
      _$RefreshTokenParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'token')
  final String token;
  @override
  @JsonKey(name: 'refreshToken')
  final String refreshToken;

  /// Create a copy of RefreshTokenParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RefreshTokenParameterDtoCopyWith<_RefreshTokenParameterDto> get copyWith =>
      __$RefreshTokenParameterDtoCopyWithImpl<_RefreshTokenParameterDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RefreshTokenParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RefreshTokenParameterDto &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.refreshToken, refreshToken) ||
                other.refreshToken == refreshToken));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, token, refreshToken);

  @override
  String toString() {
    return 'RefreshTokenParameterDto(token: $token, refreshToken: $refreshToken)';
  }
}

/// @nodoc
abstract mixin class _$RefreshTokenParameterDtoCopyWith<$Res>
    implements $RefreshTokenParameterDtoCopyWith<$Res> {
  factory _$RefreshTokenParameterDtoCopyWith(_RefreshTokenParameterDto value,
          $Res Function(_RefreshTokenParameterDto) _then) =
      __$RefreshTokenParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'token') String token,
      @JsonKey(name: 'refreshToken') String refreshToken});
}

/// @nodoc
class __$RefreshTokenParameterDtoCopyWithImpl<$Res>
    implements _$RefreshTokenParameterDtoCopyWith<$Res> {
  __$RefreshTokenParameterDtoCopyWithImpl(this._self, this._then);

  final _RefreshTokenParameterDto _self;
  final $Res Function(_RefreshTokenParameterDto) _then;

  /// Create a copy of RefreshTokenParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? token = null,
    Object? refreshToken = null,
  }) {
    return _then(_RefreshTokenParameterDto(
      token: null == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      refreshToken: null == refreshToken
          ? _self.refreshToken
          : refreshToken // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ResetPasswordParameterDto {
  @JsonKey(name: 'otpNumber')
  String? get otpNumber;
  @JsonKey(name: 'emailAddress')
  String? get emailAddress;
  @JsonKey(name: 'password')
  String? get password;

  /// Create a copy of ResetPasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ResetPasswordParameterDtoCopyWith<ResetPasswordParameterDto> get copyWith =>
      _$ResetPasswordParameterDtoCopyWithImpl<ResetPasswordParameterDto>(
          this as ResetPasswordParameterDto, _$identity);

  /// Serializes this ResetPasswordParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ResetPasswordParameterDto &&
            (identical(other.otpNumber, otpNumber) ||
                other.otpNumber == otpNumber) &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, otpNumber, emailAddress, password);

  @override
  String toString() {
    return 'ResetPasswordParameterDto(otpNumber: $otpNumber, emailAddress: $emailAddress, password: $password)';
  }
}

/// @nodoc
abstract mixin class $ResetPasswordParameterDtoCopyWith<$Res> {
  factory $ResetPasswordParameterDtoCopyWith(ResetPasswordParameterDto value,
          $Res Function(ResetPasswordParameterDto) _then) =
      _$ResetPasswordParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'otpNumber') String? otpNumber,
      @JsonKey(name: 'emailAddress') String? emailAddress,
      @JsonKey(name: 'password') String? password});
}

/// @nodoc
class _$ResetPasswordParameterDtoCopyWithImpl<$Res>
    implements $ResetPasswordParameterDtoCopyWith<$Res> {
  _$ResetPasswordParameterDtoCopyWithImpl(this._self, this._then);

  final ResetPasswordParameterDto _self;
  final $Res Function(ResetPasswordParameterDto) _then;

  /// Create a copy of ResetPasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? otpNumber = freezed,
    Object? emailAddress = freezed,
    Object? password = freezed,
  }) {
    return _then(_self.copyWith(
      otpNumber: freezed == otpNumber
          ? _self.otpNumber
          : otpNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ResetPasswordParameterDto].
extension ResetPasswordParameterDtoPatterns on ResetPasswordParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ResetPasswordParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ResetPasswordParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ResetPasswordParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResetPasswordParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ResetPasswordParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResetPasswordParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'otpNumber') String? otpNumber,
            @JsonKey(name: 'emailAddress') String? emailAddress,
            @JsonKey(name: 'password') String? password)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ResetPasswordParameterDto() when $default != null:
        return $default(_that.otpNumber, _that.emailAddress, _that.password);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'otpNumber') String? otpNumber,
            @JsonKey(name: 'emailAddress') String? emailAddress,
            @JsonKey(name: 'password') String? password)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResetPasswordParameterDto():
        return $default(_that.otpNumber, _that.emailAddress, _that.password);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'otpNumber') String? otpNumber,
            @JsonKey(name: 'emailAddress') String? emailAddress,
            @JsonKey(name: 'password') String? password)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResetPasswordParameterDto() when $default != null:
        return $default(_that.otpNumber, _that.emailAddress, _that.password);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ResetPasswordParameterDto implements ResetPasswordParameterDto {
  _ResetPasswordParameterDto(
      {@JsonKey(name: 'otpNumber') this.otpNumber,
      @JsonKey(name: 'emailAddress') this.emailAddress,
      @JsonKey(name: 'password') this.password});
  factory _ResetPasswordParameterDto.fromJson(Map<String, dynamic> json) =>
      _$ResetPasswordParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'otpNumber')
  final String? otpNumber;
  @override
  @JsonKey(name: 'emailAddress')
  final String? emailAddress;
  @override
  @JsonKey(name: 'password')
  final String? password;

  /// Create a copy of ResetPasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ResetPasswordParameterDtoCopyWith<_ResetPasswordParameterDto>
      get copyWith =>
          __$ResetPasswordParameterDtoCopyWithImpl<_ResetPasswordParameterDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ResetPasswordParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ResetPasswordParameterDto &&
            (identical(other.otpNumber, otpNumber) ||
                other.otpNumber == otpNumber) &&
            (identical(other.emailAddress, emailAddress) ||
                other.emailAddress == emailAddress) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, otpNumber, emailAddress, password);

  @override
  String toString() {
    return 'ResetPasswordParameterDto(otpNumber: $otpNumber, emailAddress: $emailAddress, password: $password)';
  }
}

/// @nodoc
abstract mixin class _$ResetPasswordParameterDtoCopyWith<$Res>
    implements $ResetPasswordParameterDtoCopyWith<$Res> {
  factory _$ResetPasswordParameterDtoCopyWith(_ResetPasswordParameterDto value,
          $Res Function(_ResetPasswordParameterDto) _then) =
      __$ResetPasswordParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'otpNumber') String? otpNumber,
      @JsonKey(name: 'emailAddress') String? emailAddress,
      @JsonKey(name: 'password') String? password});
}

/// @nodoc
class __$ResetPasswordParameterDtoCopyWithImpl<$Res>
    implements _$ResetPasswordParameterDtoCopyWith<$Res> {
  __$ResetPasswordParameterDtoCopyWithImpl(this._self, this._then);

  final _ResetPasswordParameterDto _self;
  final $Res Function(_ResetPasswordParameterDto) _then;

  /// Create a copy of ResetPasswordParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? otpNumber = freezed,
    Object? emailAddress = freezed,
    Object? password = freezed,
  }) {
    return _then(_ResetPasswordParameterDto(
      otpNumber: freezed == otpNumber
          ? _self.otpNumber
          : otpNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      emailAddress: freezed == emailAddress
          ? _self.emailAddress
          : emailAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ResourcePermissionDto {
  @JsonKey(name: 'levels')
  String? get levels;
  @JsonKey(name: 'classes')
  String? get classes;
  @JsonKey(name: 'students')
  String? get students;
  @JsonKey(name: 'batchNumber')
  String? get batchNumber;
  @JsonKey(name: 'attendeeReference')
  String? get attendeeReference;

  /// Create a copy of ResourcePermissionDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ResourcePermissionDtoCopyWith<ResourcePermissionDto> get copyWith =>
      _$ResourcePermissionDtoCopyWithImpl<ResourcePermissionDto>(
          this as ResourcePermissionDto, _$identity);

  /// Serializes this ResourcePermissionDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ResourcePermissionDto &&
            (identical(other.levels, levels) || other.levels == levels) &&
            (identical(other.classes, classes) || other.classes == classes) &&
            (identical(other.students, students) ||
                other.students == students) &&
            (identical(other.batchNumber, batchNumber) ||
                other.batchNumber == batchNumber) &&
            (identical(other.attendeeReference, attendeeReference) ||
                other.attendeeReference == attendeeReference));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, levels, classes, students, batchNumber, attendeeReference);

  @override
  String toString() {
    return 'ResourcePermissionDto(levels: $levels, classes: $classes, students: $students, batchNumber: $batchNumber, attendeeReference: $attendeeReference)';
  }
}

/// @nodoc
abstract mixin class $ResourcePermissionDtoCopyWith<$Res> {
  factory $ResourcePermissionDtoCopyWith(ResourcePermissionDto value,
          $Res Function(ResourcePermissionDto) _then) =
      _$ResourcePermissionDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'levels') String? levels,
      @JsonKey(name: 'classes') String? classes,
      @JsonKey(name: 'students') String? students,
      @JsonKey(name: 'batchNumber') String? batchNumber,
      @JsonKey(name: 'attendeeReference') String? attendeeReference});
}

/// @nodoc
class _$ResourcePermissionDtoCopyWithImpl<$Res>
    implements $ResourcePermissionDtoCopyWith<$Res> {
  _$ResourcePermissionDtoCopyWithImpl(this._self, this._then);

  final ResourcePermissionDto _self;
  final $Res Function(ResourcePermissionDto) _then;

  /// Create a copy of ResourcePermissionDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? levels = freezed,
    Object? classes = freezed,
    Object? students = freezed,
    Object? batchNumber = freezed,
    Object? attendeeReference = freezed,
  }) {
    return _then(_self.copyWith(
      levels: freezed == levels
          ? _self.levels
          : levels // ignore: cast_nullable_to_non_nullable
              as String?,
      classes: freezed == classes
          ? _self.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as String?,
      students: freezed == students
          ? _self.students
          : students // ignore: cast_nullable_to_non_nullable
              as String?,
      batchNumber: freezed == batchNumber
          ? _self.batchNumber
          : batchNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      attendeeReference: freezed == attendeeReference
          ? _self.attendeeReference
          : attendeeReference // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ResourcePermissionDto].
extension ResourcePermissionDtoPatterns on ResourcePermissionDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ResourcePermissionDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ResourcePermissionDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ResourcePermissionDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResourcePermissionDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ResourcePermissionDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResourcePermissionDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'levels') String? levels,
            @JsonKey(name: 'classes') String? classes,
            @JsonKey(name: 'students') String? students,
            @JsonKey(name: 'batchNumber') String? batchNumber,
            @JsonKey(name: 'attendeeReference') String? attendeeReference)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ResourcePermissionDto() when $default != null:
        return $default(_that.levels, _that.classes, _that.students,
            _that.batchNumber, _that.attendeeReference);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'levels') String? levels,
            @JsonKey(name: 'classes') String? classes,
            @JsonKey(name: 'students') String? students,
            @JsonKey(name: 'batchNumber') String? batchNumber,
            @JsonKey(name: 'attendeeReference') String? attendeeReference)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResourcePermissionDto():
        return $default(_that.levels, _that.classes, _that.students,
            _that.batchNumber, _that.attendeeReference);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'levels') String? levels,
            @JsonKey(name: 'classes') String? classes,
            @JsonKey(name: 'students') String? students,
            @JsonKey(name: 'batchNumber') String? batchNumber,
            @JsonKey(name: 'attendeeReference') String? attendeeReference)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResourcePermissionDto() when $default != null:
        return $default(_that.levels, _that.classes, _that.students,
            _that.batchNumber, _that.attendeeReference);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ResourcePermissionDto implements ResourcePermissionDto {
  _ResourcePermissionDto(
      {@JsonKey(name: 'levels') this.levels,
      @JsonKey(name: 'classes') this.classes,
      @JsonKey(name: 'students') this.students,
      @JsonKey(name: 'batchNumber') this.batchNumber,
      @JsonKey(name: 'attendeeReference') this.attendeeReference});
  factory _ResourcePermissionDto.fromJson(Map<String, dynamic> json) =>
      _$ResourcePermissionDtoFromJson(json);

  @override
  @JsonKey(name: 'levels')
  final String? levels;
  @override
  @JsonKey(name: 'classes')
  final String? classes;
  @override
  @JsonKey(name: 'students')
  final String? students;
  @override
  @JsonKey(name: 'batchNumber')
  final String? batchNumber;
  @override
  @JsonKey(name: 'attendeeReference')
  final String? attendeeReference;

  /// Create a copy of ResourcePermissionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ResourcePermissionDtoCopyWith<_ResourcePermissionDto> get copyWith =>
      __$ResourcePermissionDtoCopyWithImpl<_ResourcePermissionDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ResourcePermissionDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ResourcePermissionDto &&
            (identical(other.levels, levels) || other.levels == levels) &&
            (identical(other.classes, classes) || other.classes == classes) &&
            (identical(other.students, students) ||
                other.students == students) &&
            (identical(other.batchNumber, batchNumber) ||
                other.batchNumber == batchNumber) &&
            (identical(other.attendeeReference, attendeeReference) ||
                other.attendeeReference == attendeeReference));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, levels, classes, students, batchNumber, attendeeReference);

  @override
  String toString() {
    return 'ResourcePermissionDto(levels: $levels, classes: $classes, students: $students, batchNumber: $batchNumber, attendeeReference: $attendeeReference)';
  }
}

/// @nodoc
abstract mixin class _$ResourcePermissionDtoCopyWith<$Res>
    implements $ResourcePermissionDtoCopyWith<$Res> {
  factory _$ResourcePermissionDtoCopyWith(_ResourcePermissionDto value,
          $Res Function(_ResourcePermissionDto) _then) =
      __$ResourcePermissionDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'levels') String? levels,
      @JsonKey(name: 'classes') String? classes,
      @JsonKey(name: 'students') String? students,
      @JsonKey(name: 'batchNumber') String? batchNumber,
      @JsonKey(name: 'attendeeReference') String? attendeeReference});
}

/// @nodoc
class __$ResourcePermissionDtoCopyWithImpl<$Res>
    implements _$ResourcePermissionDtoCopyWith<$Res> {
  __$ResourcePermissionDtoCopyWithImpl(this._self, this._then);

  final _ResourcePermissionDto _self;
  final $Res Function(_ResourcePermissionDto) _then;

  /// Create a copy of ResourcePermissionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? levels = freezed,
    Object? classes = freezed,
    Object? students = freezed,
    Object? batchNumber = freezed,
    Object? attendeeReference = freezed,
  }) {
    return _then(_ResourcePermissionDto(
      levels: freezed == levels
          ? _self.levels
          : levels // ignore: cast_nullable_to_non_nullable
              as String?,
      classes: freezed == classes
          ? _self.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as String?,
      students: freezed == students
          ? _self.students
          : students // ignore: cast_nullable_to_non_nullable
              as String?,
      batchNumber: freezed == batchNumber
          ? _self.batchNumber
          : batchNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      attendeeReference: freezed == attendeeReference
          ? _self.attendeeReference
          : attendeeReference // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ResponseStatusDto {
  @JsonKey(name: 'response')
  ResponseTypeDto? get response;
  @JsonKey(name: 'time')
  DateTime? get time;
  @JsonKey(name: '@odata.type')
  String? get odataType;

  /// Create a copy of ResponseStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ResponseStatusDtoCopyWith<ResponseStatusDto> get copyWith =>
      _$ResponseStatusDtoCopyWithImpl<ResponseStatusDto>(
          this as ResponseStatusDto, _$identity);

  /// Serializes this ResponseStatusDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ResponseStatusDto &&
            (identical(other.response, response) ||
                other.response == response) &&
            (identical(other.time, time) || other.time == time) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, response, time, odataType);

  @override
  String toString() {
    return 'ResponseStatusDto(response: $response, time: $time, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class $ResponseStatusDtoCopyWith<$Res> {
  factory $ResponseStatusDtoCopyWith(
          ResponseStatusDto value, $Res Function(ResponseStatusDto) _then) =
      _$ResponseStatusDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'response') ResponseTypeDto? response,
      @JsonKey(name: 'time') DateTime? time,
      @JsonKey(name: '@odata.type') String? odataType});
}

/// @nodoc
class _$ResponseStatusDtoCopyWithImpl<$Res>
    implements $ResponseStatusDtoCopyWith<$Res> {
  _$ResponseStatusDtoCopyWithImpl(this._self, this._then);

  final ResponseStatusDto _self;
  final $Res Function(ResponseStatusDto) _then;

  /// Create a copy of ResponseStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? response = freezed,
    Object? time = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_self.copyWith(
      response: freezed == response
          ? _self.response
          : response // ignore: cast_nullable_to_non_nullable
              as ResponseTypeDto?,
      time: freezed == time
          ? _self.time
          : time // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ResponseStatusDto].
extension ResponseStatusDtoPatterns on ResponseStatusDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ResponseStatusDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ResponseStatusDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ResponseStatusDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResponseStatusDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ResponseStatusDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResponseStatusDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'response') ResponseTypeDto? response,
            @JsonKey(name: 'time') DateTime? time,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ResponseStatusDto() when $default != null:
        return $default(_that.response, _that.time, _that.odataType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'response') ResponseTypeDto? response,
            @JsonKey(name: 'time') DateTime? time,
            @JsonKey(name: '@odata.type') String? odataType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResponseStatusDto():
        return $default(_that.response, _that.time, _that.odataType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'response') ResponseTypeDto? response,
            @JsonKey(name: 'time') DateTime? time,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ResponseStatusDto() when $default != null:
        return $default(_that.response, _that.time, _that.odataType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ResponseStatusDto implements ResponseStatusDto {
  _ResponseStatusDto(
      {@JsonKey(name: 'response') this.response,
      @JsonKey(name: 'time') this.time,
      @JsonKey(name: '@odata.type') this.odataType});
  factory _ResponseStatusDto.fromJson(Map<String, dynamic> json) =>
      _$ResponseStatusDtoFromJson(json);

  @override
  @JsonKey(name: 'response')
  final ResponseTypeDto? response;
  @override
  @JsonKey(name: 'time')
  final DateTime? time;
  @override
  @JsonKey(name: '@odata.type')
  final String? odataType;

  /// Create a copy of ResponseStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ResponseStatusDtoCopyWith<_ResponseStatusDto> get copyWith =>
      __$ResponseStatusDtoCopyWithImpl<_ResponseStatusDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ResponseStatusDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ResponseStatusDto &&
            (identical(other.response, response) ||
                other.response == response) &&
            (identical(other.time, time) || other.time == time) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, response, time, odataType);

  @override
  String toString() {
    return 'ResponseStatusDto(response: $response, time: $time, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class _$ResponseStatusDtoCopyWith<$Res>
    implements $ResponseStatusDtoCopyWith<$Res> {
  factory _$ResponseStatusDtoCopyWith(
          _ResponseStatusDto value, $Res Function(_ResponseStatusDto) _then) =
      __$ResponseStatusDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'response') ResponseTypeDto? response,
      @JsonKey(name: 'time') DateTime? time,
      @JsonKey(name: '@odata.type') String? odataType});
}

/// @nodoc
class __$ResponseStatusDtoCopyWithImpl<$Res>
    implements _$ResponseStatusDtoCopyWith<$Res> {
  __$ResponseStatusDtoCopyWithImpl(this._self, this._then);

  final _ResponseStatusDto _self;
  final $Res Function(_ResponseStatusDto) _then;

  /// Create a copy of ResponseStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? response = freezed,
    Object? time = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_ResponseStatusDto(
      response: freezed == response
          ? _self.response
          : response // ignore: cast_nullable_to_non_nullable
              as ResponseTypeDto?,
      time: freezed == time
          ? _self.time
          : time // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$StudentDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'studentNo')
  String? get studentNo;
  @JsonKey(name: 'displayName')
  String? get displayName;
  @JsonKey(name: 'schoolId')
  String? get schoolId;
  @JsonKey(name: 'account')
  AccountDto? get account;
  @JsonKey(name: 'photo')
  String? get photo;
  @JsonKey(name: 'registrationDate')
  DateTime? get registrationDate;
  @JsonKey(name: 'schoolName')
  String? get schoolName;
  @JsonKey(name: 'studentLevelId')
  String? get studentLevelId;
  @JsonKey(name: 'levelId')
  String? get levelId;
  @JsonKey(name: 'levelName')
  String? get levelName;
  @JsonKey(name: 'classId')
  String? get classId;
  @JsonKey(name: 'className')
  String? get className;

  /// Create a copy of StudentDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentDtoCopyWith<StudentDto> get copyWith =>
      _$StudentDtoCopyWithImpl<StudentDto>(this as StudentDto, _$identity);

  /// Serializes this StudentDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentNo, studentNo) ||
                other.studentNo == studentNo) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.registrationDate, registrationDate) ||
                other.registrationDate == registrationDate) &&
            (identical(other.schoolName, schoolName) ||
                other.schoolName == schoolName) &&
            (identical(other.studentLevelId, studentLevelId) ||
                other.studentLevelId == studentLevelId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.levelName, levelName) ||
                other.levelName == levelName) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      studentNo,
      displayName,
      schoolId,
      account,
      photo,
      registrationDate,
      schoolName,
      studentLevelId,
      levelId,
      levelName,
      classId,
      className);

  @override
  String toString() {
    return 'StudentDto(id: $id, studentNo: $studentNo, displayName: $displayName, schoolId: $schoolId, account: $account, photo: $photo, registrationDate: $registrationDate, schoolName: $schoolName, studentLevelId: $studentLevelId, levelId: $levelId, levelName: $levelName, classId: $classId, className: $className)';
  }
}

/// @nodoc
abstract mixin class $StudentDtoCopyWith<$Res> {
  factory $StudentDtoCopyWith(
          StudentDto value, $Res Function(StudentDto) _then) =
      _$StudentDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'studentNo') String? studentNo,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'account') AccountDto? account,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'registrationDate') DateTime? registrationDate,
      @JsonKey(name: 'schoolName') String? schoolName,
      @JsonKey(name: 'studentLevelId') String? studentLevelId,
      @JsonKey(name: 'levelId') String? levelId,
      @JsonKey(name: 'levelName') String? levelName,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'className') String? className});

  $AccountDtoCopyWith<$Res>? get account;
}

/// @nodoc
class _$StudentDtoCopyWithImpl<$Res> implements $StudentDtoCopyWith<$Res> {
  _$StudentDtoCopyWithImpl(this._self, this._then);

  final StudentDto _self;
  final $Res Function(StudentDto) _then;

  /// Create a copy of StudentDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? studentNo = freezed,
    Object? displayName = freezed,
    Object? schoolId = freezed,
    Object? account = freezed,
    Object? photo = freezed,
    Object? registrationDate = freezed,
    Object? schoolName = freezed,
    Object? studentLevelId = freezed,
    Object? levelId = freezed,
    Object? levelName = freezed,
    Object? classId = freezed,
    Object? className = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      studentNo: freezed == studentNo
          ? _self.studentNo
          : studentNo // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountDto?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      registrationDate: freezed == registrationDate
          ? _self.registrationDate
          : registrationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      schoolName: freezed == schoolName
          ? _self.schoolName
          : schoolName // ignore: cast_nullable_to_non_nullable
              as String?,
      studentLevelId: freezed == studentLevelId
          ? _self.studentLevelId
          : studentLevelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelName: freezed == levelName
          ? _self.levelName
          : levelName // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of StudentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountDtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountDtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StudentDto].
extension StudentDtoPatterns on StudentDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'studentNo') String? studentNo,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'account') AccountDto? account,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'studentLevelId') String? studentLevelId,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentDto() when $default != null:
        return $default(
            _that.id,
            _that.studentNo,
            _that.displayName,
            _that.schoolId,
            _that.account,
            _that.photo,
            _that.registrationDate,
            _that.schoolName,
            _that.studentLevelId,
            _that.levelId,
            _that.levelName,
            _that.classId,
            _that.className);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'studentNo') String? studentNo,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'account') AccountDto? account,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'studentLevelId') String? studentLevelId,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentDto():
        return $default(
            _that.id,
            _that.studentNo,
            _that.displayName,
            _that.schoolId,
            _that.account,
            _that.photo,
            _that.registrationDate,
            _that.schoolName,
            _that.studentLevelId,
            _that.levelId,
            _that.levelName,
            _that.classId,
            _that.className);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'studentNo') String? studentNo,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'account') AccountDto? account,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'studentLevelId') String? studentLevelId,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentDto() when $default != null:
        return $default(
            _that.id,
            _that.studentNo,
            _that.displayName,
            _that.schoolId,
            _that.account,
            _that.photo,
            _that.registrationDate,
            _that.schoolName,
            _that.studentLevelId,
            _that.levelId,
            _that.levelName,
            _that.classId,
            _that.className);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentDto implements StudentDto {
  _StudentDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'studentNo') this.studentNo,
      @JsonKey(name: 'displayName') this.displayName,
      @JsonKey(name: 'schoolId') this.schoolId,
      @JsonKey(name: 'account') this.account,
      @JsonKey(name: 'photo') this.photo,
      @JsonKey(name: 'registrationDate') this.registrationDate,
      @JsonKey(name: 'schoolName') this.schoolName,
      @JsonKey(name: 'studentLevelId') this.studentLevelId,
      @JsonKey(name: 'levelId') this.levelId,
      @JsonKey(name: 'levelName') this.levelName,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'className') this.className});
  factory _StudentDto.fromJson(Map<String, dynamic> json) =>
      _$StudentDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'studentNo')
  final String? studentNo;
  @override
  @JsonKey(name: 'displayName')
  final String? displayName;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;
  @override
  @JsonKey(name: 'account')
  final AccountDto? account;
  @override
  @JsonKey(name: 'photo')
  final String? photo;
  @override
  @JsonKey(name: 'registrationDate')
  final DateTime? registrationDate;
  @override
  @JsonKey(name: 'schoolName')
  final String? schoolName;
  @override
  @JsonKey(name: 'studentLevelId')
  final String? studentLevelId;
  @override
  @JsonKey(name: 'levelId')
  final String? levelId;
  @override
  @JsonKey(name: 'levelName')
  final String? levelName;
  @override
  @JsonKey(name: 'classId')
  final String? classId;
  @override
  @JsonKey(name: 'className')
  final String? className;

  /// Create a copy of StudentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentDtoCopyWith<_StudentDto> get copyWith =>
      __$StudentDtoCopyWithImpl<_StudentDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentNo, studentNo) ||
                other.studentNo == studentNo) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.registrationDate, registrationDate) ||
                other.registrationDate == registrationDate) &&
            (identical(other.schoolName, schoolName) ||
                other.schoolName == schoolName) &&
            (identical(other.studentLevelId, studentLevelId) ||
                other.studentLevelId == studentLevelId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.levelName, levelName) ||
                other.levelName == levelName) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      studentNo,
      displayName,
      schoolId,
      account,
      photo,
      registrationDate,
      schoolName,
      studentLevelId,
      levelId,
      levelName,
      classId,
      className);

  @override
  String toString() {
    return 'StudentDto(id: $id, studentNo: $studentNo, displayName: $displayName, schoolId: $schoolId, account: $account, photo: $photo, registrationDate: $registrationDate, schoolName: $schoolName, studentLevelId: $studentLevelId, levelId: $levelId, levelName: $levelName, classId: $classId, className: $className)';
  }
}

/// @nodoc
abstract mixin class _$StudentDtoCopyWith<$Res>
    implements $StudentDtoCopyWith<$Res> {
  factory _$StudentDtoCopyWith(
          _StudentDto value, $Res Function(_StudentDto) _then) =
      __$StudentDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'studentNo') String? studentNo,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'account') AccountDto? account,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'registrationDate') DateTime? registrationDate,
      @JsonKey(name: 'schoolName') String? schoolName,
      @JsonKey(name: 'studentLevelId') String? studentLevelId,
      @JsonKey(name: 'levelId') String? levelId,
      @JsonKey(name: 'levelName') String? levelName,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'className') String? className});

  @override
  $AccountDtoCopyWith<$Res>? get account;
}

/// @nodoc
class __$StudentDtoCopyWithImpl<$Res> implements _$StudentDtoCopyWith<$Res> {
  __$StudentDtoCopyWithImpl(this._self, this._then);

  final _StudentDto _self;
  final $Res Function(_StudentDto) _then;

  /// Create a copy of StudentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? studentNo = freezed,
    Object? displayName = freezed,
    Object? schoolId = freezed,
    Object? account = freezed,
    Object? photo = freezed,
    Object? registrationDate = freezed,
    Object? schoolName = freezed,
    Object? studentLevelId = freezed,
    Object? levelId = freezed,
    Object? levelName = freezed,
    Object? classId = freezed,
    Object? className = freezed,
  }) {
    return _then(_StudentDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      studentNo: freezed == studentNo
          ? _self.studentNo
          : studentNo // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountDto?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      registrationDate: freezed == registrationDate
          ? _self.registrationDate
          : registrationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      schoolName: freezed == schoolName
          ? _self.schoolName
          : schoolName // ignore: cast_nullable_to_non_nullable
              as String?,
      studentLevelId: freezed == studentLevelId
          ? _self.studentLevelId
          : studentLevelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelName: freezed == levelName
          ? _self.levelName
          : levelName // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of StudentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountDtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountDtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// @nodoc
mixin _$StudentBaseInfoVODto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'displayName')
  String? get displayName;
  @JsonKey(name: 'schoolId')
  String? get schoolId;
  @JsonKey(name: 'schoolName')
  String? get schoolName;
  @JsonKey(name: 'classId')
  String? get classId;
  @JsonKey(name: 'className')
  String? get className;
  @JsonKey(name: 'photo')
  String? get photo;
  @JsonKey(name: 'levelId')
  String? get levelId;
  @JsonKey(name: 'levelName')
  String? get levelName;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'registrationDate')
  DateTime? get registrationDate;

  /// Create a copy of StudentBaseInfoVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentBaseInfoVODtoCopyWith<StudentBaseInfoVODto> get copyWith =>
      _$StudentBaseInfoVODtoCopyWithImpl<StudentBaseInfoVODto>(
          this as StudentBaseInfoVODto, _$identity);

  /// Serializes this StudentBaseInfoVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentBaseInfoVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.schoolName, schoolName) ||
                other.schoolName == schoolName) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.levelName, levelName) ||
                other.levelName == levelName) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.registrationDate, registrationDate) ||
                other.registrationDate == registrationDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      schoolId,
      schoolName,
      classId,
      className,
      photo,
      levelId,
      levelName,
      status,
      registrationDate);

  @override
  String toString() {
    return 'StudentBaseInfoVODto(id: $id, displayName: $displayName, schoolId: $schoolId, schoolName: $schoolName, classId: $classId, className: $className, photo: $photo, levelId: $levelId, levelName: $levelName, status: $status, registrationDate: $registrationDate)';
  }
}

/// @nodoc
abstract mixin class $StudentBaseInfoVODtoCopyWith<$Res> {
  factory $StudentBaseInfoVODtoCopyWith(StudentBaseInfoVODto value,
          $Res Function(StudentBaseInfoVODto) _then) =
      _$StudentBaseInfoVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'schoolName') String? schoolName,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'className') String? className,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'levelId') String? levelId,
      @JsonKey(name: 'levelName') String? levelName,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'registrationDate') DateTime? registrationDate});
}

/// @nodoc
class _$StudentBaseInfoVODtoCopyWithImpl<$Res>
    implements $StudentBaseInfoVODtoCopyWith<$Res> {
  _$StudentBaseInfoVODtoCopyWithImpl(this._self, this._then);

  final StudentBaseInfoVODto _self;
  final $Res Function(StudentBaseInfoVODto) _then;

  /// Create a copy of StudentBaseInfoVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? displayName = freezed,
    Object? schoolId = freezed,
    Object? schoolName = freezed,
    Object? classId = freezed,
    Object? className = freezed,
    Object? photo = freezed,
    Object? levelId = freezed,
    Object? levelName = freezed,
    Object? status = freezed,
    Object? registrationDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolName: freezed == schoolName
          ? _self.schoolName
          : schoolName // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelName: freezed == levelName
          ? _self.levelName
          : levelName // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      registrationDate: freezed == registrationDate
          ? _self.registrationDate
          : registrationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StudentBaseInfoVODto].
extension StudentBaseInfoVODtoPatterns on StudentBaseInfoVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentBaseInfoVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentBaseInfoVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentBaseInfoVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentBaseInfoVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentBaseInfoVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentBaseInfoVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentBaseInfoVODto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.schoolId,
            _that.schoolName,
            _that.classId,
            _that.className,
            _that.photo,
            _that.levelId,
            _that.levelName,
            _that.status,
            _that.registrationDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentBaseInfoVODto():
        return $default(
            _that.id,
            _that.displayName,
            _that.schoolId,
            _that.schoolName,
            _that.classId,
            _that.className,
            _that.photo,
            _that.levelId,
            _that.levelName,
            _that.status,
            _that.registrationDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentBaseInfoVODto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.schoolId,
            _that.schoolName,
            _that.classId,
            _that.className,
            _that.photo,
            _that.levelId,
            _that.levelName,
            _that.status,
            _that.registrationDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentBaseInfoVODto implements StudentBaseInfoVODto {
  _StudentBaseInfoVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'displayName') this.displayName,
      @JsonKey(name: 'schoolId') this.schoolId,
      @JsonKey(name: 'schoolName') this.schoolName,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'className') this.className,
      @JsonKey(name: 'photo') this.photo,
      @JsonKey(name: 'levelId') this.levelId,
      @JsonKey(name: 'levelName') this.levelName,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'registrationDate') this.registrationDate});
  factory _StudentBaseInfoVODto.fromJson(Map<String, dynamic> json) =>
      _$StudentBaseInfoVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'displayName')
  final String? displayName;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;
  @override
  @JsonKey(name: 'schoolName')
  final String? schoolName;
  @override
  @JsonKey(name: 'classId')
  final String? classId;
  @override
  @JsonKey(name: 'className')
  final String? className;
  @override
  @JsonKey(name: 'photo')
  final String? photo;
  @override
  @JsonKey(name: 'levelId')
  final String? levelId;
  @override
  @JsonKey(name: 'levelName')
  final String? levelName;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'registrationDate')
  final DateTime? registrationDate;

  /// Create a copy of StudentBaseInfoVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentBaseInfoVODtoCopyWith<_StudentBaseInfoVODto> get copyWith =>
      __$StudentBaseInfoVODtoCopyWithImpl<_StudentBaseInfoVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentBaseInfoVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentBaseInfoVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.schoolName, schoolName) ||
                other.schoolName == schoolName) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.levelName, levelName) ||
                other.levelName == levelName) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.registrationDate, registrationDate) ||
                other.registrationDate == registrationDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      schoolId,
      schoolName,
      classId,
      className,
      photo,
      levelId,
      levelName,
      status,
      registrationDate);

  @override
  String toString() {
    return 'StudentBaseInfoVODto(id: $id, displayName: $displayName, schoolId: $schoolId, schoolName: $schoolName, classId: $classId, className: $className, photo: $photo, levelId: $levelId, levelName: $levelName, status: $status, registrationDate: $registrationDate)';
  }
}

/// @nodoc
abstract mixin class _$StudentBaseInfoVODtoCopyWith<$Res>
    implements $StudentBaseInfoVODtoCopyWith<$Res> {
  factory _$StudentBaseInfoVODtoCopyWith(_StudentBaseInfoVODto value,
          $Res Function(_StudentBaseInfoVODto) _then) =
      __$StudentBaseInfoVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'schoolName') String? schoolName,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'className') String? className,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'levelId') String? levelId,
      @JsonKey(name: 'levelName') String? levelName,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'registrationDate') DateTime? registrationDate});
}

/// @nodoc
class __$StudentBaseInfoVODtoCopyWithImpl<$Res>
    implements _$StudentBaseInfoVODtoCopyWith<$Res> {
  __$StudentBaseInfoVODtoCopyWithImpl(this._self, this._then);

  final _StudentBaseInfoVODto _self;
  final $Res Function(_StudentBaseInfoVODto) _then;

  /// Create a copy of StudentBaseInfoVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? displayName = freezed,
    Object? schoolId = freezed,
    Object? schoolName = freezed,
    Object? classId = freezed,
    Object? className = freezed,
    Object? photo = freezed,
    Object? levelId = freezed,
    Object? levelName = freezed,
    Object? status = freezed,
    Object? registrationDate = freezed,
  }) {
    return _then(_StudentBaseInfoVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolName: freezed == schoolName
          ? _self.schoolName
          : schoolName // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelName: freezed == levelName
          ? _self.levelName
          : levelName // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      registrationDate: freezed == registrationDate
          ? _self.registrationDate
          : registrationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$StudentMiniDailyLogVODto {
  @JsonKey(name: 'student')
  StudentDto? get student;
  @JsonKey(name: 'attendanceStatus')
  AttendanceVODto? get attendanceStatus;
  @JsonKey(name: 'lastTemperatureStatus')
  LastTemperatureVODto? get lastTemperatureStatus;
  @JsonKey(name: 'signInOutStatus')
  CheckInOutVODto? get signInOutStatus;

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentMiniDailyLogVODtoCopyWith<StudentMiniDailyLogVODto> get copyWith =>
      _$StudentMiniDailyLogVODtoCopyWithImpl<StudentMiniDailyLogVODto>(
          this as StudentMiniDailyLogVODto, _$identity);

  /// Serializes this StudentMiniDailyLogVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentMiniDailyLogVODto &&
            (identical(other.student, student) || other.student == student) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.lastTemperatureStatus, lastTemperatureStatus) ||
                other.lastTemperatureStatus == lastTemperatureStatus) &&
            (identical(other.signInOutStatus, signInOutStatus) ||
                other.signInOutStatus == signInOutStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, student, attendanceStatus,
      lastTemperatureStatus, signInOutStatus);

  @override
  String toString() {
    return 'StudentMiniDailyLogVODto(student: $student, attendanceStatus: $attendanceStatus, lastTemperatureStatus: $lastTemperatureStatus, signInOutStatus: $signInOutStatus)';
  }
}

/// @nodoc
abstract mixin class $StudentMiniDailyLogVODtoCopyWith<$Res> {
  factory $StudentMiniDailyLogVODtoCopyWith(StudentMiniDailyLogVODto value,
          $Res Function(StudentMiniDailyLogVODto) _then) =
      _$StudentMiniDailyLogVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'student') StudentDto? student,
      @JsonKey(name: 'attendanceStatus') AttendanceVODto? attendanceStatus,
      @JsonKey(name: 'lastTemperatureStatus')
      LastTemperatureVODto? lastTemperatureStatus,
      @JsonKey(name: 'signInOutStatus') CheckInOutVODto? signInOutStatus});

  $StudentDtoCopyWith<$Res>? get student;
  $AttendanceVODtoCopyWith<$Res>? get attendanceStatus;
  $LastTemperatureVODtoCopyWith<$Res>? get lastTemperatureStatus;
  $CheckInOutVODtoCopyWith<$Res>? get signInOutStatus;
}

/// @nodoc
class _$StudentMiniDailyLogVODtoCopyWithImpl<$Res>
    implements $StudentMiniDailyLogVODtoCopyWith<$Res> {
  _$StudentMiniDailyLogVODtoCopyWithImpl(this._self, this._then);

  final StudentMiniDailyLogVODto _self;
  final $Res Function(StudentMiniDailyLogVODto) _then;

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? student = freezed,
    Object? attendanceStatus = freezed,
    Object? lastTemperatureStatus = freezed,
    Object? signInOutStatus = freezed,
  }) {
    return _then(_self.copyWith(
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentDto?,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as AttendanceVODto?,
      lastTemperatureStatus: freezed == lastTemperatureStatus
          ? _self.lastTemperatureStatus
          : lastTemperatureStatus // ignore: cast_nullable_to_non_nullable
              as LastTemperatureVODto?,
      signInOutStatus: freezed == signInOutStatus
          ? _self.signInOutStatus
          : signInOutStatus // ignore: cast_nullable_to_non_nullable
              as CheckInOutVODto?,
    ));
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentDtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentDtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AttendanceVODtoCopyWith<$Res>? get attendanceStatus {
    if (_self.attendanceStatus == null) {
      return null;
    }

    return $AttendanceVODtoCopyWith<$Res>(_self.attendanceStatus!, (value) {
      return _then(_self.copyWith(attendanceStatus: value));
    });
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LastTemperatureVODtoCopyWith<$Res>? get lastTemperatureStatus {
    if (_self.lastTemperatureStatus == null) {
      return null;
    }

    return $LastTemperatureVODtoCopyWith<$Res>(_self.lastTemperatureStatus!,
        (value) {
      return _then(_self.copyWith(lastTemperatureStatus: value));
    });
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CheckInOutVODtoCopyWith<$Res>? get signInOutStatus {
    if (_self.signInOutStatus == null) {
      return null;
    }

    return $CheckInOutVODtoCopyWith<$Res>(_self.signInOutStatus!, (value) {
      return _then(_self.copyWith(signInOutStatus: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StudentMiniDailyLogVODto].
extension StudentMiniDailyLogVODtoPatterns on StudentMiniDailyLogVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentMiniDailyLogVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentMiniDailyLogVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentMiniDailyLogVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentMiniDailyLogVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentMiniDailyLogVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentMiniDailyLogVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'student') StudentDto? student,
            @JsonKey(name: 'attendanceStatus')
            AttendanceVODto? attendanceStatus,
            @JsonKey(name: 'lastTemperatureStatus')
            LastTemperatureVODto? lastTemperatureStatus,
            @JsonKey(name: 'signInOutStatus') CheckInOutVODto? signInOutStatus)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentMiniDailyLogVODto() when $default != null:
        return $default(_that.student, _that.attendanceStatus,
            _that.lastTemperatureStatus, _that.signInOutStatus);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'student') StudentDto? student,
            @JsonKey(name: 'attendanceStatus')
            AttendanceVODto? attendanceStatus,
            @JsonKey(name: 'lastTemperatureStatus')
            LastTemperatureVODto? lastTemperatureStatus,
            @JsonKey(name: 'signInOutStatus') CheckInOutVODto? signInOutStatus)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentMiniDailyLogVODto():
        return $default(_that.student, _that.attendanceStatus,
            _that.lastTemperatureStatus, _that.signInOutStatus);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'student') StudentDto? student,
            @JsonKey(name: 'attendanceStatus')
            AttendanceVODto? attendanceStatus,
            @JsonKey(name: 'lastTemperatureStatus')
            LastTemperatureVODto? lastTemperatureStatus,
            @JsonKey(name: 'signInOutStatus') CheckInOutVODto? signInOutStatus)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentMiniDailyLogVODto() when $default != null:
        return $default(_that.student, _that.attendanceStatus,
            _that.lastTemperatureStatus, _that.signInOutStatus);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentMiniDailyLogVODto implements StudentMiniDailyLogVODto {
  _StudentMiniDailyLogVODto(
      {@JsonKey(name: 'student') this.student,
      @JsonKey(name: 'attendanceStatus') this.attendanceStatus,
      @JsonKey(name: 'lastTemperatureStatus') this.lastTemperatureStatus,
      @JsonKey(name: 'signInOutStatus') this.signInOutStatus});
  factory _StudentMiniDailyLogVODto.fromJson(Map<String, dynamic> json) =>
      _$StudentMiniDailyLogVODtoFromJson(json);

  @override
  @JsonKey(name: 'student')
  final StudentDto? student;
  @override
  @JsonKey(name: 'attendanceStatus')
  final AttendanceVODto? attendanceStatus;
  @override
  @JsonKey(name: 'lastTemperatureStatus')
  final LastTemperatureVODto? lastTemperatureStatus;
  @override
  @JsonKey(name: 'signInOutStatus')
  final CheckInOutVODto? signInOutStatus;

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentMiniDailyLogVODtoCopyWith<_StudentMiniDailyLogVODto> get copyWith =>
      __$StudentMiniDailyLogVODtoCopyWithImpl<_StudentMiniDailyLogVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentMiniDailyLogVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentMiniDailyLogVODto &&
            (identical(other.student, student) || other.student == student) &&
            (identical(other.attendanceStatus, attendanceStatus) ||
                other.attendanceStatus == attendanceStatus) &&
            (identical(other.lastTemperatureStatus, lastTemperatureStatus) ||
                other.lastTemperatureStatus == lastTemperatureStatus) &&
            (identical(other.signInOutStatus, signInOutStatus) ||
                other.signInOutStatus == signInOutStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, student, attendanceStatus,
      lastTemperatureStatus, signInOutStatus);

  @override
  String toString() {
    return 'StudentMiniDailyLogVODto(student: $student, attendanceStatus: $attendanceStatus, lastTemperatureStatus: $lastTemperatureStatus, signInOutStatus: $signInOutStatus)';
  }
}

/// @nodoc
abstract mixin class _$StudentMiniDailyLogVODtoCopyWith<$Res>
    implements $StudentMiniDailyLogVODtoCopyWith<$Res> {
  factory _$StudentMiniDailyLogVODtoCopyWith(_StudentMiniDailyLogVODto value,
          $Res Function(_StudentMiniDailyLogVODto) _then) =
      __$StudentMiniDailyLogVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'student') StudentDto? student,
      @JsonKey(name: 'attendanceStatus') AttendanceVODto? attendanceStatus,
      @JsonKey(name: 'lastTemperatureStatus')
      LastTemperatureVODto? lastTemperatureStatus,
      @JsonKey(name: 'signInOutStatus') CheckInOutVODto? signInOutStatus});

  @override
  $StudentDtoCopyWith<$Res>? get student;
  @override
  $AttendanceVODtoCopyWith<$Res>? get attendanceStatus;
  @override
  $LastTemperatureVODtoCopyWith<$Res>? get lastTemperatureStatus;
  @override
  $CheckInOutVODtoCopyWith<$Res>? get signInOutStatus;
}

/// @nodoc
class __$StudentMiniDailyLogVODtoCopyWithImpl<$Res>
    implements _$StudentMiniDailyLogVODtoCopyWith<$Res> {
  __$StudentMiniDailyLogVODtoCopyWithImpl(this._self, this._then);

  final _StudentMiniDailyLogVODto _self;
  final $Res Function(_StudentMiniDailyLogVODto) _then;

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? student = freezed,
    Object? attendanceStatus = freezed,
    Object? lastTemperatureStatus = freezed,
    Object? signInOutStatus = freezed,
  }) {
    return _then(_StudentMiniDailyLogVODto(
      student: freezed == student
          ? _self.student
          : student // ignore: cast_nullable_to_non_nullable
              as StudentDto?,
      attendanceStatus: freezed == attendanceStatus
          ? _self.attendanceStatus
          : attendanceStatus // ignore: cast_nullable_to_non_nullable
              as AttendanceVODto?,
      lastTemperatureStatus: freezed == lastTemperatureStatus
          ? _self.lastTemperatureStatus
          : lastTemperatureStatus // ignore: cast_nullable_to_non_nullable
              as LastTemperatureVODto?,
      signInOutStatus: freezed == signInOutStatus
          ? _self.signInOutStatus
          : signInOutStatus // ignore: cast_nullable_to_non_nullable
              as CheckInOutVODto?,
    ));
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentDtoCopyWith<$Res>? get student {
    if (_self.student == null) {
      return null;
    }

    return $StudentDtoCopyWith<$Res>(_self.student!, (value) {
      return _then(_self.copyWith(student: value));
    });
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AttendanceVODtoCopyWith<$Res>? get attendanceStatus {
    if (_self.attendanceStatus == null) {
      return null;
    }

    return $AttendanceVODtoCopyWith<$Res>(_self.attendanceStatus!, (value) {
      return _then(_self.copyWith(attendanceStatus: value));
    });
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LastTemperatureVODtoCopyWith<$Res>? get lastTemperatureStatus {
    if (_self.lastTemperatureStatus == null) {
      return null;
    }

    return $LastTemperatureVODtoCopyWith<$Res>(_self.lastTemperatureStatus!,
        (value) {
      return _then(_self.copyWith(lastTemperatureStatus: value));
    });
  }

  /// Create a copy of StudentMiniDailyLogVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CheckInOutVODtoCopyWith<$Res>? get signInOutStatus {
    if (_self.signInOutStatus == null) {
      return null;
    }

    return $CheckInOutVODtoCopyWith<$Res>(_self.signInOutStatus!, (value) {
      return _then(_self.copyWith(signInOutStatus: value));
    });
  }
}

/// @nodoc
mixin _$StudentStatisticDto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'studentId')
  String? get studentId;
  @JsonKey(name: 'academicYearId')
  String? get academicYearId;
  @JsonKey(name: 'academicYear')
  String? get academicYear;
  @JsonKey(name: 'termId')
  String? get termId;
  @JsonKey(name: 'term')
  String? get term;
  @JsonKey(name: 'weightInKg')
  num? get weightInKg;
  @JsonKey(name: 'heightInCm')
  num? get heightInCm;
  @JsonKey(name: 'status')
  String? get status;

  /// Create a copy of StudentStatisticDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentStatisticDtoCopyWith<StudentStatisticDto> get copyWith =>
      _$StudentStatisticDtoCopyWithImpl<StudentStatisticDto>(
          this as StudentStatisticDto, _$identity);

  /// Serializes this StudentStatisticDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentStatisticDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicYear, academicYear) ||
                other.academicYear == academicYear) &&
            (identical(other.termId, termId) || other.termId == termId) &&
            (identical(other.term, term) || other.term == term) &&
            (identical(other.weightInKg, weightInKg) ||
                other.weightInKg == weightInKg) &&
            (identical(other.heightInCm, heightInCm) ||
                other.heightInCm == heightInCm) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, studentId, academicYearId,
      academicYear, termId, term, weightInKg, heightInCm, status);

  @override
  String toString() {
    return 'StudentStatisticDto(id: $id, studentId: $studentId, academicYearId: $academicYearId, academicYear: $academicYear, termId: $termId, term: $term, weightInKg: $weightInKg, heightInCm: $heightInCm, status: $status)';
  }
}

/// @nodoc
abstract mixin class $StudentStatisticDtoCopyWith<$Res> {
  factory $StudentStatisticDtoCopyWith(
          StudentStatisticDto value, $Res Function(StudentStatisticDto) _then) =
      _$StudentStatisticDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'academicYear') String? academicYear,
      @JsonKey(name: 'termId') String? termId,
      @JsonKey(name: 'term') String? term,
      @JsonKey(name: 'weightInKg') num? weightInKg,
      @JsonKey(name: 'heightInCm') num? heightInCm,
      @JsonKey(name: 'status') String? status});
}

/// @nodoc
class _$StudentStatisticDtoCopyWithImpl<$Res>
    implements $StudentStatisticDtoCopyWith<$Res> {
  _$StudentStatisticDtoCopyWithImpl(this._self, this._then);

  final StudentStatisticDto _self;
  final $Res Function(StudentStatisticDto) _then;

  /// Create a copy of StudentStatisticDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? academicYearId = freezed,
    Object? academicYear = freezed,
    Object? termId = freezed,
    Object? term = freezed,
    Object? weightInKg = freezed,
    Object? heightInCm = freezed,
    Object? status = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      academicYear: freezed == academicYear
          ? _self.academicYear
          : academicYear // ignore: cast_nullable_to_non_nullable
              as String?,
      termId: freezed == termId
          ? _self.termId
          : termId // ignore: cast_nullable_to_non_nullable
              as String?,
      term: freezed == term
          ? _self.term
          : term // ignore: cast_nullable_to_non_nullable
              as String?,
      weightInKg: freezed == weightInKg
          ? _self.weightInKg
          : weightInKg // ignore: cast_nullable_to_non_nullable
              as num?,
      heightInCm: freezed == heightInCm
          ? _self.heightInCm
          : heightInCm // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StudentStatisticDto].
extension StudentStatisticDtoPatterns on StudentStatisticDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentStatisticDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentStatisticDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentStatisticDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentStatisticDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentStatisticDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentStatisticDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'academicYear') String? academicYear,
            @JsonKey(name: 'termId') String? termId,
            @JsonKey(name: 'term') String? term,
            @JsonKey(name: 'weightInKg') num? weightInKg,
            @JsonKey(name: 'heightInCm') num? heightInCm,
            @JsonKey(name: 'status') String? status)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentStatisticDto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.academicYearId,
            _that.academicYear,
            _that.termId,
            _that.term,
            _that.weightInKg,
            _that.heightInCm,
            _that.status);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'academicYear') String? academicYear,
            @JsonKey(name: 'termId') String? termId,
            @JsonKey(name: 'term') String? term,
            @JsonKey(name: 'weightInKg') num? weightInKg,
            @JsonKey(name: 'heightInCm') num? heightInCm,
            @JsonKey(name: 'status') String? status)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentStatisticDto():
        return $default(
            _that.id,
            _that.studentId,
            _that.academicYearId,
            _that.academicYear,
            _that.termId,
            _that.term,
            _that.weightInKg,
            _that.heightInCm,
            _that.status);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') String? studentId,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'academicYear') String? academicYear,
            @JsonKey(name: 'termId') String? termId,
            @JsonKey(name: 'term') String? term,
            @JsonKey(name: 'weightInKg') num? weightInKg,
            @JsonKey(name: 'heightInCm') num? heightInCm,
            @JsonKey(name: 'status') String? status)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentStatisticDto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.academicYearId,
            _that.academicYear,
            _that.termId,
            _that.term,
            _that.weightInKg,
            _that.heightInCm,
            _that.status);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentStatisticDto implements StudentStatisticDto {
  _StudentStatisticDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'academicYear') this.academicYear,
      @JsonKey(name: 'termId') this.termId,
      @JsonKey(name: 'term') this.term,
      @JsonKey(name: 'weightInKg') this.weightInKg,
      @JsonKey(name: 'heightInCm') this.heightInCm,
      @JsonKey(name: 'status') this.status});
  factory _StudentStatisticDto.fromJson(Map<String, dynamic> json) =>
      _$StudentStatisticDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;
  @override
  @JsonKey(name: 'academicYearId')
  final String? academicYearId;
  @override
  @JsonKey(name: 'academicYear')
  final String? academicYear;
  @override
  @JsonKey(name: 'termId')
  final String? termId;
  @override
  @JsonKey(name: 'term')
  final String? term;
  @override
  @JsonKey(name: 'weightInKg')
  final num? weightInKg;
  @override
  @JsonKey(name: 'heightInCm')
  final num? heightInCm;
  @override
  @JsonKey(name: 'status')
  final String? status;

  /// Create a copy of StudentStatisticDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentStatisticDtoCopyWith<_StudentStatisticDto> get copyWith =>
      __$StudentStatisticDtoCopyWithImpl<_StudentStatisticDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentStatisticDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentStatisticDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicYear, academicYear) ||
                other.academicYear == academicYear) &&
            (identical(other.termId, termId) || other.termId == termId) &&
            (identical(other.term, term) || other.term == term) &&
            (identical(other.weightInKg, weightInKg) ||
                other.weightInKg == weightInKg) &&
            (identical(other.heightInCm, heightInCm) ||
                other.heightInCm == heightInCm) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, studentId, academicYearId,
      academicYear, termId, term, weightInKg, heightInCm, status);

  @override
  String toString() {
    return 'StudentStatisticDto(id: $id, studentId: $studentId, academicYearId: $academicYearId, academicYear: $academicYear, termId: $termId, term: $term, weightInKg: $weightInKg, heightInCm: $heightInCm, status: $status)';
  }
}

/// @nodoc
abstract mixin class _$StudentStatisticDtoCopyWith<$Res>
    implements $StudentStatisticDtoCopyWith<$Res> {
  factory _$StudentStatisticDtoCopyWith(_StudentStatisticDto value,
          $Res Function(_StudentStatisticDto) _then) =
      __$StudentStatisticDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'studentId') String? studentId,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'academicYear') String? academicYear,
      @JsonKey(name: 'termId') String? termId,
      @JsonKey(name: 'term') String? term,
      @JsonKey(name: 'weightInKg') num? weightInKg,
      @JsonKey(name: 'heightInCm') num? heightInCm,
      @JsonKey(name: 'status') String? status});
}

/// @nodoc
class __$StudentStatisticDtoCopyWithImpl<$Res>
    implements _$StudentStatisticDtoCopyWith<$Res> {
  __$StudentStatisticDtoCopyWithImpl(this._self, this._then);

  final _StudentStatisticDto _self;
  final $Res Function(_StudentStatisticDto) _then;

  /// Create a copy of StudentStatisticDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? academicYearId = freezed,
    Object? academicYear = freezed,
    Object? termId = freezed,
    Object? term = freezed,
    Object? weightInKg = freezed,
    Object? heightInCm = freezed,
    Object? status = freezed,
  }) {
    return _then(_StudentStatisticDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      academicYear: freezed == academicYear
          ? _self.academicYear
          : academicYear // ignore: cast_nullable_to_non_nullable
              as String?,
      termId: freezed == termId
          ? _self.termId
          : termId // ignore: cast_nullable_to_non_nullable
              as String?,
      term: freezed == term
          ? _self.term
          : term // ignore: cast_nullable_to_non_nullable
              as String?,
      weightInKg: freezed == weightInKg
          ? _self.weightInKg
          : weightInKg // ignore: cast_nullable_to_non_nullable
              as num?,
      heightInCm: freezed == heightInCm
          ? _self.heightInCm
          : heightInCm // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$StudentWithConfigVODto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'displayName')
  String? get displayName;
  @JsonKey(name: 'schoolId')
  String? get schoolId;
  @JsonKey(name: 'schoolName')
  String? get schoolName;
  @JsonKey(name: 'classId')
  String? get classId;
  @JsonKey(name: 'className')
  String? get className;
  @JsonKey(name: 'photo')
  String? get photo;
  @JsonKey(name: 'levelId')
  String? get levelId;
  @JsonKey(name: 'levelName')
  String? get levelName;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'registrationDate')
  DateTime? get registrationDate;
  @JsonKey(name: 'config')
  ChildConfigVODto? get config;

  /// Create a copy of StudentWithConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentWithConfigVODtoCopyWith<StudentWithConfigVODto> get copyWith =>
      _$StudentWithConfigVODtoCopyWithImpl<StudentWithConfigVODto>(
          this as StudentWithConfigVODto, _$identity);

  /// Serializes this StudentWithConfigVODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentWithConfigVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.schoolName, schoolName) ||
                other.schoolName == schoolName) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.levelName, levelName) ||
                other.levelName == levelName) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.registrationDate, registrationDate) ||
                other.registrationDate == registrationDate) &&
            (identical(other.config, config) || other.config == config));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      schoolId,
      schoolName,
      classId,
      className,
      photo,
      levelId,
      levelName,
      status,
      registrationDate,
      config);

  @override
  String toString() {
    return 'StudentWithConfigVODto(id: $id, displayName: $displayName, schoolId: $schoolId, schoolName: $schoolName, classId: $classId, className: $className, photo: $photo, levelId: $levelId, levelName: $levelName, status: $status, registrationDate: $registrationDate, config: $config)';
  }
}

/// @nodoc
abstract mixin class $StudentWithConfigVODtoCopyWith<$Res> {
  factory $StudentWithConfigVODtoCopyWith(StudentWithConfigVODto value,
          $Res Function(StudentWithConfigVODto) _then) =
      _$StudentWithConfigVODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'schoolName') String? schoolName,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'className') String? className,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'levelId') String? levelId,
      @JsonKey(name: 'levelName') String? levelName,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'registrationDate') DateTime? registrationDate,
      @JsonKey(name: 'config') ChildConfigVODto? config});

  $ChildConfigVODtoCopyWith<$Res>? get config;
}

/// @nodoc
class _$StudentWithConfigVODtoCopyWithImpl<$Res>
    implements $StudentWithConfigVODtoCopyWith<$Res> {
  _$StudentWithConfigVODtoCopyWithImpl(this._self, this._then);

  final StudentWithConfigVODto _self;
  final $Res Function(StudentWithConfigVODto) _then;

  /// Create a copy of StudentWithConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? displayName = freezed,
    Object? schoolId = freezed,
    Object? schoolName = freezed,
    Object? classId = freezed,
    Object? className = freezed,
    Object? photo = freezed,
    Object? levelId = freezed,
    Object? levelName = freezed,
    Object? status = freezed,
    Object? registrationDate = freezed,
    Object? config = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolName: freezed == schoolName
          ? _self.schoolName
          : schoolName // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelName: freezed == levelName
          ? _self.levelName
          : levelName // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      registrationDate: freezed == registrationDate
          ? _self.registrationDate
          : registrationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      config: freezed == config
          ? _self.config
          : config // ignore: cast_nullable_to_non_nullable
              as ChildConfigVODto?,
    ));
  }

  /// Create a copy of StudentWithConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChildConfigVODtoCopyWith<$Res>? get config {
    if (_self.config == null) {
      return null;
    }

    return $ChildConfigVODtoCopyWith<$Res>(_self.config!, (value) {
      return _then(_self.copyWith(config: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StudentWithConfigVODto].
extension StudentWithConfigVODtoPatterns on StudentWithConfigVODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentWithConfigVODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentWithConfigVODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentWithConfigVODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentWithConfigVODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentWithConfigVODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentWithConfigVODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate,
            @JsonKey(name: 'config') ChildConfigVODto? config)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentWithConfigVODto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.schoolId,
            _that.schoolName,
            _that.classId,
            _that.className,
            _that.photo,
            _that.levelId,
            _that.levelName,
            _that.status,
            _that.registrationDate,
            _that.config);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate,
            @JsonKey(name: 'config') ChildConfigVODto? config)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentWithConfigVODto():
        return $default(
            _that.id,
            _that.displayName,
            _that.schoolId,
            _that.schoolName,
            _that.classId,
            _that.className,
            _that.photo,
            _that.levelId,
            _that.levelName,
            _that.status,
            _that.registrationDate,
            _that.config);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'schoolId') String? schoolId,
            @JsonKey(name: 'schoolName') String? schoolName,
            @JsonKey(name: 'classId') String? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'photo') String? photo,
            @JsonKey(name: 'levelId') String? levelId,
            @JsonKey(name: 'levelName') String? levelName,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'registrationDate') DateTime? registrationDate,
            @JsonKey(name: 'config') ChildConfigVODto? config)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentWithConfigVODto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.schoolId,
            _that.schoolName,
            _that.classId,
            _that.className,
            _that.photo,
            _that.levelId,
            _that.levelName,
            _that.status,
            _that.registrationDate,
            _that.config);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentWithConfigVODto implements StudentWithConfigVODto {
  _StudentWithConfigVODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'displayName') this.displayName,
      @JsonKey(name: 'schoolId') this.schoolId,
      @JsonKey(name: 'schoolName') this.schoolName,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'className') this.className,
      @JsonKey(name: 'photo') this.photo,
      @JsonKey(name: 'levelId') this.levelId,
      @JsonKey(name: 'levelName') this.levelName,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'registrationDate') this.registrationDate,
      @JsonKey(name: 'config') this.config});
  factory _StudentWithConfigVODto.fromJson(Map<String, dynamic> json) =>
      _$StudentWithConfigVODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'displayName')
  final String? displayName;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;
  @override
  @JsonKey(name: 'schoolName')
  final String? schoolName;
  @override
  @JsonKey(name: 'classId')
  final String? classId;
  @override
  @JsonKey(name: 'className')
  final String? className;
  @override
  @JsonKey(name: 'photo')
  final String? photo;
  @override
  @JsonKey(name: 'levelId')
  final String? levelId;
  @override
  @JsonKey(name: 'levelName')
  final String? levelName;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'registrationDate')
  final DateTime? registrationDate;
  @override
  @JsonKey(name: 'config')
  final ChildConfigVODto? config;

  /// Create a copy of StudentWithConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentWithConfigVODtoCopyWith<_StudentWithConfigVODto> get copyWith =>
      __$StudentWithConfigVODtoCopyWithImpl<_StudentWithConfigVODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentWithConfigVODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentWithConfigVODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.schoolName, schoolName) ||
                other.schoolName == schoolName) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className) &&
            (identical(other.photo, photo) || other.photo == photo) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.levelName, levelName) ||
                other.levelName == levelName) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.registrationDate, registrationDate) ||
                other.registrationDate == registrationDate) &&
            (identical(other.config, config) || other.config == config));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      schoolId,
      schoolName,
      classId,
      className,
      photo,
      levelId,
      levelName,
      status,
      registrationDate,
      config);

  @override
  String toString() {
    return 'StudentWithConfigVODto(id: $id, displayName: $displayName, schoolId: $schoolId, schoolName: $schoolName, classId: $classId, className: $className, photo: $photo, levelId: $levelId, levelName: $levelName, status: $status, registrationDate: $registrationDate, config: $config)';
  }
}

/// @nodoc
abstract mixin class _$StudentWithConfigVODtoCopyWith<$Res>
    implements $StudentWithConfigVODtoCopyWith<$Res> {
  factory _$StudentWithConfigVODtoCopyWith(_StudentWithConfigVODto value,
          $Res Function(_StudentWithConfigVODto) _then) =
      __$StudentWithConfigVODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'schoolId') String? schoolId,
      @JsonKey(name: 'schoolName') String? schoolName,
      @JsonKey(name: 'classId') String? classId,
      @JsonKey(name: 'className') String? className,
      @JsonKey(name: 'photo') String? photo,
      @JsonKey(name: 'levelId') String? levelId,
      @JsonKey(name: 'levelName') String? levelName,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'registrationDate') DateTime? registrationDate,
      @JsonKey(name: 'config') ChildConfigVODto? config});

  @override
  $ChildConfigVODtoCopyWith<$Res>? get config;
}

/// @nodoc
class __$StudentWithConfigVODtoCopyWithImpl<$Res>
    implements _$StudentWithConfigVODtoCopyWith<$Res> {
  __$StudentWithConfigVODtoCopyWithImpl(this._self, this._then);

  final _StudentWithConfigVODto _self;
  final $Res Function(_StudentWithConfigVODto) _then;

  /// Create a copy of StudentWithConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? displayName = freezed,
    Object? schoolId = freezed,
    Object? schoolName = freezed,
    Object? classId = freezed,
    Object? className = freezed,
    Object? photo = freezed,
    Object? levelId = freezed,
    Object? levelName = freezed,
    Object? status = freezed,
    Object? registrationDate = freezed,
    Object? config = freezed,
  }) {
    return _then(_StudentWithConfigVODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolName: freezed == schoolName
          ? _self.schoolName
          : schoolName // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
      photo: freezed == photo
          ? _self.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelName: freezed == levelName
          ? _self.levelName
          : levelName // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      registrationDate: freezed == registrationDate
          ? _self.registrationDate
          : registrationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      config: freezed == config
          ? _self.config
          : config // ignore: cast_nullable_to_non_nullable
              as ChildConfigVODto?,
    ));
  }

  /// Create a copy of StudentWithConfigVODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChildConfigVODtoCopyWith<$Res>? get config {
    if (_self.config == null) {
      return null;
    }

    return $ChildConfigVODtoCopyWith<$Res>(_self.config!, (value) {
      return _then(_self.copyWith(config: value));
    });
  }
}

/// @nodoc
mixin _$TagClassDto {
  @JsonKey(name: 'teacherId')
  String? get teacherId;
  @JsonKey(name: 'classId')
  String? get classId;

  /// Create a copy of TagClassDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TagClassDtoCopyWith<TagClassDto> get copyWith =>
      _$TagClassDtoCopyWithImpl<TagClassDto>(this as TagClassDto, _$identity);

  /// Serializes this TagClassDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TagClassDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.classId, classId) || other.classId == classId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, classId);

  @override
  String toString() {
    return 'TagClassDto(teacherId: $teacherId, classId: $classId)';
  }
}

/// @nodoc
abstract mixin class $TagClassDtoCopyWith<$Res> {
  factory $TagClassDtoCopyWith(
          TagClassDto value, $Res Function(TagClassDto) _then) =
      _$TagClassDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'classId') String? classId});
}

/// @nodoc
class _$TagClassDtoCopyWithImpl<$Res> implements $TagClassDtoCopyWith<$Res> {
  _$TagClassDtoCopyWithImpl(this._self, this._then);

  final TagClassDto _self;
  final $Res Function(TagClassDto) _then;

  /// Create a copy of TagClassDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? teacherId = freezed,
    Object? classId = freezed,
  }) {
    return _then(_self.copyWith(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [TagClassDto].
extension TagClassDtoPatterns on TagClassDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TagClassDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TagClassDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TagClassDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagClassDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TagClassDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagClassDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'classId') String? classId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TagClassDto() when $default != null:
        return $default(_that.teacherId, _that.classId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'classId') String? classId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagClassDto():
        return $default(_that.teacherId, _that.classId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'classId') String? classId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagClassDto() when $default != null:
        return $default(_that.teacherId, _that.classId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TagClassDto implements TagClassDto {
  _TagClassDto(
      {@JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'classId') this.classId});
  factory _TagClassDto.fromJson(Map<String, dynamic> json) =>
      _$TagClassDtoFromJson(json);

  @override
  @JsonKey(name: 'teacherId')
  final String? teacherId;
  @override
  @JsonKey(name: 'classId')
  final String? classId;

  /// Create a copy of TagClassDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TagClassDtoCopyWith<_TagClassDto> get copyWith =>
      __$TagClassDtoCopyWithImpl<_TagClassDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TagClassDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TagClassDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.classId, classId) || other.classId == classId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, classId);

  @override
  String toString() {
    return 'TagClassDto(teacherId: $teacherId, classId: $classId)';
  }
}

/// @nodoc
abstract mixin class _$TagClassDtoCopyWith<$Res>
    implements $TagClassDtoCopyWith<$Res> {
  factory _$TagClassDtoCopyWith(
          _TagClassDto value, $Res Function(_TagClassDto) _then) =
      __$TagClassDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'classId') String? classId});
}

/// @nodoc
class __$TagClassDtoCopyWithImpl<$Res> implements _$TagClassDtoCopyWith<$Res> {
  __$TagClassDtoCopyWithImpl(this._self, this._then);

  final _TagClassDto _self;
  final $Res Function(_TagClassDto) _then;

  /// Create a copy of TagClassDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? teacherId = freezed,
    Object? classId = freezed,
  }) {
    return _then(_TagClassDto(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$TagLevelDto {
  @JsonKey(name: 'teacherId')
  String? get teacherId;
  @JsonKey(name: 'levelId')
  String? get levelId;

  /// Create a copy of TagLevelDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TagLevelDtoCopyWith<TagLevelDto> get copyWith =>
      _$TagLevelDtoCopyWithImpl<TagLevelDto>(this as TagLevelDto, _$identity);

  /// Serializes this TagLevelDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TagLevelDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, levelId);

  @override
  String toString() {
    return 'TagLevelDto(teacherId: $teacherId, levelId: $levelId)';
  }
}

/// @nodoc
abstract mixin class $TagLevelDtoCopyWith<$Res> {
  factory $TagLevelDtoCopyWith(
          TagLevelDto value, $Res Function(TagLevelDto) _then) =
      _$TagLevelDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'levelId') String? levelId});
}

/// @nodoc
class _$TagLevelDtoCopyWithImpl<$Res> implements $TagLevelDtoCopyWith<$Res> {
  _$TagLevelDtoCopyWithImpl(this._self, this._then);

  final TagLevelDto _self;
  final $Res Function(TagLevelDto) _then;

  /// Create a copy of TagLevelDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? teacherId = freezed,
    Object? levelId = freezed,
  }) {
    return _then(_self.copyWith(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [TagLevelDto].
extension TagLevelDtoPatterns on TagLevelDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TagLevelDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TagLevelDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TagLevelDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagLevelDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TagLevelDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagLevelDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'levelId') String? levelId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TagLevelDto() when $default != null:
        return $default(_that.teacherId, _that.levelId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'levelId') String? levelId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagLevelDto():
        return $default(_that.teacherId, _that.levelId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'levelId') String? levelId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagLevelDto() when $default != null:
        return $default(_that.teacherId, _that.levelId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TagLevelDto implements TagLevelDto {
  _TagLevelDto(
      {@JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'levelId') this.levelId});
  factory _TagLevelDto.fromJson(Map<String, dynamic> json) =>
      _$TagLevelDtoFromJson(json);

  @override
  @JsonKey(name: 'teacherId')
  final String? teacherId;
  @override
  @JsonKey(name: 'levelId')
  final String? levelId;

  /// Create a copy of TagLevelDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TagLevelDtoCopyWith<_TagLevelDto> get copyWith =>
      __$TagLevelDtoCopyWithImpl<_TagLevelDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TagLevelDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TagLevelDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, levelId);

  @override
  String toString() {
    return 'TagLevelDto(teacherId: $teacherId, levelId: $levelId)';
  }
}

/// @nodoc
abstract mixin class _$TagLevelDtoCopyWith<$Res>
    implements $TagLevelDtoCopyWith<$Res> {
  factory _$TagLevelDtoCopyWith(
          _TagLevelDto value, $Res Function(_TagLevelDto) _then) =
      __$TagLevelDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'levelId') String? levelId});
}

/// @nodoc
class __$TagLevelDtoCopyWithImpl<$Res> implements _$TagLevelDtoCopyWith<$Res> {
  __$TagLevelDtoCopyWithImpl(this._self, this._then);

  final _TagLevelDto _self;
  final $Res Function(_TagLevelDto) _then;

  /// Create a copy of TagLevelDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? teacherId = freezed,
    Object? levelId = freezed,
  }) {
    return _then(_TagLevelDto(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$TagStudentsDto {
  @JsonKey(name: 'teacherId')
  String? get teacherId;
  @JsonKey(name: 'studentId')
  String? get studentId;

  /// Create a copy of TagStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TagStudentsDtoCopyWith<TagStudentsDto> get copyWith =>
      _$TagStudentsDtoCopyWithImpl<TagStudentsDto>(
          this as TagStudentsDto, _$identity);

  /// Serializes this TagStudentsDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TagStudentsDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, studentId);

  @override
  String toString() {
    return 'TagStudentsDto(teacherId: $teacherId, studentId: $studentId)';
  }
}

/// @nodoc
abstract mixin class $TagStudentsDtoCopyWith<$Res> {
  factory $TagStudentsDtoCopyWith(
          TagStudentsDto value, $Res Function(TagStudentsDto) _then) =
      _$TagStudentsDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'studentId') String? studentId});
}

/// @nodoc
class _$TagStudentsDtoCopyWithImpl<$Res>
    implements $TagStudentsDtoCopyWith<$Res> {
  _$TagStudentsDtoCopyWithImpl(this._self, this._then);

  final TagStudentsDto _self;
  final $Res Function(TagStudentsDto) _then;

  /// Create a copy of TagStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? teacherId = freezed,
    Object? studentId = freezed,
  }) {
    return _then(_self.copyWith(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [TagStudentsDto].
extension TagStudentsDtoPatterns on TagStudentsDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TagStudentsDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TagStudentsDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TagStudentsDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagStudentsDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TagStudentsDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagStudentsDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'studentId') String? studentId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TagStudentsDto() when $default != null:
        return $default(_that.teacherId, _that.studentId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'studentId') String? studentId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagStudentsDto():
        return $default(_that.teacherId, _that.studentId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'teacherId') String? teacherId,
            @JsonKey(name: 'studentId') String? studentId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TagStudentsDto() when $default != null:
        return $default(_that.teacherId, _that.studentId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TagStudentsDto implements TagStudentsDto {
  _TagStudentsDto(
      {@JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'studentId') this.studentId});
  factory _TagStudentsDto.fromJson(Map<String, dynamic> json) =>
      _$TagStudentsDtoFromJson(json);

  @override
  @JsonKey(name: 'teacherId')
  final String? teacherId;
  @override
  @JsonKey(name: 'studentId')
  final String? studentId;

  /// Create a copy of TagStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TagStudentsDtoCopyWith<_TagStudentsDto> get copyWith =>
      __$TagStudentsDtoCopyWithImpl<_TagStudentsDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TagStudentsDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TagStudentsDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, studentId);

  @override
  String toString() {
    return 'TagStudentsDto(teacherId: $teacherId, studentId: $studentId)';
  }
}

/// @nodoc
abstract mixin class _$TagStudentsDtoCopyWith<$Res>
    implements $TagStudentsDtoCopyWith<$Res> {
  factory _$TagStudentsDtoCopyWith(
          _TagStudentsDto value, $Res Function(_TagStudentsDto) _then) =
      __$TagStudentsDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') String? teacherId,
      @JsonKey(name: 'studentId') String? studentId});
}

/// @nodoc
class __$TagStudentsDtoCopyWithImpl<$Res>
    implements _$TagStudentsDtoCopyWith<$Res> {
  __$TagStudentsDtoCopyWithImpl(this._self, this._then);

  final _TagStudentsDto _self;
  final $Res Function(_TagStudentsDto) _then;

  /// Create a copy of TagStudentsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? teacherId = freezed,
    Object? studentId = freezed,
  }) {
    return _then(_TagStudentsDto(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$TeacherServiceQueryParameterDto {
  @JsonKey(name: 'pageNumber')
  int? get pageNumber;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'isActive')
  bool? get isActive;
  @JsonKey(name: 'overrideIsAciveFilter')
  bool? get overrideIsAciveFilter;
  @JsonKey(name: 'academicYearId')
  String? get academicYearId;
  @JsonKey(name: 'schoolId')
  String? get schoolId;

  /// Create a copy of TeacherServiceQueryParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TeacherServiceQueryParameterDtoCopyWith<TeacherServiceQueryParameterDto>
      get copyWith => _$TeacherServiceQueryParameterDtoCopyWithImpl<
              TeacherServiceQueryParameterDto>(
          this as TeacherServiceQueryParameterDto, _$identity);

  /// Serializes this TeacherServiceQueryParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TeacherServiceQueryParameterDto &&
            (identical(other.pageNumber, pageNumber) ||
                other.pageNumber == pageNumber) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.overrideIsAciveFilter, overrideIsAciveFilter) ||
                other.overrideIsAciveFilter == overrideIsAciveFilter) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, pageNumber, pageSize, isActive,
      overrideIsAciveFilter, academicYearId, schoolId);

  @override
  String toString() {
    return 'TeacherServiceQueryParameterDto(pageNumber: $pageNumber, pageSize: $pageSize, isActive: $isActive, overrideIsAciveFilter: $overrideIsAciveFilter, academicYearId: $academicYearId, schoolId: $schoolId)';
  }
}

/// @nodoc
abstract mixin class $TeacherServiceQueryParameterDtoCopyWith<$Res> {
  factory $TeacherServiceQueryParameterDtoCopyWith(
          TeacherServiceQueryParameterDto value,
          $Res Function(TeacherServiceQueryParameterDto) _then) =
      _$TeacherServiceQueryParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'pageNumber') int? pageNumber,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'isActive') bool? isActive,
      @JsonKey(name: 'overrideIsAciveFilter') bool? overrideIsAciveFilter,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'schoolId') String? schoolId});
}

/// @nodoc
class _$TeacherServiceQueryParameterDtoCopyWithImpl<$Res>
    implements $TeacherServiceQueryParameterDtoCopyWith<$Res> {
  _$TeacherServiceQueryParameterDtoCopyWithImpl(this._self, this._then);

  final TeacherServiceQueryParameterDto _self;
  final $Res Function(TeacherServiceQueryParameterDto) _then;

  /// Create a copy of TeacherServiceQueryParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageNumber = freezed,
    Object? pageSize = freezed,
    Object? isActive = freezed,
    Object? overrideIsAciveFilter = freezed,
    Object? academicYearId = freezed,
    Object? schoolId = freezed,
  }) {
    return _then(_self.copyWith(
      pageNumber: freezed == pageNumber
          ? _self.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      overrideIsAciveFilter: freezed == overrideIsAciveFilter
          ? _self.overrideIsAciveFilter
          : overrideIsAciveFilter // ignore: cast_nullable_to_non_nullable
              as bool?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [TeacherServiceQueryParameterDto].
extension TeacherServiceQueryParameterDtoPatterns
    on TeacherServiceQueryParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TeacherServiceQueryParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TeacherServiceQueryParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TeacherServiceQueryParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherServiceQueryParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TeacherServiceQueryParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherServiceQueryParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'pageNumber') int? pageNumber,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'overrideIsAciveFilter') bool? overrideIsAciveFilter,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'schoolId') String? schoolId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TeacherServiceQueryParameterDto() when $default != null:
        return $default(_that.pageNumber, _that.pageSize, _that.isActive,
            _that.overrideIsAciveFilter, _that.academicYearId, _that.schoolId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'pageNumber') int? pageNumber,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'overrideIsAciveFilter') bool? overrideIsAciveFilter,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'schoolId') String? schoolId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherServiceQueryParameterDto():
        return $default(_that.pageNumber, _that.pageSize, _that.isActive,
            _that.overrideIsAciveFilter, _that.academicYearId, _that.schoolId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'pageNumber') int? pageNumber,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'overrideIsAciveFilter') bool? overrideIsAciveFilter,
            @JsonKey(name: 'academicYearId') String? academicYearId,
            @JsonKey(name: 'schoolId') String? schoolId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherServiceQueryParameterDto() when $default != null:
        return $default(_that.pageNumber, _that.pageSize, _that.isActive,
            _that.overrideIsAciveFilter, _that.academicYearId, _that.schoolId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TeacherServiceQueryParameterDto
    implements TeacherServiceQueryParameterDto {
  _TeacherServiceQueryParameterDto(
      {@JsonKey(name: 'pageNumber') this.pageNumber,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'isActive') this.isActive,
      @JsonKey(name: 'overrideIsAciveFilter') this.overrideIsAciveFilter,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'schoolId') this.schoolId});
  factory _TeacherServiceQueryParameterDto.fromJson(
          Map<String, dynamic> json) =>
      _$TeacherServiceQueryParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'pageNumber')
  final int? pageNumber;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @override
  @JsonKey(name: 'overrideIsAciveFilter')
  final bool? overrideIsAciveFilter;
  @override
  @JsonKey(name: 'academicYearId')
  final String? academicYearId;
  @override
  @JsonKey(name: 'schoolId')
  final String? schoolId;

  /// Create a copy of TeacherServiceQueryParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TeacherServiceQueryParameterDtoCopyWith<_TeacherServiceQueryParameterDto>
      get copyWith => __$TeacherServiceQueryParameterDtoCopyWithImpl<
          _TeacherServiceQueryParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TeacherServiceQueryParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TeacherServiceQueryParameterDto &&
            (identical(other.pageNumber, pageNumber) ||
                other.pageNumber == pageNumber) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.overrideIsAciveFilter, overrideIsAciveFilter) ||
                other.overrideIsAciveFilter == overrideIsAciveFilter) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, pageNumber, pageSize, isActive,
      overrideIsAciveFilter, academicYearId, schoolId);

  @override
  String toString() {
    return 'TeacherServiceQueryParameterDto(pageNumber: $pageNumber, pageSize: $pageSize, isActive: $isActive, overrideIsAciveFilter: $overrideIsAciveFilter, academicYearId: $academicYearId, schoolId: $schoolId)';
  }
}

/// @nodoc
abstract mixin class _$TeacherServiceQueryParameterDtoCopyWith<$Res>
    implements $TeacherServiceQueryParameterDtoCopyWith<$Res> {
  factory _$TeacherServiceQueryParameterDtoCopyWith(
          _TeacherServiceQueryParameterDto value,
          $Res Function(_TeacherServiceQueryParameterDto) _then) =
      __$TeacherServiceQueryParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'pageNumber') int? pageNumber,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'isActive') bool? isActive,
      @JsonKey(name: 'overrideIsAciveFilter') bool? overrideIsAciveFilter,
      @JsonKey(name: 'academicYearId') String? academicYearId,
      @JsonKey(name: 'schoolId') String? schoolId});
}

/// @nodoc
class __$TeacherServiceQueryParameterDtoCopyWithImpl<$Res>
    implements _$TeacherServiceQueryParameterDtoCopyWith<$Res> {
  __$TeacherServiceQueryParameterDtoCopyWithImpl(this._self, this._then);

  final _TeacherServiceQueryParameterDto _self;
  final $Res Function(_TeacherServiceQueryParameterDto) _then;

  /// Create a copy of TeacherServiceQueryParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? pageNumber = freezed,
    Object? pageSize = freezed,
    Object? isActive = freezed,
    Object? overrideIsAciveFilter = freezed,
    Object? academicYearId = freezed,
    Object? schoolId = freezed,
  }) {
    return _then(_TeacherServiceQueryParameterDto(
      pageNumber: freezed == pageNumber
          ? _self.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      overrideIsAciveFilter: freezed == overrideIsAciveFilter
          ? _self.overrideIsAciveFilter
          : overrideIsAciveFilter // ignore: cast_nullable_to_non_nullable
              as bool?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as String?,
      schoolId: freezed == schoolId
          ? _self.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$TemperatureCheckDto {
  @JsonKey(name: 'date')
  DateTime get date;
  @JsonKey(name: 'temperature')
  num get temperature;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'utcDate')
  DateTime? get utcDate;

  /// Create a copy of TemperatureCheckDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TemperatureCheckDtoCopyWith<TemperatureCheckDto> get copyWith =>
      _$TemperatureCheckDtoCopyWithImpl<TemperatureCheckDto>(
          this as TemperatureCheckDto, _$identity);

  /// Serializes this TemperatureCheckDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TemperatureCheckDto &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, date, temperature, remarks, utcDate);

  @override
  String toString() {
    return 'TemperatureCheckDto(date: $date, temperature: $temperature, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class $TemperatureCheckDtoCopyWith<$Res> {
  factory $TemperatureCheckDtoCopyWith(
          TemperatureCheckDto value, $Res Function(TemperatureCheckDto) _then) =
      _$TemperatureCheckDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'temperature') num temperature,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class _$TemperatureCheckDtoCopyWithImpl<$Res>
    implements $TemperatureCheckDtoCopyWith<$Res> {
  _$TemperatureCheckDtoCopyWithImpl(this._self, this._then);

  final TemperatureCheckDto _self;
  final $Res Function(TemperatureCheckDto) _then;

  /// Create a copy of TemperatureCheckDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
    Object? temperature = null,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_self.copyWith(
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      temperature: null == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as num,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [TemperatureCheckDto].
extension TemperatureCheckDtoPatterns on TemperatureCheckDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TemperatureCheckDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TemperatureCheckDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TemperatureCheckDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'temperature') num temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckDto() when $default != null:
        return $default(
            _that.date, _that.temperature, _that.remarks, _that.utcDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'temperature') num temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckDto():
        return $default(
            _that.date, _that.temperature, _that.remarks, _that.utcDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'temperature') num temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckDto() when $default != null:
        return $default(
            _that.date, _that.temperature, _that.remarks, _that.utcDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TemperatureCheckDto implements TemperatureCheckDto {
  _TemperatureCheckDto(
      {@JsonKey(name: 'date') required this.date,
      @JsonKey(name: 'temperature') required this.temperature,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'utcDate') this.utcDate});
  factory _TemperatureCheckDto.fromJson(Map<String, dynamic> json) =>
      _$TemperatureCheckDtoFromJson(json);

  @override
  @JsonKey(name: 'date')
  final DateTime date;
  @override
  @JsonKey(name: 'temperature')
  final num temperature;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'utcDate')
  final DateTime? utcDate;

  /// Create a copy of TemperatureCheckDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TemperatureCheckDtoCopyWith<_TemperatureCheckDto> get copyWith =>
      __$TemperatureCheckDtoCopyWithImpl<_TemperatureCheckDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TemperatureCheckDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TemperatureCheckDto &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, date, temperature, remarks, utcDate);

  @override
  String toString() {
    return 'TemperatureCheckDto(date: $date, temperature: $temperature, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class _$TemperatureCheckDtoCopyWith<$Res>
    implements $TemperatureCheckDtoCopyWith<$Res> {
  factory _$TemperatureCheckDtoCopyWith(_TemperatureCheckDto value,
          $Res Function(_TemperatureCheckDto) _then) =
      __$TemperatureCheckDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'temperature') num temperature,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class __$TemperatureCheckDtoCopyWithImpl<$Res>
    implements _$TemperatureCheckDtoCopyWith<$Res> {
  __$TemperatureCheckDtoCopyWithImpl(this._self, this._then);

  final _TemperatureCheckDto _self;
  final $Res Function(_TemperatureCheckDto) _then;

  /// Create a copy of TemperatureCheckDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? date = null,
    Object? temperature = null,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_TemperatureCheckDto(
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      temperature: null == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as num,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$TemperatureCheckParameterDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'studentId')
  String get studentId;
  @JsonKey(name: 'date')
  DateTime get date;
  @JsonKey(name: 'temperature')
  num get temperature;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'utcDate')
  DateTime? get utcDate;

  /// Create a copy of TemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TemperatureCheckParameterDtoCopyWith<TemperatureCheckParameterDto>
      get copyWith => _$TemperatureCheckParameterDtoCopyWithImpl<
              TemperatureCheckParameterDto>(
          this as TemperatureCheckParameterDto, _$identity);

  /// Serializes this TemperatureCheckParameterDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TemperatureCheckParameterDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, temperature, remarks, utcDate);

  @override
  String toString() {
    return 'TemperatureCheckParameterDto(id: $id, studentId: $studentId, date: $date, temperature: $temperature, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class $TemperatureCheckParameterDtoCopyWith<$Res> {
  factory $TemperatureCheckParameterDtoCopyWith(
          TemperatureCheckParameterDto value,
          $Res Function(TemperatureCheckParameterDto) _then) =
      _$TemperatureCheckParameterDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'temperature') num temperature,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class _$TemperatureCheckParameterDtoCopyWithImpl<$Res>
    implements $TemperatureCheckParameterDtoCopyWith<$Res> {
  _$TemperatureCheckParameterDtoCopyWithImpl(this._self, this._then);

  final TemperatureCheckParameterDto _self;
  final $Res Function(TemperatureCheckParameterDto) _then;

  /// Create a copy of TemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? temperature = null,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      temperature: null == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as num,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [TemperatureCheckParameterDto].
extension TemperatureCheckParameterDtoPatterns on TemperatureCheckParameterDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TemperatureCheckParameterDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckParameterDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TemperatureCheckParameterDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckParameterDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TemperatureCheckParameterDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckParameterDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'temperature') num temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckParameterDto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date,
            _that.temperature, _that.remarks, _that.utcDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'temperature') num temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckParameterDto():
        return $default(_that.id, _that.studentId, _that.date,
            _that.temperature, _that.remarks, _that.utcDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'studentId') String studentId,
            @JsonKey(name: 'date') DateTime date,
            @JsonKey(name: 'temperature') num temperature,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'utcDate') DateTime? utcDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TemperatureCheckParameterDto() when $default != null:
        return $default(_that.id, _that.studentId, _that.date,
            _that.temperature, _that.remarks, _that.utcDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TemperatureCheckParameterDto implements TemperatureCheckParameterDto {
  _TemperatureCheckParameterDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') required this.studentId,
      @JsonKey(name: 'date') required this.date,
      @JsonKey(name: 'temperature') required this.temperature,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'utcDate') this.utcDate});
  factory _TemperatureCheckParameterDto.fromJson(Map<String, dynamic> json) =>
      _$TemperatureCheckParameterDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'studentId')
  final String studentId;
  @override
  @JsonKey(name: 'date')
  final DateTime date;
  @override
  @JsonKey(name: 'temperature')
  final num temperature;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'utcDate')
  final DateTime? utcDate;

  /// Create a copy of TemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TemperatureCheckParameterDtoCopyWith<_TemperatureCheckParameterDto>
      get copyWith => __$TemperatureCheckParameterDtoCopyWithImpl<
          _TemperatureCheckParameterDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TemperatureCheckParameterDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TemperatureCheckParameterDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.utcDate, utcDate) || other.utcDate == utcDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, studentId, date, temperature, remarks, utcDate);

  @override
  String toString() {
    return 'TemperatureCheckParameterDto(id: $id, studentId: $studentId, date: $date, temperature: $temperature, remarks: $remarks, utcDate: $utcDate)';
  }
}

/// @nodoc
abstract mixin class _$TemperatureCheckParameterDtoCopyWith<$Res>
    implements $TemperatureCheckParameterDtoCopyWith<$Res> {
  factory _$TemperatureCheckParameterDtoCopyWith(
          _TemperatureCheckParameterDto value,
          $Res Function(_TemperatureCheckParameterDto) _then) =
      __$TemperatureCheckParameterDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'studentId') String studentId,
      @JsonKey(name: 'date') DateTime date,
      @JsonKey(name: 'temperature') num temperature,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'utcDate') DateTime? utcDate});
}

/// @nodoc
class __$TemperatureCheckParameterDtoCopyWithImpl<$Res>
    implements _$TemperatureCheckParameterDtoCopyWith<$Res> {
  __$TemperatureCheckParameterDtoCopyWithImpl(this._self, this._then);

  final _TemperatureCheckParameterDto _self;
  final $Res Function(_TemperatureCheckParameterDto) _then;

  /// Create a copy of TemperatureCheckParameterDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = null,
    Object? date = null,
    Object? temperature = null,
    Object? remarks = freezed,
    Object? utcDate = freezed,
  }) {
    return _then(_TemperatureCheckParameterDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: null == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      temperature: null == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as num,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      utcDate: freezed == utcDate
          ? _self.utcDate
          : utcDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$TimeSlotDto {
  @JsonKey(name: 'end')
  DateTimeTimeZoneDto? get end;
  @JsonKey(name: 'start')
  DateTimeTimeZoneDto? get start;
  @JsonKey(name: '@odata.type')
  String? get odataType;

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TimeSlotDtoCopyWith<TimeSlotDto> get copyWith =>
      _$TimeSlotDtoCopyWithImpl<TimeSlotDto>(this as TimeSlotDto, _$identity);

  /// Serializes this TimeSlotDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TimeSlotDto &&
            (identical(other.end, end) || other.end == end) &&
            (identical(other.start, start) || other.start == start) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, end, start, odataType);

  @override
  String toString() {
    return 'TimeSlotDto(end: $end, start: $start, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class $TimeSlotDtoCopyWith<$Res> {
  factory $TimeSlotDtoCopyWith(
          TimeSlotDto value, $Res Function(TimeSlotDto) _then) =
      _$TimeSlotDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'end') DateTimeTimeZoneDto? end,
      @JsonKey(name: 'start') DateTimeTimeZoneDto? start,
      @JsonKey(name: '@odata.type') String? odataType});

  $DateTimeTimeZoneDtoCopyWith<$Res>? get end;
  $DateTimeTimeZoneDtoCopyWith<$Res>? get start;
}

/// @nodoc
class _$TimeSlotDtoCopyWithImpl<$Res> implements $TimeSlotDtoCopyWith<$Res> {
  _$TimeSlotDtoCopyWithImpl(this._self, this._then);

  final TimeSlotDto _self;
  final $Res Function(TimeSlotDto) _then;

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? end = freezed,
    Object? start = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_self.copyWith(
      end: freezed == end
          ? _self.end
          : end // ignore: cast_nullable_to_non_nullable
              as DateTimeTimeZoneDto?,
      start: freezed == start
          ? _self.start
          : start // ignore: cast_nullable_to_non_nullable
              as DateTimeTimeZoneDto?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DateTimeTimeZoneDtoCopyWith<$Res>? get end {
    if (_self.end == null) {
      return null;
    }

    return $DateTimeTimeZoneDtoCopyWith<$Res>(_self.end!, (value) {
      return _then(_self.copyWith(end: value));
    });
  }

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DateTimeTimeZoneDtoCopyWith<$Res>? get start {
    if (_self.start == null) {
      return null;
    }

    return $DateTimeTimeZoneDtoCopyWith<$Res>(_self.start!, (value) {
      return _then(_self.copyWith(start: value));
    });
  }
}

/// Adds pattern-matching-related methods to [TimeSlotDto].
extension TimeSlotDtoPatterns on TimeSlotDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TimeSlotDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TimeSlotDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TimeSlotDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TimeSlotDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TimeSlotDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TimeSlotDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'end') DateTimeTimeZoneDto? end,
            @JsonKey(name: 'start') DateTimeTimeZoneDto? start,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TimeSlotDto() when $default != null:
        return $default(_that.end, _that.start, _that.odataType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'end') DateTimeTimeZoneDto? end,
            @JsonKey(name: 'start') DateTimeTimeZoneDto? start,
            @JsonKey(name: '@odata.type') String? odataType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TimeSlotDto():
        return $default(_that.end, _that.start, _that.odataType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'end') DateTimeTimeZoneDto? end,
            @JsonKey(name: 'start') DateTimeTimeZoneDto? start,
            @JsonKey(name: '@odata.type') String? odataType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TimeSlotDto() when $default != null:
        return $default(_that.end, _that.start, _that.odataType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TimeSlotDto implements TimeSlotDto {
  _TimeSlotDto(
      {@JsonKey(name: 'end') this.end,
      @JsonKey(name: 'start') this.start,
      @JsonKey(name: '@odata.type') this.odataType});
  factory _TimeSlotDto.fromJson(Map<String, dynamic> json) =>
      _$TimeSlotDtoFromJson(json);

  @override
  @JsonKey(name: 'end')
  final DateTimeTimeZoneDto? end;
  @override
  @JsonKey(name: 'start')
  final DateTimeTimeZoneDto? start;
  @override
  @JsonKey(name: '@odata.type')
  final String? odataType;

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TimeSlotDtoCopyWith<_TimeSlotDto> get copyWith =>
      __$TimeSlotDtoCopyWithImpl<_TimeSlotDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TimeSlotDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TimeSlotDto &&
            (identical(other.end, end) || other.end == end) &&
            (identical(other.start, start) || other.start == start) &&
            (identical(other.odataType, odataType) ||
                other.odataType == odataType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, end, start, odataType);

  @override
  String toString() {
    return 'TimeSlotDto(end: $end, start: $start, odataType: $odataType)';
  }
}

/// @nodoc
abstract mixin class _$TimeSlotDtoCopyWith<$Res>
    implements $TimeSlotDtoCopyWith<$Res> {
  factory _$TimeSlotDtoCopyWith(
          _TimeSlotDto value, $Res Function(_TimeSlotDto) _then) =
      __$TimeSlotDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'end') DateTimeTimeZoneDto? end,
      @JsonKey(name: 'start') DateTimeTimeZoneDto? start,
      @JsonKey(name: '@odata.type') String? odataType});

  @override
  $DateTimeTimeZoneDtoCopyWith<$Res>? get end;
  @override
  $DateTimeTimeZoneDtoCopyWith<$Res>? get start;
}

/// @nodoc
class __$TimeSlotDtoCopyWithImpl<$Res> implements _$TimeSlotDtoCopyWith<$Res> {
  __$TimeSlotDtoCopyWithImpl(this._self, this._then);

  final _TimeSlotDto _self;
  final $Res Function(_TimeSlotDto) _then;

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? end = freezed,
    Object? start = freezed,
    Object? odataType = freezed,
  }) {
    return _then(_TimeSlotDto(
      end: freezed == end
          ? _self.end
          : end // ignore: cast_nullable_to_non_nullable
              as DateTimeTimeZoneDto?,
      start: freezed == start
          ? _self.start
          : start // ignore: cast_nullable_to_non_nullable
              as DateTimeTimeZoneDto?,
      odataType: freezed == odataType
          ? _self.odataType
          : odataType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DateTimeTimeZoneDtoCopyWith<$Res>? get end {
    if (_self.end == null) {
      return null;
    }

    return $DateTimeTimeZoneDtoCopyWith<$Res>(_self.end!, (value) {
      return _then(_self.copyWith(end: value));
    });
  }

  /// Create a copy of TimeSlotDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DateTimeTimeZoneDtoCopyWith<$Res>? get start {
    if (_self.start == null) {
      return null;
    }

    return $DateTimeTimeZoneDtoCopyWith<$Res>(_self.start!, (value) {
      return _then(_self.copyWith(start: value));
    });
  }
}

/// @nodoc
mixin _$UserConfigDto {
  @JsonKey(name: 'notificationFrequent')
  String? get notificationFrequent;
  @JsonKey(name: 'showDailyRoutine')
  bool? get showDailyRoutine;
  @JsonKey(name: 'enablePTCBooking')
  bool? get enablePTCBooking;

  /// Create a copy of UserConfigDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserConfigDtoCopyWith<UserConfigDto> get copyWith =>
      _$UserConfigDtoCopyWithImpl<UserConfigDto>(
          this as UserConfigDto, _$identity);

  /// Serializes this UserConfigDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserConfigDto &&
            (identical(other.notificationFrequent, notificationFrequent) ||
                other.notificationFrequent == notificationFrequent) &&
            (identical(other.showDailyRoutine, showDailyRoutine) ||
                other.showDailyRoutine == showDailyRoutine) &&
            (identical(other.enablePTCBooking, enablePTCBooking) ||
                other.enablePTCBooking == enablePTCBooking));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, notificationFrequent, showDailyRoutine, enablePTCBooking);

  @override
  String toString() {
    return 'UserConfigDto(notificationFrequent: $notificationFrequent, showDailyRoutine: $showDailyRoutine, enablePTCBooking: $enablePTCBooking)';
  }
}

/// @nodoc
abstract mixin class $UserConfigDtoCopyWith<$Res> {
  factory $UserConfigDtoCopyWith(
          UserConfigDto value, $Res Function(UserConfigDto) _then) =
      _$UserConfigDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'notificationFrequent') String? notificationFrequent,
      @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
      @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking});
}

/// @nodoc
class _$UserConfigDtoCopyWithImpl<$Res>
    implements $UserConfigDtoCopyWith<$Res> {
  _$UserConfigDtoCopyWithImpl(this._self, this._then);

  final UserConfigDto _self;
  final $Res Function(UserConfigDto) _then;

  /// Create a copy of UserConfigDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? notificationFrequent = freezed,
    Object? showDailyRoutine = freezed,
    Object? enablePTCBooking = freezed,
  }) {
    return _then(_self.copyWith(
      notificationFrequent: freezed == notificationFrequent
          ? _self.notificationFrequent
          : notificationFrequent // ignore: cast_nullable_to_non_nullable
              as String?,
      showDailyRoutine: freezed == showDailyRoutine
          ? _self.showDailyRoutine
          : showDailyRoutine // ignore: cast_nullable_to_non_nullable
              as bool?,
      enablePTCBooking: freezed == enablePTCBooking
          ? _self.enablePTCBooking
          : enablePTCBooking // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [UserConfigDto].
extension UserConfigDtoPatterns on UserConfigDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserConfigDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserConfigDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserConfigDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserConfigDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UserConfigDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserConfigDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'notificationFrequent') String? notificationFrequent,
            @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
            @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserConfigDto() when $default != null:
        return $default(_that.notificationFrequent, _that.showDailyRoutine,
            _that.enablePTCBooking);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'notificationFrequent') String? notificationFrequent,
            @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
            @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserConfigDto():
        return $default(_that.notificationFrequent, _that.showDailyRoutine,
            _that.enablePTCBooking);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'notificationFrequent') String? notificationFrequent,
            @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
            @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserConfigDto() when $default != null:
        return $default(_that.notificationFrequent, _that.showDailyRoutine,
            _that.enablePTCBooking);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UserConfigDto implements UserConfigDto {
  _UserConfigDto(
      {@JsonKey(name: 'notificationFrequent') this.notificationFrequent,
      @JsonKey(name: 'showDailyRoutine') this.showDailyRoutine,
      @JsonKey(name: 'enablePTCBooking') this.enablePTCBooking});
  factory _UserConfigDto.fromJson(Map<String, dynamic> json) =>
      _$UserConfigDtoFromJson(json);

  @override
  @JsonKey(name: 'notificationFrequent')
  final String? notificationFrequent;
  @override
  @JsonKey(name: 'showDailyRoutine')
  final bool? showDailyRoutine;
  @override
  @JsonKey(name: 'enablePTCBooking')
  final bool? enablePTCBooking;

  /// Create a copy of UserConfigDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserConfigDtoCopyWith<_UserConfigDto> get copyWith =>
      __$UserConfigDtoCopyWithImpl<_UserConfigDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserConfigDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserConfigDto &&
            (identical(other.notificationFrequent, notificationFrequent) ||
                other.notificationFrequent == notificationFrequent) &&
            (identical(other.showDailyRoutine, showDailyRoutine) ||
                other.showDailyRoutine == showDailyRoutine) &&
            (identical(other.enablePTCBooking, enablePTCBooking) ||
                other.enablePTCBooking == enablePTCBooking));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, notificationFrequent, showDailyRoutine, enablePTCBooking);

  @override
  String toString() {
    return 'UserConfigDto(notificationFrequent: $notificationFrequent, showDailyRoutine: $showDailyRoutine, enablePTCBooking: $enablePTCBooking)';
  }
}

/// @nodoc
abstract mixin class _$UserConfigDtoCopyWith<$Res>
    implements $UserConfigDtoCopyWith<$Res> {
  factory _$UserConfigDtoCopyWith(
          _UserConfigDto value, $Res Function(_UserConfigDto) _then) =
      __$UserConfigDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'notificationFrequent') String? notificationFrequent,
      @JsonKey(name: 'showDailyRoutine') bool? showDailyRoutine,
      @JsonKey(name: 'enablePTCBooking') bool? enablePTCBooking});
}

/// @nodoc
class __$UserConfigDtoCopyWithImpl<$Res>
    implements _$UserConfigDtoCopyWith<$Res> {
  __$UserConfigDtoCopyWithImpl(this._self, this._then);

  final _UserConfigDto _self;
  final $Res Function(_UserConfigDto) _then;

  /// Create a copy of UserConfigDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? notificationFrequent = freezed,
    Object? showDailyRoutine = freezed,
    Object? enablePTCBooking = freezed,
  }) {
    return _then(_UserConfigDto(
      notificationFrequent: freezed == notificationFrequent
          ? _self.notificationFrequent
          : notificationFrequent // ignore: cast_nullable_to_non_nullable
              as String?,
      showDailyRoutine: freezed == showDailyRoutine
          ? _self.showDailyRoutine
          : showDailyRoutine // ignore: cast_nullable_to_non_nullable
              as bool?,
      enablePTCBooking: freezed == enablePTCBooking
          ? _self.enablePTCBooking
          : enablePTCBooking // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

// dart format on
