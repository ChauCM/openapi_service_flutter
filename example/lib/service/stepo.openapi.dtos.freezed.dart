// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'stepo.openapi.dtos.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ApiError {
  String get message;
  int? get statusCode;
  String? get type;

  /// Create a copy of ApiError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiErrorCopyWith<ApiError> get copyWith =>
      _$ApiErrorCopyWithImpl<ApiError>(this as ApiError, _$identity);

  /// Serializes this ApiError to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiError &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, message, statusCode, type);

  @override
  String toString() {
    return 'ApiError(message: $message, statusCode: $statusCode, type: $type)';
  }
}

/// @nodoc
abstract mixin class $ApiErrorCopyWith<$Res> {
  factory $ApiErrorCopyWith(ApiError value, $Res Function(ApiError) _then) =
      _$ApiErrorCopyWithImpl;
  @useResult
  $Res call({String message, int? statusCode, String? type});
}

/// @nodoc
class _$ApiErrorCopyWithImpl<$Res> implements $ApiErrorCopyWith<$Res> {
  _$ApiErrorCopyWithImpl(this._self, this._then);

  final ApiError _self;
  final $Res Function(ApiError) _then;

  /// Create a copy of ApiError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? statusCode = freezed,
    Object? type = freezed,
  }) {
    return _then(_self.copyWith(
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      statusCode: freezed == statusCode
          ? _self.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiError].
extension ApiErrorPatterns on ApiError {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiError value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiError() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiError value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiError():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiError value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiError() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String message, int? statusCode, String? type)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiError() when $default != null:
        return $default(_that.message, _that.statusCode, _that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String message, int? statusCode, String? type) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiError():
        return $default(_that.message, _that.statusCode, _that.type);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String message, int? statusCode, String? type)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiError() when $default != null:
        return $default(_that.message, _that.statusCode, _that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiError implements ApiError {
  const _ApiError({required this.message, this.statusCode, this.type});
  factory _ApiError.fromJson(Map<String, dynamic> json) =>
      _$ApiErrorFromJson(json);

  @override
  final String message;
  @override
  final int? statusCode;
  @override
  final String? type;

  /// Create a copy of ApiError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiErrorCopyWith<_ApiError> get copyWith =>
      __$ApiErrorCopyWithImpl<_ApiError>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiErrorToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiError &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, message, statusCode, type);

  @override
  String toString() {
    return 'ApiError(message: $message, statusCode: $statusCode, type: $type)';
  }
}

/// @nodoc
abstract mixin class _$ApiErrorCopyWith<$Res>
    implements $ApiErrorCopyWith<$Res> {
  factory _$ApiErrorCopyWith(_ApiError value, $Res Function(_ApiError) _then) =
      __$ApiErrorCopyWithImpl;
  @override
  @useResult
  $Res call({String message, int? statusCode, String? type});
}

/// @nodoc
class __$ApiErrorCopyWithImpl<$Res> implements _$ApiErrorCopyWith<$Res> {
  __$ApiErrorCopyWithImpl(this._self, this._then);

  final _ApiError _self;
  final $Res Function(_ApiError) _then;

  /// Create a copy of ApiError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? message = null,
    Object? statusCode = freezed,
    Object? type = freezed,
  }) {
    return _then(_ApiError(
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      statusCode: freezed == statusCode
          ? _self.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$AccountDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'profile')
  ProfileDto get profile;

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AccountDtoCopyWith<AccountDto> get copyWith =>
      _$AccountDtoCopyWithImpl<AccountDto>(this as AccountDto, _$identity);

  /// Serializes this AccountDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AccountDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'AccountDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class $AccountDtoCopyWith<$Res> {
  factory $AccountDtoCopyWith(
          AccountDto value, $Res Function(AccountDto) _then) =
      _$AccountDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class _$AccountDtoCopyWithImpl<$Res> implements $AccountDtoCopyWith<$Res> {
  _$AccountDtoCopyWithImpl(this._self, this._then);

  final AccountDto _self;
  final $Res Function(AccountDto) _then;

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AccountDto].
extension AccountDtoPatterns on AccountDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AccountDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AccountDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AccountDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto():
        return $default(_that.id, _that.profile);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AccountDto implements AccountDto {
  _AccountDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'profile') required this.profile});
  factory _AccountDto.fromJson(Map<String, dynamic> json) =>
      _$AccountDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'profile')
  final ProfileDto profile;

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AccountDtoCopyWith<_AccountDto> get copyWith =>
      __$AccountDtoCopyWithImpl<_AccountDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AccountDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AccountDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'AccountDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class _$AccountDtoCopyWith<$Res>
    implements $AccountDtoCopyWith<$Res> {
  factory _$AccountDtoCopyWith(
          _AccountDto value, $Res Function(_AccountDto) _then) =
      __$AccountDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  @override
  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class __$AccountDtoCopyWithImpl<$Res> implements _$AccountDtoCopyWith<$Res> {
  __$AccountDtoCopyWithImpl(this._self, this._then);

  final _AccountDto _self;
  final $Res Function(_AccountDto) _then;

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_AccountDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of AccountDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// @nodoc
mixin _$BulkNotificationDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'body')
  String get body;
  @JsonKey(name: 'notificationType')
  NotificationTypeDto get notificationType;
  @JsonKey(name: 'userIds')
  List<String> get userIds;
  @JsonKey(name: 'relatedEntityId')
  String? get relatedEntityId;
  @JsonKey(name: 'data')
  Map<String, String>? get data;
  @JsonKey(name: 'priority')
  int? get priority;

  /// Create a copy of BulkNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BulkNotificationDtoCopyWith<BulkNotificationDto> get copyWith =>
      _$BulkNotificationDtoCopyWithImpl<BulkNotificationDto>(
          this as BulkNotificationDto, _$identity);

  /// Serializes this BulkNotificationDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BulkNotificationDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            const DeepCollectionEquality().equals(other.userIds, userIds) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      const DeepCollectionEquality().hash(userIds),
      relatedEntityId,
      const DeepCollectionEquality().hash(data),
      priority);

  @override
  String toString() {
    return 'BulkNotificationDto(title: $title, body: $body, notificationType: $notificationType, userIds: $userIds, relatedEntityId: $relatedEntityId, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class $BulkNotificationDtoCopyWith<$Res> {
  factory $BulkNotificationDtoCopyWith(
          BulkNotificationDto value, $Res Function(BulkNotificationDto) _then) =
      _$BulkNotificationDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'userIds') List<String> userIds,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class _$BulkNotificationDtoCopyWithImpl<$Res>
    implements $BulkNotificationDtoCopyWith<$Res> {
  _$BulkNotificationDtoCopyWithImpl(this._self, this._then);

  final BulkNotificationDto _self;
  final $Res Function(BulkNotificationDto) _then;

  /// Create a copy of BulkNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? userIds = null,
    Object? relatedEntityId = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      userIds: null == userIds
          ? _self.userIds
          : userIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [BulkNotificationDto].
extension BulkNotificationDtoPatterns on BulkNotificationDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BulkNotificationDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BulkNotificationDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BulkNotificationDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BulkNotificationDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BulkNotificationDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BulkNotificationDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'userIds') List<String> userIds,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BulkNotificationDto() when $default != null:
        return $default(_that.title, _that.body, _that.notificationType,
            _that.userIds, _that.relatedEntityId, _that.data, _that.priority);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'userIds') List<String> userIds,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BulkNotificationDto():
        return $default(_that.title, _that.body, _that.notificationType,
            _that.userIds, _that.relatedEntityId, _that.data, _that.priority);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'userIds') List<String> userIds,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BulkNotificationDto() when $default != null:
        return $default(_that.title, _that.body, _that.notificationType,
            _that.userIds, _that.relatedEntityId, _that.data, _that.priority);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BulkNotificationDto implements BulkNotificationDto {
  _BulkNotificationDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'body') required this.body,
      @JsonKey(name: 'notificationType') required this.notificationType,
      @JsonKey(name: 'userIds') required final List<String> userIds,
      @JsonKey(name: 'relatedEntityId') this.relatedEntityId,
      @JsonKey(name: 'data') final Map<String, String>? data,
      @JsonKey(name: 'priority') this.priority})
      : _userIds = userIds,
        _data = data;
  factory _BulkNotificationDto.fromJson(Map<String, dynamic> json) =>
      _$BulkNotificationDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'body')
  final String body;
  @override
  @JsonKey(name: 'notificationType')
  final NotificationTypeDto notificationType;
  final List<String> _userIds;
  @override
  @JsonKey(name: 'userIds')
  List<String> get userIds {
    if (_userIds is EqualUnmodifiableListView) return _userIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userIds);
  }

  @override
  @JsonKey(name: 'relatedEntityId')
  final String? relatedEntityId;
  final Map<String, String>? _data;
  @override
  @JsonKey(name: 'data')
  Map<String, String>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey(name: 'priority')
  final int? priority;

  /// Create a copy of BulkNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BulkNotificationDtoCopyWith<_BulkNotificationDto> get copyWith =>
      __$BulkNotificationDtoCopyWithImpl<_BulkNotificationDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BulkNotificationDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BulkNotificationDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            const DeepCollectionEquality().equals(other._userIds, _userIds) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      const DeepCollectionEquality().hash(_userIds),
      relatedEntityId,
      const DeepCollectionEquality().hash(_data),
      priority);

  @override
  String toString() {
    return 'BulkNotificationDto(title: $title, body: $body, notificationType: $notificationType, userIds: $userIds, relatedEntityId: $relatedEntityId, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class _$BulkNotificationDtoCopyWith<$Res>
    implements $BulkNotificationDtoCopyWith<$Res> {
  factory _$BulkNotificationDtoCopyWith(_BulkNotificationDto value,
          $Res Function(_BulkNotificationDto) _then) =
      __$BulkNotificationDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'userIds') List<String> userIds,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class __$BulkNotificationDtoCopyWithImpl<$Res>
    implements _$BulkNotificationDtoCopyWith<$Res> {
  __$BulkNotificationDtoCopyWithImpl(this._self, this._then);

  final _BulkNotificationDto _self;
  final $Res Function(_BulkNotificationDto) _then;

  /// Create a copy of BulkNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? userIds = null,
    Object? relatedEntityId = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_BulkNotificationDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      userIds: null == userIds
          ? _self._userIds
          : userIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$CreateCommentInteractionDto {
  @JsonKey(name: 'type')
  InteractionTypeDto? get type;

  /// Create a copy of CreateCommentInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateCommentInteractionDtoCopyWith<CreateCommentInteractionDto>
      get copyWith => _$CreateCommentInteractionDtoCopyWithImpl<
              CreateCommentInteractionDto>(
          this as CreateCommentInteractionDto, _$identity);

  /// Serializes this CreateCommentInteractionDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateCommentInteractionDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'CreateCommentInteractionDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class $CreateCommentInteractionDtoCopyWith<$Res> {
  factory $CreateCommentInteractionDtoCopyWith(
          CreateCommentInteractionDto value,
          $Res Function(CreateCommentInteractionDto) _then) =
      _$CreateCommentInteractionDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class _$CreateCommentInteractionDtoCopyWithImpl<$Res>
    implements $CreateCommentInteractionDtoCopyWith<$Res> {
  _$CreateCommentInteractionDtoCopyWithImpl(this._self, this._then);

  final CreateCommentInteractionDto _self;
  final $Res Function(CreateCommentInteractionDto) _then;

  /// Create a copy of CreateCommentInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_self.copyWith(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CreateCommentInteractionDto].
extension CreateCommentInteractionDtoPatterns on CreateCommentInteractionDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateCommentInteractionDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateCommentInteractionDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateCommentInteractionDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCommentInteractionDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateCommentInteractionDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCommentInteractionDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateCommentInteractionDto() when $default != null:
        return $default(_that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCommentInteractionDto():
        return $default(_that.type);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCommentInteractionDto() when $default != null:
        return $default(_that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateCommentInteractionDto implements CreateCommentInteractionDto {
  _CreateCommentInteractionDto({@JsonKey(name: 'type') this.type});
  factory _CreateCommentInteractionDto.fromJson(Map<String, dynamic> json) =>
      _$CreateCommentInteractionDtoFromJson(json);

  @override
  @JsonKey(name: 'type')
  final InteractionTypeDto? type;

  /// Create a copy of CreateCommentInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateCommentInteractionDtoCopyWith<_CreateCommentInteractionDto>
      get copyWith => __$CreateCommentInteractionDtoCopyWithImpl<
          _CreateCommentInteractionDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateCommentInteractionDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateCommentInteractionDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'CreateCommentInteractionDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class _$CreateCommentInteractionDtoCopyWith<$Res>
    implements $CreateCommentInteractionDtoCopyWith<$Res> {
  factory _$CreateCommentInteractionDtoCopyWith(
          _CreateCommentInteractionDto value,
          $Res Function(_CreateCommentInteractionDto) _then) =
      __$CreateCommentInteractionDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class __$CreateCommentInteractionDtoCopyWithImpl<$Res>
    implements _$CreateCommentInteractionDtoCopyWith<$Res> {
  __$CreateCommentInteractionDtoCopyWithImpl(this._self, this._then);

  final _CreateCommentInteractionDto _self;
  final $Res Function(_CreateCommentInteractionDto) _then;

  /// Create a copy of CreateCommentInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_CreateCommentInteractionDto(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// @nodoc
mixin _$CreateReplyCommentDto {
  @JsonKey(name: 'content')
  String get content;
  @JsonKey(name: 'responseToUserId')
  String? get responseToUserId;
  @JsonKey(name: 'responseToCommentId')
  String? get responseToCommentId;

  /// Create a copy of CreateReplyCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateReplyCommentDtoCopyWith<CreateReplyCommentDto> get copyWith =>
      _$CreateReplyCommentDtoCopyWithImpl<CreateReplyCommentDto>(
          this as CreateReplyCommentDto, _$identity);

  /// Serializes this CreateReplyCommentDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateReplyCommentDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.responseToUserId, responseToUserId) ||
                other.responseToUserId == responseToUserId) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, content, responseToUserId, responseToCommentId);

  @override
  String toString() {
    return 'CreateReplyCommentDto(content: $content, responseToUserId: $responseToUserId, responseToCommentId: $responseToCommentId)';
  }
}

/// @nodoc
abstract mixin class $CreateReplyCommentDtoCopyWith<$Res> {
  factory $CreateReplyCommentDtoCopyWith(CreateReplyCommentDto value,
          $Res Function(CreateReplyCommentDto) _then) =
      _$CreateReplyCommentDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'responseToUserId') String? responseToUserId,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId});
}

/// @nodoc
class _$CreateReplyCommentDtoCopyWithImpl<$Res>
    implements $CreateReplyCommentDtoCopyWith<$Res> {
  _$CreateReplyCommentDtoCopyWithImpl(this._self, this._then);

  final CreateReplyCommentDto _self;
  final $Res Function(CreateReplyCommentDto) _then;

  /// Create a copy of CreateReplyCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
    Object? responseToUserId = freezed,
    Object? responseToCommentId = freezed,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      responseToUserId: freezed == responseToUserId
          ? _self.responseToUserId
          : responseToUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CreateReplyCommentDto].
extension CreateReplyCommentDtoPatterns on CreateReplyCommentDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateReplyCommentDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateReplyCommentDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateReplyCommentDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateReplyCommentDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateReplyCommentDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateReplyCommentDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'responseToUserId') String? responseToUserId,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateReplyCommentDto() when $default != null:
        return $default(
            _that.content, _that.responseToUserId, _that.responseToCommentId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'responseToUserId') String? responseToUserId,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateReplyCommentDto():
        return $default(
            _that.content, _that.responseToUserId, _that.responseToCommentId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'responseToUserId') String? responseToUserId,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateReplyCommentDto() when $default != null:
        return $default(
            _that.content, _that.responseToUserId, _that.responseToCommentId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateReplyCommentDto implements CreateReplyCommentDto {
  _CreateReplyCommentDto(
      {@JsonKey(name: 'content') required this.content,
      @JsonKey(name: 'responseToUserId') this.responseToUserId,
      @JsonKey(name: 'responseToCommentId') this.responseToCommentId});
  factory _CreateReplyCommentDto.fromJson(Map<String, dynamic> json) =>
      _$CreateReplyCommentDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;
  @override
  @JsonKey(name: 'responseToUserId')
  final String? responseToUserId;
  @override
  @JsonKey(name: 'responseToCommentId')
  final String? responseToCommentId;

  /// Create a copy of CreateReplyCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateReplyCommentDtoCopyWith<_CreateReplyCommentDto> get copyWith =>
      __$CreateReplyCommentDtoCopyWithImpl<_CreateReplyCommentDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateReplyCommentDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateReplyCommentDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.responseToUserId, responseToUserId) ||
                other.responseToUserId == responseToUserId) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, content, responseToUserId, responseToCommentId);

  @override
  String toString() {
    return 'CreateReplyCommentDto(content: $content, responseToUserId: $responseToUserId, responseToCommentId: $responseToCommentId)';
  }
}

/// @nodoc
abstract mixin class _$CreateReplyCommentDtoCopyWith<$Res>
    implements $CreateReplyCommentDtoCopyWith<$Res> {
  factory _$CreateReplyCommentDtoCopyWith(_CreateReplyCommentDto value,
          $Res Function(_CreateReplyCommentDto) _then) =
      __$CreateReplyCommentDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'responseToUserId') String? responseToUserId,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId});
}

/// @nodoc
class __$CreateReplyCommentDtoCopyWithImpl<$Res>
    implements _$CreateReplyCommentDtoCopyWith<$Res> {
  __$CreateReplyCommentDtoCopyWithImpl(this._self, this._then);

  final _CreateReplyCommentDto _self;
  final $Res Function(_CreateReplyCommentDto) _then;

  /// Create a copy of CreateReplyCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
    Object? responseToUserId = freezed,
    Object? responseToCommentId = freezed,
  }) {
    return _then(_CreateReplyCommentDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      responseToUserId: freezed == responseToUserId
          ? _self.responseToUserId
          : responseToUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$CreateStepCommentDto {
  @JsonKey(name: 'content')
  String get content;

  /// Create a copy of CreateStepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateStepCommentDtoCopyWith<CreateStepCommentDto> get copyWith =>
      _$CreateStepCommentDtoCopyWithImpl<CreateStepCommentDto>(
          this as CreateStepCommentDto, _$identity);

  /// Serializes this CreateStepCommentDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateStepCommentDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'CreateStepCommentDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class $CreateStepCommentDtoCopyWith<$Res> {
  factory $CreateStepCommentDtoCopyWith(CreateStepCommentDto value,
          $Res Function(CreateStepCommentDto) _then) =
      _$CreateStepCommentDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class _$CreateStepCommentDtoCopyWithImpl<$Res>
    implements $CreateStepCommentDtoCopyWith<$Res> {
  _$CreateStepCommentDtoCopyWithImpl(this._self, this._then);

  final CreateStepCommentDto _self;
  final $Res Function(CreateStepCommentDto) _then;

  /// Create a copy of CreateStepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [CreateStepCommentDto].
extension CreateStepCommentDtoPatterns on CreateStepCommentDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateStepCommentDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateStepCommentDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateStepCommentDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepCommentDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateStepCommentDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepCommentDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateStepCommentDto() when $default != null:
        return $default(_that.content);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepCommentDto():
        return $default(_that.content);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'content') String content)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepCommentDto() when $default != null:
        return $default(_that.content);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateStepCommentDto implements CreateStepCommentDto {
  _CreateStepCommentDto({@JsonKey(name: 'content') required this.content});
  factory _CreateStepCommentDto.fromJson(Map<String, dynamic> json) =>
      _$CreateStepCommentDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;

  /// Create a copy of CreateStepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateStepCommentDtoCopyWith<_CreateStepCommentDto> get copyWith =>
      __$CreateStepCommentDtoCopyWithImpl<_CreateStepCommentDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateStepCommentDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateStepCommentDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'CreateStepCommentDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class _$CreateStepCommentDtoCopyWith<$Res>
    implements $CreateStepCommentDtoCopyWith<$Res> {
  factory _$CreateStepCommentDtoCopyWith(_CreateStepCommentDto value,
          $Res Function(_CreateStepCommentDto) _then) =
      __$CreateStepCommentDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class __$CreateStepCommentDtoCopyWithImpl<$Res>
    implements _$CreateStepCommentDtoCopyWith<$Res> {
  __$CreateStepCommentDtoCopyWithImpl(this._self, this._then);

  final _CreateStepCommentDto _self;
  final $Res Function(_CreateStepCommentDto) _then;

  /// Create a copy of CreateStepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
  }) {
    return _then(_CreateStepCommentDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$CreateStepDto {
  @JsonKey(name: 'content')
  String get content;
  @JsonKey(name: 'journeyId')
  String get journeyId;

  /// Create a copy of CreateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateStepDtoCopyWith<CreateStepDto> get copyWith =>
      _$CreateStepDtoCopyWithImpl<CreateStepDto>(
          this as CreateStepDto, _$identity);

  /// Serializes this CreateStepDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateStepDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content, journeyId);

  @override
  String toString() {
    return 'CreateStepDto(content: $content, journeyId: $journeyId)';
  }
}

/// @nodoc
abstract mixin class $CreateStepDtoCopyWith<$Res> {
  factory $CreateStepDtoCopyWith(
          CreateStepDto value, $Res Function(CreateStepDto) _then) =
      _$CreateStepDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'journeyId') String journeyId});
}

/// @nodoc
class _$CreateStepDtoCopyWithImpl<$Res>
    implements $CreateStepDtoCopyWith<$Res> {
  _$CreateStepDtoCopyWithImpl(this._self, this._then);

  final CreateStepDto _self;
  final $Res Function(CreateStepDto) _then;

  /// Create a copy of CreateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
    Object? journeyId = null,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      journeyId: null == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [CreateStepDto].
extension CreateStepDtoPatterns on CreateStepDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateStepDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateStepDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateStepDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateStepDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content,
            @JsonKey(name: 'journeyId') String journeyId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateStepDto() when $default != null:
        return $default(_that.content, _that.journeyId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content,
            @JsonKey(name: 'journeyId') String journeyId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepDto():
        return $default(_that.content, _that.journeyId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'content') String content,
            @JsonKey(name: 'journeyId') String journeyId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepDto() when $default != null:
        return $default(_that.content, _that.journeyId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateStepDto implements CreateStepDto {
  _CreateStepDto(
      {@JsonKey(name: 'content') required this.content,
      @JsonKey(name: 'journeyId') required this.journeyId});
  factory _CreateStepDto.fromJson(Map<String, dynamic> json) =>
      _$CreateStepDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;
  @override
  @JsonKey(name: 'journeyId')
  final String journeyId;

  /// Create a copy of CreateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateStepDtoCopyWith<_CreateStepDto> get copyWith =>
      __$CreateStepDtoCopyWithImpl<_CreateStepDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateStepDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateStepDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content, journeyId);

  @override
  String toString() {
    return 'CreateStepDto(content: $content, journeyId: $journeyId)';
  }
}

/// @nodoc
abstract mixin class _$CreateStepDtoCopyWith<$Res>
    implements $CreateStepDtoCopyWith<$Res> {
  factory _$CreateStepDtoCopyWith(
          _CreateStepDto value, $Res Function(_CreateStepDto) _then) =
      __$CreateStepDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'journeyId') String journeyId});
}

/// @nodoc
class __$CreateStepDtoCopyWithImpl<$Res>
    implements _$CreateStepDtoCopyWith<$Res> {
  __$CreateStepDtoCopyWithImpl(this._self, this._then);

  final _CreateStepDto _self;
  final $Res Function(_CreateStepDto) _then;

  /// Create a copy of CreateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
    Object? journeyId = null,
  }) {
    return _then(_CreateStepDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      journeyId: null == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$CreateStepInteractionDto {
  @JsonKey(name: 'type')
  InteractionTypeDto? get type;

  /// Create a copy of CreateStepInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateStepInteractionDtoCopyWith<CreateStepInteractionDto> get copyWith =>
      _$CreateStepInteractionDtoCopyWithImpl<CreateStepInteractionDto>(
          this as CreateStepInteractionDto, _$identity);

  /// Serializes this CreateStepInteractionDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateStepInteractionDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'CreateStepInteractionDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class $CreateStepInteractionDtoCopyWith<$Res> {
  factory $CreateStepInteractionDtoCopyWith(CreateStepInteractionDto value,
          $Res Function(CreateStepInteractionDto) _then) =
      _$CreateStepInteractionDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class _$CreateStepInteractionDtoCopyWithImpl<$Res>
    implements $CreateStepInteractionDtoCopyWith<$Res> {
  _$CreateStepInteractionDtoCopyWithImpl(this._self, this._then);

  final CreateStepInteractionDto _self;
  final $Res Function(CreateStepInteractionDto) _then;

  /// Create a copy of CreateStepInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_self.copyWith(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CreateStepInteractionDto].
extension CreateStepInteractionDtoPatterns on CreateStepInteractionDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateStepInteractionDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateStepInteractionDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateStepInteractionDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepInteractionDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateStepInteractionDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepInteractionDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateStepInteractionDto() when $default != null:
        return $default(_that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepInteractionDto():
        return $default(_that.type);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateStepInteractionDto() when $default != null:
        return $default(_that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateStepInteractionDto implements CreateStepInteractionDto {
  _CreateStepInteractionDto({@JsonKey(name: 'type') this.type});
  factory _CreateStepInteractionDto.fromJson(Map<String, dynamic> json) =>
      _$CreateStepInteractionDtoFromJson(json);

  @override
  @JsonKey(name: 'type')
  final InteractionTypeDto? type;

  /// Create a copy of CreateStepInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateStepInteractionDtoCopyWith<_CreateStepInteractionDto> get copyWith =>
      __$CreateStepInteractionDtoCopyWithImpl<_CreateStepInteractionDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateStepInteractionDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateStepInteractionDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'CreateStepInteractionDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class _$CreateStepInteractionDtoCopyWith<$Res>
    implements $CreateStepInteractionDtoCopyWith<$Res> {
  factory _$CreateStepInteractionDtoCopyWith(_CreateStepInteractionDto value,
          $Res Function(_CreateStepInteractionDto) _then) =
      __$CreateStepInteractionDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class __$CreateStepInteractionDtoCopyWithImpl<$Res>
    implements _$CreateStepInteractionDtoCopyWith<$Res> {
  __$CreateStepInteractionDtoCopyWithImpl(this._self, this._then);

  final _CreateStepInteractionDto _self;
  final $Res Function(_CreateStepInteractionDto) _then;

  /// Create a copy of CreateStepInteractionDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_CreateStepInteractionDto(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// @nodoc
mixin _$EditUserDto {
  @JsonKey(name: 'displayName')
  String get displayName;
  @JsonKey(name: 'username')
  String get username;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'isPrivate')
  bool? get isPrivate;

  /// Create a copy of EditUserDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EditUserDtoCopyWith<EditUserDto> get copyWith =>
      _$EditUserDtoCopyWithImpl<EditUserDto>(this as EditUserDto, _$identity);

  /// Serializes this EditUserDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditUserDto &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, displayName, username, description, isPrivate);

  @override
  String toString() {
    return 'EditUserDto(displayName: $displayName, username: $username, description: $description, isPrivate: $isPrivate)';
  }
}

/// @nodoc
abstract mixin class $EditUserDtoCopyWith<$Res> {
  factory $EditUserDtoCopyWith(
          EditUserDto value, $Res Function(EditUserDto) _then) =
      _$EditUserDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'displayName') String displayName,
      @JsonKey(name: 'username') String username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'isPrivate') bool? isPrivate});
}

/// @nodoc
class _$EditUserDtoCopyWithImpl<$Res> implements $EditUserDtoCopyWith<$Res> {
  _$EditUserDtoCopyWithImpl(this._self, this._then);

  final EditUserDto _self;
  final $Res Function(EditUserDto) _then;

  /// Create a copy of EditUserDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayName = null,
    Object? username = null,
    Object? description = freezed,
    Object? isPrivate = freezed,
  }) {
    return _then(_self.copyWith(
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      username: null == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [EditUserDto].
extension EditUserDtoPatterns on EditUserDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_EditUserDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EditUserDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_EditUserDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditUserDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_EditUserDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditUserDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'displayName') String displayName,
            @JsonKey(name: 'username') String username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'isPrivate') bool? isPrivate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EditUserDto() when $default != null:
        return $default(_that.displayName, _that.username, _that.description,
            _that.isPrivate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'displayName') String displayName,
            @JsonKey(name: 'username') String username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'isPrivate') bool? isPrivate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditUserDto():
        return $default(_that.displayName, _that.username, _that.description,
            _that.isPrivate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'displayName') String displayName,
            @JsonKey(name: 'username') String username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'isPrivate') bool? isPrivate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EditUserDto() when $default != null:
        return $default(_that.displayName, _that.username, _that.description,
            _that.isPrivate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _EditUserDto implements EditUserDto {
  _EditUserDto(
      {@JsonKey(name: 'displayName') required this.displayName,
      @JsonKey(name: 'username') required this.username,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'isPrivate') this.isPrivate});
  factory _EditUserDto.fromJson(Map<String, dynamic> json) =>
      _$EditUserDtoFromJson(json);

  @override
  @JsonKey(name: 'displayName')
  final String displayName;
  @override
  @JsonKey(name: 'username')
  final String username;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'isPrivate')
  final bool? isPrivate;

  /// Create a copy of EditUserDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EditUserDtoCopyWith<_EditUserDto> get copyWith =>
      __$EditUserDtoCopyWithImpl<_EditUserDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EditUserDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EditUserDto &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, displayName, username, description, isPrivate);

  @override
  String toString() {
    return 'EditUserDto(displayName: $displayName, username: $username, description: $description, isPrivate: $isPrivate)';
  }
}

/// @nodoc
abstract mixin class _$EditUserDtoCopyWith<$Res>
    implements $EditUserDtoCopyWith<$Res> {
  factory _$EditUserDtoCopyWith(
          _EditUserDto value, $Res Function(_EditUserDto) _then) =
      __$EditUserDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'displayName') String displayName,
      @JsonKey(name: 'username') String username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'isPrivate') bool? isPrivate});
}

/// @nodoc
class __$EditUserDtoCopyWithImpl<$Res> implements _$EditUserDtoCopyWith<$Res> {
  __$EditUserDtoCopyWithImpl(this._self, this._then);

  final _EditUserDto _self;
  final $Res Function(_EditUserDto) _then;

  /// Create a copy of EditUserDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? displayName = null,
    Object? username = null,
    Object? description = freezed,
    Object? isPrivate = freezed,
  }) {
    return _then(_EditUserDto(
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      username: null == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$FollowingResultDto {
  @JsonKey(name: 'status')
  FollowingStatusEnumDto get status;
  @JsonKey(name: 'message')
  String? get message;

  /// Create a copy of FollowingResultDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FollowingResultDtoCopyWith<FollowingResultDto> get copyWith =>
      _$FollowingResultDtoCopyWithImpl<FollowingResultDto>(
          this as FollowingResultDto, _$identity);

  /// Serializes this FollowingResultDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FollowingResultDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'FollowingResultDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class $FollowingResultDtoCopyWith<$Res> {
  factory $FollowingResultDtoCopyWith(
          FollowingResultDto value, $Res Function(FollowingResultDto) _then) =
      _$FollowingResultDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class _$FollowingResultDtoCopyWithImpl<$Res>
    implements $FollowingResultDtoCopyWith<$Res> {
  _$FollowingResultDtoCopyWithImpl(this._self, this._then);

  final FollowingResultDto _self;
  final $Res Function(FollowingResultDto) _then;

  /// Create a copy of FollowingResultDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [FollowingResultDto].
extension FollowingResultDtoPatterns on FollowingResultDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FollowingResultDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FollowingResultDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FollowingResultDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingResultDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FollowingResultDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingResultDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FollowingResultDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingResultDto():
        return $default(_that.status, _that.message);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingResultDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FollowingResultDto implements FollowingResultDto {
  _FollowingResultDto(
      {@JsonKey(name: 'status') required this.status,
      @JsonKey(name: 'message') this.message});
  factory _FollowingResultDto.fromJson(Map<String, dynamic> json) =>
      _$FollowingResultDtoFromJson(json);

  @override
  @JsonKey(name: 'status')
  final FollowingStatusEnumDto status;
  @override
  @JsonKey(name: 'message')
  final String? message;

  /// Create a copy of FollowingResultDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FollowingResultDtoCopyWith<_FollowingResultDto> get copyWith =>
      __$FollowingResultDtoCopyWithImpl<_FollowingResultDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FollowingResultDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FollowingResultDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'FollowingResultDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$FollowingResultDtoCopyWith<$Res>
    implements $FollowingResultDtoCopyWith<$Res> {
  factory _$FollowingResultDtoCopyWith(
          _FollowingResultDto value, $Res Function(_FollowingResultDto) _then) =
      __$FollowingResultDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class __$FollowingResultDtoCopyWithImpl<$Res>
    implements _$FollowingResultDtoCopyWith<$Res> {
  __$FollowingResultDtoCopyWithImpl(this._self, this._then);

  final _FollowingResultDto _self;
  final $Res Function(_FollowingResultDto) _then;

  /// Create a copy of FollowingResultDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_FollowingResultDto(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$FollowingStatusDto {
  @JsonKey(name: 'status')
  FollowingStatusEnumDto get status;

  /// Create a copy of FollowingStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FollowingStatusDtoCopyWith<FollowingStatusDto> get copyWith =>
      _$FollowingStatusDtoCopyWithImpl<FollowingStatusDto>(
          this as FollowingStatusDto, _$identity);

  /// Serializes this FollowingStatusDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FollowingStatusDto &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status);

  @override
  String toString() {
    return 'FollowingStatusDto(status: $status)';
  }
}

/// @nodoc
abstract mixin class $FollowingStatusDtoCopyWith<$Res> {
  factory $FollowingStatusDtoCopyWith(
          FollowingStatusDto value, $Res Function(FollowingStatusDto) _then) =
      _$FollowingStatusDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'status') FollowingStatusEnumDto status});
}

/// @nodoc
class _$FollowingStatusDtoCopyWithImpl<$Res>
    implements $FollowingStatusDtoCopyWith<$Res> {
  _$FollowingStatusDtoCopyWithImpl(this._self, this._then);

  final FollowingStatusDto _self;
  final $Res Function(FollowingStatusDto) _then;

  /// Create a copy of FollowingStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
    ));
  }
}

/// Adds pattern-matching-related methods to [FollowingStatusDto].
extension FollowingStatusDtoPatterns on FollowingStatusDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FollowingStatusDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FollowingStatusDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FollowingStatusDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingStatusDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FollowingStatusDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingStatusDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FollowingStatusDto() when $default != null:
        return $default(_that.status);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingStatusDto():
        return $default(_that.status);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'status') FollowingStatusEnumDto status)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FollowingStatusDto() when $default != null:
        return $default(_that.status);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FollowingStatusDto implements FollowingStatusDto {
  _FollowingStatusDto({@JsonKey(name: 'status') required this.status});
  factory _FollowingStatusDto.fromJson(Map<String, dynamic> json) =>
      _$FollowingStatusDtoFromJson(json);

  @override
  @JsonKey(name: 'status')
  final FollowingStatusEnumDto status;

  /// Create a copy of FollowingStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FollowingStatusDtoCopyWith<_FollowingStatusDto> get copyWith =>
      __$FollowingStatusDtoCopyWithImpl<_FollowingStatusDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FollowingStatusDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FollowingStatusDto &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status);

  @override
  String toString() {
    return 'FollowingStatusDto(status: $status)';
  }
}

/// @nodoc
abstract mixin class _$FollowingStatusDtoCopyWith<$Res>
    implements $FollowingStatusDtoCopyWith<$Res> {
  factory _$FollowingStatusDtoCopyWith(
          _FollowingStatusDto value, $Res Function(_FollowingStatusDto) _then) =
      __$FollowingStatusDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'status') FollowingStatusEnumDto status});
}

/// @nodoc
class __$FollowingStatusDtoCopyWithImpl<$Res>
    implements _$FollowingStatusDtoCopyWith<$Res> {
  __$FollowingStatusDtoCopyWithImpl(this._self, this._then);

  final _FollowingStatusDto _self;
  final $Res Function(_FollowingStatusDto) _then;

  /// Create a copy of FollowingStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
  }) {
    return _then(_FollowingStatusDto(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
    ));
  }
}

/// @nodoc
mixin _$ImageMetadataDto {
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'contentType')
  String? get contentType;

  /// Create a copy of ImageMetadataDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ImageMetadataDtoCopyWith<ImageMetadataDto> get copyWith =>
      _$ImageMetadataDtoCopyWithImpl<ImageMetadataDto>(
          this as ImageMetadataDto, _$identity);

  /// Serializes this ImageMetadataDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ImageMetadataDto &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileName, fileUrl, width, height, size, contentType);

  @override
  String toString() {
    return 'ImageMetadataDto(fileName: $fileName, fileUrl: $fileUrl, width: $width, height: $height, size: $size, contentType: $contentType)';
  }
}

/// @nodoc
abstract mixin class $ImageMetadataDtoCopyWith<$Res> {
  factory $ImageMetadataDtoCopyWith(
          ImageMetadataDto value, $Res Function(ImageMetadataDto) _then) =
      _$ImageMetadataDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'contentType') String? contentType});
}

/// @nodoc
class _$ImageMetadataDtoCopyWithImpl<$Res>
    implements $ImageMetadataDtoCopyWith<$Res> {
  _$ImageMetadataDtoCopyWithImpl(this._self, this._then);

  final ImageMetadataDto _self;
  final $Res Function(ImageMetadataDto) _then;

  /// Create a copy of ImageMetadataDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = freezed,
    Object? fileUrl = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? contentType = freezed,
  }) {
    return _then(_self.copyWith(
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ImageMetadataDto].
extension ImageMetadataDtoPatterns on ImageMetadataDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ImageMetadataDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImageMetadataDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ImageMetadataDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageMetadataDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ImageMetadataDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageMetadataDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImageMetadataDto() when $default != null:
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageMetadataDto():
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageMetadataDto() when $default != null:
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ImageMetadataDto implements ImageMetadataDto {
  _ImageMetadataDto(
      {@JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'contentType') this.contentType});
  factory _ImageMetadataDto.fromJson(Map<String, dynamic> json) =>
      _$ImageMetadataDtoFromJson(json);

  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'contentType')
  final String? contentType;

  /// Create a copy of ImageMetadataDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ImageMetadataDtoCopyWith<_ImageMetadataDto> get copyWith =>
      __$ImageMetadataDtoCopyWithImpl<_ImageMetadataDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ImageMetadataDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImageMetadataDto &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileName, fileUrl, width, height, size, contentType);

  @override
  String toString() {
    return 'ImageMetadataDto(fileName: $fileName, fileUrl: $fileUrl, width: $width, height: $height, size: $size, contentType: $contentType)';
  }
}

/// @nodoc
abstract mixin class _$ImageMetadataDtoCopyWith<$Res>
    implements $ImageMetadataDtoCopyWith<$Res> {
  factory _$ImageMetadataDtoCopyWith(
          _ImageMetadataDto value, $Res Function(_ImageMetadataDto) _then) =
      __$ImageMetadataDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'contentType') String? contentType});
}

/// @nodoc
class __$ImageMetadataDtoCopyWithImpl<$Res>
    implements _$ImageMetadataDtoCopyWith<$Res> {
  __$ImageMetadataDtoCopyWithImpl(this._self, this._then);

  final _ImageMetadataDto _self;
  final $Res Function(_ImageMetadataDto) _then;

  /// Create a copy of ImageMetadataDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileName = freezed,
    Object? fileUrl = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? contentType = freezed,
  }) {
    return _then(_ImageMetadataDto(
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ImagePresignedUrlDto {
  @JsonKey(name: 'uploadUrl')
  String? get uploadUrl;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'expiresAt')
  DateTime? get expiresAt;
  @JsonKey(name: 'headers')
  Map<String, String>? get headers;

  /// Create a copy of ImagePresignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ImagePresignedUrlDtoCopyWith<ImagePresignedUrlDto> get copyWith =>
      _$ImagePresignedUrlDtoCopyWithImpl<ImagePresignedUrlDto>(
          this as ImagePresignedUrlDto, _$identity);

  /// Serializes this ImagePresignedUrlDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ImagePresignedUrlDto &&
            (identical(other.uploadUrl, uploadUrl) ||
                other.uploadUrl == uploadUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            const DeepCollectionEquality().equals(other.headers, headers));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uploadUrl, fileUrl, fileName,
      expiresAt, const DeepCollectionEquality().hash(headers));

  @override
  String toString() {
    return 'ImagePresignedUrlDto(uploadUrl: $uploadUrl, fileUrl: $fileUrl, fileName: $fileName, expiresAt: $expiresAt, headers: $headers)';
  }
}

/// @nodoc
abstract mixin class $ImagePresignedUrlDtoCopyWith<$Res> {
  factory $ImagePresignedUrlDtoCopyWith(ImagePresignedUrlDto value,
          $Res Function(ImagePresignedUrlDto) _then) =
      _$ImagePresignedUrlDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'uploadUrl') String? uploadUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'expiresAt') DateTime? expiresAt,
      @JsonKey(name: 'headers') Map<String, String>? headers});
}

/// @nodoc
class _$ImagePresignedUrlDtoCopyWithImpl<$Res>
    implements $ImagePresignedUrlDtoCopyWith<$Res> {
  _$ImagePresignedUrlDtoCopyWithImpl(this._self, this._then);

  final ImagePresignedUrlDto _self;
  final $Res Function(ImagePresignedUrlDto) _then;

  /// Create a copy of ImagePresignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uploadUrl = freezed,
    Object? fileUrl = freezed,
    Object? fileName = freezed,
    Object? expiresAt = freezed,
    Object? headers = freezed,
  }) {
    return _then(_self.copyWith(
      uploadUrl: freezed == uploadUrl
          ? _self.uploadUrl
          : uploadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      headers: freezed == headers
          ? _self.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ImagePresignedUrlDto].
extension ImagePresignedUrlDtoPatterns on ImagePresignedUrlDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ImagePresignedUrlDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImagePresignedUrlDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ImagePresignedUrlDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagePresignedUrlDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ImagePresignedUrlDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagePresignedUrlDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImagePresignedUrlDto() when $default != null:
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagePresignedUrlDto():
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagePresignedUrlDto() when $default != null:
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ImagePresignedUrlDto implements ImagePresignedUrlDto {
  _ImagePresignedUrlDto(
      {@JsonKey(name: 'uploadUrl') this.uploadUrl,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'expiresAt') this.expiresAt,
      @JsonKey(name: 'headers') final Map<String, String>? headers})
      : _headers = headers;
  factory _ImagePresignedUrlDto.fromJson(Map<String, dynamic> json) =>
      _$ImagePresignedUrlDtoFromJson(json);

  @override
  @JsonKey(name: 'uploadUrl')
  final String? uploadUrl;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'expiresAt')
  final DateTime? expiresAt;
  final Map<String, String>? _headers;
  @override
  @JsonKey(name: 'headers')
  Map<String, String>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableMapView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ImagePresignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ImagePresignedUrlDtoCopyWith<_ImagePresignedUrlDto> get copyWith =>
      __$ImagePresignedUrlDtoCopyWithImpl<_ImagePresignedUrlDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ImagePresignedUrlDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImagePresignedUrlDto &&
            (identical(other.uploadUrl, uploadUrl) ||
                other.uploadUrl == uploadUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            const DeepCollectionEquality().equals(other._headers, _headers));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uploadUrl, fileUrl, fileName,
      expiresAt, const DeepCollectionEquality().hash(_headers));

  @override
  String toString() {
    return 'ImagePresignedUrlDto(uploadUrl: $uploadUrl, fileUrl: $fileUrl, fileName: $fileName, expiresAt: $expiresAt, headers: $headers)';
  }
}

/// @nodoc
abstract mixin class _$ImagePresignedUrlDtoCopyWith<$Res>
    implements $ImagePresignedUrlDtoCopyWith<$Res> {
  factory _$ImagePresignedUrlDtoCopyWith(_ImagePresignedUrlDto value,
          $Res Function(_ImagePresignedUrlDto) _then) =
      __$ImagePresignedUrlDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'uploadUrl') String? uploadUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'expiresAt') DateTime? expiresAt,
      @JsonKey(name: 'headers') Map<String, String>? headers});
}

/// @nodoc
class __$ImagePresignedUrlDtoCopyWithImpl<$Res>
    implements _$ImagePresignedUrlDtoCopyWith<$Res> {
  __$ImagePresignedUrlDtoCopyWithImpl(this._self, this._then);

  final _ImagePresignedUrlDto _self;
  final $Res Function(_ImagePresignedUrlDto) _then;

  /// Create a copy of ImagePresignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uploadUrl = freezed,
    Object? fileUrl = freezed,
    Object? fileName = freezed,
    Object? expiresAt = freezed,
    Object? headers = freezed,
  }) {
    return _then(_ImagePresignedUrlDto(
      uploadUrl: freezed == uploadUrl
          ? _self.uploadUrl
          : uploadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      headers: freezed == headers
          ? _self._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
mixin _$InteractionResultDto {
  @JsonKey(name: 'isSteppedWith')
  bool? get isSteppedWith;
  @JsonKey(name: 'isLiked')
  bool? get isLiked;
  @JsonKey(name: 'totalLikes')
  int? get totalLikes;

  /// Create a copy of InteractionResultDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $InteractionResultDtoCopyWith<InteractionResultDto> get copyWith =>
      _$InteractionResultDtoCopyWithImpl<InteractionResultDto>(
          this as InteractionResultDto, _$identity);

  /// Serializes this InteractionResultDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InteractionResultDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'InteractionResultDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class $InteractionResultDtoCopyWith<$Res> {
  factory $InteractionResultDtoCopyWith(InteractionResultDto value,
          $Res Function(InteractionResultDto) _then) =
      _$InteractionResultDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class _$InteractionResultDtoCopyWithImpl<$Res>
    implements $InteractionResultDtoCopyWith<$Res> {
  _$InteractionResultDtoCopyWithImpl(this._self, this._then);

  final InteractionResultDto _self;
  final $Res Function(InteractionResultDto) _then;

  /// Create a copy of InteractionResultDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_self.copyWith(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [InteractionResultDto].
extension InteractionResultDtoPatterns on InteractionResultDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_InteractionResultDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InteractionResultDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_InteractionResultDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InteractionResultDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_InteractionResultDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InteractionResultDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InteractionResultDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InteractionResultDto():
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InteractionResultDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _InteractionResultDto implements InteractionResultDto {
  _InteractionResultDto(
      {@JsonKey(name: 'isSteppedWith') this.isSteppedWith,
      @JsonKey(name: 'isLiked') this.isLiked,
      @JsonKey(name: 'totalLikes') this.totalLikes});
  factory _InteractionResultDto.fromJson(Map<String, dynamic> json) =>
      _$InteractionResultDtoFromJson(json);

  @override
  @JsonKey(name: 'isSteppedWith')
  final bool? isSteppedWith;
  @override
  @JsonKey(name: 'isLiked')
  final bool? isLiked;
  @override
  @JsonKey(name: 'totalLikes')
  final int? totalLikes;

  /// Create a copy of InteractionResultDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$InteractionResultDtoCopyWith<_InteractionResultDto> get copyWith =>
      __$InteractionResultDtoCopyWithImpl<_InteractionResultDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$InteractionResultDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _InteractionResultDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'InteractionResultDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class _$InteractionResultDtoCopyWith<$Res>
    implements $InteractionResultDtoCopyWith<$Res> {
  factory _$InteractionResultDtoCopyWith(_InteractionResultDto value,
          $Res Function(_InteractionResultDto) _then) =
      __$InteractionResultDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class __$InteractionResultDtoCopyWithImpl<$Res>
    implements _$InteractionResultDtoCopyWith<$Res> {
  __$InteractionResultDtoCopyWithImpl(this._self, this._then);

  final _InteractionResultDto _self;
  final $Res Function(_InteractionResultDto) _then;

  /// Create a copy of InteractionResultDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_InteractionResultDto(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$JourneyCreatingDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'firstStepContent')
  String get firstStepContent;

  /// Create a copy of JourneyCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JourneyCreatingDtoCopyWith<JourneyCreatingDto> get copyWith =>
      _$JourneyCreatingDtoCopyWithImpl<JourneyCreatingDto>(
          this as JourneyCreatingDto, _$identity);

  /// Serializes this JourneyCreatingDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JourneyCreatingDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.firstStepContent, firstStepContent) ||
                other.firstStepContent == firstStepContent));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, title, description, firstStepContent);

  @override
  String toString() {
    return 'JourneyCreatingDto(title: $title, description: $description, firstStepContent: $firstStepContent)';
  }
}

/// @nodoc
abstract mixin class $JourneyCreatingDtoCopyWith<$Res> {
  factory $JourneyCreatingDtoCopyWith(
          JourneyCreatingDto value, $Res Function(JourneyCreatingDto) _then) =
      _$JourneyCreatingDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'firstStepContent') String firstStepContent});
}

/// @nodoc
class _$JourneyCreatingDtoCopyWithImpl<$Res>
    implements $JourneyCreatingDtoCopyWith<$Res> {
  _$JourneyCreatingDtoCopyWithImpl(this._self, this._then);

  final JourneyCreatingDto _self;
  final $Res Function(JourneyCreatingDto) _then;

  /// Create a copy of JourneyCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? description = freezed,
    Object? firstStepContent = null,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepContent: null == firstStepContent
          ? _self.firstStepContent
          : firstStepContent // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [JourneyCreatingDto].
extension JourneyCreatingDtoPatterns on JourneyCreatingDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_JourneyCreatingDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyCreatingDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_JourneyCreatingDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyCreatingDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_JourneyCreatingDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyCreatingDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'firstStepContent') String firstStepContent)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyCreatingDto() when $default != null:
        return $default(_that.title, _that.description, _that.firstStepContent);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'firstStepContent') String firstStepContent)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyCreatingDto():
        return $default(_that.title, _that.description, _that.firstStepContent);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'firstStepContent') String firstStepContent)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyCreatingDto() when $default != null:
        return $default(_that.title, _that.description, _that.firstStepContent);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _JourneyCreatingDto implements JourneyCreatingDto {
  _JourneyCreatingDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'firstStepContent') required this.firstStepContent});
  factory _JourneyCreatingDto.fromJson(Map<String, dynamic> json) =>
      _$JourneyCreatingDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'firstStepContent')
  final String firstStepContent;

  /// Create a copy of JourneyCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JourneyCreatingDtoCopyWith<_JourneyCreatingDto> get copyWith =>
      __$JourneyCreatingDtoCopyWithImpl<_JourneyCreatingDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$JourneyCreatingDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JourneyCreatingDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.firstStepContent, firstStepContent) ||
                other.firstStepContent == firstStepContent));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, title, description, firstStepContent);

  @override
  String toString() {
    return 'JourneyCreatingDto(title: $title, description: $description, firstStepContent: $firstStepContent)';
  }
}

/// @nodoc
abstract mixin class _$JourneyCreatingDtoCopyWith<$Res>
    implements $JourneyCreatingDtoCopyWith<$Res> {
  factory _$JourneyCreatingDtoCopyWith(
          _JourneyCreatingDto value, $Res Function(_JourneyCreatingDto) _then) =
      __$JourneyCreatingDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'firstStepContent') String firstStepContent});
}

/// @nodoc
class __$JourneyCreatingDtoCopyWithImpl<$Res>
    implements _$JourneyCreatingDtoCopyWith<$Res> {
  __$JourneyCreatingDtoCopyWithImpl(this._self, this._then);

  final _JourneyCreatingDto _self;
  final $Res Function(_JourneyCreatingDto) _then;

  /// Create a copy of JourneyCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? description = freezed,
    Object? firstStepContent = null,
  }) {
    return _then(_JourneyCreatingDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepContent: null == firstStepContent
          ? _self.firstStepContent
          : firstStepContent // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$JourneyDayCalendarDto {
  @JsonKey(name: 'lastStep')
  StepDto get lastStep;
  @JsonKey(name: 'totalSteps')
  int get totalSteps;
  @JsonKey(name: 'date')
  DateTime get date;

  /// Create a copy of JourneyDayCalendarDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JourneyDayCalendarDtoCopyWith<JourneyDayCalendarDto> get copyWith =>
      _$JourneyDayCalendarDtoCopyWithImpl<JourneyDayCalendarDto>(
          this as JourneyDayCalendarDto, _$identity);

  /// Serializes this JourneyDayCalendarDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JourneyDayCalendarDto &&
            (identical(other.lastStep, lastStep) ||
                other.lastStep == lastStep) &&
            (identical(other.totalSteps, totalSteps) ||
                other.totalSteps == totalSteps) &&
            (identical(other.date, date) || other.date == date));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, lastStep, totalSteps, date);

  @override
  String toString() {
    return 'JourneyDayCalendarDto(lastStep: $lastStep, totalSteps: $totalSteps, date: $date)';
  }
}

/// @nodoc
abstract mixin class $JourneyDayCalendarDtoCopyWith<$Res> {
  factory $JourneyDayCalendarDtoCopyWith(JourneyDayCalendarDto value,
          $Res Function(JourneyDayCalendarDto) _then) =
      _$JourneyDayCalendarDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'lastStep') StepDto lastStep,
      @JsonKey(name: 'totalSteps') int totalSteps,
      @JsonKey(name: 'date') DateTime date});

  $StepDtoCopyWith<$Res> get lastStep;
}

/// @nodoc
class _$JourneyDayCalendarDtoCopyWithImpl<$Res>
    implements $JourneyDayCalendarDtoCopyWith<$Res> {
  _$JourneyDayCalendarDtoCopyWithImpl(this._self, this._then);

  final JourneyDayCalendarDto _self;
  final $Res Function(JourneyDayCalendarDto) _then;

  /// Create a copy of JourneyDayCalendarDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lastStep = null,
    Object? totalSteps = null,
    Object? date = null,
  }) {
    return _then(_self.copyWith(
      lastStep: null == lastStep
          ? _self.lastStep
          : lastStep // ignore: cast_nullable_to_non_nullable
              as StepDto,
      totalSteps: null == totalSteps
          ? _self.totalSteps
          : totalSteps // ignore: cast_nullable_to_non_nullable
              as int,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }

  /// Create a copy of JourneyDayCalendarDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepDtoCopyWith<$Res> get lastStep {
    return $StepDtoCopyWith<$Res>(_self.lastStep, (value) {
      return _then(_self.copyWith(lastStep: value));
    });
  }
}

/// Adds pattern-matching-related methods to [JourneyDayCalendarDto].
extension JourneyDayCalendarDtoPatterns on JourneyDayCalendarDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_JourneyDayCalendarDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyDayCalendarDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_JourneyDayCalendarDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDayCalendarDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_JourneyDayCalendarDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDayCalendarDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'lastStep') StepDto lastStep,
            @JsonKey(name: 'totalSteps') int totalSteps,
            @JsonKey(name: 'date') DateTime date)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyDayCalendarDto() when $default != null:
        return $default(_that.lastStep, _that.totalSteps, _that.date);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'lastStep') StepDto lastStep,
            @JsonKey(name: 'totalSteps') int totalSteps,
            @JsonKey(name: 'date') DateTime date)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDayCalendarDto():
        return $default(_that.lastStep, _that.totalSteps, _that.date);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'lastStep') StepDto lastStep,
            @JsonKey(name: 'totalSteps') int totalSteps,
            @JsonKey(name: 'date') DateTime date)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDayCalendarDto() when $default != null:
        return $default(_that.lastStep, _that.totalSteps, _that.date);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _JourneyDayCalendarDto implements JourneyDayCalendarDto {
  _JourneyDayCalendarDto(
      {@JsonKey(name: 'lastStep') required this.lastStep,
      @JsonKey(name: 'totalSteps') this.totalSteps = 0,
      @JsonKey(name: 'date') required this.date});
  factory _JourneyDayCalendarDto.fromJson(Map<String, dynamic> json) =>
      _$JourneyDayCalendarDtoFromJson(json);

  @override
  @JsonKey(name: 'lastStep')
  final StepDto lastStep;
  @override
  @JsonKey(name: 'totalSteps')
  final int totalSteps;
  @override
  @JsonKey(name: 'date')
  final DateTime date;

  /// Create a copy of JourneyDayCalendarDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JourneyDayCalendarDtoCopyWith<_JourneyDayCalendarDto> get copyWith =>
      __$JourneyDayCalendarDtoCopyWithImpl<_JourneyDayCalendarDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$JourneyDayCalendarDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JourneyDayCalendarDto &&
            (identical(other.lastStep, lastStep) ||
                other.lastStep == lastStep) &&
            (identical(other.totalSteps, totalSteps) ||
                other.totalSteps == totalSteps) &&
            (identical(other.date, date) || other.date == date));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, lastStep, totalSteps, date);

  @override
  String toString() {
    return 'JourneyDayCalendarDto(lastStep: $lastStep, totalSteps: $totalSteps, date: $date)';
  }
}

/// @nodoc
abstract mixin class _$JourneyDayCalendarDtoCopyWith<$Res>
    implements $JourneyDayCalendarDtoCopyWith<$Res> {
  factory _$JourneyDayCalendarDtoCopyWith(_JourneyDayCalendarDto value,
          $Res Function(_JourneyDayCalendarDto) _then) =
      __$JourneyDayCalendarDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'lastStep') StepDto lastStep,
      @JsonKey(name: 'totalSteps') int totalSteps,
      @JsonKey(name: 'date') DateTime date});

  @override
  $StepDtoCopyWith<$Res> get lastStep;
}

/// @nodoc
class __$JourneyDayCalendarDtoCopyWithImpl<$Res>
    implements _$JourneyDayCalendarDtoCopyWith<$Res> {
  __$JourneyDayCalendarDtoCopyWithImpl(this._self, this._then);

  final _JourneyDayCalendarDto _self;
  final $Res Function(_JourneyDayCalendarDto) _then;

  /// Create a copy of JourneyDayCalendarDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? lastStep = null,
    Object? totalSteps = null,
    Object? date = null,
  }) {
    return _then(_JourneyDayCalendarDto(
      lastStep: null == lastStep
          ? _self.lastStep
          : lastStep // ignore: cast_nullable_to_non_nullable
              as StepDto,
      totalSteps: null == totalSteps
          ? _self.totalSteps
          : totalSteps // ignore: cast_nullable_to_non_nullable
              as int,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }

  /// Create a copy of JourneyDayCalendarDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepDtoCopyWith<$Res> get lastStep {
    return $StepDtoCopyWith<$Res>(_self.lastStep, (value) {
      return _then(_self.copyWith(lastStep: value));
    });
  }
}

/// @nodoc
mixin _$JourneyDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'completedDate')
  DateTime? get completedDate;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'firstStepId')
  String? get firstStepId;
  @JsonKey(name: 'finalStepId')
  String? get finalStepId;

  /// Create a copy of JourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<JourneyDto> get copyWith =>
      _$JourneyDtoCopyWithImpl<JourneyDto>(this as JourneyDto, _$identity);

  /// Serializes this JourneyDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JourneyDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'JourneyDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class $JourneyDtoCopyWith<$Res> {
  factory $JourneyDtoCopyWith(
          JourneyDto value, $Res Function(JourneyDto) _then) =
      _$JourneyDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class _$JourneyDtoCopyWithImpl<$Res> implements $JourneyDtoCopyWith<$Res> {
  _$JourneyDtoCopyWithImpl(this._self, this._then);

  final JourneyDto _self;
  final $Res Function(JourneyDto) _then;

  /// Create a copy of JourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [JourneyDto].
extension JourneyDtoPatterns on JourneyDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_JourneyDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_JourneyDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_JourneyDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto():
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _JourneyDto implements JourneyDto {
  _JourneyDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'completedDate') this.completedDate,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'firstStepId') this.firstStepId,
      @JsonKey(name: 'finalStepId') this.finalStepId});
  factory _JourneyDto.fromJson(Map<String, dynamic> json) =>
      _$JourneyDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'completedDate')
  final DateTime? completedDate;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'firstStepId')
  final String? firstStepId;
  @override
  @JsonKey(name: 'finalStepId')
  final String? finalStepId;

  /// Create a copy of JourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JourneyDtoCopyWith<_JourneyDto> get copyWith =>
      __$JourneyDtoCopyWithImpl<_JourneyDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$JourneyDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JourneyDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'JourneyDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class _$JourneyDtoCopyWith<$Res>
    implements $JourneyDtoCopyWith<$Res> {
  factory _$JourneyDtoCopyWith(
          _JourneyDto value, $Res Function(_JourneyDto) _then) =
      __$JourneyDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class __$JourneyDtoCopyWithImpl<$Res> implements _$JourneyDtoCopyWith<$Res> {
  __$JourneyDtoCopyWithImpl(this._self, this._then);

  final _JourneyDto _self;
  final $Res Function(_JourneyDto) _then;

  /// Create a copy of JourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_JourneyDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$JourneyDto2Dto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'completedDate')
  DateTime? get completedDate;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'firstStepId')
  String? get firstStepId;
  @JsonKey(name: 'finalStepId')
  String? get finalStepId;

  /// Create a copy of JourneyDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JourneyDto2DtoCopyWith<JourneyDto2Dto> get copyWith =>
      _$JourneyDto2DtoCopyWithImpl<JourneyDto2Dto>(
          this as JourneyDto2Dto, _$identity);

  /// Serializes this JourneyDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JourneyDto2Dto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'JourneyDto2Dto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class $JourneyDto2DtoCopyWith<$Res> {
  factory $JourneyDto2DtoCopyWith(
          JourneyDto2Dto value, $Res Function(JourneyDto2Dto) _then) =
      _$JourneyDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class _$JourneyDto2DtoCopyWithImpl<$Res>
    implements $JourneyDto2DtoCopyWith<$Res> {
  _$JourneyDto2DtoCopyWithImpl(this._self, this._then);

  final JourneyDto2Dto _self;
  final $Res Function(JourneyDto2Dto) _then;

  /// Create a copy of JourneyDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [JourneyDto2Dto].
extension JourneyDto2DtoPatterns on JourneyDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_JourneyDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_JourneyDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_JourneyDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyDto2Dto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto2Dto():
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyDto2Dto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _JourneyDto2Dto implements JourneyDto2Dto {
  _JourneyDto2Dto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'completedDate') this.completedDate,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'firstStepId') this.firstStepId,
      @JsonKey(name: 'finalStepId') this.finalStepId});
  factory _JourneyDto2Dto.fromJson(Map<String, dynamic> json) =>
      _$JourneyDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'completedDate')
  final DateTime? completedDate;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'firstStepId')
  final String? firstStepId;
  @override
  @JsonKey(name: 'finalStepId')
  final String? finalStepId;

  /// Create a copy of JourneyDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JourneyDto2DtoCopyWith<_JourneyDto2Dto> get copyWith =>
      __$JourneyDto2DtoCopyWithImpl<_JourneyDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$JourneyDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JourneyDto2Dto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'JourneyDto2Dto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class _$JourneyDto2DtoCopyWith<$Res>
    implements $JourneyDto2DtoCopyWith<$Res> {
  factory _$JourneyDto2DtoCopyWith(
          _JourneyDto2Dto value, $Res Function(_JourneyDto2Dto) _then) =
      __$JourneyDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class __$JourneyDto2DtoCopyWithImpl<$Res>
    implements _$JourneyDto2DtoCopyWith<$Res> {
  __$JourneyDto2DtoCopyWithImpl(this._self, this._then);

  final _JourneyDto2Dto _self;
  final $Res Function(_JourneyDto2Dto) _then;

  /// Create a copy of JourneyDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_JourneyDto2Dto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$JourneyInDetailDto {
  @JsonKey(name: 'journey')
  JourneyDto2Dto get journey;
  @JsonKey(name: 'stepsCount')
  int get stepsCount;
  @JsonKey(name: 'lastStepDate')
  DateTime get lastStepDate;
  @JsonKey(name: 'stepperCount')
  int? get stepperCount;
  @JsonKey(name: 'latestSteppers')
  List<UserDto>? get latestSteppers;
  @JsonKey(name: 'starterCount')
  int? get starterCount;
  @JsonKey(name: 'latestStarters')
  List<dynamic>? get latestStarters;
  @JsonKey(name: 'companionCount')
  int? get companionCount;
  @JsonKey(name: 'latestCompanions')
  List<dynamic>? get latestCompanions;
  @JsonKey(name: 'celebratorCount')
  int? get celebratorCount;
  @JsonKey(name: 'latestCelebrators')
  List<dynamic>? get latestCelebrators;

  /// Create a copy of JourneyInDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JourneyInDetailDtoCopyWith<JourneyInDetailDto> get copyWith =>
      _$JourneyInDetailDtoCopyWithImpl<JourneyInDetailDto>(
          this as JourneyInDetailDto, _$identity);

  /// Serializes this JourneyInDetailDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JourneyInDetailDto &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.stepsCount, stepsCount) ||
                other.stepsCount == stepsCount) &&
            (identical(other.lastStepDate, lastStepDate) ||
                other.lastStepDate == lastStepDate) &&
            (identical(other.stepperCount, stepperCount) ||
                other.stepperCount == stepperCount) &&
            const DeepCollectionEquality()
                .equals(other.latestSteppers, latestSteppers) &&
            (identical(other.starterCount, starterCount) ||
                other.starterCount == starterCount) &&
            const DeepCollectionEquality()
                .equals(other.latestStarters, latestStarters) &&
            (identical(other.companionCount, companionCount) ||
                other.companionCount == companionCount) &&
            const DeepCollectionEquality()
                .equals(other.latestCompanions, latestCompanions) &&
            (identical(other.celebratorCount, celebratorCount) ||
                other.celebratorCount == celebratorCount) &&
            const DeepCollectionEquality()
                .equals(other.latestCelebrators, latestCelebrators));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      journey,
      stepsCount,
      lastStepDate,
      stepperCount,
      const DeepCollectionEquality().hash(latestSteppers),
      starterCount,
      const DeepCollectionEquality().hash(latestStarters),
      companionCount,
      const DeepCollectionEquality().hash(latestCompanions),
      celebratorCount,
      const DeepCollectionEquality().hash(latestCelebrators));

  @override
  String toString() {
    return 'JourneyInDetailDto(journey: $journey, stepsCount: $stepsCount, lastStepDate: $lastStepDate, stepperCount: $stepperCount, latestSteppers: $latestSteppers, starterCount: $starterCount, latestStarters: $latestStarters, companionCount: $companionCount, latestCompanions: $latestCompanions, celebratorCount: $celebratorCount, latestCelebrators: $latestCelebrators)';
  }
}

/// @nodoc
abstract mixin class $JourneyInDetailDtoCopyWith<$Res> {
  factory $JourneyInDetailDtoCopyWith(
          JourneyInDetailDto value, $Res Function(JourneyInDetailDto) _then) =
      _$JourneyInDetailDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'journey') JourneyDto2Dto journey,
      @JsonKey(name: 'stepsCount') int stepsCount,
      @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
      @JsonKey(name: 'stepperCount') int? stepperCount,
      @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
      @JsonKey(name: 'starterCount') int? starterCount,
      @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
      @JsonKey(name: 'companionCount') int? companionCount,
      @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
      @JsonKey(name: 'celebratorCount') int? celebratorCount,
      @JsonKey(name: 'latestCelebrators') List<dynamic>? latestCelebrators});

  $JourneyDto2DtoCopyWith<$Res> get journey;
}

/// @nodoc
class _$JourneyInDetailDtoCopyWithImpl<$Res>
    implements $JourneyInDetailDtoCopyWith<$Res> {
  _$JourneyInDetailDtoCopyWithImpl(this._self, this._then);

  final JourneyInDetailDto _self;
  final $Res Function(JourneyInDetailDto) _then;

  /// Create a copy of JourneyInDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? journey = null,
    Object? stepsCount = null,
    Object? lastStepDate = null,
    Object? stepperCount = freezed,
    Object? latestSteppers = freezed,
    Object? starterCount = freezed,
    Object? latestStarters = freezed,
    Object? companionCount = freezed,
    Object? latestCompanions = freezed,
    Object? celebratorCount = freezed,
    Object? latestCelebrators = freezed,
  }) {
    return _then(_self.copyWith(
      journey: null == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto2Dto,
      stepsCount: null == stepsCount
          ? _self.stepsCount
          : stepsCount // ignore: cast_nullable_to_non_nullable
              as int,
      lastStepDate: null == lastStepDate
          ? _self.lastStepDate
          : lastStepDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      stepperCount: freezed == stepperCount
          ? _self.stepperCount
          : stepperCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestSteppers: freezed == latestSteppers
          ? _self.latestSteppers
          : latestSteppers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      starterCount: freezed == starterCount
          ? _self.starterCount
          : starterCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestStarters: freezed == latestStarters
          ? _self.latestStarters
          : latestStarters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      companionCount: freezed == companionCount
          ? _self.companionCount
          : companionCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCompanions: freezed == latestCompanions
          ? _self.latestCompanions
          : latestCompanions // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      celebratorCount: freezed == celebratorCount
          ? _self.celebratorCount
          : celebratorCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCelebrators: freezed == latestCelebrators
          ? _self.latestCelebrators
          : latestCelebrators // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }

  /// Create a copy of JourneyInDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDto2DtoCopyWith<$Res> get journey {
    return $JourneyDto2DtoCopyWith<$Res>(_self.journey, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// Adds pattern-matching-related methods to [JourneyInDetailDto].
extension JourneyInDetailDtoPatterns on JourneyInDetailDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_JourneyInDetailDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyInDetailDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_JourneyInDetailDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyInDetailDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_JourneyInDetailDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyInDetailDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'journey') JourneyDto2Dto journey,
            @JsonKey(name: 'stepsCount') int stepsCount,
            @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
            @JsonKey(name: 'stepperCount') int? stepperCount,
            @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
            @JsonKey(name: 'starterCount') int? starterCount,
            @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
            @JsonKey(name: 'companionCount') int? companionCount,
            @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
            @JsonKey(name: 'celebratorCount') int? celebratorCount,
            @JsonKey(name: 'latestCelebrators')
            List<dynamic>? latestCelebrators)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JourneyInDetailDto() when $default != null:
        return $default(
            _that.journey,
            _that.stepsCount,
            _that.lastStepDate,
            _that.stepperCount,
            _that.latestSteppers,
            _that.starterCount,
            _that.latestStarters,
            _that.companionCount,
            _that.latestCompanions,
            _that.celebratorCount,
            _that.latestCelebrators);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'journey') JourneyDto2Dto journey,
            @JsonKey(name: 'stepsCount') int stepsCount,
            @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
            @JsonKey(name: 'stepperCount') int? stepperCount,
            @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
            @JsonKey(name: 'starterCount') int? starterCount,
            @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
            @JsonKey(name: 'companionCount') int? companionCount,
            @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
            @JsonKey(name: 'celebratorCount') int? celebratorCount,
            @JsonKey(name: 'latestCelebrators')
            List<dynamic>? latestCelebrators)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyInDetailDto():
        return $default(
            _that.journey,
            _that.stepsCount,
            _that.lastStepDate,
            _that.stepperCount,
            _that.latestSteppers,
            _that.starterCount,
            _that.latestStarters,
            _that.companionCount,
            _that.latestCompanions,
            _that.celebratorCount,
            _that.latestCelebrators);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'journey') JourneyDto2Dto journey,
            @JsonKey(name: 'stepsCount') int stepsCount,
            @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
            @JsonKey(name: 'stepperCount') int? stepperCount,
            @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
            @JsonKey(name: 'starterCount') int? starterCount,
            @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
            @JsonKey(name: 'companionCount') int? companionCount,
            @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
            @JsonKey(name: 'celebratorCount') int? celebratorCount,
            @JsonKey(name: 'latestCelebrators')
            List<dynamic>? latestCelebrators)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JourneyInDetailDto() when $default != null:
        return $default(
            _that.journey,
            _that.stepsCount,
            _that.lastStepDate,
            _that.stepperCount,
            _that.latestSteppers,
            _that.starterCount,
            _that.latestStarters,
            _that.companionCount,
            _that.latestCompanions,
            _that.celebratorCount,
            _that.latestCelebrators);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _JourneyInDetailDto implements JourneyInDetailDto {
  _JourneyInDetailDto(
      {@JsonKey(name: 'journey') required this.journey,
      @JsonKey(name: 'stepsCount') required this.stepsCount,
      @JsonKey(name: 'lastStepDate') required this.lastStepDate,
      @JsonKey(name: 'stepperCount') this.stepperCount,
      @JsonKey(name: 'latestSteppers') final List<UserDto>? latestSteppers,
      @JsonKey(name: 'starterCount') this.starterCount,
      @JsonKey(name: 'latestStarters') final List<dynamic>? latestStarters,
      @JsonKey(name: 'companionCount') this.companionCount,
      @JsonKey(name: 'latestCompanions') final List<dynamic>? latestCompanions,
      @JsonKey(name: 'celebratorCount') this.celebratorCount,
      @JsonKey(name: 'latestCelebrators')
      final List<dynamic>? latestCelebrators})
      : _latestSteppers = latestSteppers,
        _latestStarters = latestStarters,
        _latestCompanions = latestCompanions,
        _latestCelebrators = latestCelebrators;
  factory _JourneyInDetailDto.fromJson(Map<String, dynamic> json) =>
      _$JourneyInDetailDtoFromJson(json);

  @override
  @JsonKey(name: 'journey')
  final JourneyDto2Dto journey;
  @override
  @JsonKey(name: 'stepsCount')
  final int stepsCount;
  @override
  @JsonKey(name: 'lastStepDate')
  final DateTime lastStepDate;
  @override
  @JsonKey(name: 'stepperCount')
  final int? stepperCount;
  final List<UserDto>? _latestSteppers;
  @override
  @JsonKey(name: 'latestSteppers')
  List<UserDto>? get latestSteppers {
    final value = _latestSteppers;
    if (value == null) return null;
    if (_latestSteppers is EqualUnmodifiableListView) return _latestSteppers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'starterCount')
  final int? starterCount;
  final List<dynamic>? _latestStarters;
  @override
  @JsonKey(name: 'latestStarters')
  List<dynamic>? get latestStarters {
    final value = _latestStarters;
    if (value == null) return null;
    if (_latestStarters is EqualUnmodifiableListView) return _latestStarters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'companionCount')
  final int? companionCount;
  final List<dynamic>? _latestCompanions;
  @override
  @JsonKey(name: 'latestCompanions')
  List<dynamic>? get latestCompanions {
    final value = _latestCompanions;
    if (value == null) return null;
    if (_latestCompanions is EqualUnmodifiableListView)
      return _latestCompanions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'celebratorCount')
  final int? celebratorCount;
  final List<dynamic>? _latestCelebrators;
  @override
  @JsonKey(name: 'latestCelebrators')
  List<dynamic>? get latestCelebrators {
    final value = _latestCelebrators;
    if (value == null) return null;
    if (_latestCelebrators is EqualUnmodifiableListView)
      return _latestCelebrators;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of JourneyInDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JourneyInDetailDtoCopyWith<_JourneyInDetailDto> get copyWith =>
      __$JourneyInDetailDtoCopyWithImpl<_JourneyInDetailDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$JourneyInDetailDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JourneyInDetailDto &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.stepsCount, stepsCount) ||
                other.stepsCount == stepsCount) &&
            (identical(other.lastStepDate, lastStepDate) ||
                other.lastStepDate == lastStepDate) &&
            (identical(other.stepperCount, stepperCount) ||
                other.stepperCount == stepperCount) &&
            const DeepCollectionEquality()
                .equals(other._latestSteppers, _latestSteppers) &&
            (identical(other.starterCount, starterCount) ||
                other.starterCount == starterCount) &&
            const DeepCollectionEquality()
                .equals(other._latestStarters, _latestStarters) &&
            (identical(other.companionCount, companionCount) ||
                other.companionCount == companionCount) &&
            const DeepCollectionEquality()
                .equals(other._latestCompanions, _latestCompanions) &&
            (identical(other.celebratorCount, celebratorCount) ||
                other.celebratorCount == celebratorCount) &&
            const DeepCollectionEquality()
                .equals(other._latestCelebrators, _latestCelebrators));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      journey,
      stepsCount,
      lastStepDate,
      stepperCount,
      const DeepCollectionEquality().hash(_latestSteppers),
      starterCount,
      const DeepCollectionEquality().hash(_latestStarters),
      companionCount,
      const DeepCollectionEquality().hash(_latestCompanions),
      celebratorCount,
      const DeepCollectionEquality().hash(_latestCelebrators));

  @override
  String toString() {
    return 'JourneyInDetailDto(journey: $journey, stepsCount: $stepsCount, lastStepDate: $lastStepDate, stepperCount: $stepperCount, latestSteppers: $latestSteppers, starterCount: $starterCount, latestStarters: $latestStarters, companionCount: $companionCount, latestCompanions: $latestCompanions, celebratorCount: $celebratorCount, latestCelebrators: $latestCelebrators)';
  }
}

/// @nodoc
abstract mixin class _$JourneyInDetailDtoCopyWith<$Res>
    implements $JourneyInDetailDtoCopyWith<$Res> {
  factory _$JourneyInDetailDtoCopyWith(
          _JourneyInDetailDto value, $Res Function(_JourneyInDetailDto) _then) =
      __$JourneyInDetailDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'journey') JourneyDto2Dto journey,
      @JsonKey(name: 'stepsCount') int stepsCount,
      @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
      @JsonKey(name: 'stepperCount') int? stepperCount,
      @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
      @JsonKey(name: 'starterCount') int? starterCount,
      @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
      @JsonKey(name: 'companionCount') int? companionCount,
      @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
      @JsonKey(name: 'celebratorCount') int? celebratorCount,
      @JsonKey(name: 'latestCelebrators') List<dynamic>? latestCelebrators});

  @override
  $JourneyDto2DtoCopyWith<$Res> get journey;
}

/// @nodoc
class __$JourneyInDetailDtoCopyWithImpl<$Res>
    implements _$JourneyInDetailDtoCopyWith<$Res> {
  __$JourneyInDetailDtoCopyWithImpl(this._self, this._then);

  final _JourneyInDetailDto _self;
  final $Res Function(_JourneyInDetailDto) _then;

  /// Create a copy of JourneyInDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? journey = null,
    Object? stepsCount = null,
    Object? lastStepDate = null,
    Object? stepperCount = freezed,
    Object? latestSteppers = freezed,
    Object? starterCount = freezed,
    Object? latestStarters = freezed,
    Object? companionCount = freezed,
    Object? latestCompanions = freezed,
    Object? celebratorCount = freezed,
    Object? latestCelebrators = freezed,
  }) {
    return _then(_JourneyInDetailDto(
      journey: null == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto2Dto,
      stepsCount: null == stepsCount
          ? _self.stepsCount
          : stepsCount // ignore: cast_nullable_to_non_nullable
              as int,
      lastStepDate: null == lastStepDate
          ? _self.lastStepDate
          : lastStepDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      stepperCount: freezed == stepperCount
          ? _self.stepperCount
          : stepperCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestSteppers: freezed == latestSteppers
          ? _self._latestSteppers
          : latestSteppers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      starterCount: freezed == starterCount
          ? _self.starterCount
          : starterCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestStarters: freezed == latestStarters
          ? _self._latestStarters
          : latestStarters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      companionCount: freezed == companionCount
          ? _self.companionCount
          : companionCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCompanions: freezed == latestCompanions
          ? _self._latestCompanions
          : latestCompanions // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      celebratorCount: freezed == celebratorCount
          ? _self.celebratorCount
          : celebratorCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCelebrators: freezed == latestCelebrators
          ? _self._latestCelebrators
          : latestCelebrators // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }

  /// Create a copy of JourneyInDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDto2DtoCopyWith<$Res> get journey {
    return $JourneyDto2DtoCopyWith<$Res>(_self.journey, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// @nodoc
mixin _$LoginDto {
  @JsonKey(name: 'email')
  String get email;
  @JsonKey(name: 'password')
  String get password;

  /// Create a copy of LoginDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $LoginDtoCopyWith<LoginDto> get copyWith =>
      _$LoginDtoCopyWithImpl<LoginDto>(this as LoginDto, _$identity);

  /// Serializes this LoginDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LoginDto &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email, password);

  @override
  String toString() {
    return 'LoginDto(email: $email, password: $password)';
  }
}

/// @nodoc
abstract mixin class $LoginDtoCopyWith<$Res> {
  factory $LoginDtoCopyWith(LoginDto value, $Res Function(LoginDto) _then) =
      _$LoginDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'email') String email,
      @JsonKey(name: 'password') String password});
}

/// @nodoc
class _$LoginDtoCopyWithImpl<$Res> implements $LoginDtoCopyWith<$Res> {
  _$LoginDtoCopyWithImpl(this._self, this._then);

  final LoginDto _self;
  final $Res Function(LoginDto) _then;

  /// Create a copy of LoginDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
    Object? password = null,
  }) {
    return _then(_self.copyWith(
      email: null == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [LoginDto].
extension LoginDtoPatterns on LoginDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_LoginDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LoginDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_LoginDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_LoginDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'email') String email,
            @JsonKey(name: 'password') String password)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LoginDto() when $default != null:
        return $default(_that.email, _that.password);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'email') String email,
            @JsonKey(name: 'password') String password)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginDto():
        return $default(_that.email, _that.password);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'email') String email,
            @JsonKey(name: 'password') String password)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginDto() when $default != null:
        return $default(_that.email, _that.password);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _LoginDto implements LoginDto {
  _LoginDto(
      {@JsonKey(name: 'email') required this.email,
      @JsonKey(name: 'password') required this.password});
  factory _LoginDto.fromJson(Map<String, dynamic> json) =>
      _$LoginDtoFromJson(json);

  @override
  @JsonKey(name: 'email')
  final String email;
  @override
  @JsonKey(name: 'password')
  final String password;

  /// Create a copy of LoginDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$LoginDtoCopyWith<_LoginDto> get copyWith =>
      __$LoginDtoCopyWithImpl<_LoginDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$LoginDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LoginDto &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email, password);

  @override
  String toString() {
    return 'LoginDto(email: $email, password: $password)';
  }
}

/// @nodoc
abstract mixin class _$LoginDtoCopyWith<$Res>
    implements $LoginDtoCopyWith<$Res> {
  factory _$LoginDtoCopyWith(_LoginDto value, $Res Function(_LoginDto) _then) =
      __$LoginDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'email') String email,
      @JsonKey(name: 'password') String password});
}

/// @nodoc
class __$LoginDtoCopyWithImpl<$Res> implements _$LoginDtoCopyWith<$Res> {
  __$LoginDtoCopyWithImpl(this._self, this._then);

  final _LoginDto _self;
  final $Res Function(_LoginDto) _then;

  /// Create a copy of LoginDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? email = null,
    Object? password = null,
  }) {
    return _then(_LoginDto(
      email: null == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$LoginResponseDto {
  @JsonKey(name: 'token')
  String? get token;
  @JsonKey(name: 'uid')
  String? get uid;

  /// Create a copy of LoginResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $LoginResponseDtoCopyWith<LoginResponseDto> get copyWith =>
      _$LoginResponseDtoCopyWithImpl<LoginResponseDto>(
          this as LoginResponseDto, _$identity);

  /// Serializes this LoginResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LoginResponseDto &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.uid, uid) || other.uid == uid));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, token, uid);

  @override
  String toString() {
    return 'LoginResponseDto(token: $token, uid: $uid)';
  }
}

/// @nodoc
abstract mixin class $LoginResponseDtoCopyWith<$Res> {
  factory $LoginResponseDtoCopyWith(
          LoginResponseDto value, $Res Function(LoginResponseDto) _then) =
      _$LoginResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'token') String? token,
      @JsonKey(name: 'uid') String? uid});
}

/// @nodoc
class _$LoginResponseDtoCopyWithImpl<$Res>
    implements $LoginResponseDtoCopyWith<$Res> {
  _$LoginResponseDtoCopyWithImpl(this._self, this._then);

  final LoginResponseDto _self;
  final $Res Function(LoginResponseDto) _then;

  /// Create a copy of LoginResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = freezed,
    Object? uid = freezed,
  }) {
    return _then(_self.copyWith(
      token: freezed == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      uid: freezed == uid
          ? _self.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [LoginResponseDto].
extension LoginResponseDtoPatterns on LoginResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_LoginResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LoginResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_LoginResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_LoginResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'token') String? token,
            @JsonKey(name: 'uid') String? uid)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LoginResponseDto() when $default != null:
        return $default(_that.token, _that.uid);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'token') String? token,
            @JsonKey(name: 'uid') String? uid)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginResponseDto():
        return $default(_that.token, _that.uid);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'token') String? token,
            @JsonKey(name: 'uid') String? uid)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LoginResponseDto() when $default != null:
        return $default(_that.token, _that.uid);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _LoginResponseDto implements LoginResponseDto {
  _LoginResponseDto(
      {@JsonKey(name: 'token') this.token, @JsonKey(name: 'uid') this.uid});
  factory _LoginResponseDto.fromJson(Map<String, dynamic> json) =>
      _$LoginResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'token')
  final String? token;
  @override
  @JsonKey(name: 'uid')
  final String? uid;

  /// Create a copy of LoginResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$LoginResponseDtoCopyWith<_LoginResponseDto> get copyWith =>
      __$LoginResponseDtoCopyWithImpl<_LoginResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$LoginResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LoginResponseDto &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.uid, uid) || other.uid == uid));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, token, uid);

  @override
  String toString() {
    return 'LoginResponseDto(token: $token, uid: $uid)';
  }
}

/// @nodoc
abstract mixin class _$LoginResponseDtoCopyWith<$Res>
    implements $LoginResponseDtoCopyWith<$Res> {
  factory _$LoginResponseDtoCopyWith(
          _LoginResponseDto value, $Res Function(_LoginResponseDto) _then) =
      __$LoginResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'token') String? token,
      @JsonKey(name: 'uid') String? uid});
}

/// @nodoc
class __$LoginResponseDtoCopyWithImpl<$Res>
    implements _$LoginResponseDtoCopyWith<$Res> {
  __$LoginResponseDtoCopyWithImpl(this._self, this._then);

  final _LoginResponseDto _self;
  final $Res Function(_LoginResponseDto) _then;

  /// Create a copy of LoginResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? token = freezed,
    Object? uid = freezed,
  }) {
    return _then(_LoginResponseDto(
      token: freezed == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      uid: freezed == uid
          ? _self.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$NotificationDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'body')
  String? get body;
  @JsonKey(name: 'notificationType')
  NotificationTypeDto? get notificationType;
  @JsonKey(name: 'isRead')
  bool? get isRead;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'data')
  Map<String, String>? get data;
  @JsonKey(name: 'priority')
  int? get priority;
  @JsonKey(name: 'relatedEntityId')
  String? get relatedEntityId;
  @JsonKey(name: 'sourceUser')
  UserDetailDto2Dto? get sourceUser;

  /// Create a copy of NotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $NotificationDtoCopyWith<NotificationDto> get copyWith =>
      _$NotificationDtoCopyWithImpl<NotificationDto>(
          this as NotificationDto, _$identity);

  /// Serializes this NotificationDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NotificationDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.sourceUser, sourceUser) ||
                other.sourceUser == sourceUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      body,
      notificationType,
      isRead,
      createdDate,
      const DeepCollectionEquality().hash(data),
      priority,
      relatedEntityId,
      sourceUser);

  @override
  String toString() {
    return 'NotificationDto(id: $id, title: $title, body: $body, notificationType: $notificationType, isRead: $isRead, createdDate: $createdDate, data: $data, priority: $priority, relatedEntityId: $relatedEntityId, sourceUser: $sourceUser)';
  }
}

/// @nodoc
abstract mixin class $NotificationDtoCopyWith<$Res> {
  factory $NotificationDtoCopyWith(
          NotificationDto value, $Res Function(NotificationDto) _then) =
      _$NotificationDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'body') String? body,
      @JsonKey(name: 'notificationType') NotificationTypeDto? notificationType,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser});

  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser;
}

/// @nodoc
class _$NotificationDtoCopyWithImpl<$Res>
    implements $NotificationDtoCopyWith<$Res> {
  _$NotificationDtoCopyWithImpl(this._self, this._then);

  final NotificationDto _self;
  final $Res Function(NotificationDto) _then;

  /// Create a copy of NotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? body = freezed,
    Object? notificationType = freezed,
    Object? isRead = freezed,
    Object? createdDate = freezed,
    Object? data = freezed,
    Object? priority = freezed,
    Object? relatedEntityId = freezed,
    Object? sourceUser = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceUser: freezed == sourceUser
          ? _self.sourceUser
          : sourceUser // ignore: cast_nullable_to_non_nullable
              as UserDetailDto2Dto?,
    ));
  }

  /// Create a copy of NotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser {
    if (_self.sourceUser == null) {
      return null;
    }

    return $UserDetailDto2DtoCopyWith<$Res>(_self.sourceUser!, (value) {
      return _then(_self.copyWith(sourceUser: value));
    });
  }
}

/// Adds pattern-matching-related methods to [NotificationDto].
extension NotificationDtoPatterns on NotificationDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NotificationDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NotificationDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NotificationDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto? notificationType,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.body,
            _that.notificationType,
            _that.isRead,
            _that.createdDate,
            _that.data,
            _that.priority,
            _that.relatedEntityId,
            _that.sourceUser);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto? notificationType,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationDto():
        return $default(
            _that.id,
            _that.title,
            _that.body,
            _that.notificationType,
            _that.isRead,
            _that.createdDate,
            _that.data,
            _that.priority,
            _that.relatedEntityId,
            _that.sourceUser);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto? notificationType,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.body,
            _that.notificationType,
            _that.isRead,
            _that.createdDate,
            _that.data,
            _that.priority,
            _that.relatedEntityId,
            _that.sourceUser);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _NotificationDto implements NotificationDto {
  _NotificationDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'body') this.body,
      @JsonKey(name: 'notificationType') this.notificationType,
      @JsonKey(name: 'isRead') this.isRead,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'data') final Map<String, String>? data,
      @JsonKey(name: 'priority') this.priority,
      @JsonKey(name: 'relatedEntityId') this.relatedEntityId,
      @JsonKey(name: 'sourceUser') this.sourceUser})
      : _data = data;
  factory _NotificationDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'body')
  final String? body;
  @override
  @JsonKey(name: 'notificationType')
  final NotificationTypeDto? notificationType;
  @override
  @JsonKey(name: 'isRead')
  final bool? isRead;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  final Map<String, String>? _data;
  @override
  @JsonKey(name: 'data')
  Map<String, String>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey(name: 'priority')
  final int? priority;
  @override
  @JsonKey(name: 'relatedEntityId')
  final String? relatedEntityId;
  @override
  @JsonKey(name: 'sourceUser')
  final UserDetailDto2Dto? sourceUser;

  /// Create a copy of NotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$NotificationDtoCopyWith<_NotificationDto> get copyWith =>
      __$NotificationDtoCopyWithImpl<_NotificationDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$NotificationDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NotificationDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.sourceUser, sourceUser) ||
                other.sourceUser == sourceUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      body,
      notificationType,
      isRead,
      createdDate,
      const DeepCollectionEquality().hash(_data),
      priority,
      relatedEntityId,
      sourceUser);

  @override
  String toString() {
    return 'NotificationDto(id: $id, title: $title, body: $body, notificationType: $notificationType, isRead: $isRead, createdDate: $createdDate, data: $data, priority: $priority, relatedEntityId: $relatedEntityId, sourceUser: $sourceUser)';
  }
}

/// @nodoc
abstract mixin class _$NotificationDtoCopyWith<$Res>
    implements $NotificationDtoCopyWith<$Res> {
  factory _$NotificationDtoCopyWith(
          _NotificationDto value, $Res Function(_NotificationDto) _then) =
      __$NotificationDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'body') String? body,
      @JsonKey(name: 'notificationType') NotificationTypeDto? notificationType,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser});

  @override
  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser;
}

/// @nodoc
class __$NotificationDtoCopyWithImpl<$Res>
    implements _$NotificationDtoCopyWith<$Res> {
  __$NotificationDtoCopyWithImpl(this._self, this._then);

  final _NotificationDto _self;
  final $Res Function(_NotificationDto) _then;

  /// Create a copy of NotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? body = freezed,
    Object? notificationType = freezed,
    Object? isRead = freezed,
    Object? createdDate = freezed,
    Object? data = freezed,
    Object? priority = freezed,
    Object? relatedEntityId = freezed,
    Object? sourceUser = freezed,
  }) {
    return _then(_NotificationDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceUser: freezed == sourceUser
          ? _self.sourceUser
          : sourceUser // ignore: cast_nullable_to_non_nullable
              as UserDetailDto2Dto?,
    ));
  }

  /// Create a copy of NotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser {
    if (_self.sourceUser == null) {
      return null;
    }

    return $UserDetailDto2DtoCopyWith<$Res>(_self.sourceUser!, (value) {
      return _then(_self.copyWith(sourceUser: value));
    });
  }
}

/// @nodoc
mixin _$NotificationPagedDto {
  @JsonKey(name: 'notifications')
  List<NotificationDto>? get notifications;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'unreadCount')
  int? get unreadCount;
  @JsonKey(name: 'hasMore')
  bool? get hasMore;

  /// Create a copy of NotificationPagedDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $NotificationPagedDtoCopyWith<NotificationPagedDto> get copyWith =>
      _$NotificationPagedDtoCopyWithImpl<NotificationPagedDto>(
          this as NotificationPagedDto, _$identity);

  /// Serializes this NotificationPagedDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NotificationPagedDto &&
            const DeepCollectionEquality()
                .equals(other.notifications, notifications) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.unreadCount, unreadCount) ||
                other.unreadCount == unreadCount) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(notifications),
      page,
      pageSize,
      totalCount,
      unreadCount,
      hasMore);

  @override
  String toString() {
    return 'NotificationPagedDto(notifications: $notifications, page: $page, pageSize: $pageSize, totalCount: $totalCount, unreadCount: $unreadCount, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $NotificationPagedDtoCopyWith<$Res> {
  factory $NotificationPagedDtoCopyWith(NotificationPagedDto value,
          $Res Function(NotificationPagedDto) _then) =
      _$NotificationPagedDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'notifications') List<NotificationDto>? notifications,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'unreadCount') int? unreadCount,
      @JsonKey(name: 'hasMore') bool? hasMore});
}

/// @nodoc
class _$NotificationPagedDtoCopyWithImpl<$Res>
    implements $NotificationPagedDtoCopyWith<$Res> {
  _$NotificationPagedDtoCopyWithImpl(this._self, this._then);

  final NotificationPagedDto _self;
  final $Res Function(NotificationPagedDto) _then;

  /// Create a copy of NotificationPagedDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? notifications = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? unreadCount = freezed,
    Object? hasMore = freezed,
  }) {
    return _then(_self.copyWith(
      notifications: freezed == notifications
          ? _self.notifications
          : notifications // ignore: cast_nullable_to_non_nullable
              as List<NotificationDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      unreadCount: freezed == unreadCount
          ? _self.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasMore: freezed == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [NotificationPagedDto].
extension NotificationPagedDtoPatterns on NotificationPagedDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NotificationPagedDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationPagedDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NotificationPagedDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationPagedDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NotificationPagedDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationPagedDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'notifications')
            List<NotificationDto>? notifications,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'unreadCount') int? unreadCount,
            @JsonKey(name: 'hasMore') bool? hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationPagedDto() when $default != null:
        return $default(_that.notifications, _that.page, _that.pageSize,
            _that.totalCount, _that.unreadCount, _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'notifications')
            List<NotificationDto>? notifications,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'unreadCount') int? unreadCount,
            @JsonKey(name: 'hasMore') bool? hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationPagedDto():
        return $default(_that.notifications, _that.page, _that.pageSize,
            _that.totalCount, _that.unreadCount, _that.hasMore);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'notifications')
            List<NotificationDto>? notifications,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'unreadCount') int? unreadCount,
            @JsonKey(name: 'hasMore') bool? hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationPagedDto() when $default != null:
        return $default(_that.notifications, _that.page, _that.pageSize,
            _that.totalCount, _that.unreadCount, _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _NotificationPagedDto implements NotificationPagedDto {
  _NotificationPagedDto(
      {@JsonKey(name: 'notifications')
      final List<NotificationDto>? notifications,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'unreadCount') this.unreadCount,
      @JsonKey(name: 'hasMore') this.hasMore})
      : _notifications = notifications;
  factory _NotificationPagedDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationPagedDtoFromJson(json);

  final List<NotificationDto>? _notifications;
  @override
  @JsonKey(name: 'notifications')
  List<NotificationDto>? get notifications {
    final value = _notifications;
    if (value == null) return null;
    if (_notifications is EqualUnmodifiableListView) return _notifications;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'unreadCount')
  final int? unreadCount;
  @override
  @JsonKey(name: 'hasMore')
  final bool? hasMore;

  /// Create a copy of NotificationPagedDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$NotificationPagedDtoCopyWith<_NotificationPagedDto> get copyWith =>
      __$NotificationPagedDtoCopyWithImpl<_NotificationPagedDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$NotificationPagedDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NotificationPagedDto &&
            const DeepCollectionEquality()
                .equals(other._notifications, _notifications) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.unreadCount, unreadCount) ||
                other.unreadCount == unreadCount) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_notifications),
      page,
      pageSize,
      totalCount,
      unreadCount,
      hasMore);

  @override
  String toString() {
    return 'NotificationPagedDto(notifications: $notifications, page: $page, pageSize: $pageSize, totalCount: $totalCount, unreadCount: $unreadCount, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$NotificationPagedDtoCopyWith<$Res>
    implements $NotificationPagedDtoCopyWith<$Res> {
  factory _$NotificationPagedDtoCopyWith(_NotificationPagedDto value,
          $Res Function(_NotificationPagedDto) _then) =
      __$NotificationPagedDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'notifications') List<NotificationDto>? notifications,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'unreadCount') int? unreadCount,
      @JsonKey(name: 'hasMore') bool? hasMore});
}

/// @nodoc
class __$NotificationPagedDtoCopyWithImpl<$Res>
    implements _$NotificationPagedDtoCopyWith<$Res> {
  __$NotificationPagedDtoCopyWithImpl(this._self, this._then);

  final _NotificationPagedDto _self;
  final $Res Function(_NotificationPagedDto) _then;

  /// Create a copy of NotificationPagedDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? notifications = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? unreadCount = freezed,
    Object? hasMore = freezed,
  }) {
    return _then(_NotificationPagedDto(
      notifications: freezed == notifications
          ? _self._notifications
          : notifications // ignore: cast_nullable_to_non_nullable
              as List<NotificationDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      unreadCount: freezed == unreadCount
          ? _self.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasMore: freezed == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ProfileDto {
  @JsonKey(name: 'userDetail')
  UserDetailDto get userDetail;
  @JsonKey(name: 'badgesCount')
  int? get badgesCount;
  @JsonKey(name: 'badgesUsers')
  List<UserDto>? get badgesUsers;
  @JsonKey(name: 'supportersCount')
  int? get supportersCount;
  @JsonKey(name: 'supportersUsers')
  List<dynamic>? get supportersUsers;
  @JsonKey(name: 'followersCount')
  int? get followersCount;
  @JsonKey(name: 'followingsCount')
  int? get followingsCount;

  /// Create a copy of ProfileDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<ProfileDto> get copyWith =>
      _$ProfileDtoCopyWithImpl<ProfileDto>(this as ProfileDto, _$identity);

  /// Serializes this ProfileDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ProfileDto &&
            (identical(other.userDetail, userDetail) ||
                other.userDetail == userDetail) &&
            (identical(other.badgesCount, badgesCount) ||
                other.badgesCount == badgesCount) &&
            const DeepCollectionEquality()
                .equals(other.badgesUsers, badgesUsers) &&
            (identical(other.supportersCount, supportersCount) ||
                other.supportersCount == supportersCount) &&
            const DeepCollectionEquality()
                .equals(other.supportersUsers, supportersUsers) &&
            (identical(other.followersCount, followersCount) ||
                other.followersCount == followersCount) &&
            (identical(other.followingsCount, followingsCount) ||
                other.followingsCount == followingsCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      userDetail,
      badgesCount,
      const DeepCollectionEquality().hash(badgesUsers),
      supportersCount,
      const DeepCollectionEquality().hash(supportersUsers),
      followersCount,
      followingsCount);

  @override
  String toString() {
    return 'ProfileDto(userDetail: $userDetail, badgesCount: $badgesCount, badgesUsers: $badgesUsers, supportersCount: $supportersCount, supportersUsers: $supportersUsers, followersCount: $followersCount, followingsCount: $followingsCount)';
  }
}

/// @nodoc
abstract mixin class $ProfileDtoCopyWith<$Res> {
  factory $ProfileDtoCopyWith(
          ProfileDto value, $Res Function(ProfileDto) _then) =
      _$ProfileDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'userDetail') UserDetailDto userDetail,
      @JsonKey(name: 'badgesCount') int? badgesCount,
      @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
      @JsonKey(name: 'supportersCount') int? supportersCount,
      @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
      @JsonKey(name: 'followersCount') int? followersCount,
      @JsonKey(name: 'followingsCount') int? followingsCount});

  $UserDetailDtoCopyWith<$Res> get userDetail;
}

/// @nodoc
class _$ProfileDtoCopyWithImpl<$Res> implements $ProfileDtoCopyWith<$Res> {
  _$ProfileDtoCopyWithImpl(this._self, this._then);

  final ProfileDto _self;
  final $Res Function(ProfileDto) _then;

  /// Create a copy of ProfileDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userDetail = null,
    Object? badgesCount = freezed,
    Object? badgesUsers = freezed,
    Object? supportersCount = freezed,
    Object? supportersUsers = freezed,
    Object? followersCount = freezed,
    Object? followingsCount = freezed,
  }) {
    return _then(_self.copyWith(
      userDetail: null == userDetail
          ? _self.userDetail
          : userDetail // ignore: cast_nullable_to_non_nullable
              as UserDetailDto,
      badgesCount: freezed == badgesCount
          ? _self.badgesCount
          : badgesCount // ignore: cast_nullable_to_non_nullable
              as int?,
      badgesUsers: freezed == badgesUsers
          ? _self.badgesUsers
          : badgesUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      supportersCount: freezed == supportersCount
          ? _self.supportersCount
          : supportersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      supportersUsers: freezed == supportersUsers
          ? _self.supportersUsers
          : supportersUsers // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      followersCount: freezed == followersCount
          ? _self.followersCount
          : followersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      followingsCount: freezed == followingsCount
          ? _self.followingsCount
          : followingsCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ProfileDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDtoCopyWith<$Res> get userDetail {
    return $UserDetailDtoCopyWith<$Res>(_self.userDetail, (value) {
      return _then(_self.copyWith(userDetail: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ProfileDto].
extension ProfileDtoPatterns on ProfileDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ProfileDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ProfileDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ProfileDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ProfileDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ProfileDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ProfileDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'userDetail') UserDetailDto userDetail,
            @JsonKey(name: 'badgesCount') int? badgesCount,
            @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
            @JsonKey(name: 'supportersCount') int? supportersCount,
            @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
            @JsonKey(name: 'followersCount') int? followersCount,
            @JsonKey(name: 'followingsCount') int? followingsCount)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ProfileDto() when $default != null:
        return $default(
            _that.userDetail,
            _that.badgesCount,
            _that.badgesUsers,
            _that.supportersCount,
            _that.supportersUsers,
            _that.followersCount,
            _that.followingsCount);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'userDetail') UserDetailDto userDetail,
            @JsonKey(name: 'badgesCount') int? badgesCount,
            @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
            @JsonKey(name: 'supportersCount') int? supportersCount,
            @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
            @JsonKey(name: 'followersCount') int? followersCount,
            @JsonKey(name: 'followingsCount') int? followingsCount)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ProfileDto():
        return $default(
            _that.userDetail,
            _that.badgesCount,
            _that.badgesUsers,
            _that.supportersCount,
            _that.supportersUsers,
            _that.followersCount,
            _that.followingsCount);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'userDetail') UserDetailDto userDetail,
            @JsonKey(name: 'badgesCount') int? badgesCount,
            @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
            @JsonKey(name: 'supportersCount') int? supportersCount,
            @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
            @JsonKey(name: 'followersCount') int? followersCount,
            @JsonKey(name: 'followingsCount') int? followingsCount)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ProfileDto() when $default != null:
        return $default(
            _that.userDetail,
            _that.badgesCount,
            _that.badgesUsers,
            _that.supportersCount,
            _that.supportersUsers,
            _that.followersCount,
            _that.followingsCount);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ProfileDto implements ProfileDto {
  _ProfileDto(
      {@JsonKey(name: 'userDetail') required this.userDetail,
      @JsonKey(name: 'badgesCount') this.badgesCount,
      @JsonKey(name: 'badgesUsers') final List<UserDto>? badgesUsers,
      @JsonKey(name: 'supportersCount') this.supportersCount,
      @JsonKey(name: 'supportersUsers') final List<dynamic>? supportersUsers,
      @JsonKey(name: 'followersCount') this.followersCount,
      @JsonKey(name: 'followingsCount') this.followingsCount})
      : _badgesUsers = badgesUsers,
        _supportersUsers = supportersUsers;
  factory _ProfileDto.fromJson(Map<String, dynamic> json) =>
      _$ProfileDtoFromJson(json);

  @override
  @JsonKey(name: 'userDetail')
  final UserDetailDto userDetail;
  @override
  @JsonKey(name: 'badgesCount')
  final int? badgesCount;
  final List<UserDto>? _badgesUsers;
  @override
  @JsonKey(name: 'badgesUsers')
  List<UserDto>? get badgesUsers {
    final value = _badgesUsers;
    if (value == null) return null;
    if (_badgesUsers is EqualUnmodifiableListView) return _badgesUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'supportersCount')
  final int? supportersCount;
  final List<dynamic>? _supportersUsers;
  @override
  @JsonKey(name: 'supportersUsers')
  List<dynamic>? get supportersUsers {
    final value = _supportersUsers;
    if (value == null) return null;
    if (_supportersUsers is EqualUnmodifiableListView) return _supportersUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'followersCount')
  final int? followersCount;
  @override
  @JsonKey(name: 'followingsCount')
  final int? followingsCount;

  /// Create a copy of ProfileDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ProfileDtoCopyWith<_ProfileDto> get copyWith =>
      __$ProfileDtoCopyWithImpl<_ProfileDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ProfileDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ProfileDto &&
            (identical(other.userDetail, userDetail) ||
                other.userDetail == userDetail) &&
            (identical(other.badgesCount, badgesCount) ||
                other.badgesCount == badgesCount) &&
            const DeepCollectionEquality()
                .equals(other._badgesUsers, _badgesUsers) &&
            (identical(other.supportersCount, supportersCount) ||
                other.supportersCount == supportersCount) &&
            const DeepCollectionEquality()
                .equals(other._supportersUsers, _supportersUsers) &&
            (identical(other.followersCount, followersCount) ||
                other.followersCount == followersCount) &&
            (identical(other.followingsCount, followingsCount) ||
                other.followingsCount == followingsCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      userDetail,
      badgesCount,
      const DeepCollectionEquality().hash(_badgesUsers),
      supportersCount,
      const DeepCollectionEquality().hash(_supportersUsers),
      followersCount,
      followingsCount);

  @override
  String toString() {
    return 'ProfileDto(userDetail: $userDetail, badgesCount: $badgesCount, badgesUsers: $badgesUsers, supportersCount: $supportersCount, supportersUsers: $supportersUsers, followersCount: $followersCount, followingsCount: $followingsCount)';
  }
}

/// @nodoc
abstract mixin class _$ProfileDtoCopyWith<$Res>
    implements $ProfileDtoCopyWith<$Res> {
  factory _$ProfileDtoCopyWith(
          _ProfileDto value, $Res Function(_ProfileDto) _then) =
      __$ProfileDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'userDetail') UserDetailDto userDetail,
      @JsonKey(name: 'badgesCount') int? badgesCount,
      @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
      @JsonKey(name: 'supportersCount') int? supportersCount,
      @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
      @JsonKey(name: 'followersCount') int? followersCount,
      @JsonKey(name: 'followingsCount') int? followingsCount});

  @override
  $UserDetailDtoCopyWith<$Res> get userDetail;
}

/// @nodoc
class __$ProfileDtoCopyWithImpl<$Res> implements _$ProfileDtoCopyWith<$Res> {
  __$ProfileDtoCopyWithImpl(this._self, this._then);

  final _ProfileDto _self;
  final $Res Function(_ProfileDto) _then;

  /// Create a copy of ProfileDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? userDetail = null,
    Object? badgesCount = freezed,
    Object? badgesUsers = freezed,
    Object? supportersCount = freezed,
    Object? supportersUsers = freezed,
    Object? followersCount = freezed,
    Object? followingsCount = freezed,
  }) {
    return _then(_ProfileDto(
      userDetail: null == userDetail
          ? _self.userDetail
          : userDetail // ignore: cast_nullable_to_non_nullable
              as UserDetailDto,
      badgesCount: freezed == badgesCount
          ? _self.badgesCount
          : badgesCount // ignore: cast_nullable_to_non_nullable
              as int?,
      badgesUsers: freezed == badgesUsers
          ? _self._badgesUsers
          : badgesUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      supportersCount: freezed == supportersCount
          ? _self.supportersCount
          : supportersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      supportersUsers: freezed == supportersUsers
          ? _self._supportersUsers
          : supportersUsers // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      followersCount: freezed == followersCount
          ? _self.followersCount
          : followersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      followingsCount: freezed == followingsCount
          ? _self.followingsCount
          : followingsCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ProfileDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDtoCopyWith<$Res> get userDetail {
    return $UserDetailDtoCopyWith<$Res>(_self.userDetail, (value) {
      return _then(_self.copyWith(userDetail: value));
    });
  }
}

/// @nodoc
mixin _$ReplyDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'deletedDate')
  DateTime? get deletedDate;
  @JsonKey(name: 'user')
  UserDto? get user;
  @JsonKey(name: 'parentCommentId')
  String? get parentCommentId;
  @JsonKey(name: 'responseToUser')
  UserDto2Dto? get responseToUser;
  @JsonKey(name: 'responseToCommentId')
  String? get responseToCommentId;
  @JsonKey(name: 'heartCount')
  int? get heartCount;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ReplyDtoCopyWith<ReplyDto> get copyWith =>
      _$ReplyDtoCopyWithImpl<ReplyDto>(this as ReplyDto, _$identity);

  /// Serializes this ReplyDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ReplyDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.deletedDate, deletedDate) ||
                other.deletedDate == deletedDate) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.parentCommentId, parentCommentId) ||
                other.parentCommentId == parentCommentId) &&
            (identical(other.responseToUser, responseToUser) ||
                other.responseToUser == responseToUser) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdDate,
      lastUpdated,
      deletedDate,
      user,
      parentCommentId,
      responseToUser,
      responseToCommentId,
      heartCount,
      heartedByUser);

  @override
  String toString() {
    return 'ReplyDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, deletedDate: $deletedDate, user: $user, parentCommentId: $parentCommentId, responseToUser: $responseToUser, responseToCommentId: $responseToCommentId, heartCount: $heartCount, heartedByUser: $heartedByUser)';
  }
}

/// @nodoc
abstract mixin class $ReplyDtoCopyWith<$Res> {
  factory $ReplyDtoCopyWith(ReplyDto value, $Res Function(ReplyDto) _then) =
      _$ReplyDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'deletedDate') DateTime? deletedDate,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'parentCommentId') String? parentCommentId,
      @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser});

  $UserDtoCopyWith<$Res>? get user;
  $UserDto2DtoCopyWith<$Res>? get responseToUser;
}

/// @nodoc
class _$ReplyDtoCopyWithImpl<$Res> implements $ReplyDtoCopyWith<$Res> {
  _$ReplyDtoCopyWithImpl(this._self, this._then);

  final ReplyDto _self;
  final $Res Function(ReplyDto) _then;

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? deletedDate = freezed,
    Object? user = freezed,
    Object? parentCommentId = freezed,
    Object? responseToUser = freezed,
    Object? responseToCommentId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedDate: freezed == deletedDate
          ? _self.deletedDate
          : deletedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      parentCommentId: freezed == parentCommentId
          ? _self.parentCommentId
          : parentCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToUser: freezed == responseToUser
          ? _self.responseToUser
          : responseToUser // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get responseToUser {
    if (_self.responseToUser == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.responseToUser!, (value) {
      return _then(_self.copyWith(responseToUser: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ReplyDto].
extension ReplyDtoPatterns on ReplyDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ReplyDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ReplyDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ReplyDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReplyDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ReplyDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReplyDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'deletedDate') DateTime? deletedDate,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'parentCommentId') String? parentCommentId,
            @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ReplyDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.deletedDate,
            _that.user,
            _that.parentCommentId,
            _that.responseToUser,
            _that.responseToCommentId,
            _that.heartCount,
            _that.heartedByUser);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'deletedDate') DateTime? deletedDate,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'parentCommentId') String? parentCommentId,
            @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReplyDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.deletedDate,
            _that.user,
            _that.parentCommentId,
            _that.responseToUser,
            _that.responseToCommentId,
            _that.heartCount,
            _that.heartedByUser);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'deletedDate') DateTime? deletedDate,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'parentCommentId') String? parentCommentId,
            @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReplyDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.deletedDate,
            _that.user,
            _that.parentCommentId,
            _that.responseToUser,
            _that.responseToCommentId,
            _that.heartCount,
            _that.heartedByUser);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ReplyDto implements ReplyDto {
  _ReplyDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'deletedDate') this.deletedDate,
      @JsonKey(name: 'user') this.user,
      @JsonKey(name: 'parentCommentId') this.parentCommentId,
      @JsonKey(name: 'responseToUser') this.responseToUser,
      @JsonKey(name: 'responseToCommentId') this.responseToCommentId,
      @JsonKey(name: 'heartCount') this.heartCount,
      @JsonKey(name: 'heartedByUser') this.heartedByUser});
  factory _ReplyDto.fromJson(Map<String, dynamic> json) =>
      _$ReplyDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'deletedDate')
  final DateTime? deletedDate;
  @override
  @JsonKey(name: 'user')
  final UserDto? user;
  @override
  @JsonKey(name: 'parentCommentId')
  final String? parentCommentId;
  @override
  @JsonKey(name: 'responseToUser')
  final UserDto2Dto? responseToUser;
  @override
  @JsonKey(name: 'responseToCommentId')
  final String? responseToCommentId;
  @override
  @JsonKey(name: 'heartCount')
  final int? heartCount;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ReplyDtoCopyWith<_ReplyDto> get copyWith =>
      __$ReplyDtoCopyWithImpl<_ReplyDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ReplyDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ReplyDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.deletedDate, deletedDate) ||
                other.deletedDate == deletedDate) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.parentCommentId, parentCommentId) ||
                other.parentCommentId == parentCommentId) &&
            (identical(other.responseToUser, responseToUser) ||
                other.responseToUser == responseToUser) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdDate,
      lastUpdated,
      deletedDate,
      user,
      parentCommentId,
      responseToUser,
      responseToCommentId,
      heartCount,
      heartedByUser);

  @override
  String toString() {
    return 'ReplyDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, deletedDate: $deletedDate, user: $user, parentCommentId: $parentCommentId, responseToUser: $responseToUser, responseToCommentId: $responseToCommentId, heartCount: $heartCount, heartedByUser: $heartedByUser)';
  }
}

/// @nodoc
abstract mixin class _$ReplyDtoCopyWith<$Res>
    implements $ReplyDtoCopyWith<$Res> {
  factory _$ReplyDtoCopyWith(_ReplyDto value, $Res Function(_ReplyDto) _then) =
      __$ReplyDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'deletedDate') DateTime? deletedDate,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'parentCommentId') String? parentCommentId,
      @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser});

  @override
  $UserDtoCopyWith<$Res>? get user;
  @override
  $UserDto2DtoCopyWith<$Res>? get responseToUser;
}

/// @nodoc
class __$ReplyDtoCopyWithImpl<$Res> implements _$ReplyDtoCopyWith<$Res> {
  __$ReplyDtoCopyWithImpl(this._self, this._then);

  final _ReplyDto _self;
  final $Res Function(_ReplyDto) _then;

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? deletedDate = freezed,
    Object? user = freezed,
    Object? parentCommentId = freezed,
    Object? responseToUser = freezed,
    Object? responseToCommentId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
  }) {
    return _then(_ReplyDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedDate: freezed == deletedDate
          ? _self.deletedDate
          : deletedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      parentCommentId: freezed == parentCommentId
          ? _self.parentCommentId
          : parentCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToUser: freezed == responseToUser
          ? _self.responseToUser
          : responseToUser // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ReplyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get responseToUser {
    if (_self.responseToUser == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.responseToUser!, (value) {
      return _then(_self.copyWith(responseToUser: value));
    });
  }
}

/// @nodoc
mixin _$ReportCreatingDto {
  @JsonKey(name: 'entityType')
  String get entityType;
  @JsonKey(name: 'entityId')
  String get entityId;
  @JsonKey(name: 'reason')
  String get reason;

  /// Create a copy of ReportCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ReportCreatingDtoCopyWith<ReportCreatingDto> get copyWith =>
      _$ReportCreatingDtoCopyWithImpl<ReportCreatingDto>(
          this as ReportCreatingDto, _$identity);

  /// Serializes this ReportCreatingDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ReportCreatingDto &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, entityType, entityId, reason);

  @override
  String toString() {
    return 'ReportCreatingDto(entityType: $entityType, entityId: $entityId, reason: $reason)';
  }
}

/// @nodoc
abstract mixin class $ReportCreatingDtoCopyWith<$Res> {
  factory $ReportCreatingDtoCopyWith(
          ReportCreatingDto value, $Res Function(ReportCreatingDto) _then) =
      _$ReportCreatingDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String entityId,
      @JsonKey(name: 'reason') String reason});
}

/// @nodoc
class _$ReportCreatingDtoCopyWithImpl<$Res>
    implements $ReportCreatingDtoCopyWith<$Res> {
  _$ReportCreatingDtoCopyWithImpl(this._self, this._then);

  final ReportCreatingDto _self;
  final $Res Function(ReportCreatingDto) _then;

  /// Create a copy of ReportCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? entityType = null,
    Object? entityId = null,
    Object? reason = null,
  }) {
    return _then(_self.copyWith(
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ReportCreatingDto].
extension ReportCreatingDtoPatterns on ReportCreatingDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ReportCreatingDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ReportCreatingDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ReportCreatingDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportCreatingDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ReportCreatingDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportCreatingDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String entityId,
            @JsonKey(name: 'reason') String reason)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ReportCreatingDto() when $default != null:
        return $default(_that.entityType, _that.entityId, _that.reason);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String entityId,
            @JsonKey(name: 'reason') String reason)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportCreatingDto():
        return $default(_that.entityType, _that.entityId, _that.reason);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String entityId,
            @JsonKey(name: 'reason') String reason)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportCreatingDto() when $default != null:
        return $default(_that.entityType, _that.entityId, _that.reason);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ReportCreatingDto implements ReportCreatingDto {
  _ReportCreatingDto(
      {@JsonKey(name: 'entityType') required this.entityType,
      @JsonKey(name: 'entityId') required this.entityId,
      @JsonKey(name: 'reason') required this.reason});
  factory _ReportCreatingDto.fromJson(Map<String, dynamic> json) =>
      _$ReportCreatingDtoFromJson(json);

  @override
  @JsonKey(name: 'entityType')
  final String entityType;
  @override
  @JsonKey(name: 'entityId')
  final String entityId;
  @override
  @JsonKey(name: 'reason')
  final String reason;

  /// Create a copy of ReportCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ReportCreatingDtoCopyWith<_ReportCreatingDto> get copyWith =>
      __$ReportCreatingDtoCopyWithImpl<_ReportCreatingDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ReportCreatingDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ReportCreatingDto &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, entityType, entityId, reason);

  @override
  String toString() {
    return 'ReportCreatingDto(entityType: $entityType, entityId: $entityId, reason: $reason)';
  }
}

/// @nodoc
abstract mixin class _$ReportCreatingDtoCopyWith<$Res>
    implements $ReportCreatingDtoCopyWith<$Res> {
  factory _$ReportCreatingDtoCopyWith(
          _ReportCreatingDto value, $Res Function(_ReportCreatingDto) _then) =
      __$ReportCreatingDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String entityId,
      @JsonKey(name: 'reason') String reason});
}

/// @nodoc
class __$ReportCreatingDtoCopyWithImpl<$Res>
    implements _$ReportCreatingDtoCopyWith<$Res> {
  __$ReportCreatingDtoCopyWithImpl(this._self, this._then);

  final _ReportCreatingDto _self;
  final $Res Function(_ReportCreatingDto) _then;

  /// Create a copy of ReportCreatingDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? entityType = null,
    Object? entityId = null,
    Object? reason = null,
  }) {
    return _then(_ReportCreatingDto(
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ReportDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'entityType')
  String get entityType;
  @JsonKey(name: 'entityId')
  String? get entityId;
  @JsonKey(name: 'reporter')
  UserDto2Dto? get reporter;
  @JsonKey(name: 'reason')
  String get reason;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;

  /// Create a copy of ReportDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ReportDtoCopyWith<ReportDto> get copyWith =>
      _$ReportDtoCopyWithImpl<ReportDto>(this as ReportDto, _$identity);

  /// Serializes this ReportDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ReportDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reporter, reporter) ||
                other.reporter == reporter) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, entityType, entityId, reporter, reason, createdDate);

  @override
  String toString() {
    return 'ReportDto(id: $id, entityType: $entityType, entityId: $entityId, reporter: $reporter, reason: $reason, createdDate: $createdDate)';
  }
}

/// @nodoc
abstract mixin class $ReportDtoCopyWith<$Res> {
  factory $ReportDtoCopyWith(ReportDto value, $Res Function(ReportDto) _then) =
      _$ReportDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String? entityId,
      @JsonKey(name: 'reporter') UserDto2Dto? reporter,
      @JsonKey(name: 'reason') String reason,
      @JsonKey(name: 'createdDate') DateTime? createdDate});

  $UserDto2DtoCopyWith<$Res>? get reporter;
}

/// @nodoc
class _$ReportDtoCopyWithImpl<$Res> implements $ReportDtoCopyWith<$Res> {
  _$ReportDtoCopyWithImpl(this._self, this._then);

  final ReportDto _self;
  final $Res Function(ReportDto) _then;

  /// Create a copy of ReportDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? entityType = null,
    Object? entityId = freezed,
    Object? reporter = freezed,
    Object? reason = null,
    Object? createdDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: freezed == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String?,
      reporter: freezed == reporter
          ? _self.reporter
          : reporter // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ReportDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get reporter {
    if (_self.reporter == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.reporter!, (value) {
      return _then(_self.copyWith(reporter: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ReportDto].
extension ReportDtoPatterns on ReportDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ReportDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ReportDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ReportDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ReportDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String? entityId,
            @JsonKey(name: 'reporter') UserDto2Dto? reporter,
            @JsonKey(name: 'reason') String reason,
            @JsonKey(name: 'createdDate') DateTime? createdDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ReportDto() when $default != null:
        return $default(_that.id, _that.entityType, _that.entityId,
            _that.reporter, _that.reason, _that.createdDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String? entityId,
            @JsonKey(name: 'reporter') UserDto2Dto? reporter,
            @JsonKey(name: 'reason') String reason,
            @JsonKey(name: 'createdDate') DateTime? createdDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportDto():
        return $default(_that.id, _that.entityType, _that.entityId,
            _that.reporter, _that.reason, _that.createdDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String? entityId,
            @JsonKey(name: 'reporter') UserDto2Dto? reporter,
            @JsonKey(name: 'reason') String reason,
            @JsonKey(name: 'createdDate') DateTime? createdDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ReportDto() when $default != null:
        return $default(_that.id, _that.entityType, _that.entityId,
            _that.reporter, _that.reason, _that.createdDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ReportDto implements ReportDto {
  _ReportDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'entityType') required this.entityType,
      @JsonKey(name: 'entityId') this.entityId,
      @JsonKey(name: 'reporter') this.reporter,
      @JsonKey(name: 'reason') required this.reason,
      @JsonKey(name: 'createdDate') this.createdDate});
  factory _ReportDto.fromJson(Map<String, dynamic> json) =>
      _$ReportDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'entityType')
  final String entityType;
  @override
  @JsonKey(name: 'entityId')
  final String? entityId;
  @override
  @JsonKey(name: 'reporter')
  final UserDto2Dto? reporter;
  @override
  @JsonKey(name: 'reason')
  final String reason;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;

  /// Create a copy of ReportDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ReportDtoCopyWith<_ReportDto> get copyWith =>
      __$ReportDtoCopyWithImpl<_ReportDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ReportDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ReportDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reporter, reporter) ||
                other.reporter == reporter) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, entityType, entityId, reporter, reason, createdDate);

  @override
  String toString() {
    return 'ReportDto(id: $id, entityType: $entityType, entityId: $entityId, reporter: $reporter, reason: $reason, createdDate: $createdDate)';
  }
}

/// @nodoc
abstract mixin class _$ReportDtoCopyWith<$Res>
    implements $ReportDtoCopyWith<$Res> {
  factory _$ReportDtoCopyWith(
          _ReportDto value, $Res Function(_ReportDto) _then) =
      __$ReportDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String? entityId,
      @JsonKey(name: 'reporter') UserDto2Dto? reporter,
      @JsonKey(name: 'reason') String reason,
      @JsonKey(name: 'createdDate') DateTime? createdDate});

  @override
  $UserDto2DtoCopyWith<$Res>? get reporter;
}

/// @nodoc
class __$ReportDtoCopyWithImpl<$Res> implements _$ReportDtoCopyWith<$Res> {
  __$ReportDtoCopyWithImpl(this._self, this._then);

  final _ReportDto _self;
  final $Res Function(_ReportDto) _then;

  /// Create a copy of ReportDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? entityType = null,
    Object? entityId = freezed,
    Object? reporter = freezed,
    Object? reason = null,
    Object? createdDate = freezed,
  }) {
    return _then(_ReportDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: freezed == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String?,
      reporter: freezed == reporter
          ? _self.reporter
          : reporter // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ReportDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get reporter {
    if (_self.reporter == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.reporter!, (value) {
      return _then(_self.copyWith(reporter: value));
    });
  }
}

/// @nodoc
mixin _$SendNotificationDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'body')
  String get body;
  @JsonKey(name: 'notificationType')
  NotificationTypeDto get notificationType;
  @JsonKey(name: 'targetUserId')
  String? get targetUserId;
  @JsonKey(name: 'relatedEntityId')
  String? get relatedEntityId;
  @JsonKey(name: 'scheduledFor')
  DateTime? get scheduledFor;
  @JsonKey(name: 'data')
  Map<String, String>? get data;
  @JsonKey(name: 'priority')
  int? get priority;

  /// Create a copy of SendNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SendNotificationDtoCopyWith<SendNotificationDto> get copyWith =>
      _$SendNotificationDtoCopyWithImpl<SendNotificationDto>(
          this as SendNotificationDto, _$identity);

  /// Serializes this SendNotificationDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SendNotificationDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.targetUserId, targetUserId) ||
                other.targetUserId == targetUserId) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.scheduledFor, scheduledFor) ||
                other.scheduledFor == scheduledFor) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      targetUserId,
      relatedEntityId,
      scheduledFor,
      const DeepCollectionEquality().hash(data),
      priority);

  @override
  String toString() {
    return 'SendNotificationDto(title: $title, body: $body, notificationType: $notificationType, targetUserId: $targetUserId, relatedEntityId: $relatedEntityId, scheduledFor: $scheduledFor, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class $SendNotificationDtoCopyWith<$Res> {
  factory $SendNotificationDtoCopyWith(
          SendNotificationDto value, $Res Function(SendNotificationDto) _then) =
      _$SendNotificationDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'targetUserId') String? targetUserId,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class _$SendNotificationDtoCopyWithImpl<$Res>
    implements $SendNotificationDtoCopyWith<$Res> {
  _$SendNotificationDtoCopyWithImpl(this._self, this._then);

  final SendNotificationDto _self;
  final $Res Function(SendNotificationDto) _then;

  /// Create a copy of SendNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? targetUserId = freezed,
    Object? relatedEntityId = freezed,
    Object? scheduledFor = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      targetUserId: freezed == targetUserId
          ? _self.targetUserId
          : targetUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      scheduledFor: freezed == scheduledFor
          ? _self.scheduledFor
          : scheduledFor // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [SendNotificationDto].
extension SendNotificationDtoPatterns on SendNotificationDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SendNotificationDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _SendNotificationDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SendNotificationDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SendNotificationDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_SendNotificationDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SendNotificationDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'targetUserId') String? targetUserId,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _SendNotificationDto() when $default != null:
        return $default(
            _that.title,
            _that.body,
            _that.notificationType,
            _that.targetUserId,
            _that.relatedEntityId,
            _that.scheduledFor,
            _that.data,
            _that.priority);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'targetUserId') String? targetUserId,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SendNotificationDto():
        return $default(
            _that.title,
            _that.body,
            _that.notificationType,
            _that.targetUserId,
            _that.relatedEntityId,
            _that.scheduledFor,
            _that.data,
            _that.priority);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'targetUserId') String? targetUserId,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SendNotificationDto() when $default != null:
        return $default(
            _that.title,
            _that.body,
            _that.notificationType,
            _that.targetUserId,
            _that.relatedEntityId,
            _that.scheduledFor,
            _that.data,
            _that.priority);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _SendNotificationDto implements SendNotificationDto {
  _SendNotificationDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'body') required this.body,
      @JsonKey(name: 'notificationType') required this.notificationType,
      @JsonKey(name: 'targetUserId') this.targetUserId,
      @JsonKey(name: 'relatedEntityId') this.relatedEntityId,
      @JsonKey(name: 'scheduledFor') this.scheduledFor,
      @JsonKey(name: 'data') final Map<String, String>? data,
      @JsonKey(name: 'priority') this.priority})
      : _data = data;
  factory _SendNotificationDto.fromJson(Map<String, dynamic> json) =>
      _$SendNotificationDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'body')
  final String body;
  @override
  @JsonKey(name: 'notificationType')
  final NotificationTypeDto notificationType;
  @override
  @JsonKey(name: 'targetUserId')
  final String? targetUserId;
  @override
  @JsonKey(name: 'relatedEntityId')
  final String? relatedEntityId;
  @override
  @JsonKey(name: 'scheduledFor')
  final DateTime? scheduledFor;
  final Map<String, String>? _data;
  @override
  @JsonKey(name: 'data')
  Map<String, String>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey(name: 'priority')
  final int? priority;

  /// Create a copy of SendNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SendNotificationDtoCopyWith<_SendNotificationDto> get copyWith =>
      __$SendNotificationDtoCopyWithImpl<_SendNotificationDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$SendNotificationDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SendNotificationDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.targetUserId, targetUserId) ||
                other.targetUserId == targetUserId) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.scheduledFor, scheduledFor) ||
                other.scheduledFor == scheduledFor) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      targetUserId,
      relatedEntityId,
      scheduledFor,
      const DeepCollectionEquality().hash(_data),
      priority);

  @override
  String toString() {
    return 'SendNotificationDto(title: $title, body: $body, notificationType: $notificationType, targetUserId: $targetUserId, relatedEntityId: $relatedEntityId, scheduledFor: $scheduledFor, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class _$SendNotificationDtoCopyWith<$Res>
    implements $SendNotificationDtoCopyWith<$Res> {
  factory _$SendNotificationDtoCopyWith(_SendNotificationDto value,
          $Res Function(_SendNotificationDto) _then) =
      __$SendNotificationDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'targetUserId') String? targetUserId,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class __$SendNotificationDtoCopyWithImpl<$Res>
    implements _$SendNotificationDtoCopyWith<$Res> {
  __$SendNotificationDtoCopyWithImpl(this._self, this._then);

  final _SendNotificationDto _self;
  final $Res Function(_SendNotificationDto) _then;

  /// Create a copy of SendNotificationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? targetUserId = freezed,
    Object? relatedEntityId = freezed,
    Object? scheduledFor = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_SendNotificationDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      targetUserId: freezed == targetUserId
          ? _self.targetUserId
          : targetUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      scheduledFor: freezed == scheduledFor
          ? _self.scheduledFor
          : scheduledFor // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$StepCommentDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdAt')
  DateTime? get createdAt;
  @JsonKey(name: 'updatedAt')
  DateTime? get updatedAt;
  @JsonKey(name: 'deletedAt')
  DateTime? get deletedAt;
  @JsonKey(name: 'user')
  UserDto? get user;
  @JsonKey(name: 'stepId')
  String? get stepId;
  @JsonKey(name: 'heartCount')
  int? get heartCount;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;
  @JsonKey(name: 'replyCount')
  int? get replyCount;

  /// Create a copy of StepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StepCommentDtoCopyWith<StepCommentDto> get copyWith =>
      _$StepCommentDtoCopyWithImpl<StepCommentDto>(
          this as StepCommentDto, _$identity);

  /// Serializes this StepCommentDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StepCommentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.deletedAt, deletedAt) ||
                other.deletedAt == deletedAt) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.replyCount, replyCount) ||
                other.replyCount == replyCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdAt,
      updatedAt,
      deletedAt,
      user,
      stepId,
      heartCount,
      heartedByUser,
      replyCount);

  @override
  String toString() {
    return 'StepCommentDto(id: $id, content: $content, createdAt: $createdAt, updatedAt: $updatedAt, deletedAt: $deletedAt, user: $user, stepId: $stepId, heartCount: $heartCount, heartedByUser: $heartedByUser, replyCount: $replyCount)';
  }
}

/// @nodoc
abstract mixin class $StepCommentDtoCopyWith<$Res> {
  factory $StepCommentDtoCopyWith(
          StepCommentDto value, $Res Function(StepCommentDto) _then) =
      _$StepCommentDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdAt') DateTime? createdAt,
      @JsonKey(name: 'updatedAt') DateTime? updatedAt,
      @JsonKey(name: 'deletedAt') DateTime? deletedAt,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'replyCount') int? replyCount});

  $UserDtoCopyWith<$Res>? get user;
}

/// @nodoc
class _$StepCommentDtoCopyWithImpl<$Res>
    implements $StepCommentDtoCopyWith<$Res> {
  _$StepCommentDtoCopyWithImpl(this._self, this._then);

  final StepCommentDto _self;
  final $Res Function(StepCommentDto) _then;

  /// Create a copy of StepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? deletedAt = freezed,
    Object? user = freezed,
    Object? stepId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
    Object? replyCount = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _self.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedAt: freezed == deletedAt
          ? _self.deletedAt
          : deletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      replyCount: freezed == replyCount
          ? _self.replyCount
          : replyCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of StepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StepCommentDto].
extension StepCommentDtoPatterns on StepCommentDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StepCommentDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepCommentDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StepCommentDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepCommentDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StepCommentDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepCommentDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdAt') DateTime? createdAt,
            @JsonKey(name: 'updatedAt') DateTime? updatedAt,
            @JsonKey(name: 'deletedAt') DateTime? deletedAt,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'replyCount') int? replyCount)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepCommentDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdAt,
            _that.updatedAt,
            _that.deletedAt,
            _that.user,
            _that.stepId,
            _that.heartCount,
            _that.heartedByUser,
            _that.replyCount);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdAt') DateTime? createdAt,
            @JsonKey(name: 'updatedAt') DateTime? updatedAt,
            @JsonKey(name: 'deletedAt') DateTime? deletedAt,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'replyCount') int? replyCount)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepCommentDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdAt,
            _that.updatedAt,
            _that.deletedAt,
            _that.user,
            _that.stepId,
            _that.heartCount,
            _that.heartedByUser,
            _that.replyCount);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdAt') DateTime? createdAt,
            @JsonKey(name: 'updatedAt') DateTime? updatedAt,
            @JsonKey(name: 'deletedAt') DateTime? deletedAt,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'replyCount') int? replyCount)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepCommentDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdAt,
            _that.updatedAt,
            _that.deletedAt,
            _that.user,
            _that.stepId,
            _that.heartCount,
            _that.heartedByUser,
            _that.replyCount);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StepCommentDto implements StepCommentDto {
  _StepCommentDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdAt') this.createdAt,
      @JsonKey(name: 'updatedAt') this.updatedAt,
      @JsonKey(name: 'deletedAt') this.deletedAt,
      @JsonKey(name: 'user') this.user,
      @JsonKey(name: 'stepId') this.stepId,
      @JsonKey(name: 'heartCount') this.heartCount,
      @JsonKey(name: 'heartedByUser') this.heartedByUser,
      @JsonKey(name: 'replyCount') this.replyCount});
  factory _StepCommentDto.fromJson(Map<String, dynamic> json) =>
      _$StepCommentDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @override
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @override
  @JsonKey(name: 'deletedAt')
  final DateTime? deletedAt;
  @override
  @JsonKey(name: 'user')
  final UserDto? user;
  @override
  @JsonKey(name: 'stepId')
  final String? stepId;
  @override
  @JsonKey(name: 'heartCount')
  final int? heartCount;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;
  @override
  @JsonKey(name: 'replyCount')
  final int? replyCount;

  /// Create a copy of StepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StepCommentDtoCopyWith<_StepCommentDto> get copyWith =>
      __$StepCommentDtoCopyWithImpl<_StepCommentDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StepCommentDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StepCommentDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.deletedAt, deletedAt) ||
                other.deletedAt == deletedAt) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.replyCount, replyCount) ||
                other.replyCount == replyCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdAt,
      updatedAt,
      deletedAt,
      user,
      stepId,
      heartCount,
      heartedByUser,
      replyCount);

  @override
  String toString() {
    return 'StepCommentDto(id: $id, content: $content, createdAt: $createdAt, updatedAt: $updatedAt, deletedAt: $deletedAt, user: $user, stepId: $stepId, heartCount: $heartCount, heartedByUser: $heartedByUser, replyCount: $replyCount)';
  }
}

/// @nodoc
abstract mixin class _$StepCommentDtoCopyWith<$Res>
    implements $StepCommentDtoCopyWith<$Res> {
  factory _$StepCommentDtoCopyWith(
          _StepCommentDto value, $Res Function(_StepCommentDto) _then) =
      __$StepCommentDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdAt') DateTime? createdAt,
      @JsonKey(name: 'updatedAt') DateTime? updatedAt,
      @JsonKey(name: 'deletedAt') DateTime? deletedAt,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'replyCount') int? replyCount});

  @override
  $UserDtoCopyWith<$Res>? get user;
}

/// @nodoc
class __$StepCommentDtoCopyWithImpl<$Res>
    implements _$StepCommentDtoCopyWith<$Res> {
  __$StepCommentDtoCopyWithImpl(this._self, this._then);

  final _StepCommentDto _self;
  final $Res Function(_StepCommentDto) _then;

  /// Create a copy of StepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? deletedAt = freezed,
    Object? user = freezed,
    Object? stepId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
    Object? replyCount = freezed,
  }) {
    return _then(_StepCommentDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _self.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedAt: freezed == deletedAt
          ? _self.deletedAt
          : deletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      replyCount: freezed == replyCount
          ? _self.replyCount
          : replyCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of StepCommentDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// @nodoc
mixin _$StepDetailDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'user')
  UserDto get user;
  @JsonKey(name: 'journeyId')
  String? get journeyId;
  @JsonKey(name: 'journey')
  JourneyDto? get journey;
  @JsonKey(name: 'hearts')
  int? get hearts;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;
  @JsonKey(name: 'shares')
  int? get shares;
  @JsonKey(name: 'sharedByUser')
  bool? get sharedByUser;
  @JsonKey(name: 'comments')
  int? get comments;
  @JsonKey(name: 'commentedByUser')
  bool? get commentedByUser;
  @JsonKey(name: 'userSteppedWithInteractions')
  int? get userSteppedWithInteractions;
  @JsonKey(name: 'othersStepWith')
  int? get othersStepWith;
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers;
  @JsonKey(name: 'stepTypeString')
  String? get stepTypeString;
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media;

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StepDetailDtoCopyWith<StepDetailDto> get copyWith =>
      _$StepDetailDtoCopyWithImpl<StepDetailDto>(
          this as StepDetailDto, _$identity);

  /// Serializes this StepDetailDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StepDetailDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other.othersStepWithUsers, othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other.media, media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(media)
      ]);

  @override
  String toString() {
    return 'StepDetailDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class $StepDetailDtoCopyWith<$Res> {
  factory $StepDetailDtoCopyWith(
          StepDetailDto value, $Res Function(StepDetailDto) _then) =
      _$StepDetailDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  $UserDtoCopyWith<$Res> get user;
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class _$StepDetailDtoCopyWithImpl<$Res>
    implements $StepDetailDtoCopyWith<$Res> {
  _$StepDetailDtoCopyWithImpl(this._self, this._then);

  final StepDetailDto _self;
  final $Res Function(StepDetailDto) _then;

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self.othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StepDetailDto].
extension StepDetailDtoPatterns on StepDetailDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StepDetailDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepDetailDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StepDetailDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDetailDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StepDetailDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDetailDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepDetailDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDetailDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDetailDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StepDetailDto implements StepDetailDto {
  _StepDetailDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'user') required this.user,
      @JsonKey(name: 'journeyId') this.journeyId,
      @JsonKey(name: 'journey') this.journey,
      @JsonKey(name: 'hearts') this.hearts,
      @JsonKey(name: 'heartedByUser') this.heartedByUser,
      @JsonKey(name: 'shares') this.shares,
      @JsonKey(name: 'sharedByUser') this.sharedByUser,
      @JsonKey(name: 'comments') this.comments,
      @JsonKey(name: 'commentedByUser') this.commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      this.userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') this.othersStepWith,
      @JsonKey(name: 'othersStepWithUsers')
      final List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') this.stepTypeString,
      @JsonKey(name: 'media') final List<StepMediaDto>? media})
      : _othersStepWithUsers = othersStepWithUsers,
        _media = media;
  factory _StepDetailDto.fromJson(Map<String, dynamic> json) =>
      _$StepDetailDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'user')
  final UserDto user;
  @override
  @JsonKey(name: 'journeyId')
  final String? journeyId;
  @override
  @JsonKey(name: 'journey')
  final JourneyDto? journey;
  @override
  @JsonKey(name: 'hearts')
  final int? hearts;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;
  @override
  @JsonKey(name: 'shares')
  final int? shares;
  @override
  @JsonKey(name: 'sharedByUser')
  final bool? sharedByUser;
  @override
  @JsonKey(name: 'comments')
  final int? comments;
  @override
  @JsonKey(name: 'commentedByUser')
  final bool? commentedByUser;
  @override
  @JsonKey(name: 'userSteppedWithInteractions')
  final int? userSteppedWithInteractions;
  @override
  @JsonKey(name: 'othersStepWith')
  final int? othersStepWith;
  final List<UserDto>? _othersStepWithUsers;
  @override
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers {
    final value = _othersStepWithUsers;
    if (value == null) return null;
    if (_othersStepWithUsers is EqualUnmodifiableListView)
      return _othersStepWithUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'stepTypeString')
  final String? stepTypeString;
  final List<StepMediaDto>? _media;
  @override
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media {
    final value = _media;
    if (value == null) return null;
    if (_media is EqualUnmodifiableListView) return _media;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StepDetailDtoCopyWith<_StepDetailDto> get copyWith =>
      __$StepDetailDtoCopyWithImpl<_StepDetailDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StepDetailDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StepDetailDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other._othersStepWithUsers, _othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other._media, _media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(_othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(_media)
      ]);

  @override
  String toString() {
    return 'StepDetailDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$StepDetailDtoCopyWith<$Res>
    implements $StepDetailDtoCopyWith<$Res> {
  factory _$StepDetailDtoCopyWith(
          _StepDetailDto value, $Res Function(_StepDetailDto) _then) =
      __$StepDetailDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  @override
  $UserDtoCopyWith<$Res> get user;
  @override
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class __$StepDetailDtoCopyWithImpl<$Res>
    implements _$StepDetailDtoCopyWith<$Res> {
  __$StepDetailDtoCopyWithImpl(this._self, this._then);

  final _StepDetailDto _self;
  final $Res Function(_StepDetailDto) _then;

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_StepDetailDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self._othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self._media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of StepDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// @nodoc
mixin _$StepDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'journeyId')
  String? get journeyId;
  @JsonKey(name: 'media')
  StepMediaDto2Dto? get media;

  /// Create a copy of StepDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StepDtoCopyWith<StepDto> get copyWith =>
      _$StepDtoCopyWithImpl<StepDto>(this as StepDto, _$identity);

  /// Serializes this StepDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StepDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, content, createdDate,
      lastUpdated, userId, journeyId, media);

  @override
  String toString() {
    return 'StepDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, journeyId: $journeyId, media: $media)';
  }
}

/// @nodoc
abstract mixin class $StepDtoCopyWith<$Res> {
  factory $StepDtoCopyWith(StepDto value, $Res Function(StepDto) _then) =
      _$StepDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'media') StepMediaDto2Dto? media});

  $StepMediaDto2DtoCopyWith<$Res>? get media;
}

/// @nodoc
class _$StepDtoCopyWithImpl<$Res> implements $StepDtoCopyWith<$Res> {
  _$StepDtoCopyWithImpl(this._self, this._then);

  final StepDto _self;
  final $Res Function(StepDto) _then;

  /// Create a copy of StepDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? journeyId = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto2Dto?,
    ));
  }

  /// Create a copy of StepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDto2DtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDto2DtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StepDto].
extension StepDtoPatterns on StepDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StepDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StepDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StepDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'media') StepMediaDto2Dto? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepDto() when $default != null:
        return $default(_that.id, _that.content, _that.createdDate,
            _that.lastUpdated, _that.userId, _that.journeyId, _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'media') StepMediaDto2Dto? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDto():
        return $default(_that.id, _that.content, _that.createdDate,
            _that.lastUpdated, _that.userId, _that.journeyId, _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'media') StepMediaDto2Dto? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepDto() when $default != null:
        return $default(_that.id, _that.content, _that.createdDate,
            _that.lastUpdated, _that.userId, _that.journeyId, _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StepDto implements StepDto {
  _StepDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'journeyId') this.journeyId,
      @JsonKey(name: 'media') this.media});
  factory _StepDto.fromJson(Map<String, dynamic> json) =>
      _$StepDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'journeyId')
  final String? journeyId;
  @override
  @JsonKey(name: 'media')
  final StepMediaDto2Dto? media;

  /// Create a copy of StepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StepDtoCopyWith<_StepDto> get copyWith =>
      __$StepDtoCopyWithImpl<_StepDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StepDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StepDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, content, createdDate,
      lastUpdated, userId, journeyId, media);

  @override
  String toString() {
    return 'StepDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, journeyId: $journeyId, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$StepDtoCopyWith<$Res> implements $StepDtoCopyWith<$Res> {
  factory _$StepDtoCopyWith(_StepDto value, $Res Function(_StepDto) _then) =
      __$StepDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'media') StepMediaDto2Dto? media});

  @override
  $StepMediaDto2DtoCopyWith<$Res>? get media;
}

/// @nodoc
class __$StepDtoCopyWithImpl<$Res> implements _$StepDtoCopyWith<$Res> {
  __$StepDtoCopyWithImpl(this._self, this._then);

  final _StepDto _self;
  final $Res Function(_StepDto) _then;

  /// Create a copy of StepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? journeyId = freezed,
    Object? media = freezed,
  }) {
    return _then(_StepDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto2Dto?,
    ));
  }

  /// Create a copy of StepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDto2DtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDto2DtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// @nodoc
mixin _$StepMediaDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'stepId')
  String? get stepId;
  @JsonKey(name: 'mediaType')
  String? get mediaType;
  @JsonKey(name: 'originalUrl')
  String? get originalUrl;
  @JsonKey(name: 'largeUrl')
  String? get largeUrl;
  @JsonKey(name: 'mediumUrl')
  String? get mediumUrl;
  @JsonKey(name: 'smallUrl')
  String? get smallUrl;
  @JsonKey(name: 'thumbnailUrl')
  String? get thumbnailUrl;
  @JsonKey(name: 'videoThumbnailUrl')
  String? get videoThumbnailUrl;
  @JsonKey(name: 'bunnyVideoId')
  String? get bunnyVideoId;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'duration')
  num? get duration;
  @JsonKey(name: 'status')
  MediaStatusDto? get status;
  @JsonKey(name: 'isVideo')
  bool? get isVideo;
  @JsonKey(name: 'isImage')
  bool? get isImage;

  /// Create a copy of StepMediaDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StepMediaDtoCopyWith<StepMediaDto> get copyWith =>
      _$StepMediaDtoCopyWithImpl<StepMediaDto>(
          this as StepMediaDto, _$identity);

  /// Serializes this StepMediaDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StepMediaDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'StepMediaDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class $StepMediaDtoCopyWith<$Res> {
  factory $StepMediaDtoCopyWith(
          StepMediaDto value, $Res Function(StepMediaDto) _then) =
      _$StepMediaDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class _$StepMediaDtoCopyWithImpl<$Res> implements $StepMediaDtoCopyWith<$Res> {
  _$StepMediaDtoCopyWithImpl(this._self, this._then);

  final StepMediaDto _self;
  final $Res Function(StepMediaDto) _then;

  /// Create a copy of StepMediaDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StepMediaDto].
extension StepMediaDtoPatterns on StepMediaDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StepMediaDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StepMediaDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StepMediaDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto():
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StepMediaDto implements StepMediaDto {
  _StepMediaDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'stepId') this.stepId,
      @JsonKey(name: 'mediaType') this.mediaType,
      @JsonKey(name: 'originalUrl') this.originalUrl,
      @JsonKey(name: 'largeUrl') this.largeUrl,
      @JsonKey(name: 'mediumUrl') this.mediumUrl,
      @JsonKey(name: 'smallUrl') this.smallUrl,
      @JsonKey(name: 'thumbnailUrl') this.thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') this.videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') this.bunnyVideoId,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'duration') this.duration,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'isVideo') this.isVideo,
      @JsonKey(name: 'isImage') this.isImage});
  factory _StepMediaDto.fromJson(Map<String, dynamic> json) =>
      _$StepMediaDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'stepId')
  final String? stepId;
  @override
  @JsonKey(name: 'mediaType')
  final String? mediaType;
  @override
  @JsonKey(name: 'originalUrl')
  final String? originalUrl;
  @override
  @JsonKey(name: 'largeUrl')
  final String? largeUrl;
  @override
  @JsonKey(name: 'mediumUrl')
  final String? mediumUrl;
  @override
  @JsonKey(name: 'smallUrl')
  final String? smallUrl;
  @override
  @JsonKey(name: 'thumbnailUrl')
  final String? thumbnailUrl;
  @override
  @JsonKey(name: 'videoThumbnailUrl')
  final String? videoThumbnailUrl;
  @override
  @JsonKey(name: 'bunnyVideoId')
  final String? bunnyVideoId;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'duration')
  final num? duration;
  @override
  @JsonKey(name: 'status')
  final MediaStatusDto? status;
  @override
  @JsonKey(name: 'isVideo')
  final bool? isVideo;
  @override
  @JsonKey(name: 'isImage')
  final bool? isImage;

  /// Create a copy of StepMediaDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StepMediaDtoCopyWith<_StepMediaDto> get copyWith =>
      __$StepMediaDtoCopyWithImpl<_StepMediaDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StepMediaDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StepMediaDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'StepMediaDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class _$StepMediaDtoCopyWith<$Res>
    implements $StepMediaDtoCopyWith<$Res> {
  factory _$StepMediaDtoCopyWith(
          _StepMediaDto value, $Res Function(_StepMediaDto) _then) =
      __$StepMediaDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class __$StepMediaDtoCopyWithImpl<$Res>
    implements _$StepMediaDtoCopyWith<$Res> {
  __$StepMediaDtoCopyWithImpl(this._self, this._then);

  final _StepMediaDto _self;
  final $Res Function(_StepMediaDto) _then;

  /// Create a copy of StepMediaDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_StepMediaDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$StepMediaDto2Dto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'stepId')
  String? get stepId;
  @JsonKey(name: 'mediaType')
  String? get mediaType;
  @JsonKey(name: 'originalUrl')
  String? get originalUrl;
  @JsonKey(name: 'largeUrl')
  String? get largeUrl;
  @JsonKey(name: 'mediumUrl')
  String? get mediumUrl;
  @JsonKey(name: 'smallUrl')
  String? get smallUrl;
  @JsonKey(name: 'thumbnailUrl')
  String? get thumbnailUrl;
  @JsonKey(name: 'videoThumbnailUrl')
  String? get videoThumbnailUrl;
  @JsonKey(name: 'bunnyVideoId')
  String? get bunnyVideoId;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'duration')
  num? get duration;
  @JsonKey(name: 'status')
  MediaStatusDto? get status;
  @JsonKey(name: 'isVideo')
  bool? get isVideo;
  @JsonKey(name: 'isImage')
  bool? get isImage;

  /// Create a copy of StepMediaDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StepMediaDto2DtoCopyWith<StepMediaDto2Dto> get copyWith =>
      _$StepMediaDto2DtoCopyWithImpl<StepMediaDto2Dto>(
          this as StepMediaDto2Dto, _$identity);

  /// Serializes this StepMediaDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StepMediaDto2Dto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'StepMediaDto2Dto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class $StepMediaDto2DtoCopyWith<$Res> {
  factory $StepMediaDto2DtoCopyWith(
          StepMediaDto2Dto value, $Res Function(StepMediaDto2Dto) _then) =
      _$StepMediaDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class _$StepMediaDto2DtoCopyWithImpl<$Res>
    implements $StepMediaDto2DtoCopyWith<$Res> {
  _$StepMediaDto2DtoCopyWithImpl(this._self, this._then);

  final StepMediaDto2Dto _self;
  final $Res Function(StepMediaDto2Dto) _then;

  /// Create a copy of StepMediaDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StepMediaDto2Dto].
extension StepMediaDto2DtoPatterns on StepMediaDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StepMediaDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StepMediaDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StepMediaDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto2Dto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto2Dto():
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StepMediaDto2Dto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StepMediaDto2Dto implements StepMediaDto2Dto {
  _StepMediaDto2Dto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'stepId') this.stepId,
      @JsonKey(name: 'mediaType') this.mediaType,
      @JsonKey(name: 'originalUrl') this.originalUrl,
      @JsonKey(name: 'largeUrl') this.largeUrl,
      @JsonKey(name: 'mediumUrl') this.mediumUrl,
      @JsonKey(name: 'smallUrl') this.smallUrl,
      @JsonKey(name: 'thumbnailUrl') this.thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') this.videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') this.bunnyVideoId,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'duration') this.duration,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'isVideo') this.isVideo,
      @JsonKey(name: 'isImage') this.isImage});
  factory _StepMediaDto2Dto.fromJson(Map<String, dynamic> json) =>
      _$StepMediaDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'stepId')
  final String? stepId;
  @override
  @JsonKey(name: 'mediaType')
  final String? mediaType;
  @override
  @JsonKey(name: 'originalUrl')
  final String? originalUrl;
  @override
  @JsonKey(name: 'largeUrl')
  final String? largeUrl;
  @override
  @JsonKey(name: 'mediumUrl')
  final String? mediumUrl;
  @override
  @JsonKey(name: 'smallUrl')
  final String? smallUrl;
  @override
  @JsonKey(name: 'thumbnailUrl')
  final String? thumbnailUrl;
  @override
  @JsonKey(name: 'videoThumbnailUrl')
  final String? videoThumbnailUrl;
  @override
  @JsonKey(name: 'bunnyVideoId')
  final String? bunnyVideoId;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'duration')
  final num? duration;
  @override
  @JsonKey(name: 'status')
  final MediaStatusDto? status;
  @override
  @JsonKey(name: 'isVideo')
  final bool? isVideo;
  @override
  @JsonKey(name: 'isImage')
  final bool? isImage;

  /// Create a copy of StepMediaDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StepMediaDto2DtoCopyWith<_StepMediaDto2Dto> get copyWith =>
      __$StepMediaDto2DtoCopyWithImpl<_StepMediaDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StepMediaDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StepMediaDto2Dto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'StepMediaDto2Dto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class _$StepMediaDto2DtoCopyWith<$Res>
    implements $StepMediaDto2DtoCopyWith<$Res> {
  factory _$StepMediaDto2DtoCopyWith(
          _StepMediaDto2Dto value, $Res Function(_StepMediaDto2Dto) _then) =
      __$StepMediaDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class __$StepMediaDto2DtoCopyWithImpl<$Res>
    implements _$StepMediaDto2DtoCopyWith<$Res> {
  __$StepMediaDto2DtoCopyWithImpl(this._self, this._then);

  final _StepMediaDto2Dto _self;
  final $Res Function(_StepMediaDto2Dto) _then;

  /// Create a copy of StepMediaDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_StepMediaDto2Dto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$UpdateJourneyDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'description')
  String? get description;

  /// Create a copy of UpdateJourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UpdateJourneyDtoCopyWith<UpdateJourneyDto> get copyWith =>
      _$UpdateJourneyDtoCopyWithImpl<UpdateJourneyDto>(
          this as UpdateJourneyDto, _$identity);

  /// Serializes this UpdateJourneyDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UpdateJourneyDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, title, description);

  @override
  String toString() {
    return 'UpdateJourneyDto(title: $title, description: $description)';
  }
}

/// @nodoc
abstract mixin class $UpdateJourneyDtoCopyWith<$Res> {
  factory $UpdateJourneyDtoCopyWith(
          UpdateJourneyDto value, $Res Function(UpdateJourneyDto) _then) =
      _$UpdateJourneyDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class _$UpdateJourneyDtoCopyWithImpl<$Res>
    implements $UpdateJourneyDtoCopyWith<$Res> {
  _$UpdateJourneyDtoCopyWithImpl(this._self, this._then);

  final UpdateJourneyDto _self;
  final $Res Function(UpdateJourneyDto) _then;

  /// Create a copy of UpdateJourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? description = freezed,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [UpdateJourneyDto].
extension UpdateJourneyDtoPatterns on UpdateJourneyDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UpdateJourneyDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UpdateJourneyDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UpdateJourneyDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateJourneyDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UpdateJourneyDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateJourneyDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UpdateJourneyDto() when $default != null:
        return $default(_that.title, _that.description);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateJourneyDto():
        return $default(_that.title, _that.description);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateJourneyDto() when $default != null:
        return $default(_that.title, _that.description);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UpdateJourneyDto implements UpdateJourneyDto {
  _UpdateJourneyDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'description') this.description});
  factory _UpdateJourneyDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateJourneyDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Create a copy of UpdateJourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UpdateJourneyDtoCopyWith<_UpdateJourneyDto> get copyWith =>
      __$UpdateJourneyDtoCopyWithImpl<_UpdateJourneyDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UpdateJourneyDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateJourneyDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, title, description);

  @override
  String toString() {
    return 'UpdateJourneyDto(title: $title, description: $description)';
  }
}

/// @nodoc
abstract mixin class _$UpdateJourneyDtoCopyWith<$Res>
    implements $UpdateJourneyDtoCopyWith<$Res> {
  factory _$UpdateJourneyDtoCopyWith(
          _UpdateJourneyDto value, $Res Function(_UpdateJourneyDto) _then) =
      __$UpdateJourneyDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class __$UpdateJourneyDtoCopyWithImpl<$Res>
    implements _$UpdateJourneyDtoCopyWith<$Res> {
  __$UpdateJourneyDtoCopyWithImpl(this._self, this._then);

  final _UpdateJourneyDto _self;
  final $Res Function(_UpdateJourneyDto) _then;

  /// Create a copy of UpdateJourneyDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? description = freezed,
  }) {
    return _then(_UpdateJourneyDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$UpdateStepDto {
  @JsonKey(name: 'content')
  String get content;

  /// Create a copy of UpdateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UpdateStepDtoCopyWith<UpdateStepDto> get copyWith =>
      _$UpdateStepDtoCopyWithImpl<UpdateStepDto>(
          this as UpdateStepDto, _$identity);

  /// Serializes this UpdateStepDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UpdateStepDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'UpdateStepDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class $UpdateStepDtoCopyWith<$Res> {
  factory $UpdateStepDtoCopyWith(
          UpdateStepDto value, $Res Function(UpdateStepDto) _then) =
      _$UpdateStepDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class _$UpdateStepDtoCopyWithImpl<$Res>
    implements $UpdateStepDtoCopyWith<$Res> {
  _$UpdateStepDtoCopyWithImpl(this._self, this._then);

  final UpdateStepDto _self;
  final $Res Function(UpdateStepDto) _then;

  /// Create a copy of UpdateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [UpdateStepDto].
extension UpdateStepDtoPatterns on UpdateStepDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UpdateStepDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UpdateStepDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UpdateStepDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateStepDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UpdateStepDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateStepDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UpdateStepDto() when $default != null:
        return $default(_that.content);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateStepDto():
        return $default(_that.content);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'content') String content)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateStepDto() when $default != null:
        return $default(_that.content);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UpdateStepDto implements UpdateStepDto {
  _UpdateStepDto({@JsonKey(name: 'content') required this.content});
  factory _UpdateStepDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateStepDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;

  /// Create a copy of UpdateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UpdateStepDtoCopyWith<_UpdateStepDto> get copyWith =>
      __$UpdateStepDtoCopyWithImpl<_UpdateStepDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UpdateStepDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateStepDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'UpdateStepDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class _$UpdateStepDtoCopyWith<$Res>
    implements $UpdateStepDtoCopyWith<$Res> {
  factory _$UpdateStepDtoCopyWith(
          _UpdateStepDto value, $Res Function(_UpdateStepDto) _then) =
      __$UpdateStepDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class __$UpdateStepDtoCopyWithImpl<$Res>
    implements _$UpdateStepDtoCopyWith<$Res> {
  __$UpdateStepDtoCopyWithImpl(this._self, this._then);

  final _UpdateStepDto _self;
  final $Res Function(_UpdateStepDto) _then;

  /// Create a copy of UpdateStepDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
  }) {
    return _then(_UpdateStepDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$UserDetailDto {
  @JsonKey(name: 'user')
  UserDto get user;
  @JsonKey(name: 'followingStatus')
  FollowingStatusEnumDto? get followingStatus;

  /// Create a copy of UserDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserDetailDtoCopyWith<UserDetailDto> get copyWith =>
      _$UserDetailDtoCopyWithImpl<UserDetailDto>(
          this as UserDetailDto, _$identity);

  /// Serializes this UserDetailDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserDetailDto &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.followingStatus, followingStatus) ||
                other.followingStatus == followingStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, user, followingStatus);

  @override
  String toString() {
    return 'UserDetailDto(user: $user, followingStatus: $followingStatus)';
  }
}

/// @nodoc
abstract mixin class $UserDetailDtoCopyWith<$Res> {
  factory $UserDetailDtoCopyWith(
          UserDetailDto value, $Res Function(UserDetailDto) _then) =
      _$UserDetailDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'followingStatus')
      FollowingStatusEnumDto? followingStatus});

  $UserDtoCopyWith<$Res> get user;
}

/// @nodoc
class _$UserDetailDtoCopyWithImpl<$Res>
    implements $UserDetailDtoCopyWith<$Res> {
  _$UserDetailDtoCopyWithImpl(this._self, this._then);

  final UserDetailDto _self;
  final $Res Function(UserDetailDto) _then;

  /// Create a copy of UserDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = null,
    Object? followingStatus = freezed,
  }) {
    return _then(_self.copyWith(
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      followingStatus: freezed == followingStatus
          ? _self.followingStatus
          : followingStatus // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto?,
    ));
  }

  /// Create a copy of UserDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// Adds pattern-matching-related methods to [UserDetailDto].
extension UserDetailDtoPatterns on UserDetailDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserDetailDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserDetailDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UserDetailDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'followingStatus')
            FollowingStatusEnumDto? followingStatus)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto() when $default != null:
        return $default(_that.user, _that.followingStatus);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'followingStatus')
            FollowingStatusEnumDto? followingStatus)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto():
        return $default(_that.user, _that.followingStatus);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'followingStatus')
            FollowingStatusEnumDto? followingStatus)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto() when $default != null:
        return $default(_that.user, _that.followingStatus);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UserDetailDto implements UserDetailDto {
  _UserDetailDto(
      {@JsonKey(name: 'user') required this.user,
      @JsonKey(name: 'followingStatus') this.followingStatus});
  factory _UserDetailDto.fromJson(Map<String, dynamic> json) =>
      _$UserDetailDtoFromJson(json);

  @override
  @JsonKey(name: 'user')
  final UserDto user;
  @override
  @JsonKey(name: 'followingStatus')
  final FollowingStatusEnumDto? followingStatus;

  /// Create a copy of UserDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserDetailDtoCopyWith<_UserDetailDto> get copyWith =>
      __$UserDetailDtoCopyWithImpl<_UserDetailDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserDetailDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserDetailDto &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.followingStatus, followingStatus) ||
                other.followingStatus == followingStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, user, followingStatus);

  @override
  String toString() {
    return 'UserDetailDto(user: $user, followingStatus: $followingStatus)';
  }
}

/// @nodoc
abstract mixin class _$UserDetailDtoCopyWith<$Res>
    implements $UserDetailDtoCopyWith<$Res> {
  factory _$UserDetailDtoCopyWith(
          _UserDetailDto value, $Res Function(_UserDetailDto) _then) =
      __$UserDetailDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'followingStatus')
      FollowingStatusEnumDto? followingStatus});

  @override
  $UserDtoCopyWith<$Res> get user;
}

/// @nodoc
class __$UserDetailDtoCopyWithImpl<$Res>
    implements _$UserDetailDtoCopyWith<$Res> {
  __$UserDetailDtoCopyWithImpl(this._self, this._then);

  final _UserDetailDto _self;
  final $Res Function(_UserDetailDto) _then;

  /// Create a copy of UserDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? user = null,
    Object? followingStatus = freezed,
  }) {
    return _then(_UserDetailDto(
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      followingStatus: freezed == followingStatus
          ? _self.followingStatus
          : followingStatus // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto?,
    ));
  }

  /// Create a copy of UserDetailDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// @nodoc
mixin _$UserDetailDto2Dto {
  @JsonKey(name: 'user')
  UserDto get user;
  @JsonKey(name: 'followingStatus')
  FollowingStatusEnumDto? get followingStatus;

  /// Create a copy of UserDetailDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserDetailDto2DtoCopyWith<UserDetailDto2Dto> get copyWith =>
      _$UserDetailDto2DtoCopyWithImpl<UserDetailDto2Dto>(
          this as UserDetailDto2Dto, _$identity);

  /// Serializes this UserDetailDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserDetailDto2Dto &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.followingStatus, followingStatus) ||
                other.followingStatus == followingStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, user, followingStatus);

  @override
  String toString() {
    return 'UserDetailDto2Dto(user: $user, followingStatus: $followingStatus)';
  }
}

/// @nodoc
abstract mixin class $UserDetailDto2DtoCopyWith<$Res> {
  factory $UserDetailDto2DtoCopyWith(
          UserDetailDto2Dto value, $Res Function(UserDetailDto2Dto) _then) =
      _$UserDetailDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'followingStatus')
      FollowingStatusEnumDto? followingStatus});

  $UserDtoCopyWith<$Res> get user;
}

/// @nodoc
class _$UserDetailDto2DtoCopyWithImpl<$Res>
    implements $UserDetailDto2DtoCopyWith<$Res> {
  _$UserDetailDto2DtoCopyWithImpl(this._self, this._then);

  final UserDetailDto2Dto _self;
  final $Res Function(UserDetailDto2Dto) _then;

  /// Create a copy of UserDetailDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = null,
    Object? followingStatus = freezed,
  }) {
    return _then(_self.copyWith(
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      followingStatus: freezed == followingStatus
          ? _self.followingStatus
          : followingStatus // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto?,
    ));
  }

  /// Create a copy of UserDetailDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// Adds pattern-matching-related methods to [UserDetailDto2Dto].
extension UserDetailDto2DtoPatterns on UserDetailDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserDetailDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserDetailDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UserDetailDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'followingStatus')
            FollowingStatusEnumDto? followingStatus)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto2Dto() when $default != null:
        return $default(_that.user, _that.followingStatus);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'followingStatus')
            FollowingStatusEnumDto? followingStatus)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto2Dto():
        return $default(_that.user, _that.followingStatus);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'followingStatus')
            FollowingStatusEnumDto? followingStatus)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDetailDto2Dto() when $default != null:
        return $default(_that.user, _that.followingStatus);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UserDetailDto2Dto implements UserDetailDto2Dto {
  _UserDetailDto2Dto(
      {@JsonKey(name: 'user') required this.user,
      @JsonKey(name: 'followingStatus') this.followingStatus});
  factory _UserDetailDto2Dto.fromJson(Map<String, dynamic> json) =>
      _$UserDetailDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'user')
  final UserDto user;
  @override
  @JsonKey(name: 'followingStatus')
  final FollowingStatusEnumDto? followingStatus;

  /// Create a copy of UserDetailDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserDetailDto2DtoCopyWith<_UserDetailDto2Dto> get copyWith =>
      __$UserDetailDto2DtoCopyWithImpl<_UserDetailDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserDetailDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserDetailDto2Dto &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.followingStatus, followingStatus) ||
                other.followingStatus == followingStatus));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, user, followingStatus);

  @override
  String toString() {
    return 'UserDetailDto2Dto(user: $user, followingStatus: $followingStatus)';
  }
}

/// @nodoc
abstract mixin class _$UserDetailDto2DtoCopyWith<$Res>
    implements $UserDetailDto2DtoCopyWith<$Res> {
  factory _$UserDetailDto2DtoCopyWith(
          _UserDetailDto2Dto value, $Res Function(_UserDetailDto2Dto) _then) =
      __$UserDetailDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'followingStatus')
      FollowingStatusEnumDto? followingStatus});

  @override
  $UserDtoCopyWith<$Res> get user;
}

/// @nodoc
class __$UserDetailDto2DtoCopyWithImpl<$Res>
    implements _$UserDetailDto2DtoCopyWith<$Res> {
  __$UserDetailDto2DtoCopyWithImpl(this._self, this._then);

  final _UserDetailDto2Dto _self;
  final $Res Function(_UserDetailDto2Dto) _then;

  /// Create a copy of UserDetailDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? user = null,
    Object? followingStatus = freezed,
  }) {
    return _then(_UserDetailDto2Dto(
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      followingStatus: freezed == followingStatus
          ? _self.followingStatus
          : followingStatus // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto?,
    ));
  }

  /// Create a copy of UserDetailDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// @nodoc
mixin _$UserDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'displayName')
  String? get displayName;
  @JsonKey(name: 'username')
  String? get username;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'profilePictureUrl')
  String? get profilePictureUrl;
  @JsonKey(name: 'phoneNumber')
  String? get phoneNumber;
  @JsonKey(name: 'email')
  String? get email;
  @JsonKey(name: 'age')
  int? get age;
  @JsonKey(name: 'isPrivate')
  bool? get isPrivate;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;

  /// Create a copy of UserDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<UserDto> get copyWith =>
      _$UserDtoCopyWithImpl<UserDto>(this as UserDto, _$identity);

  /// Serializes this UserDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.profilePictureUrl, profilePictureUrl) ||
                other.profilePictureUrl == profilePictureUrl) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      username,
      description,
      profilePictureUrl,
      phoneNumber,
      email,
      age,
      isPrivate,
      createdDate,
      lastUpdated);

  @override
  String toString() {
    return 'UserDto(id: $id, displayName: $displayName, username: $username, description: $description, profilePictureUrl: $profilePictureUrl, phoneNumber: $phoneNumber, email: $email, age: $age, isPrivate: $isPrivate, createdDate: $createdDate, lastUpdated: $lastUpdated)';
  }
}

/// @nodoc
abstract mixin class $UserDtoCopyWith<$Res> {
  factory $UserDtoCopyWith(UserDto value, $Res Function(UserDto) _then) =
      _$UserDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'username') String? username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'age') int? age,
      @JsonKey(name: 'isPrivate') bool? isPrivate,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated});
}

/// @nodoc
class _$UserDtoCopyWithImpl<$Res> implements $UserDtoCopyWith<$Res> {
  _$UserDtoCopyWithImpl(this._self, this._then);

  final UserDto _self;
  final $Res Function(UserDto) _then;

  /// Create a copy of UserDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? displayName = freezed,
    Object? username = freezed,
    Object? description = freezed,
    Object? profilePictureUrl = freezed,
    Object? phoneNumber = freezed,
    Object? email = freezed,
    Object? age = freezed,
    Object? isPrivate = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      profilePictureUrl: freezed == profilePictureUrl
          ? _self.profilePictureUrl
          : profilePictureUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _self.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [UserDto].
extension UserDtoPatterns on UserDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UserDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'username') String? username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'isPrivate') bool? isPrivate,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.username,
            _that.description,
            _that.profilePictureUrl,
            _that.phoneNumber,
            _that.email,
            _that.age,
            _that.isPrivate,
            _that.createdDate,
            _that.lastUpdated);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'username') String? username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'isPrivate') bool? isPrivate,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto():
        return $default(
            _that.id,
            _that.displayName,
            _that.username,
            _that.description,
            _that.profilePictureUrl,
            _that.phoneNumber,
            _that.email,
            _that.age,
            _that.isPrivate,
            _that.createdDate,
            _that.lastUpdated);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'username') String? username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'isPrivate') bool? isPrivate,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.username,
            _that.description,
            _that.profilePictureUrl,
            _that.phoneNumber,
            _that.email,
            _that.age,
            _that.isPrivate,
            _that.createdDate,
            _that.lastUpdated);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UserDto implements UserDto {
  _UserDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'displayName') this.displayName,
      @JsonKey(name: 'username') this.username,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'profilePictureUrl') this.profilePictureUrl,
      @JsonKey(name: 'phoneNumber') this.phoneNumber,
      @JsonKey(name: 'email') this.email,
      @JsonKey(name: 'age') this.age,
      @JsonKey(name: 'isPrivate') this.isPrivate,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated});
  factory _UserDto.fromJson(Map<String, dynamic> json) =>
      _$UserDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'displayName')
  final String? displayName;
  @override
  @JsonKey(name: 'username')
  final String? username;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'profilePictureUrl')
  final String? profilePictureUrl;
  @override
  @JsonKey(name: 'phoneNumber')
  final String? phoneNumber;
  @override
  @JsonKey(name: 'email')
  final String? email;
  @override
  @JsonKey(name: 'age')
  final int? age;
  @override
  @JsonKey(name: 'isPrivate')
  final bool? isPrivate;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;

  /// Create a copy of UserDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserDtoCopyWith<_UserDto> get copyWith =>
      __$UserDtoCopyWithImpl<_UserDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.profilePictureUrl, profilePictureUrl) ||
                other.profilePictureUrl == profilePictureUrl) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      username,
      description,
      profilePictureUrl,
      phoneNumber,
      email,
      age,
      isPrivate,
      createdDate,
      lastUpdated);

  @override
  String toString() {
    return 'UserDto(id: $id, displayName: $displayName, username: $username, description: $description, profilePictureUrl: $profilePictureUrl, phoneNumber: $phoneNumber, email: $email, age: $age, isPrivate: $isPrivate, createdDate: $createdDate, lastUpdated: $lastUpdated)';
  }
}

/// @nodoc
abstract mixin class _$UserDtoCopyWith<$Res> implements $UserDtoCopyWith<$Res> {
  factory _$UserDtoCopyWith(_UserDto value, $Res Function(_UserDto) _then) =
      __$UserDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'username') String? username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'age') int? age,
      @JsonKey(name: 'isPrivate') bool? isPrivate,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated});
}

/// @nodoc
class __$UserDtoCopyWithImpl<$Res> implements _$UserDtoCopyWith<$Res> {
  __$UserDtoCopyWithImpl(this._self, this._then);

  final _UserDto _self;
  final $Res Function(_UserDto) _then;

  /// Create a copy of UserDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? displayName = freezed,
    Object? username = freezed,
    Object? description = freezed,
    Object? profilePictureUrl = freezed,
    Object? phoneNumber = freezed,
    Object? email = freezed,
    Object? age = freezed,
    Object? isPrivate = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
  }) {
    return _then(_UserDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      profilePictureUrl: freezed == profilePictureUrl
          ? _self.profilePictureUrl
          : profilePictureUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _self.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$UserDto2Dto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'displayName')
  String? get displayName;
  @JsonKey(name: 'username')
  String? get username;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'profilePictureUrl')
  String? get profilePictureUrl;
  @JsonKey(name: 'phoneNumber')
  String? get phoneNumber;
  @JsonKey(name: 'email')
  String? get email;
  @JsonKey(name: 'age')
  int? get age;
  @JsonKey(name: 'isPrivate')
  bool? get isPrivate;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;

  /// Create a copy of UserDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<UserDto2Dto> get copyWith =>
      _$UserDto2DtoCopyWithImpl<UserDto2Dto>(this as UserDto2Dto, _$identity);

  /// Serializes this UserDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserDto2Dto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.profilePictureUrl, profilePictureUrl) ||
                other.profilePictureUrl == profilePictureUrl) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      username,
      description,
      profilePictureUrl,
      phoneNumber,
      email,
      age,
      isPrivate,
      createdDate,
      lastUpdated);

  @override
  String toString() {
    return 'UserDto2Dto(id: $id, displayName: $displayName, username: $username, description: $description, profilePictureUrl: $profilePictureUrl, phoneNumber: $phoneNumber, email: $email, age: $age, isPrivate: $isPrivate, createdDate: $createdDate, lastUpdated: $lastUpdated)';
  }
}

/// @nodoc
abstract mixin class $UserDto2DtoCopyWith<$Res> {
  factory $UserDto2DtoCopyWith(
          UserDto2Dto value, $Res Function(UserDto2Dto) _then) =
      _$UserDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'username') String? username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'age') int? age,
      @JsonKey(name: 'isPrivate') bool? isPrivate,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated});
}

/// @nodoc
class _$UserDto2DtoCopyWithImpl<$Res> implements $UserDto2DtoCopyWith<$Res> {
  _$UserDto2DtoCopyWithImpl(this._self, this._then);

  final UserDto2Dto _self;
  final $Res Function(UserDto2Dto) _then;

  /// Create a copy of UserDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? displayName = freezed,
    Object? username = freezed,
    Object? description = freezed,
    Object? profilePictureUrl = freezed,
    Object? phoneNumber = freezed,
    Object? email = freezed,
    Object? age = freezed,
    Object? isPrivate = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      profilePictureUrl: freezed == profilePictureUrl
          ? _self.profilePictureUrl
          : profilePictureUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _self.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [UserDto2Dto].
extension UserDto2DtoPatterns on UserDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UserDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'username') String? username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'isPrivate') bool? isPrivate,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserDto2Dto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.username,
            _that.description,
            _that.profilePictureUrl,
            _that.phoneNumber,
            _that.email,
            _that.age,
            _that.isPrivate,
            _that.createdDate,
            _that.lastUpdated);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'username') String? username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'isPrivate') bool? isPrivate,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto2Dto():
        return $default(
            _that.id,
            _that.displayName,
            _that.username,
            _that.description,
            _that.profilePictureUrl,
            _that.phoneNumber,
            _that.email,
            _that.age,
            _that.isPrivate,
            _that.createdDate,
            _that.lastUpdated);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'displayName') String? displayName,
            @JsonKey(name: 'username') String? username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'isPrivate') bool? isPrivate,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserDto2Dto() when $default != null:
        return $default(
            _that.id,
            _that.displayName,
            _that.username,
            _that.description,
            _that.profilePictureUrl,
            _that.phoneNumber,
            _that.email,
            _that.age,
            _that.isPrivate,
            _that.createdDate,
            _that.lastUpdated);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UserDto2Dto implements UserDto2Dto {
  _UserDto2Dto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'displayName') this.displayName,
      @JsonKey(name: 'username') this.username,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'profilePictureUrl') this.profilePictureUrl,
      @JsonKey(name: 'phoneNumber') this.phoneNumber,
      @JsonKey(name: 'email') this.email,
      @JsonKey(name: 'age') this.age,
      @JsonKey(name: 'isPrivate') this.isPrivate,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated});
  factory _UserDto2Dto.fromJson(Map<String, dynamic> json) =>
      _$UserDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'displayName')
  final String? displayName;
  @override
  @JsonKey(name: 'username')
  final String? username;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'profilePictureUrl')
  final String? profilePictureUrl;
  @override
  @JsonKey(name: 'phoneNumber')
  final String? phoneNumber;
  @override
  @JsonKey(name: 'email')
  final String? email;
  @override
  @JsonKey(name: 'age')
  final int? age;
  @override
  @JsonKey(name: 'isPrivate')
  final bool? isPrivate;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;

  /// Create a copy of UserDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserDto2DtoCopyWith<_UserDto2Dto> get copyWith =>
      __$UserDto2DtoCopyWithImpl<_UserDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserDto2Dto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.profilePictureUrl, profilePictureUrl) ||
                other.profilePictureUrl == profilePictureUrl) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      displayName,
      username,
      description,
      profilePictureUrl,
      phoneNumber,
      email,
      age,
      isPrivate,
      createdDate,
      lastUpdated);

  @override
  String toString() {
    return 'UserDto2Dto(id: $id, displayName: $displayName, username: $username, description: $description, profilePictureUrl: $profilePictureUrl, phoneNumber: $phoneNumber, email: $email, age: $age, isPrivate: $isPrivate, createdDate: $createdDate, lastUpdated: $lastUpdated)';
  }
}

/// @nodoc
abstract mixin class _$UserDto2DtoCopyWith<$Res>
    implements $UserDto2DtoCopyWith<$Res> {
  factory _$UserDto2DtoCopyWith(
          _UserDto2Dto value, $Res Function(_UserDto2Dto) _then) =
      __$UserDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'displayName') String? displayName,
      @JsonKey(name: 'username') String? username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'profilePictureUrl') String? profilePictureUrl,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'age') int? age,
      @JsonKey(name: 'isPrivate') bool? isPrivate,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated});
}

/// @nodoc
class __$UserDto2DtoCopyWithImpl<$Res> implements _$UserDto2DtoCopyWith<$Res> {
  __$UserDto2DtoCopyWithImpl(this._self, this._then);

  final _UserDto2Dto _self;
  final $Res Function(_UserDto2Dto) _then;

  /// Create a copy of UserDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? displayName = freezed,
    Object? username = freezed,
    Object? description = freezed,
    Object? profilePictureUrl = freezed,
    Object? phoneNumber = freezed,
    Object? email = freezed,
    Object? age = freezed,
    Object? isPrivate = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
  }) {
    return _then(_UserDto2Dto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      profilePictureUrl: freezed == profilePictureUrl
          ? _self.profilePictureUrl
          : profilePictureUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _self.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$VideoPreSignedUrlDto {
  @JsonKey(name: 'authorizationSignature')
  String? get authorizationSignature;
  @JsonKey(name: 'authorizationExpire')
  int? get authorizationExpire;
  @JsonKey(name: 'videoGuid')
  String? get videoGuid;
  @JsonKey(name: 'libraryId')
  int? get libraryId;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'collectionId')
  String? get collectionId;
  @JsonKey(name: 'media')
  StepMediaDto? get media;

  /// Create a copy of VideoPreSignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VideoPreSignedUrlDtoCopyWith<VideoPreSignedUrlDto> get copyWith =>
      _$VideoPreSignedUrlDtoCopyWithImpl<VideoPreSignedUrlDto>(
          this as VideoPreSignedUrlDto, _$identity);

  /// Serializes this VideoPreSignedUrlDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VideoPreSignedUrlDto &&
            (identical(other.authorizationSignature, authorizationSignature) ||
                other.authorizationSignature == authorizationSignature) &&
            (identical(other.authorizationExpire, authorizationExpire) ||
                other.authorizationExpire == authorizationExpire) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.libraryId, libraryId) ||
                other.libraryId == libraryId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.collectionId, collectionId) ||
                other.collectionId == collectionId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationSignature,
      authorizationExpire, videoGuid, libraryId, title, collectionId, media);

  @override
  String toString() {
    return 'VideoPreSignedUrlDto(authorizationSignature: $authorizationSignature, authorizationExpire: $authorizationExpire, videoGuid: $videoGuid, libraryId: $libraryId, title: $title, collectionId: $collectionId, media: $media)';
  }
}

/// @nodoc
abstract mixin class $VideoPreSignedUrlDtoCopyWith<$Res> {
  factory $VideoPreSignedUrlDtoCopyWith(VideoPreSignedUrlDto value,
          $Res Function(VideoPreSignedUrlDto) _then) =
      _$VideoPreSignedUrlDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'authorizationSignature') String? authorizationSignature,
      @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'libraryId') int? libraryId,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'collectionId') String? collectionId,
      @JsonKey(name: 'media') StepMediaDto? media});

  $StepMediaDtoCopyWith<$Res>? get media;
}

/// @nodoc
class _$VideoPreSignedUrlDtoCopyWithImpl<$Res>
    implements $VideoPreSignedUrlDtoCopyWith<$Res> {
  _$VideoPreSignedUrlDtoCopyWithImpl(this._self, this._then);

  final VideoPreSignedUrlDto _self;
  final $Res Function(VideoPreSignedUrlDto) _then;

  /// Create a copy of VideoPreSignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? authorizationSignature = freezed,
    Object? authorizationExpire = freezed,
    Object? videoGuid = freezed,
    Object? libraryId = freezed,
    Object? title = freezed,
    Object? collectionId = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      authorizationSignature: freezed == authorizationSignature
          ? _self.authorizationSignature
          : authorizationSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      authorizationExpire: freezed == authorizationExpire
          ? _self.authorizationExpire
          : authorizationExpire // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      libraryId: freezed == libraryId
          ? _self.libraryId
          : libraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      collectionId: freezed == collectionId
          ? _self.collectionId
          : collectionId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto?,
    ));
  }

  /// Create a copy of VideoPreSignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// Adds pattern-matching-related methods to [VideoPreSignedUrlDto].
extension VideoPreSignedUrlDtoPatterns on VideoPreSignedUrlDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VideoPreSignedUrlDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VideoPreSignedUrlDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VideoPreSignedUrlDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoPreSignedUrlDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VideoPreSignedUrlDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoPreSignedUrlDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VideoPreSignedUrlDto() when $default != null:
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoPreSignedUrlDto():
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoPreSignedUrlDto() when $default != null:
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VideoPreSignedUrlDto implements VideoPreSignedUrlDto {
  _VideoPreSignedUrlDto(
      {@JsonKey(name: 'authorizationSignature') this.authorizationSignature,
      @JsonKey(name: 'authorizationExpire') this.authorizationExpire,
      @JsonKey(name: 'videoGuid') this.videoGuid,
      @JsonKey(name: 'libraryId') this.libraryId,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'collectionId') this.collectionId,
      @JsonKey(name: 'media') this.media});
  factory _VideoPreSignedUrlDto.fromJson(Map<String, dynamic> json) =>
      _$VideoPreSignedUrlDtoFromJson(json);

  @override
  @JsonKey(name: 'authorizationSignature')
  final String? authorizationSignature;
  @override
  @JsonKey(name: 'authorizationExpire')
  final int? authorizationExpire;
  @override
  @JsonKey(name: 'videoGuid')
  final String? videoGuid;
  @override
  @JsonKey(name: 'libraryId')
  final int? libraryId;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'collectionId')
  final String? collectionId;
  @override
  @JsonKey(name: 'media')
  final StepMediaDto? media;

  /// Create a copy of VideoPreSignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VideoPreSignedUrlDtoCopyWith<_VideoPreSignedUrlDto> get copyWith =>
      __$VideoPreSignedUrlDtoCopyWithImpl<_VideoPreSignedUrlDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VideoPreSignedUrlDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VideoPreSignedUrlDto &&
            (identical(other.authorizationSignature, authorizationSignature) ||
                other.authorizationSignature == authorizationSignature) &&
            (identical(other.authorizationExpire, authorizationExpire) ||
                other.authorizationExpire == authorizationExpire) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.libraryId, libraryId) ||
                other.libraryId == libraryId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.collectionId, collectionId) ||
                other.collectionId == collectionId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationSignature,
      authorizationExpire, videoGuid, libraryId, title, collectionId, media);

  @override
  String toString() {
    return 'VideoPreSignedUrlDto(authorizationSignature: $authorizationSignature, authorizationExpire: $authorizationExpire, videoGuid: $videoGuid, libraryId: $libraryId, title: $title, collectionId: $collectionId, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$VideoPreSignedUrlDtoCopyWith<$Res>
    implements $VideoPreSignedUrlDtoCopyWith<$Res> {
  factory _$VideoPreSignedUrlDtoCopyWith(_VideoPreSignedUrlDto value,
          $Res Function(_VideoPreSignedUrlDto) _then) =
      __$VideoPreSignedUrlDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'authorizationSignature') String? authorizationSignature,
      @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'libraryId') int? libraryId,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'collectionId') String? collectionId,
      @JsonKey(name: 'media') StepMediaDto? media});

  @override
  $StepMediaDtoCopyWith<$Res>? get media;
}

/// @nodoc
class __$VideoPreSignedUrlDtoCopyWithImpl<$Res>
    implements _$VideoPreSignedUrlDtoCopyWith<$Res> {
  __$VideoPreSignedUrlDtoCopyWithImpl(this._self, this._then);

  final _VideoPreSignedUrlDto _self;
  final $Res Function(_VideoPreSignedUrlDto) _then;

  /// Create a copy of VideoPreSignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? authorizationSignature = freezed,
    Object? authorizationExpire = freezed,
    Object? videoGuid = freezed,
    Object? libraryId = freezed,
    Object? title = freezed,
    Object? collectionId = freezed,
    Object? media = freezed,
  }) {
    return _then(_VideoPreSignedUrlDto(
      authorizationSignature: freezed == authorizationSignature
          ? _self.authorizationSignature
          : authorizationSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      authorizationExpire: freezed == authorizationExpire
          ? _self.authorizationExpire
          : authorizationExpire // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      libraryId: freezed == libraryId
          ? _self.libraryId
          : libraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      collectionId: freezed == collectionId
          ? _self.collectionId
          : collectionId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto?,
    ));
  }

  /// Create a copy of VideoPreSignedUrlDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// @nodoc
mixin _$VideoStatusDto {
  @JsonKey(name: 'videoLibraryId')
  int? get videoLibraryId;
  @JsonKey(name: 'videoGuid')
  String? get videoGuid;
  @JsonKey(name: 'status')
  int? get status;

  /// Create a copy of VideoStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VideoStatusDtoCopyWith<VideoStatusDto> get copyWith =>
      _$VideoStatusDtoCopyWithImpl<VideoStatusDto>(
          this as VideoStatusDto, _$identity);

  /// Serializes this VideoStatusDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VideoStatusDto &&
            (identical(other.videoLibraryId, videoLibraryId) ||
                other.videoLibraryId == videoLibraryId) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, videoLibraryId, videoGuid, status);

  @override
  String toString() {
    return 'VideoStatusDto(videoLibraryId: $videoLibraryId, videoGuid: $videoGuid, status: $status)';
  }
}

/// @nodoc
abstract mixin class $VideoStatusDtoCopyWith<$Res> {
  factory $VideoStatusDtoCopyWith(
          VideoStatusDto value, $Res Function(VideoStatusDto) _then) =
      _$VideoStatusDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'videoLibraryId') int? videoLibraryId,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'status') int? status});
}

/// @nodoc
class _$VideoStatusDtoCopyWithImpl<$Res>
    implements $VideoStatusDtoCopyWith<$Res> {
  _$VideoStatusDtoCopyWithImpl(this._self, this._then);

  final VideoStatusDto _self;
  final $Res Function(VideoStatusDto) _then;

  /// Create a copy of VideoStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? videoLibraryId = freezed,
    Object? videoGuid = freezed,
    Object? status = freezed,
  }) {
    return _then(_self.copyWith(
      videoLibraryId: freezed == videoLibraryId
          ? _self.videoLibraryId
          : videoLibraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [VideoStatusDto].
extension VideoStatusDtoPatterns on VideoStatusDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VideoStatusDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VideoStatusDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VideoStatusDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoStatusDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VideoStatusDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoStatusDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'videoLibraryId') int? videoLibraryId,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'status') int? status)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VideoStatusDto() when $default != null:
        return $default(_that.videoLibraryId, _that.videoGuid, _that.status);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'videoLibraryId') int? videoLibraryId,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'status') int? status)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoStatusDto():
        return $default(_that.videoLibraryId, _that.videoGuid, _that.status);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'videoLibraryId') int? videoLibraryId,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'status') int? status)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VideoStatusDto() when $default != null:
        return $default(_that.videoLibraryId, _that.videoGuid, _that.status);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VideoStatusDto implements VideoStatusDto {
  _VideoStatusDto(
      {@JsonKey(name: 'videoLibraryId') this.videoLibraryId,
      @JsonKey(name: 'videoGuid') this.videoGuid,
      @JsonKey(name: 'status') this.status});
  factory _VideoStatusDto.fromJson(Map<String, dynamic> json) =>
      _$VideoStatusDtoFromJson(json);

  @override
  @JsonKey(name: 'videoLibraryId')
  final int? videoLibraryId;
  @override
  @JsonKey(name: 'videoGuid')
  final String? videoGuid;
  @override
  @JsonKey(name: 'status')
  final int? status;

  /// Create a copy of VideoStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VideoStatusDtoCopyWith<_VideoStatusDto> get copyWith =>
      __$VideoStatusDtoCopyWithImpl<_VideoStatusDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VideoStatusDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VideoStatusDto &&
            (identical(other.videoLibraryId, videoLibraryId) ||
                other.videoLibraryId == videoLibraryId) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, videoLibraryId, videoGuid, status);

  @override
  String toString() {
    return 'VideoStatusDto(videoLibraryId: $videoLibraryId, videoGuid: $videoGuid, status: $status)';
  }
}

/// @nodoc
abstract mixin class _$VideoStatusDtoCopyWith<$Res>
    implements $VideoStatusDtoCopyWith<$Res> {
  factory _$VideoStatusDtoCopyWith(
          _VideoStatusDto value, $Res Function(_VideoStatusDto) _then) =
      __$VideoStatusDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'videoLibraryId') int? videoLibraryId,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'status') int? status});
}

/// @nodoc
class __$VideoStatusDtoCopyWithImpl<$Res>
    implements _$VideoStatusDtoCopyWith<$Res> {
  __$VideoStatusDtoCopyWithImpl(this._self, this._then);

  final _VideoStatusDto _self;
  final $Res Function(_VideoStatusDto) _then;

  /// Create a copy of VideoStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? videoLibraryId = freezed,
    Object? videoGuid = freezed,
    Object? status = freezed,
  }) {
    return _then(_VideoStatusDto(
      videoLibraryId: freezed == videoLibraryId
          ? _self.videoLibraryId
          : videoLibraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1AccountGetResponseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'profile')
  ProfileDto get profile;

  /// Create a copy of ApiV1AccountGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1AccountGetResponseDtoCopyWith<ApiV1AccountGetResponseDto>
      get copyWith =>
          _$ApiV1AccountGetResponseDtoCopyWithImpl<ApiV1AccountGetResponseDto>(
              this as ApiV1AccountGetResponseDto, _$identity);

  /// Serializes this ApiV1AccountGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1AccountGetResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'ApiV1AccountGetResponseDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class $ApiV1AccountGetResponseDtoCopyWith<$Res> {
  factory $ApiV1AccountGetResponseDtoCopyWith(ApiV1AccountGetResponseDto value,
          $Res Function(ApiV1AccountGetResponseDto) _then) =
      _$ApiV1AccountGetResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class _$ApiV1AccountGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1AccountGetResponseDtoCopyWith<$Res> {
  _$ApiV1AccountGetResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1AccountGetResponseDto _self;
  final $Res Function(ApiV1AccountGetResponseDto) _then;

  /// Create a copy of ApiV1AccountGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of ApiV1AccountGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1AccountGetResponseDto].
extension ApiV1AccountGetResponseDtoPatterns on ApiV1AccountGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1AccountGetResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1AccountGetResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1AccountGetResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountGetResponseDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountGetResponseDto():
        return $default(_that.id, _that.profile);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountGetResponseDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1AccountGetResponseDto implements ApiV1AccountGetResponseDto {
  _ApiV1AccountGetResponseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'profile') required this.profile});
  factory _ApiV1AccountGetResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1AccountGetResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'profile')
  final ProfileDto profile;

  /// Create a copy of ApiV1AccountGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1AccountGetResponseDtoCopyWith<_ApiV1AccountGetResponseDto>
      get copyWith => __$ApiV1AccountGetResponseDtoCopyWithImpl<
          _ApiV1AccountGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1AccountGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1AccountGetResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'ApiV1AccountGetResponseDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1AccountGetResponseDtoCopyWith<$Res>
    implements $ApiV1AccountGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1AccountGetResponseDtoCopyWith(
          _ApiV1AccountGetResponseDto value,
          $Res Function(_ApiV1AccountGetResponseDto) _then) =
      __$ApiV1AccountGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  @override
  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class __$ApiV1AccountGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1AccountGetResponseDtoCopyWith<$Res> {
  __$ApiV1AccountGetResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1AccountGetResponseDto _self;
  final $Res Function(_ApiV1AccountGetResponseDto) _then;

  /// Create a copy of ApiV1AccountGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_ApiV1AccountGetResponseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of ApiV1AccountGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1AccountPutResponseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'profile')
  ProfileDto get profile;

  /// Create a copy of ApiV1AccountPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1AccountPutResponseDtoCopyWith<ApiV1AccountPutResponseDto>
      get copyWith =>
          _$ApiV1AccountPutResponseDtoCopyWithImpl<ApiV1AccountPutResponseDto>(
              this as ApiV1AccountPutResponseDto, _$identity);

  /// Serializes this ApiV1AccountPutResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1AccountPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'ApiV1AccountPutResponseDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class $ApiV1AccountPutResponseDtoCopyWith<$Res> {
  factory $ApiV1AccountPutResponseDtoCopyWith(ApiV1AccountPutResponseDto value,
          $Res Function(ApiV1AccountPutResponseDto) _then) =
      _$ApiV1AccountPutResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class _$ApiV1AccountPutResponseDtoCopyWithImpl<$Res>
    implements $ApiV1AccountPutResponseDtoCopyWith<$Res> {
  _$ApiV1AccountPutResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1AccountPutResponseDto _self;
  final $Res Function(ApiV1AccountPutResponseDto) _then;

  /// Create a copy of ApiV1AccountPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of ApiV1AccountPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1AccountPutResponseDto].
extension ApiV1AccountPutResponseDtoPatterns on ApiV1AccountPutResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1AccountPutResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1AccountPutResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1AccountPutResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutResponseDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutResponseDto():
        return $default(_that.id, _that.profile);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutResponseDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1AccountPutResponseDto implements ApiV1AccountPutResponseDto {
  _ApiV1AccountPutResponseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'profile') required this.profile});
  factory _ApiV1AccountPutResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1AccountPutResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'profile')
  final ProfileDto profile;

  /// Create a copy of ApiV1AccountPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1AccountPutResponseDtoCopyWith<_ApiV1AccountPutResponseDto>
      get copyWith => __$ApiV1AccountPutResponseDtoCopyWithImpl<
          _ApiV1AccountPutResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1AccountPutResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1AccountPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'ApiV1AccountPutResponseDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1AccountPutResponseDtoCopyWith<$Res>
    implements $ApiV1AccountPutResponseDtoCopyWith<$Res> {
  factory _$ApiV1AccountPutResponseDtoCopyWith(
          _ApiV1AccountPutResponseDto value,
          $Res Function(_ApiV1AccountPutResponseDto) _then) =
      __$ApiV1AccountPutResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  @override
  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class __$ApiV1AccountPutResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1AccountPutResponseDtoCopyWith<$Res> {
  __$ApiV1AccountPutResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1AccountPutResponseDto _self;
  final $Res Function(_ApiV1AccountPutResponseDto) _then;

  /// Create a copy of ApiV1AccountPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_ApiV1AccountPutResponseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of ApiV1AccountPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1AccountPutRequestDto {
  @JsonKey(name: 'displayName')
  String get displayName;
  @JsonKey(name: 'username')
  String get username;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'isPrivate')
  bool? get isPrivate;

  /// Create a copy of ApiV1AccountPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1AccountPutRequestDtoCopyWith<ApiV1AccountPutRequestDto> get copyWith =>
      _$ApiV1AccountPutRequestDtoCopyWithImpl<ApiV1AccountPutRequestDto>(
          this as ApiV1AccountPutRequestDto, _$identity);

  /// Serializes this ApiV1AccountPutRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1AccountPutRequestDto &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, displayName, username, description, isPrivate);

  @override
  String toString() {
    return 'ApiV1AccountPutRequestDto(displayName: $displayName, username: $username, description: $description, isPrivate: $isPrivate)';
  }
}

/// @nodoc
abstract mixin class $ApiV1AccountPutRequestDtoCopyWith<$Res> {
  factory $ApiV1AccountPutRequestDtoCopyWith(ApiV1AccountPutRequestDto value,
          $Res Function(ApiV1AccountPutRequestDto) _then) =
      _$ApiV1AccountPutRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'displayName') String displayName,
      @JsonKey(name: 'username') String username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'isPrivate') bool? isPrivate});
}

/// @nodoc
class _$ApiV1AccountPutRequestDtoCopyWithImpl<$Res>
    implements $ApiV1AccountPutRequestDtoCopyWith<$Res> {
  _$ApiV1AccountPutRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1AccountPutRequestDto _self;
  final $Res Function(ApiV1AccountPutRequestDto) _then;

  /// Create a copy of ApiV1AccountPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayName = null,
    Object? username = null,
    Object? description = freezed,
    Object? isPrivate = freezed,
  }) {
    return _then(_self.copyWith(
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      username: null == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1AccountPutRequestDto].
extension ApiV1AccountPutRequestDtoPatterns on ApiV1AccountPutRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1AccountPutRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1AccountPutRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1AccountPutRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'displayName') String displayName,
            @JsonKey(name: 'username') String username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'isPrivate') bool? isPrivate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutRequestDto() when $default != null:
        return $default(_that.displayName, _that.username, _that.description,
            _that.isPrivate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'displayName') String displayName,
            @JsonKey(name: 'username') String username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'isPrivate') bool? isPrivate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutRequestDto():
        return $default(_that.displayName, _that.username, _that.description,
            _that.isPrivate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'displayName') String displayName,
            @JsonKey(name: 'username') String username,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'isPrivate') bool? isPrivate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountPutRequestDto() when $default != null:
        return $default(_that.displayName, _that.username, _that.description,
            _that.isPrivate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1AccountPutRequestDto implements ApiV1AccountPutRequestDto {
  _ApiV1AccountPutRequestDto(
      {@JsonKey(name: 'displayName') required this.displayName,
      @JsonKey(name: 'username') required this.username,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'isPrivate') this.isPrivate});
  factory _ApiV1AccountPutRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1AccountPutRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'displayName')
  final String displayName;
  @override
  @JsonKey(name: 'username')
  final String username;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'isPrivate')
  final bool? isPrivate;

  /// Create a copy of ApiV1AccountPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1AccountPutRequestDtoCopyWith<_ApiV1AccountPutRequestDto>
      get copyWith =>
          __$ApiV1AccountPutRequestDtoCopyWithImpl<_ApiV1AccountPutRequestDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1AccountPutRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1AccountPutRequestDto &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, displayName, username, description, isPrivate);

  @override
  String toString() {
    return 'ApiV1AccountPutRequestDto(displayName: $displayName, username: $username, description: $description, isPrivate: $isPrivate)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1AccountPutRequestDtoCopyWith<$Res>
    implements $ApiV1AccountPutRequestDtoCopyWith<$Res> {
  factory _$ApiV1AccountPutRequestDtoCopyWith(_ApiV1AccountPutRequestDto value,
          $Res Function(_ApiV1AccountPutRequestDto) _then) =
      __$ApiV1AccountPutRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'displayName') String displayName,
      @JsonKey(name: 'username') String username,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'isPrivate') bool? isPrivate});
}

/// @nodoc
class __$ApiV1AccountPutRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1AccountPutRequestDtoCopyWith<$Res> {
  __$ApiV1AccountPutRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1AccountPutRequestDto _self;
  final $Res Function(_ApiV1AccountPutRequestDto) _then;

  /// Create a copy of ApiV1AccountPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? displayName = null,
    Object? username = null,
    Object? description = freezed,
    Object? isPrivate = freezed,
  }) {
    return _then(_ApiV1AccountPutRequestDto(
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      username: null == username
          ? _self.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      isPrivate: freezed == isPrivate
          ? _self.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1AccountAvatarPutResponseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'profile')
  ProfileDto get profile;

  /// Create a copy of ApiV1AccountAvatarPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1AccountAvatarPutResponseDtoCopyWith<ApiV1AccountAvatarPutResponseDto>
      get copyWith => _$ApiV1AccountAvatarPutResponseDtoCopyWithImpl<
              ApiV1AccountAvatarPutResponseDto>(
          this as ApiV1AccountAvatarPutResponseDto, _$identity);

  /// Serializes this ApiV1AccountAvatarPutResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1AccountAvatarPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'ApiV1AccountAvatarPutResponseDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class $ApiV1AccountAvatarPutResponseDtoCopyWith<$Res> {
  factory $ApiV1AccountAvatarPutResponseDtoCopyWith(
          ApiV1AccountAvatarPutResponseDto value,
          $Res Function(ApiV1AccountAvatarPutResponseDto) _then) =
      _$ApiV1AccountAvatarPutResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class _$ApiV1AccountAvatarPutResponseDtoCopyWithImpl<$Res>
    implements $ApiV1AccountAvatarPutResponseDtoCopyWith<$Res> {
  _$ApiV1AccountAvatarPutResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1AccountAvatarPutResponseDto _self;
  final $Res Function(ApiV1AccountAvatarPutResponseDto) _then;

  /// Create a copy of ApiV1AccountAvatarPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of ApiV1AccountAvatarPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1AccountAvatarPutResponseDto].
extension ApiV1AccountAvatarPutResponseDtoPatterns
    on ApiV1AccountAvatarPutResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1AccountAvatarPutResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountAvatarPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1AccountAvatarPutResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountAvatarPutResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1AccountAvatarPutResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountAvatarPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountAvatarPutResponseDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountAvatarPutResponseDto():
        return $default(_that.id, _that.profile);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'id') String id,
            @JsonKey(name: 'profile') ProfileDto profile)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AccountAvatarPutResponseDto() when $default != null:
        return $default(_that.id, _that.profile);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1AccountAvatarPutResponseDto
    implements ApiV1AccountAvatarPutResponseDto {
  _ApiV1AccountAvatarPutResponseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'profile') required this.profile});
  factory _ApiV1AccountAvatarPutResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1AccountAvatarPutResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'profile')
  final ProfileDto profile;

  /// Create a copy of ApiV1AccountAvatarPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1AccountAvatarPutResponseDtoCopyWith<_ApiV1AccountAvatarPutResponseDto>
      get copyWith => __$ApiV1AccountAvatarPutResponseDtoCopyWithImpl<
          _ApiV1AccountAvatarPutResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1AccountAvatarPutResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1AccountAvatarPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.profile, profile) || other.profile == profile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, profile);

  @override
  String toString() {
    return 'ApiV1AccountAvatarPutResponseDto(id: $id, profile: $profile)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1AccountAvatarPutResponseDtoCopyWith<$Res>
    implements $ApiV1AccountAvatarPutResponseDtoCopyWith<$Res> {
  factory _$ApiV1AccountAvatarPutResponseDtoCopyWith(
          _ApiV1AccountAvatarPutResponseDto value,
          $Res Function(_ApiV1AccountAvatarPutResponseDto) _then) =
      __$ApiV1AccountAvatarPutResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'profile') ProfileDto profile});

  @override
  $ProfileDtoCopyWith<$Res> get profile;
}

/// @nodoc
class __$ApiV1AccountAvatarPutResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1AccountAvatarPutResponseDtoCopyWith<$Res> {
  __$ApiV1AccountAvatarPutResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1AccountAvatarPutResponseDto _self;
  final $Res Function(_ApiV1AccountAvatarPutResponseDto) _then;

  /// Create a copy of ApiV1AccountAvatarPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? profile = null,
  }) {
    return _then(_ApiV1AccountAvatarPutResponseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      profile: null == profile
          ? _self.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as ProfileDto,
    ));
  }

  /// Create a copy of ApiV1AccountAvatarPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProfileDtoCopyWith<$Res> get profile {
    return $ProfileDtoCopyWith<$Res>(_self.profile, (value) {
      return _then(_self.copyWith(profile: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1AuthLoginPostResponseDto {
  @JsonKey(name: 'token')
  String? get token;
  @JsonKey(name: 'uid')
  String? get uid;

  /// Create a copy of ApiV1AuthLoginPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1AuthLoginPostResponseDtoCopyWith<ApiV1AuthLoginPostResponseDto>
      get copyWith => _$ApiV1AuthLoginPostResponseDtoCopyWithImpl<
              ApiV1AuthLoginPostResponseDto>(
          this as ApiV1AuthLoginPostResponseDto, _$identity);

  /// Serializes this ApiV1AuthLoginPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1AuthLoginPostResponseDto &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.uid, uid) || other.uid == uid));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, token, uid);

  @override
  String toString() {
    return 'ApiV1AuthLoginPostResponseDto(token: $token, uid: $uid)';
  }
}

/// @nodoc
abstract mixin class $ApiV1AuthLoginPostResponseDtoCopyWith<$Res> {
  factory $ApiV1AuthLoginPostResponseDtoCopyWith(
          ApiV1AuthLoginPostResponseDto value,
          $Res Function(ApiV1AuthLoginPostResponseDto) _then) =
      _$ApiV1AuthLoginPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'token') String? token,
      @JsonKey(name: 'uid') String? uid});
}

/// @nodoc
class _$ApiV1AuthLoginPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1AuthLoginPostResponseDtoCopyWith<$Res> {
  _$ApiV1AuthLoginPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1AuthLoginPostResponseDto _self;
  final $Res Function(ApiV1AuthLoginPostResponseDto) _then;

  /// Create a copy of ApiV1AuthLoginPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = freezed,
    Object? uid = freezed,
  }) {
    return _then(_self.copyWith(
      token: freezed == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      uid: freezed == uid
          ? _self.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1AuthLoginPostResponseDto].
extension ApiV1AuthLoginPostResponseDtoPatterns
    on ApiV1AuthLoginPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1AuthLoginPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1AuthLoginPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1AuthLoginPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'token') String? token,
            @JsonKey(name: 'uid') String? uid)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostResponseDto() when $default != null:
        return $default(_that.token, _that.uid);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'token') String? token,
            @JsonKey(name: 'uid') String? uid)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostResponseDto():
        return $default(_that.token, _that.uid);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'token') String? token,
            @JsonKey(name: 'uid') String? uid)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostResponseDto() when $default != null:
        return $default(_that.token, _that.uid);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1AuthLoginPostResponseDto implements ApiV1AuthLoginPostResponseDto {
  _ApiV1AuthLoginPostResponseDto(
      {@JsonKey(name: 'token') this.token, @JsonKey(name: 'uid') this.uid});
  factory _ApiV1AuthLoginPostResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1AuthLoginPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'token')
  final String? token;
  @override
  @JsonKey(name: 'uid')
  final String? uid;

  /// Create a copy of ApiV1AuthLoginPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1AuthLoginPostResponseDtoCopyWith<_ApiV1AuthLoginPostResponseDto>
      get copyWith => __$ApiV1AuthLoginPostResponseDtoCopyWithImpl<
          _ApiV1AuthLoginPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1AuthLoginPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1AuthLoginPostResponseDto &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.uid, uid) || other.uid == uid));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, token, uid);

  @override
  String toString() {
    return 'ApiV1AuthLoginPostResponseDto(token: $token, uid: $uid)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1AuthLoginPostResponseDtoCopyWith<$Res>
    implements $ApiV1AuthLoginPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1AuthLoginPostResponseDtoCopyWith(
          _ApiV1AuthLoginPostResponseDto value,
          $Res Function(_ApiV1AuthLoginPostResponseDto) _then) =
      __$ApiV1AuthLoginPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'token') String? token,
      @JsonKey(name: 'uid') String? uid});
}

/// @nodoc
class __$ApiV1AuthLoginPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1AuthLoginPostResponseDtoCopyWith<$Res> {
  __$ApiV1AuthLoginPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1AuthLoginPostResponseDto _self;
  final $Res Function(_ApiV1AuthLoginPostResponseDto) _then;

  /// Create a copy of ApiV1AuthLoginPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? token = freezed,
    Object? uid = freezed,
  }) {
    return _then(_ApiV1AuthLoginPostResponseDto(
      token: freezed == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      uid: freezed == uid
          ? _self.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1AuthLoginPostRequestDto {
  @JsonKey(name: 'email')
  String get email;
  @JsonKey(name: 'password')
  String get password;

  /// Create a copy of ApiV1AuthLoginPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1AuthLoginPostRequestDtoCopyWith<ApiV1AuthLoginPostRequestDto>
      get copyWith => _$ApiV1AuthLoginPostRequestDtoCopyWithImpl<
              ApiV1AuthLoginPostRequestDto>(
          this as ApiV1AuthLoginPostRequestDto, _$identity);

  /// Serializes this ApiV1AuthLoginPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1AuthLoginPostRequestDto &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email, password);

  @override
  String toString() {
    return 'ApiV1AuthLoginPostRequestDto(email: $email, password: $password)';
  }
}

/// @nodoc
abstract mixin class $ApiV1AuthLoginPostRequestDtoCopyWith<$Res> {
  factory $ApiV1AuthLoginPostRequestDtoCopyWith(
          ApiV1AuthLoginPostRequestDto value,
          $Res Function(ApiV1AuthLoginPostRequestDto) _then) =
      _$ApiV1AuthLoginPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'email') String email,
      @JsonKey(name: 'password') String password});
}

/// @nodoc
class _$ApiV1AuthLoginPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1AuthLoginPostRequestDtoCopyWith<$Res> {
  _$ApiV1AuthLoginPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1AuthLoginPostRequestDto _self;
  final $Res Function(ApiV1AuthLoginPostRequestDto) _then;

  /// Create a copy of ApiV1AuthLoginPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
    Object? password = null,
  }) {
    return _then(_self.copyWith(
      email: null == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1AuthLoginPostRequestDto].
extension ApiV1AuthLoginPostRequestDtoPatterns on ApiV1AuthLoginPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1AuthLoginPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1AuthLoginPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1AuthLoginPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'email') String email,
            @JsonKey(name: 'password') String password)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostRequestDto() when $default != null:
        return $default(_that.email, _that.password);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'email') String email,
            @JsonKey(name: 'password') String password)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostRequestDto():
        return $default(_that.email, _that.password);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'email') String email,
            @JsonKey(name: 'password') String password)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1AuthLoginPostRequestDto() when $default != null:
        return $default(_that.email, _that.password);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1AuthLoginPostRequestDto implements ApiV1AuthLoginPostRequestDto {
  _ApiV1AuthLoginPostRequestDto(
      {@JsonKey(name: 'email') required this.email,
      @JsonKey(name: 'password') required this.password});
  factory _ApiV1AuthLoginPostRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1AuthLoginPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'email')
  final String email;
  @override
  @JsonKey(name: 'password')
  final String password;

  /// Create a copy of ApiV1AuthLoginPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1AuthLoginPostRequestDtoCopyWith<_ApiV1AuthLoginPostRequestDto>
      get copyWith => __$ApiV1AuthLoginPostRequestDtoCopyWithImpl<
          _ApiV1AuthLoginPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1AuthLoginPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1AuthLoginPostRequestDto &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email, password);

  @override
  String toString() {
    return 'ApiV1AuthLoginPostRequestDto(email: $email, password: $password)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1AuthLoginPostRequestDtoCopyWith<$Res>
    implements $ApiV1AuthLoginPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1AuthLoginPostRequestDtoCopyWith(
          _ApiV1AuthLoginPostRequestDto value,
          $Res Function(_ApiV1AuthLoginPostRequestDto) _then) =
      __$ApiV1AuthLoginPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'email') String email,
      @JsonKey(name: 'password') String password});
}

/// @nodoc
class __$ApiV1AuthLoginPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1AuthLoginPostRequestDtoCopyWith<$Res> {
  __$ApiV1AuthLoginPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1AuthLoginPostRequestDto _self;
  final $Res Function(_ApiV1AuthLoginPostRequestDto) _then;

  /// Create a copy of ApiV1AuthLoginPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? email = null,
    Object? password = null,
  }) {
    return _then(_ApiV1AuthLoginPostRequestDto(
      email: null == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ApiV1UsersIdGetResponseDto {
  @JsonKey(name: 'userDetail')
  UserDetailDto get userDetail;
  @JsonKey(name: 'badgesCount')
  int? get badgesCount;
  @JsonKey(name: 'badgesUsers')
  List<UserDto>? get badgesUsers;
  @JsonKey(name: 'supportersCount')
  int? get supportersCount;
  @JsonKey(name: 'supportersUsers')
  List<dynamic>? get supportersUsers;
  @JsonKey(name: 'followersCount')
  int? get followersCount;
  @JsonKey(name: 'followingsCount')
  int? get followingsCount;

  /// Create a copy of ApiV1UsersIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1UsersIdGetResponseDtoCopyWith<ApiV1UsersIdGetResponseDto>
      get copyWith =>
          _$ApiV1UsersIdGetResponseDtoCopyWithImpl<ApiV1UsersIdGetResponseDto>(
              this as ApiV1UsersIdGetResponseDto, _$identity);

  /// Serializes this ApiV1UsersIdGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1UsersIdGetResponseDto &&
            (identical(other.userDetail, userDetail) ||
                other.userDetail == userDetail) &&
            (identical(other.badgesCount, badgesCount) ||
                other.badgesCount == badgesCount) &&
            const DeepCollectionEquality()
                .equals(other.badgesUsers, badgesUsers) &&
            (identical(other.supportersCount, supportersCount) ||
                other.supportersCount == supportersCount) &&
            const DeepCollectionEquality()
                .equals(other.supportersUsers, supportersUsers) &&
            (identical(other.followersCount, followersCount) ||
                other.followersCount == followersCount) &&
            (identical(other.followingsCount, followingsCount) ||
                other.followingsCount == followingsCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      userDetail,
      badgesCount,
      const DeepCollectionEquality().hash(badgesUsers),
      supportersCount,
      const DeepCollectionEquality().hash(supportersUsers),
      followersCount,
      followingsCount);

  @override
  String toString() {
    return 'ApiV1UsersIdGetResponseDto(userDetail: $userDetail, badgesCount: $badgesCount, badgesUsers: $badgesUsers, supportersCount: $supportersCount, supportersUsers: $supportersUsers, followersCount: $followersCount, followingsCount: $followingsCount)';
  }
}

/// @nodoc
abstract mixin class $ApiV1UsersIdGetResponseDtoCopyWith<$Res> {
  factory $ApiV1UsersIdGetResponseDtoCopyWith(ApiV1UsersIdGetResponseDto value,
          $Res Function(ApiV1UsersIdGetResponseDto) _then) =
      _$ApiV1UsersIdGetResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'userDetail') UserDetailDto userDetail,
      @JsonKey(name: 'badgesCount') int? badgesCount,
      @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
      @JsonKey(name: 'supportersCount') int? supportersCount,
      @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
      @JsonKey(name: 'followersCount') int? followersCount,
      @JsonKey(name: 'followingsCount') int? followingsCount});

  $UserDetailDtoCopyWith<$Res> get userDetail;
}

/// @nodoc
class _$ApiV1UsersIdGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1UsersIdGetResponseDtoCopyWith<$Res> {
  _$ApiV1UsersIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1UsersIdGetResponseDto _self;
  final $Res Function(ApiV1UsersIdGetResponseDto) _then;

  /// Create a copy of ApiV1UsersIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userDetail = null,
    Object? badgesCount = freezed,
    Object? badgesUsers = freezed,
    Object? supportersCount = freezed,
    Object? supportersUsers = freezed,
    Object? followersCount = freezed,
    Object? followingsCount = freezed,
  }) {
    return _then(_self.copyWith(
      userDetail: null == userDetail
          ? _self.userDetail
          : userDetail // ignore: cast_nullable_to_non_nullable
              as UserDetailDto,
      badgesCount: freezed == badgesCount
          ? _self.badgesCount
          : badgesCount // ignore: cast_nullable_to_non_nullable
              as int?,
      badgesUsers: freezed == badgesUsers
          ? _self.badgesUsers
          : badgesUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      supportersCount: freezed == supportersCount
          ? _self.supportersCount
          : supportersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      supportersUsers: freezed == supportersUsers
          ? _self.supportersUsers
          : supportersUsers // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      followersCount: freezed == followersCount
          ? _self.followersCount
          : followersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      followingsCount: freezed == followingsCount
          ? _self.followingsCount
          : followingsCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ApiV1UsersIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDtoCopyWith<$Res> get userDetail {
    return $UserDetailDtoCopyWith<$Res>(_self.userDetail, (value) {
      return _then(_self.copyWith(userDetail: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1UsersIdGetResponseDto].
extension ApiV1UsersIdGetResponseDtoPatterns on ApiV1UsersIdGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1UsersIdGetResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1UsersIdGetResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersIdGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1UsersIdGetResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'userDetail') UserDetailDto userDetail,
            @JsonKey(name: 'badgesCount') int? badgesCount,
            @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
            @JsonKey(name: 'supportersCount') int? supportersCount,
            @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
            @JsonKey(name: 'followersCount') int? followersCount,
            @JsonKey(name: 'followingsCount') int? followingsCount)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersIdGetResponseDto() when $default != null:
        return $default(
            _that.userDetail,
            _that.badgesCount,
            _that.badgesUsers,
            _that.supportersCount,
            _that.supportersUsers,
            _that.followersCount,
            _that.followingsCount);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'userDetail') UserDetailDto userDetail,
            @JsonKey(name: 'badgesCount') int? badgesCount,
            @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
            @JsonKey(name: 'supportersCount') int? supportersCount,
            @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
            @JsonKey(name: 'followersCount') int? followersCount,
            @JsonKey(name: 'followingsCount') int? followingsCount)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersIdGetResponseDto():
        return $default(
            _that.userDetail,
            _that.badgesCount,
            _that.badgesUsers,
            _that.supportersCount,
            _that.supportersUsers,
            _that.followersCount,
            _that.followingsCount);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'userDetail') UserDetailDto userDetail,
            @JsonKey(name: 'badgesCount') int? badgesCount,
            @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
            @JsonKey(name: 'supportersCount') int? supportersCount,
            @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
            @JsonKey(name: 'followersCount') int? followersCount,
            @JsonKey(name: 'followingsCount') int? followingsCount)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersIdGetResponseDto() when $default != null:
        return $default(
            _that.userDetail,
            _that.badgesCount,
            _that.badgesUsers,
            _that.supportersCount,
            _that.supportersUsers,
            _that.followersCount,
            _that.followingsCount);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1UsersIdGetResponseDto implements ApiV1UsersIdGetResponseDto {
  _ApiV1UsersIdGetResponseDto(
      {@JsonKey(name: 'userDetail') required this.userDetail,
      @JsonKey(name: 'badgesCount') this.badgesCount,
      @JsonKey(name: 'badgesUsers') final List<UserDto>? badgesUsers,
      @JsonKey(name: 'supportersCount') this.supportersCount,
      @JsonKey(name: 'supportersUsers') final List<dynamic>? supportersUsers,
      @JsonKey(name: 'followersCount') this.followersCount,
      @JsonKey(name: 'followingsCount') this.followingsCount})
      : _badgesUsers = badgesUsers,
        _supportersUsers = supportersUsers;
  factory _ApiV1UsersIdGetResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1UsersIdGetResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'userDetail')
  final UserDetailDto userDetail;
  @override
  @JsonKey(name: 'badgesCount')
  final int? badgesCount;
  final List<UserDto>? _badgesUsers;
  @override
  @JsonKey(name: 'badgesUsers')
  List<UserDto>? get badgesUsers {
    final value = _badgesUsers;
    if (value == null) return null;
    if (_badgesUsers is EqualUnmodifiableListView) return _badgesUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'supportersCount')
  final int? supportersCount;
  final List<dynamic>? _supportersUsers;
  @override
  @JsonKey(name: 'supportersUsers')
  List<dynamic>? get supportersUsers {
    final value = _supportersUsers;
    if (value == null) return null;
    if (_supportersUsers is EqualUnmodifiableListView) return _supportersUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'followersCount')
  final int? followersCount;
  @override
  @JsonKey(name: 'followingsCount')
  final int? followingsCount;

  /// Create a copy of ApiV1UsersIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1UsersIdGetResponseDtoCopyWith<_ApiV1UsersIdGetResponseDto>
      get copyWith => __$ApiV1UsersIdGetResponseDtoCopyWithImpl<
          _ApiV1UsersIdGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1UsersIdGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1UsersIdGetResponseDto &&
            (identical(other.userDetail, userDetail) ||
                other.userDetail == userDetail) &&
            (identical(other.badgesCount, badgesCount) ||
                other.badgesCount == badgesCount) &&
            const DeepCollectionEquality()
                .equals(other._badgesUsers, _badgesUsers) &&
            (identical(other.supportersCount, supportersCount) ||
                other.supportersCount == supportersCount) &&
            const DeepCollectionEquality()
                .equals(other._supportersUsers, _supportersUsers) &&
            (identical(other.followersCount, followersCount) ||
                other.followersCount == followersCount) &&
            (identical(other.followingsCount, followingsCount) ||
                other.followingsCount == followingsCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      userDetail,
      badgesCount,
      const DeepCollectionEquality().hash(_badgesUsers),
      supportersCount,
      const DeepCollectionEquality().hash(_supportersUsers),
      followersCount,
      followingsCount);

  @override
  String toString() {
    return 'ApiV1UsersIdGetResponseDto(userDetail: $userDetail, badgesCount: $badgesCount, badgesUsers: $badgesUsers, supportersCount: $supportersCount, supportersUsers: $supportersUsers, followersCount: $followersCount, followingsCount: $followingsCount)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1UsersIdGetResponseDtoCopyWith<$Res>
    implements $ApiV1UsersIdGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1UsersIdGetResponseDtoCopyWith(
          _ApiV1UsersIdGetResponseDto value,
          $Res Function(_ApiV1UsersIdGetResponseDto) _then) =
      __$ApiV1UsersIdGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'userDetail') UserDetailDto userDetail,
      @JsonKey(name: 'badgesCount') int? badgesCount,
      @JsonKey(name: 'badgesUsers') List<UserDto>? badgesUsers,
      @JsonKey(name: 'supportersCount') int? supportersCount,
      @JsonKey(name: 'supportersUsers') List<dynamic>? supportersUsers,
      @JsonKey(name: 'followersCount') int? followersCount,
      @JsonKey(name: 'followingsCount') int? followingsCount});

  @override
  $UserDetailDtoCopyWith<$Res> get userDetail;
}

/// @nodoc
class __$ApiV1UsersIdGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1UsersIdGetResponseDtoCopyWith<$Res> {
  __$ApiV1UsersIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1UsersIdGetResponseDto _self;
  final $Res Function(_ApiV1UsersIdGetResponseDto) _then;

  /// Create a copy of ApiV1UsersIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? userDetail = null,
    Object? badgesCount = freezed,
    Object? badgesUsers = freezed,
    Object? supportersCount = freezed,
    Object? supportersUsers = freezed,
    Object? followersCount = freezed,
    Object? followingsCount = freezed,
  }) {
    return _then(_ApiV1UsersIdGetResponseDto(
      userDetail: null == userDetail
          ? _self.userDetail
          : userDetail // ignore: cast_nullable_to_non_nullable
              as UserDetailDto,
      badgesCount: freezed == badgesCount
          ? _self.badgesCount
          : badgesCount // ignore: cast_nullable_to_non_nullable
              as int?,
      badgesUsers: freezed == badgesUsers
          ? _self._badgesUsers
          : badgesUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      supportersCount: freezed == supportersCount
          ? _self.supportersCount
          : supportersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      supportersUsers: freezed == supportersUsers
          ? _self._supportersUsers
          : supportersUsers // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      followersCount: freezed == followersCount
          ? _self.followersCount
          : followersCount // ignore: cast_nullable_to_non_nullable
              as int?,
      followingsCount: freezed == followingsCount
          ? _self.followingsCount
          : followingsCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ApiV1UsersIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDtoCopyWith<$Res> get userDetail {
    return $UserDetailDtoCopyWith<$Res>(_self.userDetail, (value) {
      return _then(_self.copyWith(userDetail: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1StepsPostResponseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'user')
  UserDto get user;
  @JsonKey(name: 'journeyId')
  String? get journeyId;
  @JsonKey(name: 'journey')
  JourneyDto? get journey;
  @JsonKey(name: 'hearts')
  int? get hearts;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;
  @JsonKey(name: 'shares')
  int? get shares;
  @JsonKey(name: 'sharedByUser')
  bool? get sharedByUser;
  @JsonKey(name: 'comments')
  int? get comments;
  @JsonKey(name: 'commentedByUser')
  bool? get commentedByUser;
  @JsonKey(name: 'userSteppedWithInteractions')
  int? get userSteppedWithInteractions;
  @JsonKey(name: 'othersStepWith')
  int? get othersStepWith;
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers;
  @JsonKey(name: 'stepTypeString')
  String? get stepTypeString;
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media;

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsPostResponseDtoCopyWith<ApiV1StepsPostResponseDto> get copyWith =>
      _$ApiV1StepsPostResponseDtoCopyWithImpl<ApiV1StepsPostResponseDto>(
          this as ApiV1StepsPostResponseDto, _$identity);

  /// Serializes this ApiV1StepsPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other.othersStepWithUsers, othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other.media, media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(media)
      ]);

  @override
  String toString() {
    return 'ApiV1StepsPostResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsPostResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsPostResponseDtoCopyWith(ApiV1StepsPostResponseDto value,
          $Res Function(ApiV1StepsPostResponseDto) _then) =
      _$ApiV1StepsPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  $UserDtoCopyWith<$Res> get user;
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class _$ApiV1StepsPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsPostResponseDtoCopyWith<$Res> {
  _$ApiV1StepsPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsPostResponseDto _self;
  final $Res Function(ApiV1StepsPostResponseDto) _then;

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self.othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsPostResponseDto].
extension ApiV1StepsPostResponseDtoPatterns on ApiV1StepsPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostResponseDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsPostResponseDto implements ApiV1StepsPostResponseDto {
  _ApiV1StepsPostResponseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'user') required this.user,
      @JsonKey(name: 'journeyId') this.journeyId,
      @JsonKey(name: 'journey') this.journey,
      @JsonKey(name: 'hearts') this.hearts,
      @JsonKey(name: 'heartedByUser') this.heartedByUser,
      @JsonKey(name: 'shares') this.shares,
      @JsonKey(name: 'sharedByUser') this.sharedByUser,
      @JsonKey(name: 'comments') this.comments,
      @JsonKey(name: 'commentedByUser') this.commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      this.userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') this.othersStepWith,
      @JsonKey(name: 'othersStepWithUsers')
      final List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') this.stepTypeString,
      @JsonKey(name: 'media') final List<StepMediaDto>? media})
      : _othersStepWithUsers = othersStepWithUsers,
        _media = media;
  factory _ApiV1StepsPostResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1StepsPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'user')
  final UserDto user;
  @override
  @JsonKey(name: 'journeyId')
  final String? journeyId;
  @override
  @JsonKey(name: 'journey')
  final JourneyDto? journey;
  @override
  @JsonKey(name: 'hearts')
  final int? hearts;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;
  @override
  @JsonKey(name: 'shares')
  final int? shares;
  @override
  @JsonKey(name: 'sharedByUser')
  final bool? sharedByUser;
  @override
  @JsonKey(name: 'comments')
  final int? comments;
  @override
  @JsonKey(name: 'commentedByUser')
  final bool? commentedByUser;
  @override
  @JsonKey(name: 'userSteppedWithInteractions')
  final int? userSteppedWithInteractions;
  @override
  @JsonKey(name: 'othersStepWith')
  final int? othersStepWith;
  final List<UserDto>? _othersStepWithUsers;
  @override
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers {
    final value = _othersStepWithUsers;
    if (value == null) return null;
    if (_othersStepWithUsers is EqualUnmodifiableListView)
      return _othersStepWithUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'stepTypeString')
  final String? stepTypeString;
  final List<StepMediaDto>? _media;
  @override
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media {
    final value = _media;
    if (value == null) return null;
    if (_media is EqualUnmodifiableListView) return _media;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsPostResponseDtoCopyWith<_ApiV1StepsPostResponseDto>
      get copyWith =>
          __$ApiV1StepsPostResponseDtoCopyWithImpl<_ApiV1StepsPostResponseDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other._othersStepWithUsers, _othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other._media, _media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(_othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(_media)
      ]);

  @override
  String toString() {
    return 'ApiV1StepsPostResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsPostResponseDtoCopyWith<$Res>
    implements $ApiV1StepsPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsPostResponseDtoCopyWith(_ApiV1StepsPostResponseDto value,
          $Res Function(_ApiV1StepsPostResponseDto) _then) =
      __$ApiV1StepsPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  @override
  $UserDtoCopyWith<$Res> get user;
  @override
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class __$ApiV1StepsPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsPostResponseDtoCopyWith<$Res> {
  __$ApiV1StepsPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsPostResponseDto _self;
  final $Res Function(_ApiV1StepsPostResponseDto) _then;

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_ApiV1StepsPostResponseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self._othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self._media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1StepsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1StepsPostRequestDto {
  @JsonKey(name: 'content')
  String get content;
  @JsonKey(name: 'journeyId')
  String get journeyId;

  /// Create a copy of ApiV1StepsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsPostRequestDtoCopyWith<ApiV1StepsPostRequestDto> get copyWith =>
      _$ApiV1StepsPostRequestDtoCopyWithImpl<ApiV1StepsPostRequestDto>(
          this as ApiV1StepsPostRequestDto, _$identity);

  /// Serializes this ApiV1StepsPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsPostRequestDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content, journeyId);

  @override
  String toString() {
    return 'ApiV1StepsPostRequestDto(content: $content, journeyId: $journeyId)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsPostRequestDtoCopyWith<$Res> {
  factory $ApiV1StepsPostRequestDtoCopyWith(ApiV1StepsPostRequestDto value,
          $Res Function(ApiV1StepsPostRequestDto) _then) =
      _$ApiV1StepsPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'journeyId') String journeyId});
}

/// @nodoc
class _$ApiV1StepsPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1StepsPostRequestDtoCopyWith<$Res> {
  _$ApiV1StepsPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsPostRequestDto _self;
  final $Res Function(ApiV1StepsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
    Object? journeyId = null,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      journeyId: null == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsPostRequestDto].
extension ApiV1StepsPostRequestDtoPatterns on ApiV1StepsPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content,
            @JsonKey(name: 'journeyId') String journeyId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostRequestDto() when $default != null:
        return $default(_that.content, _that.journeyId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content,
            @JsonKey(name: 'journeyId') String journeyId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostRequestDto():
        return $default(_that.content, _that.journeyId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'content') String content,
            @JsonKey(name: 'journeyId') String journeyId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsPostRequestDto() when $default != null:
        return $default(_that.content, _that.journeyId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsPostRequestDto implements ApiV1StepsPostRequestDto {
  _ApiV1StepsPostRequestDto(
      {@JsonKey(name: 'content') required this.content,
      @JsonKey(name: 'journeyId') required this.journeyId});
  factory _ApiV1StepsPostRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1StepsPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;
  @override
  @JsonKey(name: 'journeyId')
  final String journeyId;

  /// Create a copy of ApiV1StepsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsPostRequestDtoCopyWith<_ApiV1StepsPostRequestDto> get copyWith =>
      __$ApiV1StepsPostRequestDtoCopyWithImpl<_ApiV1StepsPostRequestDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsPostRequestDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content, journeyId);

  @override
  String toString() {
    return 'ApiV1StepsPostRequestDto(content: $content, journeyId: $journeyId)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsPostRequestDtoCopyWith<$Res>
    implements $ApiV1StepsPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1StepsPostRequestDtoCopyWith(_ApiV1StepsPostRequestDto value,
          $Res Function(_ApiV1StepsPostRequestDto) _then) =
      __$ApiV1StepsPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'journeyId') String journeyId});
}

/// @nodoc
class __$ApiV1StepsPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsPostRequestDtoCopyWith<$Res> {
  __$ApiV1StepsPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsPostRequestDto _self;
  final $Res Function(_ApiV1StepsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
    Object? journeyId = null,
  }) {
    return _then(_ApiV1StepsPostRequestDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      journeyId: null == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdGetResponseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'user')
  UserDto get user;
  @JsonKey(name: 'journeyId')
  String? get journeyId;
  @JsonKey(name: 'journey')
  JourneyDto? get journey;
  @JsonKey(name: 'hearts')
  int? get hearts;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;
  @JsonKey(name: 'shares')
  int? get shares;
  @JsonKey(name: 'sharedByUser')
  bool? get sharedByUser;
  @JsonKey(name: 'comments')
  int? get comments;
  @JsonKey(name: 'commentedByUser')
  bool? get commentedByUser;
  @JsonKey(name: 'userSteppedWithInteractions')
  int? get userSteppedWithInteractions;
  @JsonKey(name: 'othersStepWith')
  int? get othersStepWith;
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers;
  @JsonKey(name: 'stepTypeString')
  String? get stepTypeString;
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media;

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdGetResponseDtoCopyWith<ApiV1StepsStepIdGetResponseDto>
      get copyWith => _$ApiV1StepsStepIdGetResponseDtoCopyWithImpl<
              ApiV1StepsStepIdGetResponseDto>(
          this as ApiV1StepsStepIdGetResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdGetResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other.othersStepWithUsers, othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other.media, media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(media)
      ]);

  @override
  String toString() {
    return 'ApiV1StepsStepIdGetResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdGetResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdGetResponseDtoCopyWith(
          ApiV1StepsStepIdGetResponseDto value,
          $Res Function(ApiV1StepsStepIdGetResponseDto) _then) =
      _$ApiV1StepsStepIdGetResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  $UserDtoCopyWith<$Res> get user;
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class _$ApiV1StepsStepIdGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdGetResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdGetResponseDto _self;
  final $Res Function(ApiV1StepsStepIdGetResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self.othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdGetResponseDto].
extension ApiV1StepsStepIdGetResponseDtoPatterns
    on ApiV1StepsStepIdGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdGetResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdGetResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdGetResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdGetResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdGetResponseDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdGetResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdGetResponseDto
    implements ApiV1StepsStepIdGetResponseDto {
  _ApiV1StepsStepIdGetResponseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'user') required this.user,
      @JsonKey(name: 'journeyId') this.journeyId,
      @JsonKey(name: 'journey') this.journey,
      @JsonKey(name: 'hearts') this.hearts,
      @JsonKey(name: 'heartedByUser') this.heartedByUser,
      @JsonKey(name: 'shares') this.shares,
      @JsonKey(name: 'sharedByUser') this.sharedByUser,
      @JsonKey(name: 'comments') this.comments,
      @JsonKey(name: 'commentedByUser') this.commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      this.userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') this.othersStepWith,
      @JsonKey(name: 'othersStepWithUsers')
      final List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') this.stepTypeString,
      @JsonKey(name: 'media') final List<StepMediaDto>? media})
      : _othersStepWithUsers = othersStepWithUsers,
        _media = media;
  factory _ApiV1StepsStepIdGetResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdGetResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'user')
  final UserDto user;
  @override
  @JsonKey(name: 'journeyId')
  final String? journeyId;
  @override
  @JsonKey(name: 'journey')
  final JourneyDto? journey;
  @override
  @JsonKey(name: 'hearts')
  final int? hearts;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;
  @override
  @JsonKey(name: 'shares')
  final int? shares;
  @override
  @JsonKey(name: 'sharedByUser')
  final bool? sharedByUser;
  @override
  @JsonKey(name: 'comments')
  final int? comments;
  @override
  @JsonKey(name: 'commentedByUser')
  final bool? commentedByUser;
  @override
  @JsonKey(name: 'userSteppedWithInteractions')
  final int? userSteppedWithInteractions;
  @override
  @JsonKey(name: 'othersStepWith')
  final int? othersStepWith;
  final List<UserDto>? _othersStepWithUsers;
  @override
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers {
    final value = _othersStepWithUsers;
    if (value == null) return null;
    if (_othersStepWithUsers is EqualUnmodifiableListView)
      return _othersStepWithUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'stepTypeString')
  final String? stepTypeString;
  final List<StepMediaDto>? _media;
  @override
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media {
    final value = _media;
    if (value == null) return null;
    if (_media is EqualUnmodifiableListView) return _media;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdGetResponseDtoCopyWith<_ApiV1StepsStepIdGetResponseDto>
      get copyWith => __$ApiV1StepsStepIdGetResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdGetResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other._othersStepWithUsers, _othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other._media, _media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(_othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(_media)
      ]);

  @override
  String toString() {
    return 'ApiV1StepsStepIdGetResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdGetResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdGetResponseDtoCopyWith(
          _ApiV1StepsStepIdGetResponseDto value,
          $Res Function(_ApiV1StepsStepIdGetResponseDto) _then) =
      __$ApiV1StepsStepIdGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  @override
  $UserDtoCopyWith<$Res> get user;
  @override
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class __$ApiV1StepsStepIdGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdGetResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdGetResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdGetResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_ApiV1StepsStepIdGetResponseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self._othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self._media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1StepsStepIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdPutResponseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'user')
  UserDto get user;
  @JsonKey(name: 'journeyId')
  String? get journeyId;
  @JsonKey(name: 'journey')
  JourneyDto? get journey;
  @JsonKey(name: 'hearts')
  int? get hearts;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;
  @JsonKey(name: 'shares')
  int? get shares;
  @JsonKey(name: 'sharedByUser')
  bool? get sharedByUser;
  @JsonKey(name: 'comments')
  int? get comments;
  @JsonKey(name: 'commentedByUser')
  bool? get commentedByUser;
  @JsonKey(name: 'userSteppedWithInteractions')
  int? get userSteppedWithInteractions;
  @JsonKey(name: 'othersStepWith')
  int? get othersStepWith;
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers;
  @JsonKey(name: 'stepTypeString')
  String? get stepTypeString;
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media;

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdPutResponseDtoCopyWith<ApiV1StepsStepIdPutResponseDto>
      get copyWith => _$ApiV1StepsStepIdPutResponseDtoCopyWithImpl<
              ApiV1StepsStepIdPutResponseDto>(
          this as ApiV1StepsStepIdPutResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdPutResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other.othersStepWithUsers, othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other.media, media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(media)
      ]);

  @override
  String toString() {
    return 'ApiV1StepsStepIdPutResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdPutResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdPutResponseDtoCopyWith(
          ApiV1StepsStepIdPutResponseDto value,
          $Res Function(ApiV1StepsStepIdPutResponseDto) _then) =
      _$ApiV1StepsStepIdPutResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  $UserDtoCopyWith<$Res> get user;
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class _$ApiV1StepsStepIdPutResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdPutResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdPutResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdPutResponseDto _self;
  final $Res Function(ApiV1StepsStepIdPutResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self.othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdPutResponseDto].
extension ApiV1StepsStepIdPutResponseDtoPatterns
    on ApiV1StepsStepIdPutResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdPutResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdPutResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdPutResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutResponseDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdPutResponseDto
    implements ApiV1StepsStepIdPutResponseDto {
  _ApiV1StepsStepIdPutResponseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'user') required this.user,
      @JsonKey(name: 'journeyId') this.journeyId,
      @JsonKey(name: 'journey') this.journey,
      @JsonKey(name: 'hearts') this.hearts,
      @JsonKey(name: 'heartedByUser') this.heartedByUser,
      @JsonKey(name: 'shares') this.shares,
      @JsonKey(name: 'sharedByUser') this.sharedByUser,
      @JsonKey(name: 'comments') this.comments,
      @JsonKey(name: 'commentedByUser') this.commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      this.userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') this.othersStepWith,
      @JsonKey(name: 'othersStepWithUsers')
      final List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') this.stepTypeString,
      @JsonKey(name: 'media') final List<StepMediaDto>? media})
      : _othersStepWithUsers = othersStepWithUsers,
        _media = media;
  factory _ApiV1StepsStepIdPutResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdPutResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'user')
  final UserDto user;
  @override
  @JsonKey(name: 'journeyId')
  final String? journeyId;
  @override
  @JsonKey(name: 'journey')
  final JourneyDto? journey;
  @override
  @JsonKey(name: 'hearts')
  final int? hearts;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;
  @override
  @JsonKey(name: 'shares')
  final int? shares;
  @override
  @JsonKey(name: 'sharedByUser')
  final bool? sharedByUser;
  @override
  @JsonKey(name: 'comments')
  final int? comments;
  @override
  @JsonKey(name: 'commentedByUser')
  final bool? commentedByUser;
  @override
  @JsonKey(name: 'userSteppedWithInteractions')
  final int? userSteppedWithInteractions;
  @override
  @JsonKey(name: 'othersStepWith')
  final int? othersStepWith;
  final List<UserDto>? _othersStepWithUsers;
  @override
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers {
    final value = _othersStepWithUsers;
    if (value == null) return null;
    if (_othersStepWithUsers is EqualUnmodifiableListView)
      return _othersStepWithUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'stepTypeString')
  final String? stepTypeString;
  final List<StepMediaDto>? _media;
  @override
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media {
    final value = _media;
    if (value == null) return null;
    if (_media is EqualUnmodifiableListView) return _media;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdPutResponseDtoCopyWith<_ApiV1StepsStepIdPutResponseDto>
      get copyWith => __$ApiV1StepsStepIdPutResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdPutResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdPutResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other._othersStepWithUsers, _othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other._media, _media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(_othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(_media)
      ]);

  @override
  String toString() {
    return 'ApiV1StepsStepIdPutResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdPutResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdPutResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdPutResponseDtoCopyWith(
          _ApiV1StepsStepIdPutResponseDto value,
          $Res Function(_ApiV1StepsStepIdPutResponseDto) _then) =
      __$ApiV1StepsStepIdPutResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  @override
  $UserDtoCopyWith<$Res> get user;
  @override
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class __$ApiV1StepsStepIdPutResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdPutResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdPutResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdPutResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdPutResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_ApiV1StepsStepIdPutResponseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self._othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self._media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1StepsStepIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdPutRequestDto {
  @JsonKey(name: 'content')
  String get content;

  /// Create a copy of ApiV1StepsStepIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdPutRequestDtoCopyWith<ApiV1StepsStepIdPutRequestDto>
      get copyWith => _$ApiV1StepsStepIdPutRequestDtoCopyWithImpl<
              ApiV1StepsStepIdPutRequestDto>(
          this as ApiV1StepsStepIdPutRequestDto, _$identity);

  /// Serializes this ApiV1StepsStepIdPutRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdPutRequestDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'ApiV1StepsStepIdPutRequestDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdPutRequestDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdPutRequestDtoCopyWith(
          ApiV1StepsStepIdPutRequestDto value,
          $Res Function(ApiV1StepsStepIdPutRequestDto) _then) =
      _$ApiV1StepsStepIdPutRequestDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class _$ApiV1StepsStepIdPutRequestDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdPutRequestDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdPutRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdPutRequestDto _self;
  final $Res Function(ApiV1StepsStepIdPutRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdPutRequestDto].
extension ApiV1StepsStepIdPutRequestDtoPatterns
    on ApiV1StepsStepIdPutRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdPutRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdPutRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdPutRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutRequestDto() when $default != null:
        return $default(_that.content);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutRequestDto():
        return $default(_that.content);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'content') String content)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdPutRequestDto() when $default != null:
        return $default(_that.content);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdPutRequestDto implements ApiV1StepsStepIdPutRequestDto {
  _ApiV1StepsStepIdPutRequestDto(
      {@JsonKey(name: 'content') required this.content});
  factory _ApiV1StepsStepIdPutRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdPutRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;

  /// Create a copy of ApiV1StepsStepIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdPutRequestDtoCopyWith<_ApiV1StepsStepIdPutRequestDto>
      get copyWith => __$ApiV1StepsStepIdPutRequestDtoCopyWithImpl<
          _ApiV1StepsStepIdPutRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdPutRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdPutRequestDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'ApiV1StepsStepIdPutRequestDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdPutRequestDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdPutRequestDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdPutRequestDtoCopyWith(
          _ApiV1StepsStepIdPutRequestDto value,
          $Res Function(_ApiV1StepsStepIdPutRequestDto) _then) =
      __$ApiV1StepsStepIdPutRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class __$ApiV1StepsStepIdPutRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdPutRequestDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdPutRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdPutRequestDto _self;
  final $Res Function(_ApiV1StepsStepIdPutRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
  }) {
    return _then(_ApiV1StepsStepIdPutRequestDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDto {
  @JsonKey(name: 'uploadUrl')
  String? get uploadUrl;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'expiresAt')
  DateTime? get expiresAt;
  @JsonKey(name: 'headers')
  Map<String, String>? get headers;

  /// Create a copy of ApiV1StepsStepIdMediaUploadRequestsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith<
          ApiV1StepsStepIdMediaUploadRequestsPostResponseDto>
      get copyWith =>
          _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl<
                  ApiV1StepsStepIdMediaUploadRequestsPostResponseDto>(
              this as ApiV1StepsStepIdMediaUploadRequestsPostResponseDto,
              _$identity);

  /// Serializes this ApiV1StepsStepIdMediaUploadRequestsPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdMediaUploadRequestsPostResponseDto &&
            (identical(other.uploadUrl, uploadUrl) ||
                other.uploadUrl == uploadUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            const DeepCollectionEquality().equals(other.headers, headers));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uploadUrl, fileUrl, fileName,
      expiresAt, const DeepCollectionEquality().hash(headers));

  @override
  String toString() {
    return 'ApiV1StepsStepIdMediaUploadRequestsPostResponseDto(uploadUrl: $uploadUrl, fileUrl: $fileUrl, fileName: $fileName, expiresAt: $expiresAt, headers: $headers)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith<
    $Res> {
  factory $ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith(
          ApiV1StepsStepIdMediaUploadRequestsPostResponseDto value,
          $Res Function(ApiV1StepsStepIdMediaUploadRequestsPostResponseDto)
              _then) =
      _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'uploadUrl') String? uploadUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'expiresAt') DateTime? expiresAt,
      @JsonKey(name: 'headers') Map<String, String>? headers});
}

/// @nodoc
class _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl<$Res>
    implements
        $ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl(
      this._self, this._then);

  final ApiV1StepsStepIdMediaUploadRequestsPostResponseDto _self;
  final $Res Function(ApiV1StepsStepIdMediaUploadRequestsPostResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdMediaUploadRequestsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uploadUrl = freezed,
    Object? fileUrl = freezed,
    Object? fileName = freezed,
    Object? expiresAt = freezed,
    Object? headers = freezed,
  }) {
    return _then(_self.copyWith(
      uploadUrl: freezed == uploadUrl
          ? _self.uploadUrl
          : uploadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      headers: freezed == headers
          ? _self.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdMediaUploadRequestsPostResponseDto].
extension ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoPatterns
    on ApiV1StepsStepIdMediaUploadRequestsPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdMediaUploadRequestsPostResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdMediaUploadRequestsPostResponseDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(
            _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto()
          when $default != null:
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto():
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto()
          when $default != null:
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto
    implements ApiV1StepsStepIdMediaUploadRequestsPostResponseDto {
  _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto(
      {@JsonKey(name: 'uploadUrl') this.uploadUrl,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'expiresAt') this.expiresAt,
      @JsonKey(name: 'headers') final Map<String, String>? headers})
      : _headers = headers;
  factory _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'uploadUrl')
  final String? uploadUrl;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'expiresAt')
  final DateTime? expiresAt;
  final Map<String, String>? _headers;
  @override
  @JsonKey(name: 'headers')
  Map<String, String>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableMapView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ApiV1StepsStepIdMediaUploadRequestsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith<
          _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto>
      get copyWith =>
          __$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl<
                  _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto &&
            (identical(other.uploadUrl, uploadUrl) ||
                other.uploadUrl == uploadUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            const DeepCollectionEquality().equals(other._headers, _headers));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uploadUrl, fileUrl, fileName,
      expiresAt, const DeepCollectionEquality().hash(_headers));

  @override
  String toString() {
    return 'ApiV1StepsStepIdMediaUploadRequestsPostResponseDto(uploadUrl: $uploadUrl, fileUrl: $fileUrl, fileName: $fileName, expiresAt: $expiresAt, headers: $headers)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith<
        $Res>
    implements
        $ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith(
          _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto value,
          $Res Function(_ApiV1StepsStepIdMediaUploadRequestsPostResponseDto)
              _then) =
      __$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'uploadUrl') String? uploadUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'expiresAt') DateTime? expiresAt,
      @JsonKey(name: 'headers') Map<String, String>? headers});
}

/// @nodoc
class __$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl<$Res>
    implements
        _$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdMediaUploadRequestsPostResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1StepsStepIdMediaUploadRequestsPostResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdMediaUploadRequestsPostResponseDto)
      _then;

  /// Create a copy of ApiV1StepsStepIdMediaUploadRequestsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uploadUrl = freezed,
    Object? fileUrl = freezed,
    Object? fileName = freezed,
    Object? expiresAt = freezed,
    Object? headers = freezed,
  }) {
    return _then(_ApiV1StepsStepIdMediaUploadRequestsPostResponseDto(
      uploadUrl: freezed == uploadUrl
          ? _self.uploadUrl
          : uploadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      headers: freezed == headers
          ? _self._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdImagesPutResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'stepId')
  String? get stepId;
  @JsonKey(name: 'mediaType')
  String? get mediaType;
  @JsonKey(name: 'originalUrl')
  String? get originalUrl;
  @JsonKey(name: 'largeUrl')
  String? get largeUrl;
  @JsonKey(name: 'mediumUrl')
  String? get mediumUrl;
  @JsonKey(name: 'smallUrl')
  String? get smallUrl;
  @JsonKey(name: 'thumbnailUrl')
  String? get thumbnailUrl;
  @JsonKey(name: 'videoThumbnailUrl')
  String? get videoThumbnailUrl;
  @JsonKey(name: 'bunnyVideoId')
  String? get bunnyVideoId;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'duration')
  num? get duration;
  @JsonKey(name: 'status')
  MediaStatusDto? get status;
  @JsonKey(name: 'isVideo')
  bool? get isVideo;
  @JsonKey(name: 'isImage')
  bool? get isImage;

  /// Create a copy of ApiV1StepsStepIdImagesPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdImagesPutResponseDtoCopyWith<
          ApiV1StepsStepIdImagesPutResponseDto>
      get copyWith => _$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl<
              ApiV1StepsStepIdImagesPutResponseDto>(
          this as ApiV1StepsStepIdImagesPutResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdImagesPutResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdImagesPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'ApiV1StepsStepIdImagesPutResponseDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdImagesPutResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdImagesPutResponseDtoCopyWith(
          ApiV1StepsStepIdImagesPutResponseDto value,
          $Res Function(ApiV1StepsStepIdImagesPutResponseDto) _then) =
      _$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class _$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdImagesPutResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdImagesPutResponseDto _self;
  final $Res Function(ApiV1StepsStepIdImagesPutResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdImagesPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdImagesPutResponseDto].
extension ApiV1StepsStepIdImagesPutResponseDtoPatterns
    on ApiV1StepsStepIdImagesPutResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdImagesPutResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdImagesPutResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdImagesPutResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutResponseDto():
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdImagesPutResponseDto
    implements ApiV1StepsStepIdImagesPutResponseDto {
  _ApiV1StepsStepIdImagesPutResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'stepId') this.stepId,
      @JsonKey(name: 'mediaType') this.mediaType,
      @JsonKey(name: 'originalUrl') this.originalUrl,
      @JsonKey(name: 'largeUrl') this.largeUrl,
      @JsonKey(name: 'mediumUrl') this.mediumUrl,
      @JsonKey(name: 'smallUrl') this.smallUrl,
      @JsonKey(name: 'thumbnailUrl') this.thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') this.videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') this.bunnyVideoId,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'duration') this.duration,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'isVideo') this.isVideo,
      @JsonKey(name: 'isImage') this.isImage});
  factory _ApiV1StepsStepIdImagesPutResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdImagesPutResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'stepId')
  final String? stepId;
  @override
  @JsonKey(name: 'mediaType')
  final String? mediaType;
  @override
  @JsonKey(name: 'originalUrl')
  final String? originalUrl;
  @override
  @JsonKey(name: 'largeUrl')
  final String? largeUrl;
  @override
  @JsonKey(name: 'mediumUrl')
  final String? mediumUrl;
  @override
  @JsonKey(name: 'smallUrl')
  final String? smallUrl;
  @override
  @JsonKey(name: 'thumbnailUrl')
  final String? thumbnailUrl;
  @override
  @JsonKey(name: 'videoThumbnailUrl')
  final String? videoThumbnailUrl;
  @override
  @JsonKey(name: 'bunnyVideoId')
  final String? bunnyVideoId;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'duration')
  final num? duration;
  @override
  @JsonKey(name: 'status')
  final MediaStatusDto? status;
  @override
  @JsonKey(name: 'isVideo')
  final bool? isVideo;
  @override
  @JsonKey(name: 'isImage')
  final bool? isImage;

  /// Create a copy of ApiV1StepsStepIdImagesPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdImagesPutResponseDtoCopyWith<
          _ApiV1StepsStepIdImagesPutResponseDto>
      get copyWith => __$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdImagesPutResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdImagesPutResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdImagesPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'ApiV1StepsStepIdImagesPutResponseDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdImagesPutResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdImagesPutResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdImagesPutResponseDtoCopyWith(
          _ApiV1StepsStepIdImagesPutResponseDto value,
          $Res Function(_ApiV1StepsStepIdImagesPutResponseDto) _then) =
      __$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class __$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdImagesPutResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdImagesPutResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdImagesPutResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdImagesPutResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdImagesPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_ApiV1StepsStepIdImagesPutResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdImagesPutRequestDto {
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'contentType')
  String? get contentType;

  /// Create a copy of ApiV1StepsStepIdImagesPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdImagesPutRequestDtoCopyWith<
          ApiV1StepsStepIdImagesPutRequestDto>
      get copyWith => _$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl<
              ApiV1StepsStepIdImagesPutRequestDto>(
          this as ApiV1StepsStepIdImagesPutRequestDto, _$identity);

  /// Serializes this ApiV1StepsStepIdImagesPutRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdImagesPutRequestDto &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileName, fileUrl, width, height, size, contentType);

  @override
  String toString() {
    return 'ApiV1StepsStepIdImagesPutRequestDto(fileName: $fileName, fileUrl: $fileUrl, width: $width, height: $height, size: $size, contentType: $contentType)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdImagesPutRequestDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdImagesPutRequestDtoCopyWith(
          ApiV1StepsStepIdImagesPutRequestDto value,
          $Res Function(ApiV1StepsStepIdImagesPutRequestDto) _then) =
      _$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'contentType') String? contentType});
}

/// @nodoc
class _$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdImagesPutRequestDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdImagesPutRequestDto _self;
  final $Res Function(ApiV1StepsStepIdImagesPutRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdImagesPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = freezed,
    Object? fileUrl = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? contentType = freezed,
  }) {
    return _then(_self.copyWith(
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdImagesPutRequestDto].
extension ApiV1StepsStepIdImagesPutRequestDtoPatterns
    on ApiV1StepsStepIdImagesPutRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdImagesPutRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdImagesPutRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdImagesPutRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutRequestDto() when $default != null:
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutRequestDto():
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdImagesPutRequestDto() when $default != null:
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdImagesPutRequestDto
    implements ApiV1StepsStepIdImagesPutRequestDto {
  _ApiV1StepsStepIdImagesPutRequestDto(
      {@JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'contentType') this.contentType});
  factory _ApiV1StepsStepIdImagesPutRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdImagesPutRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'contentType')
  final String? contentType;

  /// Create a copy of ApiV1StepsStepIdImagesPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdImagesPutRequestDtoCopyWith<
          _ApiV1StepsStepIdImagesPutRequestDto>
      get copyWith => __$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl<
          _ApiV1StepsStepIdImagesPutRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdImagesPutRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdImagesPutRequestDto &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileName, fileUrl, width, height, size, contentType);

  @override
  String toString() {
    return 'ApiV1StepsStepIdImagesPutRequestDto(fileName: $fileName, fileUrl: $fileUrl, width: $width, height: $height, size: $size, contentType: $contentType)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdImagesPutRequestDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdImagesPutRequestDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdImagesPutRequestDtoCopyWith(
          _ApiV1StepsStepIdImagesPutRequestDto value,
          $Res Function(_ApiV1StepsStepIdImagesPutRequestDto) _then) =
      __$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'contentType') String? contentType});
}

/// @nodoc
class __$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdImagesPutRequestDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdImagesPutRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdImagesPutRequestDto _self;
  final $Res Function(_ApiV1StepsStepIdImagesPutRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdImagesPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileName = freezed,
    Object? fileUrl = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? contentType = freezed,
  }) {
    return _then(_ApiV1StepsStepIdImagesPutRequestDto(
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdVideoPutResponseDto {
  @JsonKey(name: 'authorizationSignature')
  String? get authorizationSignature;
  @JsonKey(name: 'authorizationExpire')
  int? get authorizationExpire;
  @JsonKey(name: 'videoGuid')
  String? get videoGuid;
  @JsonKey(name: 'libraryId')
  int? get libraryId;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'collectionId')
  String? get collectionId;
  @JsonKey(name: 'media')
  StepMediaDto? get media;

  /// Create a copy of ApiV1StepsStepIdVideoPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdVideoPutResponseDtoCopyWith<
          ApiV1StepsStepIdVideoPutResponseDto>
      get copyWith => _$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl<
              ApiV1StepsStepIdVideoPutResponseDto>(
          this as ApiV1StepsStepIdVideoPutResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdVideoPutResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdVideoPutResponseDto &&
            (identical(other.authorizationSignature, authorizationSignature) ||
                other.authorizationSignature == authorizationSignature) &&
            (identical(other.authorizationExpire, authorizationExpire) ||
                other.authorizationExpire == authorizationExpire) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.libraryId, libraryId) ||
                other.libraryId == libraryId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.collectionId, collectionId) ||
                other.collectionId == collectionId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationSignature,
      authorizationExpire, videoGuid, libraryId, title, collectionId, media);

  @override
  String toString() {
    return 'ApiV1StepsStepIdVideoPutResponseDto(authorizationSignature: $authorizationSignature, authorizationExpire: $authorizationExpire, videoGuid: $videoGuid, libraryId: $libraryId, title: $title, collectionId: $collectionId, media: $media)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdVideoPutResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdVideoPutResponseDtoCopyWith(
          ApiV1StepsStepIdVideoPutResponseDto value,
          $Res Function(ApiV1StepsStepIdVideoPutResponseDto) _then) =
      _$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'authorizationSignature') String? authorizationSignature,
      @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'libraryId') int? libraryId,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'collectionId') String? collectionId,
      @JsonKey(name: 'media') StepMediaDto? media});

  $StepMediaDtoCopyWith<$Res>? get media;
}

/// @nodoc
class _$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdVideoPutResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdVideoPutResponseDto _self;
  final $Res Function(ApiV1StepsStepIdVideoPutResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdVideoPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? authorizationSignature = freezed,
    Object? authorizationExpire = freezed,
    Object? videoGuid = freezed,
    Object? libraryId = freezed,
    Object? title = freezed,
    Object? collectionId = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      authorizationSignature: freezed == authorizationSignature
          ? _self.authorizationSignature
          : authorizationSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      authorizationExpire: freezed == authorizationExpire
          ? _self.authorizationExpire
          : authorizationExpire // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      libraryId: freezed == libraryId
          ? _self.libraryId
          : libraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      collectionId: freezed == collectionId
          ? _self.collectionId
          : collectionId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdVideoPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdVideoPutResponseDto].
extension ApiV1StepsStepIdVideoPutResponseDtoPatterns
    on ApiV1StepsStepIdVideoPutResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdVideoPutResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdVideoPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdVideoPutResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdVideoPutResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdVideoPutResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdVideoPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdVideoPutResponseDto() when $default != null:
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdVideoPutResponseDto():
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdVideoPutResponseDto() when $default != null:
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdVideoPutResponseDto
    implements ApiV1StepsStepIdVideoPutResponseDto {
  _ApiV1StepsStepIdVideoPutResponseDto(
      {@JsonKey(name: 'authorizationSignature') this.authorizationSignature,
      @JsonKey(name: 'authorizationExpire') this.authorizationExpire,
      @JsonKey(name: 'videoGuid') this.videoGuid,
      @JsonKey(name: 'libraryId') this.libraryId,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'collectionId') this.collectionId,
      @JsonKey(name: 'media') this.media});
  factory _ApiV1StepsStepIdVideoPutResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdVideoPutResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'authorizationSignature')
  final String? authorizationSignature;
  @override
  @JsonKey(name: 'authorizationExpire')
  final int? authorizationExpire;
  @override
  @JsonKey(name: 'videoGuid')
  final String? videoGuid;
  @override
  @JsonKey(name: 'libraryId')
  final int? libraryId;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'collectionId')
  final String? collectionId;
  @override
  @JsonKey(name: 'media')
  final StepMediaDto? media;

  /// Create a copy of ApiV1StepsStepIdVideoPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdVideoPutResponseDtoCopyWith<
          _ApiV1StepsStepIdVideoPutResponseDto>
      get copyWith => __$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdVideoPutResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdVideoPutResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdVideoPutResponseDto &&
            (identical(other.authorizationSignature, authorizationSignature) ||
                other.authorizationSignature == authorizationSignature) &&
            (identical(other.authorizationExpire, authorizationExpire) ||
                other.authorizationExpire == authorizationExpire) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.libraryId, libraryId) ||
                other.libraryId == libraryId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.collectionId, collectionId) ||
                other.collectionId == collectionId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationSignature,
      authorizationExpire, videoGuid, libraryId, title, collectionId, media);

  @override
  String toString() {
    return 'ApiV1StepsStepIdVideoPutResponseDto(authorizationSignature: $authorizationSignature, authorizationExpire: $authorizationExpire, videoGuid: $videoGuid, libraryId: $libraryId, title: $title, collectionId: $collectionId, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdVideoPutResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdVideoPutResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdVideoPutResponseDtoCopyWith(
          _ApiV1StepsStepIdVideoPutResponseDto value,
          $Res Function(_ApiV1StepsStepIdVideoPutResponseDto) _then) =
      __$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'authorizationSignature') String? authorizationSignature,
      @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'libraryId') int? libraryId,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'collectionId') String? collectionId,
      @JsonKey(name: 'media') StepMediaDto? media});

  @override
  $StepMediaDtoCopyWith<$Res>? get media;
}

/// @nodoc
class __$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdVideoPutResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdVideoPutResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdVideoPutResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdVideoPutResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdVideoPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? authorizationSignature = freezed,
    Object? authorizationExpire = freezed,
    Object? videoGuid = freezed,
    Object? libraryId = freezed,
    Object? title = freezed,
    Object? collectionId = freezed,
    Object? media = freezed,
  }) {
    return _then(_ApiV1StepsStepIdVideoPutResponseDto(
      authorizationSignature: freezed == authorizationSignature
          ? _self.authorizationSignature
          : authorizationSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      authorizationExpire: freezed == authorizationExpire
          ? _self.authorizationExpire
          : authorizationExpire // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      libraryId: freezed == libraryId
          ? _self.libraryId
          : libraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      collectionId: freezed == collectionId
          ? _self.collectionId
          : collectionId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdVideoPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1ReportsPostResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'entityType')
  String get entityType;
  @JsonKey(name: 'entityId')
  String? get entityId;
  @JsonKey(name: 'reporter')
  UserDto2Dto? get reporter;
  @JsonKey(name: 'reason')
  String get reason;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;

  /// Create a copy of ApiV1ReportsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1ReportsPostResponseDtoCopyWith<ApiV1ReportsPostResponseDto>
      get copyWith => _$ApiV1ReportsPostResponseDtoCopyWithImpl<
              ApiV1ReportsPostResponseDto>(
          this as ApiV1ReportsPostResponseDto, _$identity);

  /// Serializes this ApiV1ReportsPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1ReportsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reporter, reporter) ||
                other.reporter == reporter) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, entityType, entityId, reporter, reason, createdDate);

  @override
  String toString() {
    return 'ApiV1ReportsPostResponseDto(id: $id, entityType: $entityType, entityId: $entityId, reporter: $reporter, reason: $reason, createdDate: $createdDate)';
  }
}

/// @nodoc
abstract mixin class $ApiV1ReportsPostResponseDtoCopyWith<$Res> {
  factory $ApiV1ReportsPostResponseDtoCopyWith(
          ApiV1ReportsPostResponseDto value,
          $Res Function(ApiV1ReportsPostResponseDto) _then) =
      _$ApiV1ReportsPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String? entityId,
      @JsonKey(name: 'reporter') UserDto2Dto? reporter,
      @JsonKey(name: 'reason') String reason,
      @JsonKey(name: 'createdDate') DateTime? createdDate});

  $UserDto2DtoCopyWith<$Res>? get reporter;
}

/// @nodoc
class _$ApiV1ReportsPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1ReportsPostResponseDtoCopyWith<$Res> {
  _$ApiV1ReportsPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1ReportsPostResponseDto _self;
  final $Res Function(ApiV1ReportsPostResponseDto) _then;

  /// Create a copy of ApiV1ReportsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? entityType = null,
    Object? entityId = freezed,
    Object? reporter = freezed,
    Object? reason = null,
    Object? createdDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: freezed == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String?,
      reporter: freezed == reporter
          ? _self.reporter
          : reporter // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ApiV1ReportsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get reporter {
    if (_self.reporter == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.reporter!, (value) {
      return _then(_self.copyWith(reporter: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1ReportsPostResponseDto].
extension ApiV1ReportsPostResponseDtoPatterns on ApiV1ReportsPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1ReportsPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1ReportsPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1ReportsPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String? entityId,
            @JsonKey(name: 'reporter') UserDto2Dto? reporter,
            @JsonKey(name: 'reason') String reason,
            @JsonKey(name: 'createdDate') DateTime? createdDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostResponseDto() when $default != null:
        return $default(_that.id, _that.entityType, _that.entityId,
            _that.reporter, _that.reason, _that.createdDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String? entityId,
            @JsonKey(name: 'reporter') UserDto2Dto? reporter,
            @JsonKey(name: 'reason') String reason,
            @JsonKey(name: 'createdDate') DateTime? createdDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostResponseDto():
        return $default(_that.id, _that.entityType, _that.entityId,
            _that.reporter, _that.reason, _that.createdDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String? entityId,
            @JsonKey(name: 'reporter') UserDto2Dto? reporter,
            @JsonKey(name: 'reason') String reason,
            @JsonKey(name: 'createdDate') DateTime? createdDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostResponseDto() when $default != null:
        return $default(_that.id, _that.entityType, _that.entityId,
            _that.reporter, _that.reason, _that.createdDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1ReportsPostResponseDto implements ApiV1ReportsPostResponseDto {
  _ApiV1ReportsPostResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'entityType') required this.entityType,
      @JsonKey(name: 'entityId') this.entityId,
      @JsonKey(name: 'reporter') this.reporter,
      @JsonKey(name: 'reason') required this.reason,
      @JsonKey(name: 'createdDate') this.createdDate});
  factory _ApiV1ReportsPostResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1ReportsPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'entityType')
  final String entityType;
  @override
  @JsonKey(name: 'entityId')
  final String? entityId;
  @override
  @JsonKey(name: 'reporter')
  final UserDto2Dto? reporter;
  @override
  @JsonKey(name: 'reason')
  final String reason;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;

  /// Create a copy of ApiV1ReportsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1ReportsPostResponseDtoCopyWith<_ApiV1ReportsPostResponseDto>
      get copyWith => __$ApiV1ReportsPostResponseDtoCopyWithImpl<
          _ApiV1ReportsPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1ReportsPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1ReportsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reporter, reporter) ||
                other.reporter == reporter) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, entityType, entityId, reporter, reason, createdDate);

  @override
  String toString() {
    return 'ApiV1ReportsPostResponseDto(id: $id, entityType: $entityType, entityId: $entityId, reporter: $reporter, reason: $reason, createdDate: $createdDate)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1ReportsPostResponseDtoCopyWith<$Res>
    implements $ApiV1ReportsPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1ReportsPostResponseDtoCopyWith(
          _ApiV1ReportsPostResponseDto value,
          $Res Function(_ApiV1ReportsPostResponseDto) _then) =
      __$ApiV1ReportsPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String? entityId,
      @JsonKey(name: 'reporter') UserDto2Dto? reporter,
      @JsonKey(name: 'reason') String reason,
      @JsonKey(name: 'createdDate') DateTime? createdDate});

  @override
  $UserDto2DtoCopyWith<$Res>? get reporter;
}

/// @nodoc
class __$ApiV1ReportsPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1ReportsPostResponseDtoCopyWith<$Res> {
  __$ApiV1ReportsPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1ReportsPostResponseDto _self;
  final $Res Function(_ApiV1ReportsPostResponseDto) _then;

  /// Create a copy of ApiV1ReportsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? entityType = null,
    Object? entityId = freezed,
    Object? reporter = freezed,
    Object? reason = null,
    Object? createdDate = freezed,
  }) {
    return _then(_ApiV1ReportsPostResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: freezed == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String?,
      reporter: freezed == reporter
          ? _self.reporter
          : reporter // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ApiV1ReportsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get reporter {
    if (_self.reporter == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.reporter!, (value) {
      return _then(_self.copyWith(reporter: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1ReportsPostRequestDto {
  @JsonKey(name: 'entityType')
  String get entityType;
  @JsonKey(name: 'entityId')
  String get entityId;
  @JsonKey(name: 'reason')
  String get reason;

  /// Create a copy of ApiV1ReportsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1ReportsPostRequestDtoCopyWith<ApiV1ReportsPostRequestDto>
      get copyWith =>
          _$ApiV1ReportsPostRequestDtoCopyWithImpl<ApiV1ReportsPostRequestDto>(
              this as ApiV1ReportsPostRequestDto, _$identity);

  /// Serializes this ApiV1ReportsPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1ReportsPostRequestDto &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, entityType, entityId, reason);

  @override
  String toString() {
    return 'ApiV1ReportsPostRequestDto(entityType: $entityType, entityId: $entityId, reason: $reason)';
  }
}

/// @nodoc
abstract mixin class $ApiV1ReportsPostRequestDtoCopyWith<$Res> {
  factory $ApiV1ReportsPostRequestDtoCopyWith(ApiV1ReportsPostRequestDto value,
          $Res Function(ApiV1ReportsPostRequestDto) _then) =
      _$ApiV1ReportsPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String entityId,
      @JsonKey(name: 'reason') String reason});
}

/// @nodoc
class _$ApiV1ReportsPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1ReportsPostRequestDtoCopyWith<$Res> {
  _$ApiV1ReportsPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1ReportsPostRequestDto _self;
  final $Res Function(ApiV1ReportsPostRequestDto) _then;

  /// Create a copy of ApiV1ReportsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? entityType = null,
    Object? entityId = null,
    Object? reason = null,
  }) {
    return _then(_self.copyWith(
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1ReportsPostRequestDto].
extension ApiV1ReportsPostRequestDtoPatterns on ApiV1ReportsPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1ReportsPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1ReportsPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1ReportsPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String entityId,
            @JsonKey(name: 'reason') String reason)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostRequestDto() when $default != null:
        return $default(_that.entityType, _that.entityId, _that.reason);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String entityId,
            @JsonKey(name: 'reason') String reason)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostRequestDto():
        return $default(_that.entityType, _that.entityId, _that.reason);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'entityType') String entityType,
            @JsonKey(name: 'entityId') String entityId,
            @JsonKey(name: 'reason') String reason)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1ReportsPostRequestDto() when $default != null:
        return $default(_that.entityType, _that.entityId, _that.reason);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1ReportsPostRequestDto implements ApiV1ReportsPostRequestDto {
  _ApiV1ReportsPostRequestDto(
      {@JsonKey(name: 'entityType') required this.entityType,
      @JsonKey(name: 'entityId') required this.entityId,
      @JsonKey(name: 'reason') required this.reason});
  factory _ApiV1ReportsPostRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1ReportsPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'entityType')
  final String entityType;
  @override
  @JsonKey(name: 'entityId')
  final String entityId;
  @override
  @JsonKey(name: 'reason')
  final String reason;

  /// Create a copy of ApiV1ReportsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1ReportsPostRequestDtoCopyWith<_ApiV1ReportsPostRequestDto>
      get copyWith => __$ApiV1ReportsPostRequestDtoCopyWithImpl<
          _ApiV1ReportsPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1ReportsPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1ReportsPostRequestDto &&
            (identical(other.entityType, entityType) ||
                other.entityType == entityType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, entityType, entityId, reason);

  @override
  String toString() {
    return 'ApiV1ReportsPostRequestDto(entityType: $entityType, entityId: $entityId, reason: $reason)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1ReportsPostRequestDtoCopyWith<$Res>
    implements $ApiV1ReportsPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1ReportsPostRequestDtoCopyWith(
          _ApiV1ReportsPostRequestDto value,
          $Res Function(_ApiV1ReportsPostRequestDto) _then) =
      __$ApiV1ReportsPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'entityType') String entityType,
      @JsonKey(name: 'entityId') String entityId,
      @JsonKey(name: 'reason') String reason});
}

/// @nodoc
class __$ApiV1ReportsPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1ReportsPostRequestDtoCopyWith<$Res> {
  __$ApiV1ReportsPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1ReportsPostRequestDto _self;
  final $Res Function(_ApiV1ReportsPostRequestDto) _then;

  /// Create a copy of ApiV1ReportsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? entityType = null,
    Object? entityId = null,
    Object? reason = null,
  }) {
    return _then(_ApiV1ReportsPostRequestDto(
      entityType: null == entityType
          ? _self.entityType
          : entityType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ApiV1NotificationsGetResponseDto {
  @JsonKey(name: 'notifications')
  List<NotificationDto>? get notifications;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'unreadCount')
  int? get unreadCount;
  @JsonKey(name: 'hasMore')
  bool? get hasMore;

  /// Create a copy of ApiV1NotificationsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1NotificationsGetResponseDtoCopyWith<ApiV1NotificationsGetResponseDto>
      get copyWith => _$ApiV1NotificationsGetResponseDtoCopyWithImpl<
              ApiV1NotificationsGetResponseDto>(
          this as ApiV1NotificationsGetResponseDto, _$identity);

  /// Serializes this ApiV1NotificationsGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1NotificationsGetResponseDto &&
            const DeepCollectionEquality()
                .equals(other.notifications, notifications) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.unreadCount, unreadCount) ||
                other.unreadCount == unreadCount) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(notifications),
      page,
      pageSize,
      totalCount,
      unreadCount,
      hasMore);

  @override
  String toString() {
    return 'ApiV1NotificationsGetResponseDto(notifications: $notifications, page: $page, pageSize: $pageSize, totalCount: $totalCount, unreadCount: $unreadCount, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ApiV1NotificationsGetResponseDtoCopyWith<$Res> {
  factory $ApiV1NotificationsGetResponseDtoCopyWith(
          ApiV1NotificationsGetResponseDto value,
          $Res Function(ApiV1NotificationsGetResponseDto) _then) =
      _$ApiV1NotificationsGetResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'notifications') List<NotificationDto>? notifications,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'unreadCount') int? unreadCount,
      @JsonKey(name: 'hasMore') bool? hasMore});
}

/// @nodoc
class _$ApiV1NotificationsGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1NotificationsGetResponseDtoCopyWith<$Res> {
  _$ApiV1NotificationsGetResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1NotificationsGetResponseDto _self;
  final $Res Function(ApiV1NotificationsGetResponseDto) _then;

  /// Create a copy of ApiV1NotificationsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? notifications = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? unreadCount = freezed,
    Object? hasMore = freezed,
  }) {
    return _then(_self.copyWith(
      notifications: freezed == notifications
          ? _self.notifications
          : notifications // ignore: cast_nullable_to_non_nullable
              as List<NotificationDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      unreadCount: freezed == unreadCount
          ? _self.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasMore: freezed == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1NotificationsGetResponseDto].
extension ApiV1NotificationsGetResponseDtoPatterns
    on ApiV1NotificationsGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsGetResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsGetResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1NotificationsGetResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'notifications')
            List<NotificationDto>? notifications,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'unreadCount') int? unreadCount,
            @JsonKey(name: 'hasMore') bool? hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsGetResponseDto() when $default != null:
        return $default(_that.notifications, _that.page, _that.pageSize,
            _that.totalCount, _that.unreadCount, _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'notifications')
            List<NotificationDto>? notifications,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'unreadCount') int? unreadCount,
            @JsonKey(name: 'hasMore') bool? hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsGetResponseDto():
        return $default(_that.notifications, _that.page, _that.pageSize,
            _that.totalCount, _that.unreadCount, _that.hasMore);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'notifications')
            List<NotificationDto>? notifications,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'unreadCount') int? unreadCount,
            @JsonKey(name: 'hasMore') bool? hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsGetResponseDto() when $default != null:
        return $default(_that.notifications, _that.page, _that.pageSize,
            _that.totalCount, _that.unreadCount, _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1NotificationsGetResponseDto
    implements ApiV1NotificationsGetResponseDto {
  _ApiV1NotificationsGetResponseDto(
      {@JsonKey(name: 'notifications')
      final List<NotificationDto>? notifications,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'unreadCount') this.unreadCount,
      @JsonKey(name: 'hasMore') this.hasMore})
      : _notifications = notifications;
  factory _ApiV1NotificationsGetResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1NotificationsGetResponseDtoFromJson(json);

  final List<NotificationDto>? _notifications;
  @override
  @JsonKey(name: 'notifications')
  List<NotificationDto>? get notifications {
    final value = _notifications;
    if (value == null) return null;
    if (_notifications is EqualUnmodifiableListView) return _notifications;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'unreadCount')
  final int? unreadCount;
  @override
  @JsonKey(name: 'hasMore')
  final bool? hasMore;

  /// Create a copy of ApiV1NotificationsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1NotificationsGetResponseDtoCopyWith<_ApiV1NotificationsGetResponseDto>
      get copyWith => __$ApiV1NotificationsGetResponseDtoCopyWithImpl<
          _ApiV1NotificationsGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1NotificationsGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1NotificationsGetResponseDto &&
            const DeepCollectionEquality()
                .equals(other._notifications, _notifications) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.unreadCount, unreadCount) ||
                other.unreadCount == unreadCount) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_notifications),
      page,
      pageSize,
      totalCount,
      unreadCount,
      hasMore);

  @override
  String toString() {
    return 'ApiV1NotificationsGetResponseDto(notifications: $notifications, page: $page, pageSize: $pageSize, totalCount: $totalCount, unreadCount: $unreadCount, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1NotificationsGetResponseDtoCopyWith<$Res>
    implements $ApiV1NotificationsGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1NotificationsGetResponseDtoCopyWith(
          _ApiV1NotificationsGetResponseDto value,
          $Res Function(_ApiV1NotificationsGetResponseDto) _then) =
      __$ApiV1NotificationsGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'notifications') List<NotificationDto>? notifications,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'unreadCount') int? unreadCount,
      @JsonKey(name: 'hasMore') bool? hasMore});
}

/// @nodoc
class __$ApiV1NotificationsGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1NotificationsGetResponseDtoCopyWith<$Res> {
  __$ApiV1NotificationsGetResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1NotificationsGetResponseDto _self;
  final $Res Function(_ApiV1NotificationsGetResponseDto) _then;

  /// Create a copy of ApiV1NotificationsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? notifications = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? unreadCount = freezed,
    Object? hasMore = freezed,
  }) {
    return _then(_ApiV1NotificationsGetResponseDto(
      notifications: freezed == notifications
          ? _self._notifications
          : notifications // ignore: cast_nullable_to_non_nullable
              as List<NotificationDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      unreadCount: freezed == unreadCount
          ? _self.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasMore: freezed == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1NotificationsPostResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'body')
  String? get body;
  @JsonKey(name: 'notificationType')
  NotificationTypeDto? get notificationType;
  @JsonKey(name: 'isRead')
  bool? get isRead;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'data')
  Map<String, String>? get data;
  @JsonKey(name: 'priority')
  int? get priority;
  @JsonKey(name: 'relatedEntityId')
  String? get relatedEntityId;
  @JsonKey(name: 'sourceUser')
  UserDetailDto2Dto? get sourceUser;

  /// Create a copy of ApiV1NotificationsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1NotificationsPostResponseDtoCopyWith<ApiV1NotificationsPostResponseDto>
      get copyWith => _$ApiV1NotificationsPostResponseDtoCopyWithImpl<
              ApiV1NotificationsPostResponseDto>(
          this as ApiV1NotificationsPostResponseDto, _$identity);

  /// Serializes this ApiV1NotificationsPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1NotificationsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.sourceUser, sourceUser) ||
                other.sourceUser == sourceUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      body,
      notificationType,
      isRead,
      createdDate,
      const DeepCollectionEquality().hash(data),
      priority,
      relatedEntityId,
      sourceUser);

  @override
  String toString() {
    return 'ApiV1NotificationsPostResponseDto(id: $id, title: $title, body: $body, notificationType: $notificationType, isRead: $isRead, createdDate: $createdDate, data: $data, priority: $priority, relatedEntityId: $relatedEntityId, sourceUser: $sourceUser)';
  }
}

/// @nodoc
abstract mixin class $ApiV1NotificationsPostResponseDtoCopyWith<$Res> {
  factory $ApiV1NotificationsPostResponseDtoCopyWith(
          ApiV1NotificationsPostResponseDto value,
          $Res Function(ApiV1NotificationsPostResponseDto) _then) =
      _$ApiV1NotificationsPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'body') String? body,
      @JsonKey(name: 'notificationType') NotificationTypeDto? notificationType,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser});

  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser;
}

/// @nodoc
class _$ApiV1NotificationsPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1NotificationsPostResponseDtoCopyWith<$Res> {
  _$ApiV1NotificationsPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1NotificationsPostResponseDto _self;
  final $Res Function(ApiV1NotificationsPostResponseDto) _then;

  /// Create a copy of ApiV1NotificationsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? body = freezed,
    Object? notificationType = freezed,
    Object? isRead = freezed,
    Object? createdDate = freezed,
    Object? data = freezed,
    Object? priority = freezed,
    Object? relatedEntityId = freezed,
    Object? sourceUser = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceUser: freezed == sourceUser
          ? _self.sourceUser
          : sourceUser // ignore: cast_nullable_to_non_nullable
              as UserDetailDto2Dto?,
    ));
  }

  /// Create a copy of ApiV1NotificationsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser {
    if (_self.sourceUser == null) {
      return null;
    }

    return $UserDetailDto2DtoCopyWith<$Res>(_self.sourceUser!, (value) {
      return _then(_self.copyWith(sourceUser: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1NotificationsPostResponseDto].
extension ApiV1NotificationsPostResponseDtoPatterns
    on ApiV1NotificationsPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1NotificationsPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto? notificationType,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.body,
            _that.notificationType,
            _that.isRead,
            _that.createdDate,
            _that.data,
            _that.priority,
            _that.relatedEntityId,
            _that.sourceUser);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto? notificationType,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostResponseDto():
        return $default(
            _that.id,
            _that.title,
            _that.body,
            _that.notificationType,
            _that.isRead,
            _that.createdDate,
            _that.data,
            _that.priority,
            _that.relatedEntityId,
            _that.sourceUser);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'body') String? body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto? notificationType,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.body,
            _that.notificationType,
            _that.isRead,
            _that.createdDate,
            _that.data,
            _that.priority,
            _that.relatedEntityId,
            _that.sourceUser);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1NotificationsPostResponseDto
    implements ApiV1NotificationsPostResponseDto {
  _ApiV1NotificationsPostResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'body') this.body,
      @JsonKey(name: 'notificationType') this.notificationType,
      @JsonKey(name: 'isRead') this.isRead,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'data') final Map<String, String>? data,
      @JsonKey(name: 'priority') this.priority,
      @JsonKey(name: 'relatedEntityId') this.relatedEntityId,
      @JsonKey(name: 'sourceUser') this.sourceUser})
      : _data = data;
  factory _ApiV1NotificationsPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1NotificationsPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'body')
  final String? body;
  @override
  @JsonKey(name: 'notificationType')
  final NotificationTypeDto? notificationType;
  @override
  @JsonKey(name: 'isRead')
  final bool? isRead;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  final Map<String, String>? _data;
  @override
  @JsonKey(name: 'data')
  Map<String, String>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey(name: 'priority')
  final int? priority;
  @override
  @JsonKey(name: 'relatedEntityId')
  final String? relatedEntityId;
  @override
  @JsonKey(name: 'sourceUser')
  final UserDetailDto2Dto? sourceUser;

  /// Create a copy of ApiV1NotificationsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1NotificationsPostResponseDtoCopyWith<
          _ApiV1NotificationsPostResponseDto>
      get copyWith => __$ApiV1NotificationsPostResponseDtoCopyWithImpl<
          _ApiV1NotificationsPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1NotificationsPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1NotificationsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.sourceUser, sourceUser) ||
                other.sourceUser == sourceUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      body,
      notificationType,
      isRead,
      createdDate,
      const DeepCollectionEquality().hash(_data),
      priority,
      relatedEntityId,
      sourceUser);

  @override
  String toString() {
    return 'ApiV1NotificationsPostResponseDto(id: $id, title: $title, body: $body, notificationType: $notificationType, isRead: $isRead, createdDate: $createdDate, data: $data, priority: $priority, relatedEntityId: $relatedEntityId, sourceUser: $sourceUser)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1NotificationsPostResponseDtoCopyWith<$Res>
    implements $ApiV1NotificationsPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1NotificationsPostResponseDtoCopyWith(
          _ApiV1NotificationsPostResponseDto value,
          $Res Function(_ApiV1NotificationsPostResponseDto) _then) =
      __$ApiV1NotificationsPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'body') String? body,
      @JsonKey(name: 'notificationType') NotificationTypeDto? notificationType,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'sourceUser') UserDetailDto2Dto? sourceUser});

  @override
  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser;
}

/// @nodoc
class __$ApiV1NotificationsPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1NotificationsPostResponseDtoCopyWith<$Res> {
  __$ApiV1NotificationsPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1NotificationsPostResponseDto _self;
  final $Res Function(_ApiV1NotificationsPostResponseDto) _then;

  /// Create a copy of ApiV1NotificationsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? body = freezed,
    Object? notificationType = freezed,
    Object? isRead = freezed,
    Object? createdDate = freezed,
    Object? data = freezed,
    Object? priority = freezed,
    Object? relatedEntityId = freezed,
    Object? sourceUser = freezed,
  }) {
    return _then(_ApiV1NotificationsPostResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceUser: freezed == sourceUser
          ? _self.sourceUser
          : sourceUser // ignore: cast_nullable_to_non_nullable
              as UserDetailDto2Dto?,
    ));
  }

  /// Create a copy of ApiV1NotificationsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDetailDto2DtoCopyWith<$Res>? get sourceUser {
    if (_self.sourceUser == null) {
      return null;
    }

    return $UserDetailDto2DtoCopyWith<$Res>(_self.sourceUser!, (value) {
      return _then(_self.copyWith(sourceUser: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1NotificationsPostRequestDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'body')
  String get body;
  @JsonKey(name: 'notificationType')
  NotificationTypeDto get notificationType;
  @JsonKey(name: 'targetUserId')
  String? get targetUserId;
  @JsonKey(name: 'relatedEntityId')
  String? get relatedEntityId;
  @JsonKey(name: 'scheduledFor')
  DateTime? get scheduledFor;
  @JsonKey(name: 'data')
  Map<String, String>? get data;
  @JsonKey(name: 'priority')
  int? get priority;

  /// Create a copy of ApiV1NotificationsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1NotificationsPostRequestDtoCopyWith<ApiV1NotificationsPostRequestDto>
      get copyWith => _$ApiV1NotificationsPostRequestDtoCopyWithImpl<
              ApiV1NotificationsPostRequestDto>(
          this as ApiV1NotificationsPostRequestDto, _$identity);

  /// Serializes this ApiV1NotificationsPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1NotificationsPostRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.targetUserId, targetUserId) ||
                other.targetUserId == targetUserId) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.scheduledFor, scheduledFor) ||
                other.scheduledFor == scheduledFor) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      targetUserId,
      relatedEntityId,
      scheduledFor,
      const DeepCollectionEquality().hash(data),
      priority);

  @override
  String toString() {
    return 'ApiV1NotificationsPostRequestDto(title: $title, body: $body, notificationType: $notificationType, targetUserId: $targetUserId, relatedEntityId: $relatedEntityId, scheduledFor: $scheduledFor, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class $ApiV1NotificationsPostRequestDtoCopyWith<$Res> {
  factory $ApiV1NotificationsPostRequestDtoCopyWith(
          ApiV1NotificationsPostRequestDto value,
          $Res Function(ApiV1NotificationsPostRequestDto) _then) =
      _$ApiV1NotificationsPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'targetUserId') String? targetUserId,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class _$ApiV1NotificationsPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1NotificationsPostRequestDtoCopyWith<$Res> {
  _$ApiV1NotificationsPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1NotificationsPostRequestDto _self;
  final $Res Function(ApiV1NotificationsPostRequestDto) _then;

  /// Create a copy of ApiV1NotificationsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? targetUserId = freezed,
    Object? relatedEntityId = freezed,
    Object? scheduledFor = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      targetUserId: freezed == targetUserId
          ? _self.targetUserId
          : targetUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      scheduledFor: freezed == scheduledFor
          ? _self.scheduledFor
          : scheduledFor // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1NotificationsPostRequestDto].
extension ApiV1NotificationsPostRequestDtoPatterns
    on ApiV1NotificationsPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1NotificationsPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'targetUserId') String? targetUserId,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostRequestDto() when $default != null:
        return $default(
            _that.title,
            _that.body,
            _that.notificationType,
            _that.targetUserId,
            _that.relatedEntityId,
            _that.scheduledFor,
            _that.data,
            _that.priority);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'targetUserId') String? targetUserId,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostRequestDto():
        return $default(
            _that.title,
            _that.body,
            _that.notificationType,
            _that.targetUserId,
            _that.relatedEntityId,
            _that.scheduledFor,
            _that.data,
            _that.priority);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'targetUserId') String? targetUserId,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsPostRequestDto() when $default != null:
        return $default(
            _that.title,
            _that.body,
            _that.notificationType,
            _that.targetUserId,
            _that.relatedEntityId,
            _that.scheduledFor,
            _that.data,
            _that.priority);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1NotificationsPostRequestDto
    implements ApiV1NotificationsPostRequestDto {
  _ApiV1NotificationsPostRequestDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'body') required this.body,
      @JsonKey(name: 'notificationType') required this.notificationType,
      @JsonKey(name: 'targetUserId') this.targetUserId,
      @JsonKey(name: 'relatedEntityId') this.relatedEntityId,
      @JsonKey(name: 'scheduledFor') this.scheduledFor,
      @JsonKey(name: 'data') final Map<String, String>? data,
      @JsonKey(name: 'priority') this.priority})
      : _data = data;
  factory _ApiV1NotificationsPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1NotificationsPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'body')
  final String body;
  @override
  @JsonKey(name: 'notificationType')
  final NotificationTypeDto notificationType;
  @override
  @JsonKey(name: 'targetUserId')
  final String? targetUserId;
  @override
  @JsonKey(name: 'relatedEntityId')
  final String? relatedEntityId;
  @override
  @JsonKey(name: 'scheduledFor')
  final DateTime? scheduledFor;
  final Map<String, String>? _data;
  @override
  @JsonKey(name: 'data')
  Map<String, String>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey(name: 'priority')
  final int? priority;

  /// Create a copy of ApiV1NotificationsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1NotificationsPostRequestDtoCopyWith<_ApiV1NotificationsPostRequestDto>
      get copyWith => __$ApiV1NotificationsPostRequestDtoCopyWithImpl<
          _ApiV1NotificationsPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1NotificationsPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1NotificationsPostRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.targetUserId, targetUserId) ||
                other.targetUserId == targetUserId) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            (identical(other.scheduledFor, scheduledFor) ||
                other.scheduledFor == scheduledFor) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      targetUserId,
      relatedEntityId,
      scheduledFor,
      const DeepCollectionEquality().hash(_data),
      priority);

  @override
  String toString() {
    return 'ApiV1NotificationsPostRequestDto(title: $title, body: $body, notificationType: $notificationType, targetUserId: $targetUserId, relatedEntityId: $relatedEntityId, scheduledFor: $scheduledFor, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1NotificationsPostRequestDtoCopyWith<$Res>
    implements $ApiV1NotificationsPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1NotificationsPostRequestDtoCopyWith(
          _ApiV1NotificationsPostRequestDto value,
          $Res Function(_ApiV1NotificationsPostRequestDto) _then) =
      __$ApiV1NotificationsPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'targetUserId') String? targetUserId,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'scheduledFor') DateTime? scheduledFor,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class __$ApiV1NotificationsPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1NotificationsPostRequestDtoCopyWith<$Res> {
  __$ApiV1NotificationsPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1NotificationsPostRequestDto _self;
  final $Res Function(_ApiV1NotificationsPostRequestDto) _then;

  /// Create a copy of ApiV1NotificationsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? targetUserId = freezed,
    Object? relatedEntityId = freezed,
    Object? scheduledFor = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_ApiV1NotificationsPostRequestDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      targetUserId: freezed == targetUserId
          ? _self.targetUserId
          : targetUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      scheduledFor: freezed == scheduledFor
          ? _self.scheduledFor
          : scheduledFor // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1NotificationsBulkPostRequestDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'body')
  String get body;
  @JsonKey(name: 'notificationType')
  NotificationTypeDto get notificationType;
  @JsonKey(name: 'userIds')
  List<String> get userIds;
  @JsonKey(name: 'relatedEntityId')
  String? get relatedEntityId;
  @JsonKey(name: 'data')
  Map<String, String>? get data;
  @JsonKey(name: 'priority')
  int? get priority;

  /// Create a copy of ApiV1NotificationsBulkPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1NotificationsBulkPostRequestDtoCopyWith<
          ApiV1NotificationsBulkPostRequestDto>
      get copyWith => _$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl<
              ApiV1NotificationsBulkPostRequestDto>(
          this as ApiV1NotificationsBulkPostRequestDto, _$identity);

  /// Serializes this ApiV1NotificationsBulkPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1NotificationsBulkPostRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            const DeepCollectionEquality().equals(other.userIds, userIds) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      const DeepCollectionEquality().hash(userIds),
      relatedEntityId,
      const DeepCollectionEquality().hash(data),
      priority);

  @override
  String toString() {
    return 'ApiV1NotificationsBulkPostRequestDto(title: $title, body: $body, notificationType: $notificationType, userIds: $userIds, relatedEntityId: $relatedEntityId, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class $ApiV1NotificationsBulkPostRequestDtoCopyWith<$Res> {
  factory $ApiV1NotificationsBulkPostRequestDtoCopyWith(
          ApiV1NotificationsBulkPostRequestDto value,
          $Res Function(ApiV1NotificationsBulkPostRequestDto) _then) =
      _$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'userIds') List<String> userIds,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class _$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1NotificationsBulkPostRequestDtoCopyWith<$Res> {
  _$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1NotificationsBulkPostRequestDto _self;
  final $Res Function(ApiV1NotificationsBulkPostRequestDto) _then;

  /// Create a copy of ApiV1NotificationsBulkPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? userIds = null,
    Object? relatedEntityId = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      userIds: null == userIds
          ? _self.userIds
          : userIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1NotificationsBulkPostRequestDto].
extension ApiV1NotificationsBulkPostRequestDtoPatterns
    on ApiV1NotificationsBulkPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsBulkPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsBulkPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1NotificationsBulkPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsBulkPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1NotificationsBulkPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsBulkPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'userIds') List<String> userIds,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsBulkPostRequestDto() when $default != null:
        return $default(_that.title, _that.body, _that.notificationType,
            _that.userIds, _that.relatedEntityId, _that.data, _that.priority);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'userIds') List<String> userIds,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsBulkPostRequestDto():
        return $default(_that.title, _that.body, _that.notificationType,
            _that.userIds, _that.relatedEntityId, _that.data, _that.priority);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'body') String body,
            @JsonKey(name: 'notificationType')
            NotificationTypeDto notificationType,
            @JsonKey(name: 'userIds') List<String> userIds,
            @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
            @JsonKey(name: 'data') Map<String, String>? data,
            @JsonKey(name: 'priority') int? priority)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1NotificationsBulkPostRequestDto() when $default != null:
        return $default(_that.title, _that.body, _that.notificationType,
            _that.userIds, _that.relatedEntityId, _that.data, _that.priority);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1NotificationsBulkPostRequestDto
    implements ApiV1NotificationsBulkPostRequestDto {
  _ApiV1NotificationsBulkPostRequestDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'body') required this.body,
      @JsonKey(name: 'notificationType') required this.notificationType,
      @JsonKey(name: 'userIds') required final List<String> userIds,
      @JsonKey(name: 'relatedEntityId') this.relatedEntityId,
      @JsonKey(name: 'data') final Map<String, String>? data,
      @JsonKey(name: 'priority') this.priority})
      : _userIds = userIds,
        _data = data;
  factory _ApiV1NotificationsBulkPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1NotificationsBulkPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'body')
  final String body;
  @override
  @JsonKey(name: 'notificationType')
  final NotificationTypeDto notificationType;
  final List<String> _userIds;
  @override
  @JsonKey(name: 'userIds')
  List<String> get userIds {
    if (_userIds is EqualUnmodifiableListView) return _userIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userIds);
  }

  @override
  @JsonKey(name: 'relatedEntityId')
  final String? relatedEntityId;
  final Map<String, String>? _data;
  @override
  @JsonKey(name: 'data')
  Map<String, String>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey(name: 'priority')
  final int? priority;

  /// Create a copy of ApiV1NotificationsBulkPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1NotificationsBulkPostRequestDtoCopyWith<
          _ApiV1NotificationsBulkPostRequestDto>
      get copyWith => __$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl<
          _ApiV1NotificationsBulkPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1NotificationsBulkPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1NotificationsBulkPostRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            const DeepCollectionEquality().equals(other._userIds, _userIds) &&
            (identical(other.relatedEntityId, relatedEntityId) ||
                other.relatedEntityId == relatedEntityId) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      body,
      notificationType,
      const DeepCollectionEquality().hash(_userIds),
      relatedEntityId,
      const DeepCollectionEquality().hash(_data),
      priority);

  @override
  String toString() {
    return 'ApiV1NotificationsBulkPostRequestDto(title: $title, body: $body, notificationType: $notificationType, userIds: $userIds, relatedEntityId: $relatedEntityId, data: $data, priority: $priority)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1NotificationsBulkPostRequestDtoCopyWith<$Res>
    implements $ApiV1NotificationsBulkPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1NotificationsBulkPostRequestDtoCopyWith(
          _ApiV1NotificationsBulkPostRequestDto value,
          $Res Function(_ApiV1NotificationsBulkPostRequestDto) _then) =
      __$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'body') String body,
      @JsonKey(name: 'notificationType') NotificationTypeDto notificationType,
      @JsonKey(name: 'userIds') List<String> userIds,
      @JsonKey(name: 'relatedEntityId') String? relatedEntityId,
      @JsonKey(name: 'data') Map<String, String>? data,
      @JsonKey(name: 'priority') int? priority});
}

/// @nodoc
class __$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1NotificationsBulkPostRequestDtoCopyWith<$Res> {
  __$ApiV1NotificationsBulkPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1NotificationsBulkPostRequestDto _self;
  final $Res Function(_ApiV1NotificationsBulkPostRequestDto) _then;

  /// Create a copy of ApiV1NotificationsBulkPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? body = null,
    Object? notificationType = null,
    Object? userIds = null,
    Object? relatedEntityId = freezed,
    Object? data = freezed,
    Object? priority = freezed,
  }) {
    return _then(_ApiV1NotificationsBulkPostRequestDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: null == body
          ? _self.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      notificationType: null == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationTypeDto,
      userIds: null == userIds
          ? _self._userIds
          : userIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      relatedEntityId: freezed == relatedEntityId
          ? _self.relatedEntityId
          : relatedEntityId // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      priority: freezed == priority
          ? _self.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1MediaUploadsPostResponseDto {
  @JsonKey(name: 'uploadUrl')
  String? get uploadUrl;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'expiresAt')
  DateTime? get expiresAt;
  @JsonKey(name: 'headers')
  Map<String, String>? get headers;

  /// Create a copy of ApiV1MediaUploadsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1MediaUploadsPostResponseDtoCopyWith<ApiV1MediaUploadsPostResponseDto>
      get copyWith => _$ApiV1MediaUploadsPostResponseDtoCopyWithImpl<
              ApiV1MediaUploadsPostResponseDto>(
          this as ApiV1MediaUploadsPostResponseDto, _$identity);

  /// Serializes this ApiV1MediaUploadsPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1MediaUploadsPostResponseDto &&
            (identical(other.uploadUrl, uploadUrl) ||
                other.uploadUrl == uploadUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            const DeepCollectionEquality().equals(other.headers, headers));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uploadUrl, fileUrl, fileName,
      expiresAt, const DeepCollectionEquality().hash(headers));

  @override
  String toString() {
    return 'ApiV1MediaUploadsPostResponseDto(uploadUrl: $uploadUrl, fileUrl: $fileUrl, fileName: $fileName, expiresAt: $expiresAt, headers: $headers)';
  }
}

/// @nodoc
abstract mixin class $ApiV1MediaUploadsPostResponseDtoCopyWith<$Res> {
  factory $ApiV1MediaUploadsPostResponseDtoCopyWith(
          ApiV1MediaUploadsPostResponseDto value,
          $Res Function(ApiV1MediaUploadsPostResponseDto) _then) =
      _$ApiV1MediaUploadsPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'uploadUrl') String? uploadUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'expiresAt') DateTime? expiresAt,
      @JsonKey(name: 'headers') Map<String, String>? headers});
}

/// @nodoc
class _$ApiV1MediaUploadsPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1MediaUploadsPostResponseDtoCopyWith<$Res> {
  _$ApiV1MediaUploadsPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1MediaUploadsPostResponseDto _self;
  final $Res Function(ApiV1MediaUploadsPostResponseDto) _then;

  /// Create a copy of ApiV1MediaUploadsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uploadUrl = freezed,
    Object? fileUrl = freezed,
    Object? fileName = freezed,
    Object? expiresAt = freezed,
    Object? headers = freezed,
  }) {
    return _then(_self.copyWith(
      uploadUrl: freezed == uploadUrl
          ? _self.uploadUrl
          : uploadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      headers: freezed == headers
          ? _self.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1MediaUploadsPostResponseDto].
extension ApiV1MediaUploadsPostResponseDtoPatterns
    on ApiV1MediaUploadsPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1MediaUploadsPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaUploadsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1MediaUploadsPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaUploadsPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1MediaUploadsPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaUploadsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaUploadsPostResponseDto() when $default != null:
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaUploadsPostResponseDto():
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'uploadUrl') String? uploadUrl,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'expiresAt') DateTime? expiresAt,
            @JsonKey(name: 'headers') Map<String, String>? headers)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaUploadsPostResponseDto() when $default != null:
        return $default(_that.uploadUrl, _that.fileUrl, _that.fileName,
            _that.expiresAt, _that.headers);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1MediaUploadsPostResponseDto
    implements ApiV1MediaUploadsPostResponseDto {
  _ApiV1MediaUploadsPostResponseDto(
      {@JsonKey(name: 'uploadUrl') this.uploadUrl,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'expiresAt') this.expiresAt,
      @JsonKey(name: 'headers') final Map<String, String>? headers})
      : _headers = headers;
  factory _ApiV1MediaUploadsPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1MediaUploadsPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'uploadUrl')
  final String? uploadUrl;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'expiresAt')
  final DateTime? expiresAt;
  final Map<String, String>? _headers;
  @override
  @JsonKey(name: 'headers')
  Map<String, String>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableMapView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ApiV1MediaUploadsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1MediaUploadsPostResponseDtoCopyWith<_ApiV1MediaUploadsPostResponseDto>
      get copyWith => __$ApiV1MediaUploadsPostResponseDtoCopyWithImpl<
          _ApiV1MediaUploadsPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1MediaUploadsPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1MediaUploadsPostResponseDto &&
            (identical(other.uploadUrl, uploadUrl) ||
                other.uploadUrl == uploadUrl) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            const DeepCollectionEquality().equals(other._headers, _headers));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uploadUrl, fileUrl, fileName,
      expiresAt, const DeepCollectionEquality().hash(_headers));

  @override
  String toString() {
    return 'ApiV1MediaUploadsPostResponseDto(uploadUrl: $uploadUrl, fileUrl: $fileUrl, fileName: $fileName, expiresAt: $expiresAt, headers: $headers)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1MediaUploadsPostResponseDtoCopyWith<$Res>
    implements $ApiV1MediaUploadsPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1MediaUploadsPostResponseDtoCopyWith(
          _ApiV1MediaUploadsPostResponseDto value,
          $Res Function(_ApiV1MediaUploadsPostResponseDto) _then) =
      __$ApiV1MediaUploadsPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'uploadUrl') String? uploadUrl,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'expiresAt') DateTime? expiresAt,
      @JsonKey(name: 'headers') Map<String, String>? headers});
}

/// @nodoc
class __$ApiV1MediaUploadsPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1MediaUploadsPostResponseDtoCopyWith<$Res> {
  __$ApiV1MediaUploadsPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1MediaUploadsPostResponseDto _self;
  final $Res Function(_ApiV1MediaUploadsPostResponseDto) _then;

  /// Create a copy of ApiV1MediaUploadsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uploadUrl = freezed,
    Object? fileUrl = freezed,
    Object? fileName = freezed,
    Object? expiresAt = freezed,
    Object? headers = freezed,
  }) {
    return _then(_ApiV1MediaUploadsPostResponseDto(
      uploadUrl: freezed == uploadUrl
          ? _self.uploadUrl
          : uploadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      headers: freezed == headers
          ? _self._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1MediaImagesPostResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'stepId')
  String? get stepId;
  @JsonKey(name: 'mediaType')
  String? get mediaType;
  @JsonKey(name: 'originalUrl')
  String? get originalUrl;
  @JsonKey(name: 'largeUrl')
  String? get largeUrl;
  @JsonKey(name: 'mediumUrl')
  String? get mediumUrl;
  @JsonKey(name: 'smallUrl')
  String? get smallUrl;
  @JsonKey(name: 'thumbnailUrl')
  String? get thumbnailUrl;
  @JsonKey(name: 'videoThumbnailUrl')
  String? get videoThumbnailUrl;
  @JsonKey(name: 'bunnyVideoId')
  String? get bunnyVideoId;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'duration')
  num? get duration;
  @JsonKey(name: 'status')
  MediaStatusDto? get status;
  @JsonKey(name: 'isVideo')
  bool? get isVideo;
  @JsonKey(name: 'isImage')
  bool? get isImage;

  /// Create a copy of ApiV1MediaImagesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1MediaImagesPostResponseDtoCopyWith<ApiV1MediaImagesPostResponseDto>
      get copyWith => _$ApiV1MediaImagesPostResponseDtoCopyWithImpl<
              ApiV1MediaImagesPostResponseDto>(
          this as ApiV1MediaImagesPostResponseDto, _$identity);

  /// Serializes this ApiV1MediaImagesPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1MediaImagesPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'ApiV1MediaImagesPostResponseDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class $ApiV1MediaImagesPostResponseDtoCopyWith<$Res> {
  factory $ApiV1MediaImagesPostResponseDtoCopyWith(
          ApiV1MediaImagesPostResponseDto value,
          $Res Function(ApiV1MediaImagesPostResponseDto) _then) =
      _$ApiV1MediaImagesPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class _$ApiV1MediaImagesPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1MediaImagesPostResponseDtoCopyWith<$Res> {
  _$ApiV1MediaImagesPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1MediaImagesPostResponseDto _self;
  final $Res Function(ApiV1MediaImagesPostResponseDto) _then;

  /// Create a copy of ApiV1MediaImagesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1MediaImagesPostResponseDto].
extension ApiV1MediaImagesPostResponseDtoPatterns
    on ApiV1MediaImagesPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1MediaImagesPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1MediaImagesPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1MediaImagesPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostResponseDto():
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1MediaImagesPostResponseDto
    implements ApiV1MediaImagesPostResponseDto {
  _ApiV1MediaImagesPostResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'stepId') this.stepId,
      @JsonKey(name: 'mediaType') this.mediaType,
      @JsonKey(name: 'originalUrl') this.originalUrl,
      @JsonKey(name: 'largeUrl') this.largeUrl,
      @JsonKey(name: 'mediumUrl') this.mediumUrl,
      @JsonKey(name: 'smallUrl') this.smallUrl,
      @JsonKey(name: 'thumbnailUrl') this.thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') this.videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') this.bunnyVideoId,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'duration') this.duration,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'isVideo') this.isVideo,
      @JsonKey(name: 'isImage') this.isImage});
  factory _ApiV1MediaImagesPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1MediaImagesPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'stepId')
  final String? stepId;
  @override
  @JsonKey(name: 'mediaType')
  final String? mediaType;
  @override
  @JsonKey(name: 'originalUrl')
  final String? originalUrl;
  @override
  @JsonKey(name: 'largeUrl')
  final String? largeUrl;
  @override
  @JsonKey(name: 'mediumUrl')
  final String? mediumUrl;
  @override
  @JsonKey(name: 'smallUrl')
  final String? smallUrl;
  @override
  @JsonKey(name: 'thumbnailUrl')
  final String? thumbnailUrl;
  @override
  @JsonKey(name: 'videoThumbnailUrl')
  final String? videoThumbnailUrl;
  @override
  @JsonKey(name: 'bunnyVideoId')
  final String? bunnyVideoId;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'duration')
  final num? duration;
  @override
  @JsonKey(name: 'status')
  final MediaStatusDto? status;
  @override
  @JsonKey(name: 'isVideo')
  final bool? isVideo;
  @override
  @JsonKey(name: 'isImage')
  final bool? isImage;

  /// Create a copy of ApiV1MediaImagesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1MediaImagesPostResponseDtoCopyWith<_ApiV1MediaImagesPostResponseDto>
      get copyWith => __$ApiV1MediaImagesPostResponseDtoCopyWithImpl<
          _ApiV1MediaImagesPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1MediaImagesPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1MediaImagesPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'ApiV1MediaImagesPostResponseDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1MediaImagesPostResponseDtoCopyWith<$Res>
    implements $ApiV1MediaImagesPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1MediaImagesPostResponseDtoCopyWith(
          _ApiV1MediaImagesPostResponseDto value,
          $Res Function(_ApiV1MediaImagesPostResponseDto) _then) =
      __$ApiV1MediaImagesPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class __$ApiV1MediaImagesPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1MediaImagesPostResponseDtoCopyWith<$Res> {
  __$ApiV1MediaImagesPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1MediaImagesPostResponseDto _self;
  final $Res Function(_ApiV1MediaImagesPostResponseDto) _then;

  /// Create a copy of ApiV1MediaImagesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_ApiV1MediaImagesPostResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1MediaImagesPostRequestDto {
  @JsonKey(name: 'fileName')
  String? get fileName;
  @JsonKey(name: 'fileUrl')
  String? get fileUrl;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'contentType')
  String? get contentType;

  /// Create a copy of ApiV1MediaImagesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1MediaImagesPostRequestDtoCopyWith<ApiV1MediaImagesPostRequestDto>
      get copyWith => _$ApiV1MediaImagesPostRequestDtoCopyWithImpl<
              ApiV1MediaImagesPostRequestDto>(
          this as ApiV1MediaImagesPostRequestDto, _$identity);

  /// Serializes this ApiV1MediaImagesPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1MediaImagesPostRequestDto &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileName, fileUrl, width, height, size, contentType);

  @override
  String toString() {
    return 'ApiV1MediaImagesPostRequestDto(fileName: $fileName, fileUrl: $fileUrl, width: $width, height: $height, size: $size, contentType: $contentType)';
  }
}

/// @nodoc
abstract mixin class $ApiV1MediaImagesPostRequestDtoCopyWith<$Res> {
  factory $ApiV1MediaImagesPostRequestDtoCopyWith(
          ApiV1MediaImagesPostRequestDto value,
          $Res Function(ApiV1MediaImagesPostRequestDto) _then) =
      _$ApiV1MediaImagesPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'contentType') String? contentType});
}

/// @nodoc
class _$ApiV1MediaImagesPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1MediaImagesPostRequestDtoCopyWith<$Res> {
  _$ApiV1MediaImagesPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1MediaImagesPostRequestDto _self;
  final $Res Function(ApiV1MediaImagesPostRequestDto) _then;

  /// Create a copy of ApiV1MediaImagesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = freezed,
    Object? fileUrl = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? contentType = freezed,
  }) {
    return _then(_self.copyWith(
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1MediaImagesPostRequestDto].
extension ApiV1MediaImagesPostRequestDtoPatterns
    on ApiV1MediaImagesPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1MediaImagesPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1MediaImagesPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1MediaImagesPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostRequestDto() when $default != null:
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostRequestDto():
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'fileName') String? fileName,
            @JsonKey(name: 'fileUrl') String? fileUrl,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'contentType') String? contentType)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaImagesPostRequestDto() when $default != null:
        return $default(_that.fileName, _that.fileUrl, _that.width,
            _that.height, _that.size, _that.contentType);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1MediaImagesPostRequestDto
    implements ApiV1MediaImagesPostRequestDto {
  _ApiV1MediaImagesPostRequestDto(
      {@JsonKey(name: 'fileName') this.fileName,
      @JsonKey(name: 'fileUrl') this.fileUrl,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'contentType') this.contentType});
  factory _ApiV1MediaImagesPostRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1MediaImagesPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'fileName')
  final String? fileName;
  @override
  @JsonKey(name: 'fileUrl')
  final String? fileUrl;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'contentType')
  final String? contentType;

  /// Create a copy of ApiV1MediaImagesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1MediaImagesPostRequestDtoCopyWith<_ApiV1MediaImagesPostRequestDto>
      get copyWith => __$ApiV1MediaImagesPostRequestDtoCopyWithImpl<
          _ApiV1MediaImagesPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1MediaImagesPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1MediaImagesPostRequestDto &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.fileUrl, fileUrl) || other.fileUrl == fileUrl) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileName, fileUrl, width, height, size, contentType);

  @override
  String toString() {
    return 'ApiV1MediaImagesPostRequestDto(fileName: $fileName, fileUrl: $fileUrl, width: $width, height: $height, size: $size, contentType: $contentType)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1MediaImagesPostRequestDtoCopyWith<$Res>
    implements $ApiV1MediaImagesPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1MediaImagesPostRequestDtoCopyWith(
          _ApiV1MediaImagesPostRequestDto value,
          $Res Function(_ApiV1MediaImagesPostRequestDto) _then) =
      __$ApiV1MediaImagesPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'fileName') String? fileName,
      @JsonKey(name: 'fileUrl') String? fileUrl,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'contentType') String? contentType});
}

/// @nodoc
class __$ApiV1MediaImagesPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1MediaImagesPostRequestDtoCopyWith<$Res> {
  __$ApiV1MediaImagesPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1MediaImagesPostRequestDto _self;
  final $Res Function(_ApiV1MediaImagesPostRequestDto) _then;

  /// Create a copy of ApiV1MediaImagesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileName = freezed,
    Object? fileUrl = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? contentType = freezed,
  }) {
    return _then(_ApiV1MediaImagesPostRequestDto(
      fileName: freezed == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      fileUrl: freezed == fileUrl
          ? _self.fileUrl
          : fileUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1MediaVideosPostResponseDto {
  @JsonKey(name: 'authorizationSignature')
  String? get authorizationSignature;
  @JsonKey(name: 'authorizationExpire')
  int? get authorizationExpire;
  @JsonKey(name: 'videoGuid')
  String? get videoGuid;
  @JsonKey(name: 'libraryId')
  int? get libraryId;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'collectionId')
  String? get collectionId;
  @JsonKey(name: 'media')
  StepMediaDto? get media;

  /// Create a copy of ApiV1MediaVideosPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1MediaVideosPostResponseDtoCopyWith<ApiV1MediaVideosPostResponseDto>
      get copyWith => _$ApiV1MediaVideosPostResponseDtoCopyWithImpl<
              ApiV1MediaVideosPostResponseDto>(
          this as ApiV1MediaVideosPostResponseDto, _$identity);

  /// Serializes this ApiV1MediaVideosPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1MediaVideosPostResponseDto &&
            (identical(other.authorizationSignature, authorizationSignature) ||
                other.authorizationSignature == authorizationSignature) &&
            (identical(other.authorizationExpire, authorizationExpire) ||
                other.authorizationExpire == authorizationExpire) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.libraryId, libraryId) ||
                other.libraryId == libraryId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.collectionId, collectionId) ||
                other.collectionId == collectionId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationSignature,
      authorizationExpire, videoGuid, libraryId, title, collectionId, media);

  @override
  String toString() {
    return 'ApiV1MediaVideosPostResponseDto(authorizationSignature: $authorizationSignature, authorizationExpire: $authorizationExpire, videoGuid: $videoGuid, libraryId: $libraryId, title: $title, collectionId: $collectionId, media: $media)';
  }
}

/// @nodoc
abstract mixin class $ApiV1MediaVideosPostResponseDtoCopyWith<$Res> {
  factory $ApiV1MediaVideosPostResponseDtoCopyWith(
          ApiV1MediaVideosPostResponseDto value,
          $Res Function(ApiV1MediaVideosPostResponseDto) _then) =
      _$ApiV1MediaVideosPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'authorizationSignature') String? authorizationSignature,
      @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'libraryId') int? libraryId,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'collectionId') String? collectionId,
      @JsonKey(name: 'media') StepMediaDto? media});

  $StepMediaDtoCopyWith<$Res>? get media;
}

/// @nodoc
class _$ApiV1MediaVideosPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1MediaVideosPostResponseDtoCopyWith<$Res> {
  _$ApiV1MediaVideosPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1MediaVideosPostResponseDto _self;
  final $Res Function(ApiV1MediaVideosPostResponseDto) _then;

  /// Create a copy of ApiV1MediaVideosPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? authorizationSignature = freezed,
    Object? authorizationExpire = freezed,
    Object? videoGuid = freezed,
    Object? libraryId = freezed,
    Object? title = freezed,
    Object? collectionId = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      authorizationSignature: freezed == authorizationSignature
          ? _self.authorizationSignature
          : authorizationSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      authorizationExpire: freezed == authorizationExpire
          ? _self.authorizationExpire
          : authorizationExpire // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      libraryId: freezed == libraryId
          ? _self.libraryId
          : libraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      collectionId: freezed == collectionId
          ? _self.collectionId
          : collectionId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto?,
    ));
  }

  /// Create a copy of ApiV1MediaVideosPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1MediaVideosPostResponseDto].
extension ApiV1MediaVideosPostResponseDtoPatterns
    on ApiV1MediaVideosPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1MediaVideosPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaVideosPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1MediaVideosPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaVideosPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1MediaVideosPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaVideosPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaVideosPostResponseDto() when $default != null:
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaVideosPostResponseDto():
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'authorizationSignature')
            String? authorizationSignature,
            @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'libraryId') int? libraryId,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'collectionId') String? collectionId,
            @JsonKey(name: 'media') StepMediaDto? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaVideosPostResponseDto() when $default != null:
        return $default(
            _that.authorizationSignature,
            _that.authorizationExpire,
            _that.videoGuid,
            _that.libraryId,
            _that.title,
            _that.collectionId,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1MediaVideosPostResponseDto
    implements ApiV1MediaVideosPostResponseDto {
  _ApiV1MediaVideosPostResponseDto(
      {@JsonKey(name: 'authorizationSignature') this.authorizationSignature,
      @JsonKey(name: 'authorizationExpire') this.authorizationExpire,
      @JsonKey(name: 'videoGuid') this.videoGuid,
      @JsonKey(name: 'libraryId') this.libraryId,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'collectionId') this.collectionId,
      @JsonKey(name: 'media') this.media});
  factory _ApiV1MediaVideosPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1MediaVideosPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'authorizationSignature')
  final String? authorizationSignature;
  @override
  @JsonKey(name: 'authorizationExpire')
  final int? authorizationExpire;
  @override
  @JsonKey(name: 'videoGuid')
  final String? videoGuid;
  @override
  @JsonKey(name: 'libraryId')
  final int? libraryId;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'collectionId')
  final String? collectionId;
  @override
  @JsonKey(name: 'media')
  final StepMediaDto? media;

  /// Create a copy of ApiV1MediaVideosPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1MediaVideosPostResponseDtoCopyWith<_ApiV1MediaVideosPostResponseDto>
      get copyWith => __$ApiV1MediaVideosPostResponseDtoCopyWithImpl<
          _ApiV1MediaVideosPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1MediaVideosPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1MediaVideosPostResponseDto &&
            (identical(other.authorizationSignature, authorizationSignature) ||
                other.authorizationSignature == authorizationSignature) &&
            (identical(other.authorizationExpire, authorizationExpire) ||
                other.authorizationExpire == authorizationExpire) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.libraryId, libraryId) ||
                other.libraryId == libraryId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.collectionId, collectionId) ||
                other.collectionId == collectionId) &&
            (identical(other.media, media) || other.media == media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationSignature,
      authorizationExpire, videoGuid, libraryId, title, collectionId, media);

  @override
  String toString() {
    return 'ApiV1MediaVideosPostResponseDto(authorizationSignature: $authorizationSignature, authorizationExpire: $authorizationExpire, videoGuid: $videoGuid, libraryId: $libraryId, title: $title, collectionId: $collectionId, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1MediaVideosPostResponseDtoCopyWith<$Res>
    implements $ApiV1MediaVideosPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1MediaVideosPostResponseDtoCopyWith(
          _ApiV1MediaVideosPostResponseDto value,
          $Res Function(_ApiV1MediaVideosPostResponseDto) _then) =
      __$ApiV1MediaVideosPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'authorizationSignature') String? authorizationSignature,
      @JsonKey(name: 'authorizationExpire') int? authorizationExpire,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'libraryId') int? libraryId,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'collectionId') String? collectionId,
      @JsonKey(name: 'media') StepMediaDto? media});

  @override
  $StepMediaDtoCopyWith<$Res>? get media;
}

/// @nodoc
class __$ApiV1MediaVideosPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1MediaVideosPostResponseDtoCopyWith<$Res> {
  __$ApiV1MediaVideosPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1MediaVideosPostResponseDto _self;
  final $Res Function(_ApiV1MediaVideosPostResponseDto) _then;

  /// Create a copy of ApiV1MediaVideosPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? authorizationSignature = freezed,
    Object? authorizationExpire = freezed,
    Object? videoGuid = freezed,
    Object? libraryId = freezed,
    Object? title = freezed,
    Object? collectionId = freezed,
    Object? media = freezed,
  }) {
    return _then(_ApiV1MediaVideosPostResponseDto(
      authorizationSignature: freezed == authorizationSignature
          ? _self.authorizationSignature
          : authorizationSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      authorizationExpire: freezed == authorizationExpire
          ? _self.authorizationExpire
          : authorizationExpire // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      libraryId: freezed == libraryId
          ? _self.libraryId
          : libraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      collectionId: freezed == collectionId
          ? _self.collectionId
          : collectionId // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as StepMediaDto?,
    ));
  }

  /// Create a copy of ApiV1MediaVideosPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StepMediaDtoCopyWith<$Res>? get media {
    if (_self.media == null) {
      return null;
    }

    return $StepMediaDtoCopyWith<$Res>(_self.media!, (value) {
      return _then(_self.copyWith(media: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1MediaMediaIdGetResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'stepId')
  String? get stepId;
  @JsonKey(name: 'mediaType')
  String? get mediaType;
  @JsonKey(name: 'originalUrl')
  String? get originalUrl;
  @JsonKey(name: 'largeUrl')
  String? get largeUrl;
  @JsonKey(name: 'mediumUrl')
  String? get mediumUrl;
  @JsonKey(name: 'smallUrl')
  String? get smallUrl;
  @JsonKey(name: 'thumbnailUrl')
  String? get thumbnailUrl;
  @JsonKey(name: 'videoThumbnailUrl')
  String? get videoThumbnailUrl;
  @JsonKey(name: 'bunnyVideoId')
  String? get bunnyVideoId;
  @JsonKey(name: 'width')
  int? get width;
  @JsonKey(name: 'height')
  int? get height;
  @JsonKey(name: 'size')
  int? get size;
  @JsonKey(name: 'duration')
  num? get duration;
  @JsonKey(name: 'status')
  MediaStatusDto? get status;
  @JsonKey(name: 'isVideo')
  bool? get isVideo;
  @JsonKey(name: 'isImage')
  bool? get isImage;

  /// Create a copy of ApiV1MediaMediaIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1MediaMediaIdGetResponseDtoCopyWith<ApiV1MediaMediaIdGetResponseDto>
      get copyWith => _$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl<
              ApiV1MediaMediaIdGetResponseDto>(
          this as ApiV1MediaMediaIdGetResponseDto, _$identity);

  /// Serializes this ApiV1MediaMediaIdGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1MediaMediaIdGetResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'ApiV1MediaMediaIdGetResponseDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class $ApiV1MediaMediaIdGetResponseDtoCopyWith<$Res> {
  factory $ApiV1MediaMediaIdGetResponseDtoCopyWith(
          ApiV1MediaMediaIdGetResponseDto value,
          $Res Function(ApiV1MediaMediaIdGetResponseDto) _then) =
      _$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class _$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1MediaMediaIdGetResponseDtoCopyWith<$Res> {
  _$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1MediaMediaIdGetResponseDto _self;
  final $Res Function(ApiV1MediaMediaIdGetResponseDto) _then;

  /// Create a copy of ApiV1MediaMediaIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1MediaMediaIdGetResponseDto].
extension ApiV1MediaMediaIdGetResponseDtoPatterns
    on ApiV1MediaMediaIdGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1MediaMediaIdGetResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaMediaIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1MediaMediaIdGetResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaMediaIdGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1MediaMediaIdGetResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaMediaIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaMediaIdGetResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaMediaIdGetResponseDto():
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'mediaType') String? mediaType,
            @JsonKey(name: 'originalUrl') String? originalUrl,
            @JsonKey(name: 'largeUrl') String? largeUrl,
            @JsonKey(name: 'mediumUrl') String? mediumUrl,
            @JsonKey(name: 'smallUrl') String? smallUrl,
            @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
            @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
            @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
            @JsonKey(name: 'width') int? width,
            @JsonKey(name: 'height') int? height,
            @JsonKey(name: 'size') int? size,
            @JsonKey(name: 'duration') num? duration,
            @JsonKey(name: 'status') MediaStatusDto? status,
            @JsonKey(name: 'isVideo') bool? isVideo,
            @JsonKey(name: 'isImage') bool? isImage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1MediaMediaIdGetResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.stepId,
            _that.mediaType,
            _that.originalUrl,
            _that.largeUrl,
            _that.mediumUrl,
            _that.smallUrl,
            _that.thumbnailUrl,
            _that.videoThumbnailUrl,
            _that.bunnyVideoId,
            _that.width,
            _that.height,
            _that.size,
            _that.duration,
            _that.status,
            _that.isVideo,
            _that.isImage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1MediaMediaIdGetResponseDto
    implements ApiV1MediaMediaIdGetResponseDto {
  _ApiV1MediaMediaIdGetResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'stepId') this.stepId,
      @JsonKey(name: 'mediaType') this.mediaType,
      @JsonKey(name: 'originalUrl') this.originalUrl,
      @JsonKey(name: 'largeUrl') this.largeUrl,
      @JsonKey(name: 'mediumUrl') this.mediumUrl,
      @JsonKey(name: 'smallUrl') this.smallUrl,
      @JsonKey(name: 'thumbnailUrl') this.thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') this.videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') this.bunnyVideoId,
      @JsonKey(name: 'width') this.width,
      @JsonKey(name: 'height') this.height,
      @JsonKey(name: 'size') this.size,
      @JsonKey(name: 'duration') this.duration,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'isVideo') this.isVideo,
      @JsonKey(name: 'isImage') this.isImage});
  factory _ApiV1MediaMediaIdGetResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1MediaMediaIdGetResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'stepId')
  final String? stepId;
  @override
  @JsonKey(name: 'mediaType')
  final String? mediaType;
  @override
  @JsonKey(name: 'originalUrl')
  final String? originalUrl;
  @override
  @JsonKey(name: 'largeUrl')
  final String? largeUrl;
  @override
  @JsonKey(name: 'mediumUrl')
  final String? mediumUrl;
  @override
  @JsonKey(name: 'smallUrl')
  final String? smallUrl;
  @override
  @JsonKey(name: 'thumbnailUrl')
  final String? thumbnailUrl;
  @override
  @JsonKey(name: 'videoThumbnailUrl')
  final String? videoThumbnailUrl;
  @override
  @JsonKey(name: 'bunnyVideoId')
  final String? bunnyVideoId;
  @override
  @JsonKey(name: 'width')
  final int? width;
  @override
  @JsonKey(name: 'height')
  final int? height;
  @override
  @JsonKey(name: 'size')
  final int? size;
  @override
  @JsonKey(name: 'duration')
  final num? duration;
  @override
  @JsonKey(name: 'status')
  final MediaStatusDto? status;
  @override
  @JsonKey(name: 'isVideo')
  final bool? isVideo;
  @override
  @JsonKey(name: 'isImage')
  final bool? isImage;

  /// Create a copy of ApiV1MediaMediaIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1MediaMediaIdGetResponseDtoCopyWith<_ApiV1MediaMediaIdGetResponseDto>
      get copyWith => __$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl<
          _ApiV1MediaMediaIdGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1MediaMediaIdGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1MediaMediaIdGetResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.originalUrl, originalUrl) ||
                other.originalUrl == originalUrl) &&
            (identical(other.largeUrl, largeUrl) ||
                other.largeUrl == largeUrl) &&
            (identical(other.mediumUrl, mediumUrl) ||
                other.mediumUrl == mediumUrl) &&
            (identical(other.smallUrl, smallUrl) ||
                other.smallUrl == smallUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.videoThumbnailUrl, videoThumbnailUrl) ||
                other.videoThumbnailUrl == videoThumbnailUrl) &&
            (identical(other.bunnyVideoId, bunnyVideoId) ||
                other.bunnyVideoId == bunnyVideoId) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isVideo, isVideo) || other.isVideo == isVideo) &&
            (identical(other.isImage, isImage) || other.isImage == isImage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stepId,
      mediaType,
      originalUrl,
      largeUrl,
      mediumUrl,
      smallUrl,
      thumbnailUrl,
      videoThumbnailUrl,
      bunnyVideoId,
      width,
      height,
      size,
      duration,
      status,
      isVideo,
      isImage);

  @override
  String toString() {
    return 'ApiV1MediaMediaIdGetResponseDto(id: $id, stepId: $stepId, mediaType: $mediaType, originalUrl: $originalUrl, largeUrl: $largeUrl, mediumUrl: $mediumUrl, smallUrl: $smallUrl, thumbnailUrl: $thumbnailUrl, videoThumbnailUrl: $videoThumbnailUrl, bunnyVideoId: $bunnyVideoId, width: $width, height: $height, size: $size, duration: $duration, status: $status, isVideo: $isVideo, isImage: $isImage)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1MediaMediaIdGetResponseDtoCopyWith<$Res>
    implements $ApiV1MediaMediaIdGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1MediaMediaIdGetResponseDtoCopyWith(
          _ApiV1MediaMediaIdGetResponseDto value,
          $Res Function(_ApiV1MediaMediaIdGetResponseDto) _then) =
      __$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'mediaType') String? mediaType,
      @JsonKey(name: 'originalUrl') String? originalUrl,
      @JsonKey(name: 'largeUrl') String? largeUrl,
      @JsonKey(name: 'mediumUrl') String? mediumUrl,
      @JsonKey(name: 'smallUrl') String? smallUrl,
      @JsonKey(name: 'thumbnailUrl') String? thumbnailUrl,
      @JsonKey(name: 'videoThumbnailUrl') String? videoThumbnailUrl,
      @JsonKey(name: 'bunnyVideoId') String? bunnyVideoId,
      @JsonKey(name: 'width') int? width,
      @JsonKey(name: 'height') int? height,
      @JsonKey(name: 'size') int? size,
      @JsonKey(name: 'duration') num? duration,
      @JsonKey(name: 'status') MediaStatusDto? status,
      @JsonKey(name: 'isVideo') bool? isVideo,
      @JsonKey(name: 'isImage') bool? isImage});
}

/// @nodoc
class __$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1MediaMediaIdGetResponseDtoCopyWith<$Res> {
  __$ApiV1MediaMediaIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1MediaMediaIdGetResponseDto _self;
  final $Res Function(_ApiV1MediaMediaIdGetResponseDto) _then;

  /// Create a copy of ApiV1MediaMediaIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? stepId = freezed,
    Object? mediaType = freezed,
    Object? originalUrl = freezed,
    Object? largeUrl = freezed,
    Object? mediumUrl = freezed,
    Object? smallUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? videoThumbnailUrl = freezed,
    Object? bunnyVideoId = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? duration = freezed,
    Object? status = freezed,
    Object? isVideo = freezed,
    Object? isImage = freezed,
  }) {
    return _then(_ApiV1MediaMediaIdGetResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: freezed == mediaType
          ? _self.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String?,
      originalUrl: freezed == originalUrl
          ? _self.originalUrl
          : originalUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      largeUrl: freezed == largeUrl
          ? _self.largeUrl
          : largeUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      mediumUrl: freezed == mediumUrl
          ? _self.mediumUrl
          : mediumUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      smallUrl: freezed == smallUrl
          ? _self.smallUrl
          : smallUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _self.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      videoThumbnailUrl: freezed == videoThumbnailUrl
          ? _self.videoThumbnailUrl
          : videoThumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      bunnyVideoId: freezed == bunnyVideoId
          ? _self.bunnyVideoId
          : bunnyVideoId // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _self.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _self.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as num?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MediaStatusDto?,
      isVideo: freezed == isVideo
          ? _self.isVideo
          : isVideo // ignore: cast_nullable_to_non_nullable
              as bool?,
      isImage: freezed == isImage
          ? _self.isImage
          : isImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1WebhooksVideoUpdatesPostRequestDto {
  @JsonKey(name: 'videoLibraryId')
  int? get videoLibraryId;
  @JsonKey(name: 'videoGuid')
  String? get videoGuid;
  @JsonKey(name: 'status')
  int? get status;

  /// Create a copy of ApiV1WebhooksVideoUpdatesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith<
          ApiV1WebhooksVideoUpdatesPostRequestDto>
      get copyWith => _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl<
              ApiV1WebhooksVideoUpdatesPostRequestDto>(
          this as ApiV1WebhooksVideoUpdatesPostRequestDto, _$identity);

  /// Serializes this ApiV1WebhooksVideoUpdatesPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1WebhooksVideoUpdatesPostRequestDto &&
            (identical(other.videoLibraryId, videoLibraryId) ||
                other.videoLibraryId == videoLibraryId) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, videoLibraryId, videoGuid, status);

  @override
  String toString() {
    return 'ApiV1WebhooksVideoUpdatesPostRequestDto(videoLibraryId: $videoLibraryId, videoGuid: $videoGuid, status: $status)';
  }
}

/// @nodoc
abstract mixin class $ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith<$Res> {
  factory $ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith(
          ApiV1WebhooksVideoUpdatesPostRequestDto value,
          $Res Function(ApiV1WebhooksVideoUpdatesPostRequestDto) _then) =
      _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'videoLibraryId') int? videoLibraryId,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'status') int? status});
}

/// @nodoc
class _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith<$Res> {
  _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1WebhooksVideoUpdatesPostRequestDto _self;
  final $Res Function(ApiV1WebhooksVideoUpdatesPostRequestDto) _then;

  /// Create a copy of ApiV1WebhooksVideoUpdatesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? videoLibraryId = freezed,
    Object? videoGuid = freezed,
    Object? status = freezed,
  }) {
    return _then(_self.copyWith(
      videoLibraryId: freezed == videoLibraryId
          ? _self.videoLibraryId
          : videoLibraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1WebhooksVideoUpdatesPostRequestDto].
extension ApiV1WebhooksVideoUpdatesPostRequestDtoPatterns
    on ApiV1WebhooksVideoUpdatesPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1WebhooksVideoUpdatesPostRequestDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1WebhooksVideoUpdatesPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1WebhooksVideoUpdatesPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1WebhooksVideoUpdatesPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1WebhooksVideoUpdatesPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1WebhooksVideoUpdatesPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'videoLibraryId') int? videoLibraryId,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'status') int? status)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1WebhooksVideoUpdatesPostRequestDto() when $default != null:
        return $default(_that.videoLibraryId, _that.videoGuid, _that.status);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'videoLibraryId') int? videoLibraryId,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'status') int? status)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1WebhooksVideoUpdatesPostRequestDto():
        return $default(_that.videoLibraryId, _that.videoGuid, _that.status);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'videoLibraryId') int? videoLibraryId,
            @JsonKey(name: 'videoGuid') String? videoGuid,
            @JsonKey(name: 'status') int? status)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1WebhooksVideoUpdatesPostRequestDto() when $default != null:
        return $default(_that.videoLibraryId, _that.videoGuid, _that.status);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1WebhooksVideoUpdatesPostRequestDto
    implements ApiV1WebhooksVideoUpdatesPostRequestDto {
  _ApiV1WebhooksVideoUpdatesPostRequestDto(
      {@JsonKey(name: 'videoLibraryId') this.videoLibraryId,
      @JsonKey(name: 'videoGuid') this.videoGuid,
      @JsonKey(name: 'status') this.status});
  factory _ApiV1WebhooksVideoUpdatesPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1WebhooksVideoUpdatesPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'videoLibraryId')
  final int? videoLibraryId;
  @override
  @JsonKey(name: 'videoGuid')
  final String? videoGuid;
  @override
  @JsonKey(name: 'status')
  final int? status;

  /// Create a copy of ApiV1WebhooksVideoUpdatesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith<
          _ApiV1WebhooksVideoUpdatesPostRequestDto>
      get copyWith => __$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl<
          _ApiV1WebhooksVideoUpdatesPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1WebhooksVideoUpdatesPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1WebhooksVideoUpdatesPostRequestDto &&
            (identical(other.videoLibraryId, videoLibraryId) ||
                other.videoLibraryId == videoLibraryId) &&
            (identical(other.videoGuid, videoGuid) ||
                other.videoGuid == videoGuid) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, videoLibraryId, videoGuid, status);

  @override
  String toString() {
    return 'ApiV1WebhooksVideoUpdatesPostRequestDto(videoLibraryId: $videoLibraryId, videoGuid: $videoGuid, status: $status)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith<$Res>
    implements $ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith(
          _ApiV1WebhooksVideoUpdatesPostRequestDto value,
          $Res Function(_ApiV1WebhooksVideoUpdatesPostRequestDto) _then) =
      __$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'videoLibraryId') int? videoLibraryId,
      @JsonKey(name: 'videoGuid') String? videoGuid,
      @JsonKey(name: 'status') int? status});
}

/// @nodoc
class __$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWith<$Res> {
  __$ApiV1WebhooksVideoUpdatesPostRequestDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1WebhooksVideoUpdatesPostRequestDto _self;
  final $Res Function(_ApiV1WebhooksVideoUpdatesPostRequestDto) _then;

  /// Create a copy of ApiV1WebhooksVideoUpdatesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? videoLibraryId = freezed,
    Object? videoGuid = freezed,
    Object? status = freezed,
  }) {
    return _then(_ApiV1WebhooksVideoUpdatesPostRequestDto(
      videoLibraryId: freezed == videoLibraryId
          ? _self.videoLibraryId
          : videoLibraryId // ignore: cast_nullable_to_non_nullable
              as int?,
      videoGuid: freezed == videoGuid
          ? _self.videoGuid
          : videoGuid // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1JourneysIdGetResponseDto {
  @JsonKey(name: 'journey')
  JourneyDto2Dto get journey;
  @JsonKey(name: 'stepsCount')
  int get stepsCount;
  @JsonKey(name: 'lastStepDate')
  DateTime get lastStepDate;
  @JsonKey(name: 'stepperCount')
  int? get stepperCount;
  @JsonKey(name: 'latestSteppers')
  List<UserDto>? get latestSteppers;
  @JsonKey(name: 'starterCount')
  int? get starterCount;
  @JsonKey(name: 'latestStarters')
  List<dynamic>? get latestStarters;
  @JsonKey(name: 'companionCount')
  int? get companionCount;
  @JsonKey(name: 'latestCompanions')
  List<dynamic>? get latestCompanions;
  @JsonKey(name: 'celebratorCount')
  int? get celebratorCount;
  @JsonKey(name: 'latestCelebrators')
  List<dynamic>? get latestCelebrators;

  /// Create a copy of ApiV1JourneysIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1JourneysIdGetResponseDtoCopyWith<ApiV1JourneysIdGetResponseDto>
      get copyWith => _$ApiV1JourneysIdGetResponseDtoCopyWithImpl<
              ApiV1JourneysIdGetResponseDto>(
          this as ApiV1JourneysIdGetResponseDto, _$identity);

  /// Serializes this ApiV1JourneysIdGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1JourneysIdGetResponseDto &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.stepsCount, stepsCount) ||
                other.stepsCount == stepsCount) &&
            (identical(other.lastStepDate, lastStepDate) ||
                other.lastStepDate == lastStepDate) &&
            (identical(other.stepperCount, stepperCount) ||
                other.stepperCount == stepperCount) &&
            const DeepCollectionEquality()
                .equals(other.latestSteppers, latestSteppers) &&
            (identical(other.starterCount, starterCount) ||
                other.starterCount == starterCount) &&
            const DeepCollectionEquality()
                .equals(other.latestStarters, latestStarters) &&
            (identical(other.companionCount, companionCount) ||
                other.companionCount == companionCount) &&
            const DeepCollectionEquality()
                .equals(other.latestCompanions, latestCompanions) &&
            (identical(other.celebratorCount, celebratorCount) ||
                other.celebratorCount == celebratorCount) &&
            const DeepCollectionEquality()
                .equals(other.latestCelebrators, latestCelebrators));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      journey,
      stepsCount,
      lastStepDate,
      stepperCount,
      const DeepCollectionEquality().hash(latestSteppers),
      starterCount,
      const DeepCollectionEquality().hash(latestStarters),
      companionCount,
      const DeepCollectionEquality().hash(latestCompanions),
      celebratorCount,
      const DeepCollectionEquality().hash(latestCelebrators));

  @override
  String toString() {
    return 'ApiV1JourneysIdGetResponseDto(journey: $journey, stepsCount: $stepsCount, lastStepDate: $lastStepDate, stepperCount: $stepperCount, latestSteppers: $latestSteppers, starterCount: $starterCount, latestStarters: $latestStarters, companionCount: $companionCount, latestCompanions: $latestCompanions, celebratorCount: $celebratorCount, latestCelebrators: $latestCelebrators)';
  }
}

/// @nodoc
abstract mixin class $ApiV1JourneysIdGetResponseDtoCopyWith<$Res> {
  factory $ApiV1JourneysIdGetResponseDtoCopyWith(
          ApiV1JourneysIdGetResponseDto value,
          $Res Function(ApiV1JourneysIdGetResponseDto) _then) =
      _$ApiV1JourneysIdGetResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'journey') JourneyDto2Dto journey,
      @JsonKey(name: 'stepsCount') int stepsCount,
      @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
      @JsonKey(name: 'stepperCount') int? stepperCount,
      @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
      @JsonKey(name: 'starterCount') int? starterCount,
      @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
      @JsonKey(name: 'companionCount') int? companionCount,
      @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
      @JsonKey(name: 'celebratorCount') int? celebratorCount,
      @JsonKey(name: 'latestCelebrators') List<dynamic>? latestCelebrators});

  $JourneyDto2DtoCopyWith<$Res> get journey;
}

/// @nodoc
class _$ApiV1JourneysIdGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1JourneysIdGetResponseDtoCopyWith<$Res> {
  _$ApiV1JourneysIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1JourneysIdGetResponseDto _self;
  final $Res Function(ApiV1JourneysIdGetResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? journey = null,
    Object? stepsCount = null,
    Object? lastStepDate = null,
    Object? stepperCount = freezed,
    Object? latestSteppers = freezed,
    Object? starterCount = freezed,
    Object? latestStarters = freezed,
    Object? companionCount = freezed,
    Object? latestCompanions = freezed,
    Object? celebratorCount = freezed,
    Object? latestCelebrators = freezed,
  }) {
    return _then(_self.copyWith(
      journey: null == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto2Dto,
      stepsCount: null == stepsCount
          ? _self.stepsCount
          : stepsCount // ignore: cast_nullable_to_non_nullable
              as int,
      lastStepDate: null == lastStepDate
          ? _self.lastStepDate
          : lastStepDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      stepperCount: freezed == stepperCount
          ? _self.stepperCount
          : stepperCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestSteppers: freezed == latestSteppers
          ? _self.latestSteppers
          : latestSteppers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      starterCount: freezed == starterCount
          ? _self.starterCount
          : starterCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestStarters: freezed == latestStarters
          ? _self.latestStarters
          : latestStarters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      companionCount: freezed == companionCount
          ? _self.companionCount
          : companionCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCompanions: freezed == latestCompanions
          ? _self.latestCompanions
          : latestCompanions // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      celebratorCount: freezed == celebratorCount
          ? _self.celebratorCount
          : celebratorCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCelebrators: freezed == latestCelebrators
          ? _self.latestCelebrators
          : latestCelebrators // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }

  /// Create a copy of ApiV1JourneysIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDto2DtoCopyWith<$Res> get journey {
    return $JourneyDto2DtoCopyWith<$Res>(_self.journey, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1JourneysIdGetResponseDto].
extension ApiV1JourneysIdGetResponseDtoPatterns
    on ApiV1JourneysIdGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdGetResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdGetResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1JourneysIdGetResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'journey') JourneyDto2Dto journey,
            @JsonKey(name: 'stepsCount') int stepsCount,
            @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
            @JsonKey(name: 'stepperCount') int? stepperCount,
            @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
            @JsonKey(name: 'starterCount') int? starterCount,
            @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
            @JsonKey(name: 'companionCount') int? companionCount,
            @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
            @JsonKey(name: 'celebratorCount') int? celebratorCount,
            @JsonKey(name: 'latestCelebrators')
            List<dynamic>? latestCelebrators)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdGetResponseDto() when $default != null:
        return $default(
            _that.journey,
            _that.stepsCount,
            _that.lastStepDate,
            _that.stepperCount,
            _that.latestSteppers,
            _that.starterCount,
            _that.latestStarters,
            _that.companionCount,
            _that.latestCompanions,
            _that.celebratorCount,
            _that.latestCelebrators);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'journey') JourneyDto2Dto journey,
            @JsonKey(name: 'stepsCount') int stepsCount,
            @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
            @JsonKey(name: 'stepperCount') int? stepperCount,
            @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
            @JsonKey(name: 'starterCount') int? starterCount,
            @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
            @JsonKey(name: 'companionCount') int? companionCount,
            @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
            @JsonKey(name: 'celebratorCount') int? celebratorCount,
            @JsonKey(name: 'latestCelebrators')
            List<dynamic>? latestCelebrators)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdGetResponseDto():
        return $default(
            _that.journey,
            _that.stepsCount,
            _that.lastStepDate,
            _that.stepperCount,
            _that.latestSteppers,
            _that.starterCount,
            _that.latestStarters,
            _that.companionCount,
            _that.latestCompanions,
            _that.celebratorCount,
            _that.latestCelebrators);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'journey') JourneyDto2Dto journey,
            @JsonKey(name: 'stepsCount') int stepsCount,
            @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
            @JsonKey(name: 'stepperCount') int? stepperCount,
            @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
            @JsonKey(name: 'starterCount') int? starterCount,
            @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
            @JsonKey(name: 'companionCount') int? companionCount,
            @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
            @JsonKey(name: 'celebratorCount') int? celebratorCount,
            @JsonKey(name: 'latestCelebrators')
            List<dynamic>? latestCelebrators)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdGetResponseDto() when $default != null:
        return $default(
            _that.journey,
            _that.stepsCount,
            _that.lastStepDate,
            _that.stepperCount,
            _that.latestSteppers,
            _that.starterCount,
            _that.latestStarters,
            _that.companionCount,
            _that.latestCompanions,
            _that.celebratorCount,
            _that.latestCelebrators);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1JourneysIdGetResponseDto implements ApiV1JourneysIdGetResponseDto {
  _ApiV1JourneysIdGetResponseDto(
      {@JsonKey(name: 'journey') required this.journey,
      @JsonKey(name: 'stepsCount') required this.stepsCount,
      @JsonKey(name: 'lastStepDate') required this.lastStepDate,
      @JsonKey(name: 'stepperCount') this.stepperCount,
      @JsonKey(name: 'latestSteppers') final List<UserDto>? latestSteppers,
      @JsonKey(name: 'starterCount') this.starterCount,
      @JsonKey(name: 'latestStarters') final List<dynamic>? latestStarters,
      @JsonKey(name: 'companionCount') this.companionCount,
      @JsonKey(name: 'latestCompanions') final List<dynamic>? latestCompanions,
      @JsonKey(name: 'celebratorCount') this.celebratorCount,
      @JsonKey(name: 'latestCelebrators')
      final List<dynamic>? latestCelebrators})
      : _latestSteppers = latestSteppers,
        _latestStarters = latestStarters,
        _latestCompanions = latestCompanions,
        _latestCelebrators = latestCelebrators;
  factory _ApiV1JourneysIdGetResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1JourneysIdGetResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'journey')
  final JourneyDto2Dto journey;
  @override
  @JsonKey(name: 'stepsCount')
  final int stepsCount;
  @override
  @JsonKey(name: 'lastStepDate')
  final DateTime lastStepDate;
  @override
  @JsonKey(name: 'stepperCount')
  final int? stepperCount;
  final List<UserDto>? _latestSteppers;
  @override
  @JsonKey(name: 'latestSteppers')
  List<UserDto>? get latestSteppers {
    final value = _latestSteppers;
    if (value == null) return null;
    if (_latestSteppers is EqualUnmodifiableListView) return _latestSteppers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'starterCount')
  final int? starterCount;
  final List<dynamic>? _latestStarters;
  @override
  @JsonKey(name: 'latestStarters')
  List<dynamic>? get latestStarters {
    final value = _latestStarters;
    if (value == null) return null;
    if (_latestStarters is EqualUnmodifiableListView) return _latestStarters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'companionCount')
  final int? companionCount;
  final List<dynamic>? _latestCompanions;
  @override
  @JsonKey(name: 'latestCompanions')
  List<dynamic>? get latestCompanions {
    final value = _latestCompanions;
    if (value == null) return null;
    if (_latestCompanions is EqualUnmodifiableListView)
      return _latestCompanions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'celebratorCount')
  final int? celebratorCount;
  final List<dynamic>? _latestCelebrators;
  @override
  @JsonKey(name: 'latestCelebrators')
  List<dynamic>? get latestCelebrators {
    final value = _latestCelebrators;
    if (value == null) return null;
    if (_latestCelebrators is EqualUnmodifiableListView)
      return _latestCelebrators;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ApiV1JourneysIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1JourneysIdGetResponseDtoCopyWith<_ApiV1JourneysIdGetResponseDto>
      get copyWith => __$ApiV1JourneysIdGetResponseDtoCopyWithImpl<
          _ApiV1JourneysIdGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1JourneysIdGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1JourneysIdGetResponseDto &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.stepsCount, stepsCount) ||
                other.stepsCount == stepsCount) &&
            (identical(other.lastStepDate, lastStepDate) ||
                other.lastStepDate == lastStepDate) &&
            (identical(other.stepperCount, stepperCount) ||
                other.stepperCount == stepperCount) &&
            const DeepCollectionEquality()
                .equals(other._latestSteppers, _latestSteppers) &&
            (identical(other.starterCount, starterCount) ||
                other.starterCount == starterCount) &&
            const DeepCollectionEquality()
                .equals(other._latestStarters, _latestStarters) &&
            (identical(other.companionCount, companionCount) ||
                other.companionCount == companionCount) &&
            const DeepCollectionEquality()
                .equals(other._latestCompanions, _latestCompanions) &&
            (identical(other.celebratorCount, celebratorCount) ||
                other.celebratorCount == celebratorCount) &&
            const DeepCollectionEquality()
                .equals(other._latestCelebrators, _latestCelebrators));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      journey,
      stepsCount,
      lastStepDate,
      stepperCount,
      const DeepCollectionEquality().hash(_latestSteppers),
      starterCount,
      const DeepCollectionEquality().hash(_latestStarters),
      companionCount,
      const DeepCollectionEquality().hash(_latestCompanions),
      celebratorCount,
      const DeepCollectionEquality().hash(_latestCelebrators));

  @override
  String toString() {
    return 'ApiV1JourneysIdGetResponseDto(journey: $journey, stepsCount: $stepsCount, lastStepDate: $lastStepDate, stepperCount: $stepperCount, latestSteppers: $latestSteppers, starterCount: $starterCount, latestStarters: $latestStarters, companionCount: $companionCount, latestCompanions: $latestCompanions, celebratorCount: $celebratorCount, latestCelebrators: $latestCelebrators)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1JourneysIdGetResponseDtoCopyWith<$Res>
    implements $ApiV1JourneysIdGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1JourneysIdGetResponseDtoCopyWith(
          _ApiV1JourneysIdGetResponseDto value,
          $Res Function(_ApiV1JourneysIdGetResponseDto) _then) =
      __$ApiV1JourneysIdGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'journey') JourneyDto2Dto journey,
      @JsonKey(name: 'stepsCount') int stepsCount,
      @JsonKey(name: 'lastStepDate') DateTime lastStepDate,
      @JsonKey(name: 'stepperCount') int? stepperCount,
      @JsonKey(name: 'latestSteppers') List<UserDto>? latestSteppers,
      @JsonKey(name: 'starterCount') int? starterCount,
      @JsonKey(name: 'latestStarters') List<dynamic>? latestStarters,
      @JsonKey(name: 'companionCount') int? companionCount,
      @JsonKey(name: 'latestCompanions') List<dynamic>? latestCompanions,
      @JsonKey(name: 'celebratorCount') int? celebratorCount,
      @JsonKey(name: 'latestCelebrators') List<dynamic>? latestCelebrators});

  @override
  $JourneyDto2DtoCopyWith<$Res> get journey;
}

/// @nodoc
class __$ApiV1JourneysIdGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1JourneysIdGetResponseDtoCopyWith<$Res> {
  __$ApiV1JourneysIdGetResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1JourneysIdGetResponseDto _self;
  final $Res Function(_ApiV1JourneysIdGetResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? journey = null,
    Object? stepsCount = null,
    Object? lastStepDate = null,
    Object? stepperCount = freezed,
    Object? latestSteppers = freezed,
    Object? starterCount = freezed,
    Object? latestStarters = freezed,
    Object? companionCount = freezed,
    Object? latestCompanions = freezed,
    Object? celebratorCount = freezed,
    Object? latestCelebrators = freezed,
  }) {
    return _then(_ApiV1JourneysIdGetResponseDto(
      journey: null == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto2Dto,
      stepsCount: null == stepsCount
          ? _self.stepsCount
          : stepsCount // ignore: cast_nullable_to_non_nullable
              as int,
      lastStepDate: null == lastStepDate
          ? _self.lastStepDate
          : lastStepDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      stepperCount: freezed == stepperCount
          ? _self.stepperCount
          : stepperCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestSteppers: freezed == latestSteppers
          ? _self._latestSteppers
          : latestSteppers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      starterCount: freezed == starterCount
          ? _self.starterCount
          : starterCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestStarters: freezed == latestStarters
          ? _self._latestStarters
          : latestStarters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      companionCount: freezed == companionCount
          ? _self.companionCount
          : companionCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCompanions: freezed == latestCompanions
          ? _self._latestCompanions
          : latestCompanions // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      celebratorCount: freezed == celebratorCount
          ? _self.celebratorCount
          : celebratorCount // ignore: cast_nullable_to_non_nullable
              as int?,
      latestCelebrators: freezed == latestCelebrators
          ? _self._latestCelebrators
          : latestCelebrators // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }

  /// Create a copy of ApiV1JourneysIdGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDto2DtoCopyWith<$Res> get journey {
    return $JourneyDto2DtoCopyWith<$Res>(_self.journey, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1JourneysIdPutResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'completedDate')
  DateTime? get completedDate;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'firstStepId')
  String? get firstStepId;
  @JsonKey(name: 'finalStepId')
  String? get finalStepId;

  /// Create a copy of ApiV1JourneysIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1JourneysIdPutResponseDtoCopyWith<ApiV1JourneysIdPutResponseDto>
      get copyWith => _$ApiV1JourneysIdPutResponseDtoCopyWithImpl<
              ApiV1JourneysIdPutResponseDto>(
          this as ApiV1JourneysIdPutResponseDto, _$identity);

  /// Serializes this ApiV1JourneysIdPutResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1JourneysIdPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'ApiV1JourneysIdPutResponseDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class $ApiV1JourneysIdPutResponseDtoCopyWith<$Res> {
  factory $ApiV1JourneysIdPutResponseDtoCopyWith(
          ApiV1JourneysIdPutResponseDto value,
          $Res Function(ApiV1JourneysIdPutResponseDto) _then) =
      _$ApiV1JourneysIdPutResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class _$ApiV1JourneysIdPutResponseDtoCopyWithImpl<$Res>
    implements $ApiV1JourneysIdPutResponseDtoCopyWith<$Res> {
  _$ApiV1JourneysIdPutResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1JourneysIdPutResponseDto _self;
  final $Res Function(ApiV1JourneysIdPutResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1JourneysIdPutResponseDto].
extension ApiV1JourneysIdPutResponseDtoPatterns
    on ApiV1JourneysIdPutResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdPutResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdPutResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1JourneysIdPutResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutResponseDto():
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1JourneysIdPutResponseDto implements ApiV1JourneysIdPutResponseDto {
  _ApiV1JourneysIdPutResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'completedDate') this.completedDate,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'firstStepId') this.firstStepId,
      @JsonKey(name: 'finalStepId') this.finalStepId});
  factory _ApiV1JourneysIdPutResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1JourneysIdPutResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'completedDate')
  final DateTime? completedDate;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'firstStepId')
  final String? firstStepId;
  @override
  @JsonKey(name: 'finalStepId')
  final String? finalStepId;

  /// Create a copy of ApiV1JourneysIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1JourneysIdPutResponseDtoCopyWith<_ApiV1JourneysIdPutResponseDto>
      get copyWith => __$ApiV1JourneysIdPutResponseDtoCopyWithImpl<
          _ApiV1JourneysIdPutResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1JourneysIdPutResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1JourneysIdPutResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'ApiV1JourneysIdPutResponseDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1JourneysIdPutResponseDtoCopyWith<$Res>
    implements $ApiV1JourneysIdPutResponseDtoCopyWith<$Res> {
  factory _$ApiV1JourneysIdPutResponseDtoCopyWith(
          _ApiV1JourneysIdPutResponseDto value,
          $Res Function(_ApiV1JourneysIdPutResponseDto) _then) =
      __$ApiV1JourneysIdPutResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class __$ApiV1JourneysIdPutResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1JourneysIdPutResponseDtoCopyWith<$Res> {
  __$ApiV1JourneysIdPutResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1JourneysIdPutResponseDto _self;
  final $Res Function(_ApiV1JourneysIdPutResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdPutResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_ApiV1JourneysIdPutResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1JourneysIdPutRequestDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'description')
  String? get description;

  /// Create a copy of ApiV1JourneysIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1JourneysIdPutRequestDtoCopyWith<ApiV1JourneysIdPutRequestDto>
      get copyWith => _$ApiV1JourneysIdPutRequestDtoCopyWithImpl<
              ApiV1JourneysIdPutRequestDto>(
          this as ApiV1JourneysIdPutRequestDto, _$identity);

  /// Serializes this ApiV1JourneysIdPutRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1JourneysIdPutRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, title, description);

  @override
  String toString() {
    return 'ApiV1JourneysIdPutRequestDto(title: $title, description: $description)';
  }
}

/// @nodoc
abstract mixin class $ApiV1JourneysIdPutRequestDtoCopyWith<$Res> {
  factory $ApiV1JourneysIdPutRequestDtoCopyWith(
          ApiV1JourneysIdPutRequestDto value,
          $Res Function(ApiV1JourneysIdPutRequestDto) _then) =
      _$ApiV1JourneysIdPutRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class _$ApiV1JourneysIdPutRequestDtoCopyWithImpl<$Res>
    implements $ApiV1JourneysIdPutRequestDtoCopyWith<$Res> {
  _$ApiV1JourneysIdPutRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1JourneysIdPutRequestDto _self;
  final $Res Function(ApiV1JourneysIdPutRequestDto) _then;

  /// Create a copy of ApiV1JourneysIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? description = freezed,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1JourneysIdPutRequestDto].
extension ApiV1JourneysIdPutRequestDtoPatterns on ApiV1JourneysIdPutRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdPutRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdPutRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1JourneysIdPutRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutRequestDto() when $default != null:
        return $default(_that.title, _that.description);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutRequestDto():
        return $default(_that.title, _that.description);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdPutRequestDto() when $default != null:
        return $default(_that.title, _that.description);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1JourneysIdPutRequestDto implements ApiV1JourneysIdPutRequestDto {
  _ApiV1JourneysIdPutRequestDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'description') this.description});
  factory _ApiV1JourneysIdPutRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1JourneysIdPutRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Create a copy of ApiV1JourneysIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1JourneysIdPutRequestDtoCopyWith<_ApiV1JourneysIdPutRequestDto>
      get copyWith => __$ApiV1JourneysIdPutRequestDtoCopyWithImpl<
          _ApiV1JourneysIdPutRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1JourneysIdPutRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1JourneysIdPutRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, title, description);

  @override
  String toString() {
    return 'ApiV1JourneysIdPutRequestDto(title: $title, description: $description)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1JourneysIdPutRequestDtoCopyWith<$Res>
    implements $ApiV1JourneysIdPutRequestDtoCopyWith<$Res> {
  factory _$ApiV1JourneysIdPutRequestDtoCopyWith(
          _ApiV1JourneysIdPutRequestDto value,
          $Res Function(_ApiV1JourneysIdPutRequestDto) _then) =
      __$ApiV1JourneysIdPutRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class __$ApiV1JourneysIdPutRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1JourneysIdPutRequestDtoCopyWith<$Res> {
  __$ApiV1JourneysIdPutRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1JourneysIdPutRequestDto _self;
  final $Res Function(_ApiV1JourneysIdPutRequestDto) _then;

  /// Create a copy of ApiV1JourneysIdPutRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? description = freezed,
  }) {
    return _then(_ApiV1JourneysIdPutRequestDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1JourneysPostResponseDto {
  @JsonKey(name: 'id')
  String get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'user')
  UserDto get user;
  @JsonKey(name: 'journeyId')
  String? get journeyId;
  @JsonKey(name: 'journey')
  JourneyDto? get journey;
  @JsonKey(name: 'hearts')
  int? get hearts;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;
  @JsonKey(name: 'shares')
  int? get shares;
  @JsonKey(name: 'sharedByUser')
  bool? get sharedByUser;
  @JsonKey(name: 'comments')
  int? get comments;
  @JsonKey(name: 'commentedByUser')
  bool? get commentedByUser;
  @JsonKey(name: 'userSteppedWithInteractions')
  int? get userSteppedWithInteractions;
  @JsonKey(name: 'othersStepWith')
  int? get othersStepWith;
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers;
  @JsonKey(name: 'stepTypeString')
  String? get stepTypeString;
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media;

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1JourneysPostResponseDtoCopyWith<ApiV1JourneysPostResponseDto>
      get copyWith => _$ApiV1JourneysPostResponseDtoCopyWithImpl<
              ApiV1JourneysPostResponseDto>(
          this as ApiV1JourneysPostResponseDto, _$identity);

  /// Serializes this ApiV1JourneysPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1JourneysPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other.othersStepWithUsers, othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other.media, media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(media)
      ]);

  @override
  String toString() {
    return 'ApiV1JourneysPostResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class $ApiV1JourneysPostResponseDtoCopyWith<$Res> {
  factory $ApiV1JourneysPostResponseDtoCopyWith(
          ApiV1JourneysPostResponseDto value,
          $Res Function(ApiV1JourneysPostResponseDto) _then) =
      _$ApiV1JourneysPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  $UserDtoCopyWith<$Res> get user;
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class _$ApiV1JourneysPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1JourneysPostResponseDtoCopyWith<$Res> {
  _$ApiV1JourneysPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1JourneysPostResponseDto _self;
  final $Res Function(ApiV1JourneysPostResponseDto) _then;

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self.othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self.media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1JourneysPostResponseDto].
extension ApiV1JourneysPostResponseDtoPatterns on ApiV1JourneysPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1JourneysPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1JourneysPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1JourneysPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostResponseDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'user') UserDto user,
            @JsonKey(name: 'journeyId') String? journeyId,
            @JsonKey(name: 'journey') JourneyDto? journey,
            @JsonKey(name: 'hearts') int? hearts,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'shares') int? shares,
            @JsonKey(name: 'sharedByUser') bool? sharedByUser,
            @JsonKey(name: 'comments') int? comments,
            @JsonKey(name: 'commentedByUser') bool? commentedByUser,
            @JsonKey(name: 'userSteppedWithInteractions')
            int? userSteppedWithInteractions,
            @JsonKey(name: 'othersStepWith') int? othersStepWith,
            @JsonKey(name: 'othersStepWithUsers')
            List<UserDto>? othersStepWithUsers,
            @JsonKey(name: 'stepTypeString') String? stepTypeString,
            @JsonKey(name: 'media') List<StepMediaDto>? media)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.userId,
            _that.user,
            _that.journeyId,
            _that.journey,
            _that.hearts,
            _that.heartedByUser,
            _that.shares,
            _that.sharedByUser,
            _that.comments,
            _that.commentedByUser,
            _that.userSteppedWithInteractions,
            _that.othersStepWith,
            _that.othersStepWithUsers,
            _that.stepTypeString,
            _that.media);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1JourneysPostResponseDto implements ApiV1JourneysPostResponseDto {
  _ApiV1JourneysPostResponseDto(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'user') required this.user,
      @JsonKey(name: 'journeyId') this.journeyId,
      @JsonKey(name: 'journey') this.journey,
      @JsonKey(name: 'hearts') this.hearts,
      @JsonKey(name: 'heartedByUser') this.heartedByUser,
      @JsonKey(name: 'shares') this.shares,
      @JsonKey(name: 'sharedByUser') this.sharedByUser,
      @JsonKey(name: 'comments') this.comments,
      @JsonKey(name: 'commentedByUser') this.commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      this.userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') this.othersStepWith,
      @JsonKey(name: 'othersStepWithUsers')
      final List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') this.stepTypeString,
      @JsonKey(name: 'media') final List<StepMediaDto>? media})
      : _othersStepWithUsers = othersStepWithUsers,
        _media = media;
  factory _ApiV1JourneysPostResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1JourneysPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'user')
  final UserDto user;
  @override
  @JsonKey(name: 'journeyId')
  final String? journeyId;
  @override
  @JsonKey(name: 'journey')
  final JourneyDto? journey;
  @override
  @JsonKey(name: 'hearts')
  final int? hearts;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;
  @override
  @JsonKey(name: 'shares')
  final int? shares;
  @override
  @JsonKey(name: 'sharedByUser')
  final bool? sharedByUser;
  @override
  @JsonKey(name: 'comments')
  final int? comments;
  @override
  @JsonKey(name: 'commentedByUser')
  final bool? commentedByUser;
  @override
  @JsonKey(name: 'userSteppedWithInteractions')
  final int? userSteppedWithInteractions;
  @override
  @JsonKey(name: 'othersStepWith')
  final int? othersStepWith;
  final List<UserDto>? _othersStepWithUsers;
  @override
  @JsonKey(name: 'othersStepWithUsers')
  List<UserDto>? get othersStepWithUsers {
    final value = _othersStepWithUsers;
    if (value == null) return null;
    if (_othersStepWithUsers is EqualUnmodifiableListView)
      return _othersStepWithUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'stepTypeString')
  final String? stepTypeString;
  final List<StepMediaDto>? _media;
  @override
  @JsonKey(name: 'media')
  List<StepMediaDto>? get media {
    final value = _media;
    if (value == null) return null;
    if (_media is EqualUnmodifiableListView) return _media;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1JourneysPostResponseDtoCopyWith<_ApiV1JourneysPostResponseDto>
      get copyWith => __$ApiV1JourneysPostResponseDtoCopyWithImpl<
          _ApiV1JourneysPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1JourneysPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1JourneysPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.journey, journey) || other.journey == journey) &&
            (identical(other.hearts, hearts) || other.hearts == hearts) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.shares, shares) || other.shares == shares) &&
            (identical(other.sharedByUser, sharedByUser) ||
                other.sharedByUser == sharedByUser) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.commentedByUser, commentedByUser) ||
                other.commentedByUser == commentedByUser) &&
            (identical(other.userSteppedWithInteractions,
                    userSteppedWithInteractions) ||
                other.userSteppedWithInteractions ==
                    userSteppedWithInteractions) &&
            (identical(other.othersStepWith, othersStepWith) ||
                other.othersStepWith == othersStepWith) &&
            const DeepCollectionEquality()
                .equals(other._othersStepWithUsers, _othersStepWithUsers) &&
            (identical(other.stepTypeString, stepTypeString) ||
                other.stepTypeString == stepTypeString) &&
            const DeepCollectionEquality().equals(other._media, _media));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        content,
        createdDate,
        lastUpdated,
        userId,
        user,
        journeyId,
        journey,
        hearts,
        heartedByUser,
        shares,
        sharedByUser,
        comments,
        commentedByUser,
        userSteppedWithInteractions,
        othersStepWith,
        const DeepCollectionEquality().hash(_othersStepWithUsers),
        stepTypeString,
        const DeepCollectionEquality().hash(_media)
      ]);

  @override
  String toString() {
    return 'ApiV1JourneysPostResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, userId: $userId, user: $user, journeyId: $journeyId, journey: $journey, hearts: $hearts, heartedByUser: $heartedByUser, shares: $shares, sharedByUser: $sharedByUser, comments: $comments, commentedByUser: $commentedByUser, userSteppedWithInteractions: $userSteppedWithInteractions, othersStepWith: $othersStepWith, othersStepWithUsers: $othersStepWithUsers, stepTypeString: $stepTypeString, media: $media)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1JourneysPostResponseDtoCopyWith<$Res>
    implements $ApiV1JourneysPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1JourneysPostResponseDtoCopyWith(
          _ApiV1JourneysPostResponseDto value,
          $Res Function(_ApiV1JourneysPostResponseDto) _then) =
      __$ApiV1JourneysPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'user') UserDto user,
      @JsonKey(name: 'journeyId') String? journeyId,
      @JsonKey(name: 'journey') JourneyDto? journey,
      @JsonKey(name: 'hearts') int? hearts,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'shares') int? shares,
      @JsonKey(name: 'sharedByUser') bool? sharedByUser,
      @JsonKey(name: 'comments') int? comments,
      @JsonKey(name: 'commentedByUser') bool? commentedByUser,
      @JsonKey(name: 'userSteppedWithInteractions')
      int? userSteppedWithInteractions,
      @JsonKey(name: 'othersStepWith') int? othersStepWith,
      @JsonKey(name: 'othersStepWithUsers') List<UserDto>? othersStepWithUsers,
      @JsonKey(name: 'stepTypeString') String? stepTypeString,
      @JsonKey(name: 'media') List<StepMediaDto>? media});

  @override
  $UserDtoCopyWith<$Res> get user;
  @override
  $JourneyDtoCopyWith<$Res>? get journey;
}

/// @nodoc
class __$ApiV1JourneysPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1JourneysPostResponseDtoCopyWith<$Res> {
  __$ApiV1JourneysPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1JourneysPostResponseDto _self;
  final $Res Function(_ApiV1JourneysPostResponseDto) _then;

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? userId = freezed,
    Object? user = null,
    Object? journeyId = freezed,
    Object? journey = freezed,
    Object? hearts = freezed,
    Object? heartedByUser = freezed,
    Object? shares = freezed,
    Object? sharedByUser = freezed,
    Object? comments = freezed,
    Object? commentedByUser = freezed,
    Object? userSteppedWithInteractions = freezed,
    Object? othersStepWith = freezed,
    Object? othersStepWithUsers = freezed,
    Object? stepTypeString = freezed,
    Object? media = freezed,
  }) {
    return _then(_ApiV1JourneysPostResponseDto(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      user: null == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
      journeyId: freezed == journeyId
          ? _self.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      journey: freezed == journey
          ? _self.journey
          : journey // ignore: cast_nullable_to_non_nullable
              as JourneyDto?,
      hearts: freezed == hearts
          ? _self.hearts
          : hearts // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      shares: freezed == shares
          ? _self.shares
          : shares // ignore: cast_nullable_to_non_nullable
              as int?,
      sharedByUser: freezed == sharedByUser
          ? _self.sharedByUser
          : sharedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      comments: freezed == comments
          ? _self.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int?,
      commentedByUser: freezed == commentedByUser
          ? _self.commentedByUser
          : commentedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      userSteppedWithInteractions: freezed == userSteppedWithInteractions
          ? _self.userSteppedWithInteractions
          : userSteppedWithInteractions // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWith: freezed == othersStepWith
          ? _self.othersStepWith
          : othersStepWith // ignore: cast_nullable_to_non_nullable
              as int?,
      othersStepWithUsers: freezed == othersStepWithUsers
          ? _self._othersStepWithUsers
          : othersStepWithUsers // ignore: cast_nullable_to_non_nullable
              as List<UserDto>?,
      stepTypeString: freezed == stepTypeString
          ? _self.stepTypeString
          : stepTypeString // ignore: cast_nullable_to_non_nullable
              as String?,
      media: freezed == media
          ? _self._media
          : media // ignore: cast_nullable_to_non_nullable
              as List<StepMediaDto>?,
    ));
  }

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_self.user, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1JourneysPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JourneyDtoCopyWith<$Res>? get journey {
    if (_self.journey == null) {
      return null;
    }

    return $JourneyDtoCopyWith<$Res>(_self.journey!, (value) {
      return _then(_self.copyWith(journey: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1JourneysPostRequestDto {
  @JsonKey(name: 'title')
  String get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'firstStepContent')
  String get firstStepContent;

  /// Create a copy of ApiV1JourneysPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1JourneysPostRequestDtoCopyWith<ApiV1JourneysPostRequestDto>
      get copyWith => _$ApiV1JourneysPostRequestDtoCopyWithImpl<
              ApiV1JourneysPostRequestDto>(
          this as ApiV1JourneysPostRequestDto, _$identity);

  /// Serializes this ApiV1JourneysPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1JourneysPostRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.firstStepContent, firstStepContent) ||
                other.firstStepContent == firstStepContent));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, title, description, firstStepContent);

  @override
  String toString() {
    return 'ApiV1JourneysPostRequestDto(title: $title, description: $description, firstStepContent: $firstStepContent)';
  }
}

/// @nodoc
abstract mixin class $ApiV1JourneysPostRequestDtoCopyWith<$Res> {
  factory $ApiV1JourneysPostRequestDtoCopyWith(
          ApiV1JourneysPostRequestDto value,
          $Res Function(ApiV1JourneysPostRequestDto) _then) =
      _$ApiV1JourneysPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'firstStepContent') String firstStepContent});
}

/// @nodoc
class _$ApiV1JourneysPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1JourneysPostRequestDtoCopyWith<$Res> {
  _$ApiV1JourneysPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1JourneysPostRequestDto _self;
  final $Res Function(ApiV1JourneysPostRequestDto) _then;

  /// Create a copy of ApiV1JourneysPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? description = freezed,
    Object? firstStepContent = null,
  }) {
    return _then(_self.copyWith(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepContent: null == firstStepContent
          ? _self.firstStepContent
          : firstStepContent // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1JourneysPostRequestDto].
extension ApiV1JourneysPostRequestDtoPatterns on ApiV1JourneysPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1JourneysPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1JourneysPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1JourneysPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'firstStepContent') String firstStepContent)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostRequestDto() when $default != null:
        return $default(_that.title, _that.description, _that.firstStepContent);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'firstStepContent') String firstStepContent)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostRequestDto():
        return $default(_that.title, _that.description, _that.firstStepContent);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'title') String title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'firstStepContent') String firstStepContent)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysPostRequestDto() when $default != null:
        return $default(_that.title, _that.description, _that.firstStepContent);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1JourneysPostRequestDto implements ApiV1JourneysPostRequestDto {
  _ApiV1JourneysPostRequestDto(
      {@JsonKey(name: 'title') required this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'firstStepContent') required this.firstStepContent});
  factory _ApiV1JourneysPostRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ApiV1JourneysPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'firstStepContent')
  final String firstStepContent;

  /// Create a copy of ApiV1JourneysPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1JourneysPostRequestDtoCopyWith<_ApiV1JourneysPostRequestDto>
      get copyWith => __$ApiV1JourneysPostRequestDtoCopyWithImpl<
          _ApiV1JourneysPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1JourneysPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1JourneysPostRequestDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.firstStepContent, firstStepContent) ||
                other.firstStepContent == firstStepContent));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, title, description, firstStepContent);

  @override
  String toString() {
    return 'ApiV1JourneysPostRequestDto(title: $title, description: $description, firstStepContent: $firstStepContent)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1JourneysPostRequestDtoCopyWith<$Res>
    implements $ApiV1JourneysPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1JourneysPostRequestDtoCopyWith(
          _ApiV1JourneysPostRequestDto value,
          $Res Function(_ApiV1JourneysPostRequestDto) _then) =
      __$ApiV1JourneysPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'firstStepContent') String firstStepContent});
}

/// @nodoc
class __$ApiV1JourneysPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1JourneysPostRequestDtoCopyWith<$Res> {
  __$ApiV1JourneysPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1JourneysPostRequestDto _self;
  final $Res Function(_ApiV1JourneysPostRequestDto) _then;

  /// Create a copy of ApiV1JourneysPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = null,
    Object? description = freezed,
    Object? firstStepContent = null,
  }) {
    return _then(_ApiV1JourneysPostRequestDto(
      title: null == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepContent: null == firstStepContent
          ? _self.firstStepContent
          : firstStepContent // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ApiV1JourneysIdClosePostResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'completedDate')
  DateTime? get completedDate;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'firstStepId')
  String? get firstStepId;
  @JsonKey(name: 'finalStepId')
  String? get finalStepId;

  /// Create a copy of ApiV1JourneysIdClosePostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1JourneysIdClosePostResponseDtoCopyWith<
          ApiV1JourneysIdClosePostResponseDto>
      get copyWith => _$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl<
              ApiV1JourneysIdClosePostResponseDto>(
          this as ApiV1JourneysIdClosePostResponseDto, _$identity);

  /// Serializes this ApiV1JourneysIdClosePostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1JourneysIdClosePostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'ApiV1JourneysIdClosePostResponseDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class $ApiV1JourneysIdClosePostResponseDtoCopyWith<$Res> {
  factory $ApiV1JourneysIdClosePostResponseDtoCopyWith(
          ApiV1JourneysIdClosePostResponseDto value,
          $Res Function(ApiV1JourneysIdClosePostResponseDto) _then) =
      _$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class _$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1JourneysIdClosePostResponseDtoCopyWith<$Res> {
  _$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1JourneysIdClosePostResponseDto _self;
  final $Res Function(ApiV1JourneysIdClosePostResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdClosePostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1JourneysIdClosePostResponseDto].
extension ApiV1JourneysIdClosePostResponseDtoPatterns
    on ApiV1JourneysIdClosePostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdClosePostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdClosePostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdClosePostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdClosePostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1JourneysIdClosePostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdClosePostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdClosePostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdClosePostResponseDto():
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdClosePostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1JourneysIdClosePostResponseDto
    implements ApiV1JourneysIdClosePostResponseDto {
  _ApiV1JourneysIdClosePostResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'completedDate') this.completedDate,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'firstStepId') this.firstStepId,
      @JsonKey(name: 'finalStepId') this.finalStepId});
  factory _ApiV1JourneysIdClosePostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1JourneysIdClosePostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'completedDate')
  final DateTime? completedDate;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'firstStepId')
  final String? firstStepId;
  @override
  @JsonKey(name: 'finalStepId')
  final String? finalStepId;

  /// Create a copy of ApiV1JourneysIdClosePostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1JourneysIdClosePostResponseDtoCopyWith<
          _ApiV1JourneysIdClosePostResponseDto>
      get copyWith => __$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl<
          _ApiV1JourneysIdClosePostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1JourneysIdClosePostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1JourneysIdClosePostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'ApiV1JourneysIdClosePostResponseDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1JourneysIdClosePostResponseDtoCopyWith<$Res>
    implements $ApiV1JourneysIdClosePostResponseDtoCopyWith<$Res> {
  factory _$ApiV1JourneysIdClosePostResponseDtoCopyWith(
          _ApiV1JourneysIdClosePostResponseDto value,
          $Res Function(_ApiV1JourneysIdClosePostResponseDto) _then) =
      __$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class __$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1JourneysIdClosePostResponseDtoCopyWith<$Res> {
  __$ApiV1JourneysIdClosePostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1JourneysIdClosePostResponseDto _self;
  final $Res Function(_ApiV1JourneysIdClosePostResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdClosePostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_ApiV1JourneysIdClosePostResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1JourneysIdReopenPostResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'completedDate')
  DateTime? get completedDate;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'firstStepId')
  String? get firstStepId;
  @JsonKey(name: 'finalStepId')
  String? get finalStepId;

  /// Create a copy of ApiV1JourneysIdReopenPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1JourneysIdReopenPostResponseDtoCopyWith<
          ApiV1JourneysIdReopenPostResponseDto>
      get copyWith => _$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl<
              ApiV1JourneysIdReopenPostResponseDto>(
          this as ApiV1JourneysIdReopenPostResponseDto, _$identity);

  /// Serializes this ApiV1JourneysIdReopenPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1JourneysIdReopenPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'ApiV1JourneysIdReopenPostResponseDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class $ApiV1JourneysIdReopenPostResponseDtoCopyWith<$Res> {
  factory $ApiV1JourneysIdReopenPostResponseDtoCopyWith(
          ApiV1JourneysIdReopenPostResponseDto value,
          $Res Function(ApiV1JourneysIdReopenPostResponseDto) _then) =
      _$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class _$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1JourneysIdReopenPostResponseDtoCopyWith<$Res> {
  _$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1JourneysIdReopenPostResponseDto _self;
  final $Res Function(ApiV1JourneysIdReopenPostResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdReopenPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1JourneysIdReopenPostResponseDto].
extension ApiV1JourneysIdReopenPostResponseDtoPatterns
    on ApiV1JourneysIdReopenPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdReopenPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdReopenPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1JourneysIdReopenPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdReopenPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1JourneysIdReopenPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdReopenPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdReopenPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdReopenPostResponseDto():
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'completedDate') DateTime? completedDate,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'firstStepId') String? firstStepId,
            @JsonKey(name: 'finalStepId') String? finalStepId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1JourneysIdReopenPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.title,
            _that.description,
            _that.createdDate,
            _that.lastUpdated,
            _that.status,
            _that.completedDate,
            _that.userId,
            _that.firstStepId,
            _that.finalStepId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1JourneysIdReopenPostResponseDto
    implements ApiV1JourneysIdReopenPostResponseDto {
  _ApiV1JourneysIdReopenPostResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'completedDate') this.completedDate,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'firstStepId') this.firstStepId,
      @JsonKey(name: 'finalStepId') this.finalStepId});
  factory _ApiV1JourneysIdReopenPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1JourneysIdReopenPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'completedDate')
  final DateTime? completedDate;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'firstStepId')
  final String? firstStepId;
  @override
  @JsonKey(name: 'finalStepId')
  final String? finalStepId;

  /// Create a copy of ApiV1JourneysIdReopenPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1JourneysIdReopenPostResponseDtoCopyWith<
          _ApiV1JourneysIdReopenPostResponseDto>
      get copyWith => __$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl<
          _ApiV1JourneysIdReopenPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1JourneysIdReopenPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1JourneysIdReopenPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.completedDate, completedDate) ||
                other.completedDate == completedDate) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.firstStepId, firstStepId) ||
                other.firstStepId == firstStepId) &&
            (identical(other.finalStepId, finalStepId) ||
                other.finalStepId == finalStepId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      description,
      createdDate,
      lastUpdated,
      status,
      completedDate,
      userId,
      firstStepId,
      finalStepId);

  @override
  String toString() {
    return 'ApiV1JourneysIdReopenPostResponseDto(id: $id, title: $title, description: $description, createdDate: $createdDate, lastUpdated: $lastUpdated, status: $status, completedDate: $completedDate, userId: $userId, firstStepId: $firstStepId, finalStepId: $finalStepId)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1JourneysIdReopenPostResponseDtoCopyWith<$Res>
    implements $ApiV1JourneysIdReopenPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1JourneysIdReopenPostResponseDtoCopyWith(
          _ApiV1JourneysIdReopenPostResponseDto value,
          $Res Function(_ApiV1JourneysIdReopenPostResponseDto) _then) =
      __$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'completedDate') DateTime? completedDate,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'firstStepId') String? firstStepId,
      @JsonKey(name: 'finalStepId') String? finalStepId});
}

/// @nodoc
class __$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1JourneysIdReopenPostResponseDtoCopyWith<$Res> {
  __$ApiV1JourneysIdReopenPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1JourneysIdReopenPostResponseDto _self;
  final $Res Function(_ApiV1JourneysIdReopenPostResponseDto) _then;

  /// Create a copy of ApiV1JourneysIdReopenPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? status = freezed,
    Object? completedDate = freezed,
    Object? userId = freezed,
    Object? firstStepId = freezed,
    Object? finalStepId = freezed,
  }) {
    return _then(_ApiV1JourneysIdReopenPostResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      completedDate: freezed == completedDate
          ? _self.completedDate
          : completedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      firstStepId: freezed == firstStepId
          ? _self.firstStepId
          : firstStepId // ignore: cast_nullable_to_non_nullable
              as String?,
      finalStepId: freezed == finalStepId
          ? _self.finalStepId
          : finalStepId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdHeartsPostResponseDto {
  @JsonKey(name: 'isSteppedWith')
  bool? get isSteppedWith;
  @JsonKey(name: 'isLiked')
  bool? get isLiked;
  @JsonKey(name: 'totalLikes')
  int? get totalLikes;

  /// Create a copy of ApiV1StepsStepIdHeartsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdHeartsPostResponseDtoCopyWith<
          ApiV1StepsStepIdHeartsPostResponseDto>
      get copyWith => _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl<
              ApiV1StepsStepIdHeartsPostResponseDto>(
          this as ApiV1StepsStepIdHeartsPostResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdHeartsPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdHeartsPostResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdHeartsPostResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdHeartsPostResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdHeartsPostResponseDtoCopyWith(
          ApiV1StepsStepIdHeartsPostResponseDto value,
          $Res Function(ApiV1StepsStepIdHeartsPostResponseDto) _then) =
      _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdHeartsPostResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdHeartsPostResponseDto _self;
  final $Res Function(ApiV1StepsStepIdHeartsPostResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdHeartsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_self.copyWith(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdHeartsPostResponseDto].
extension ApiV1StepsStepIdHeartsPostResponseDtoPatterns
    on ApiV1StepsStepIdHeartsPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdHeartsPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdHeartsPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdHeartsPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostResponseDto():
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdHeartsPostResponseDto
    implements ApiV1StepsStepIdHeartsPostResponseDto {
  _ApiV1StepsStepIdHeartsPostResponseDto(
      {@JsonKey(name: 'isSteppedWith') this.isSteppedWith,
      @JsonKey(name: 'isLiked') this.isLiked,
      @JsonKey(name: 'totalLikes') this.totalLikes});
  factory _ApiV1StepsStepIdHeartsPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdHeartsPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'isSteppedWith')
  final bool? isSteppedWith;
  @override
  @JsonKey(name: 'isLiked')
  final bool? isLiked;
  @override
  @JsonKey(name: 'totalLikes')
  final int? totalLikes;

  /// Create a copy of ApiV1StepsStepIdHeartsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWith<
          _ApiV1StepsStepIdHeartsPostResponseDto>
      get copyWith => __$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdHeartsPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdHeartsPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdHeartsPostResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdHeartsPostResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdHeartsPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWith(
          _ApiV1StepsStepIdHeartsPostResponseDto value,
          $Res Function(_ApiV1StepsStepIdHeartsPostResponseDto) _then) =
      __$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class __$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdHeartsPostResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdHeartsPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdHeartsPostResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdHeartsPostResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdHeartsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_ApiV1StepsStepIdHeartsPostResponseDto(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdHeartsPostRequestDto {
  @JsonKey(name: 'type')
  InteractionTypeDto? get type;

  /// Create a copy of ApiV1StepsStepIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdHeartsPostRequestDtoCopyWith<
          ApiV1StepsStepIdHeartsPostRequestDto>
      get copyWith => _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl<
              ApiV1StepsStepIdHeartsPostRequestDto>(
          this as ApiV1StepsStepIdHeartsPostRequestDto, _$identity);

  /// Serializes this ApiV1StepsStepIdHeartsPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdHeartsPostRequestDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ApiV1StepsStepIdHeartsPostRequestDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdHeartsPostRequestDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdHeartsPostRequestDtoCopyWith(
          ApiV1StepsStepIdHeartsPostRequestDto value,
          $Res Function(ApiV1StepsStepIdHeartsPostRequestDto) _then) =
      _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdHeartsPostRequestDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdHeartsPostRequestDto _self;
  final $Res Function(ApiV1StepsStepIdHeartsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_self.copyWith(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdHeartsPostRequestDto].
extension ApiV1StepsStepIdHeartsPostRequestDtoPatterns
    on ApiV1StepsStepIdHeartsPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdHeartsPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdHeartsPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdHeartsPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostRequestDto() when $default != null:
        return $default(_that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostRequestDto():
        return $default(_that.type);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsPostRequestDto() when $default != null:
        return $default(_that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdHeartsPostRequestDto
    implements ApiV1StepsStepIdHeartsPostRequestDto {
  _ApiV1StepsStepIdHeartsPostRequestDto({@JsonKey(name: 'type') this.type});
  factory _ApiV1StepsStepIdHeartsPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdHeartsPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'type')
  final InteractionTypeDto? type;

  /// Create a copy of ApiV1StepsStepIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWith<
          _ApiV1StepsStepIdHeartsPostRequestDto>
      get copyWith => __$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl<
          _ApiV1StepsStepIdHeartsPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdHeartsPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdHeartsPostRequestDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ApiV1StepsStepIdHeartsPostRequestDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdHeartsPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWith(
          _ApiV1StepsStepIdHeartsPostRequestDto value,
          $Res Function(_ApiV1StepsStepIdHeartsPostRequestDto) _then) =
      __$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class __$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdHeartsPostRequestDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdHeartsPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdHeartsPostRequestDto _self;
  final $Res Function(_ApiV1StepsStepIdHeartsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_ApiV1StepsStepIdHeartsPostRequestDto(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdHeartsDeleteResponseDto {
  @JsonKey(name: 'isSteppedWith')
  bool? get isSteppedWith;
  @JsonKey(name: 'isLiked')
  bool? get isLiked;
  @JsonKey(name: 'totalLikes')
  int? get totalLikes;

  /// Create a copy of ApiV1StepsStepIdHeartsDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith<
          ApiV1StepsStepIdHeartsDeleteResponseDto>
      get copyWith => _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl<
              ApiV1StepsStepIdHeartsDeleteResponseDto>(
          this as ApiV1StepsStepIdHeartsDeleteResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdHeartsDeleteResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdHeartsDeleteResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdHeartsDeleteResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith(
          ApiV1StepsStepIdHeartsDeleteResponseDto value,
          $Res Function(ApiV1StepsStepIdHeartsDeleteResponseDto) _then) =
      _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdHeartsDeleteResponseDto _self;
  final $Res Function(ApiV1StepsStepIdHeartsDeleteResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdHeartsDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_self.copyWith(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdHeartsDeleteResponseDto].
extension ApiV1StepsStepIdHeartsDeleteResponseDtoPatterns
    on ApiV1StepsStepIdHeartsDeleteResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdHeartsDeleteResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsDeleteResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdHeartsDeleteResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsDeleteResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdHeartsDeleteResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsDeleteResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsDeleteResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsDeleteResponseDto():
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdHeartsDeleteResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdHeartsDeleteResponseDto
    implements ApiV1StepsStepIdHeartsDeleteResponseDto {
  _ApiV1StepsStepIdHeartsDeleteResponseDto(
      {@JsonKey(name: 'isSteppedWith') this.isSteppedWith,
      @JsonKey(name: 'isLiked') this.isLiked,
      @JsonKey(name: 'totalLikes') this.totalLikes});
  factory _ApiV1StepsStepIdHeartsDeleteResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdHeartsDeleteResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'isSteppedWith')
  final bool? isSteppedWith;
  @override
  @JsonKey(name: 'isLiked')
  final bool? isLiked;
  @override
  @JsonKey(name: 'totalLikes')
  final int? totalLikes;

  /// Create a copy of ApiV1StepsStepIdHeartsDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith<
          _ApiV1StepsStepIdHeartsDeleteResponseDto>
      get copyWith => __$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdHeartsDeleteResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdHeartsDeleteResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdHeartsDeleteResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdHeartsDeleteResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith(
          _ApiV1StepsStepIdHeartsDeleteResponseDto value,
          $Res Function(_ApiV1StepsStepIdHeartsDeleteResponseDto) _then) =
      __$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class __$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdHeartsDeleteResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1StepsStepIdHeartsDeleteResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdHeartsDeleteResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdHeartsDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_ApiV1StepsStepIdHeartsDeleteResponseDto(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdSharesPostResponseDto {
  @JsonKey(name: 'isSteppedWith')
  bool? get isSteppedWith;
  @JsonKey(name: 'isLiked')
  bool? get isLiked;
  @JsonKey(name: 'totalLikes')
  int? get totalLikes;

  /// Create a copy of ApiV1StepsStepIdSharesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdSharesPostResponseDtoCopyWith<
          ApiV1StepsStepIdSharesPostResponseDto>
      get copyWith => _$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl<
              ApiV1StepsStepIdSharesPostResponseDto>(
          this as ApiV1StepsStepIdSharesPostResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdSharesPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdSharesPostResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdSharesPostResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdSharesPostResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdSharesPostResponseDtoCopyWith(
          ApiV1StepsStepIdSharesPostResponseDto value,
          $Res Function(ApiV1StepsStepIdSharesPostResponseDto) _then) =
      _$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class _$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdSharesPostResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdSharesPostResponseDto _self;
  final $Res Function(ApiV1StepsStepIdSharesPostResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdSharesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_self.copyWith(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdSharesPostResponseDto].
extension ApiV1StepsStepIdSharesPostResponseDtoPatterns
    on ApiV1StepsStepIdSharesPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdSharesPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdSharesPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdSharesPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostResponseDto():
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdSharesPostResponseDto
    implements ApiV1StepsStepIdSharesPostResponseDto {
  _ApiV1StepsStepIdSharesPostResponseDto(
      {@JsonKey(name: 'isSteppedWith') this.isSteppedWith,
      @JsonKey(name: 'isLiked') this.isLiked,
      @JsonKey(name: 'totalLikes') this.totalLikes});
  factory _ApiV1StepsStepIdSharesPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdSharesPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'isSteppedWith')
  final bool? isSteppedWith;
  @override
  @JsonKey(name: 'isLiked')
  final bool? isLiked;
  @override
  @JsonKey(name: 'totalLikes')
  final int? totalLikes;

  /// Create a copy of ApiV1StepsStepIdSharesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdSharesPostResponseDtoCopyWith<
          _ApiV1StepsStepIdSharesPostResponseDto>
      get copyWith => __$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdSharesPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdSharesPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdSharesPostResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdSharesPostResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdSharesPostResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdSharesPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdSharesPostResponseDtoCopyWith(
          _ApiV1StepsStepIdSharesPostResponseDto value,
          $Res Function(_ApiV1StepsStepIdSharesPostResponseDto) _then) =
      __$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class __$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdSharesPostResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdSharesPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdSharesPostResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdSharesPostResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdSharesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_ApiV1StepsStepIdSharesPostResponseDto(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdSharesPostRequestDto {
  @JsonKey(name: 'type')
  InteractionTypeDto? get type;

  /// Create a copy of ApiV1StepsStepIdSharesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdSharesPostRequestDtoCopyWith<
          ApiV1StepsStepIdSharesPostRequestDto>
      get copyWith => _$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl<
              ApiV1StepsStepIdSharesPostRequestDto>(
          this as ApiV1StepsStepIdSharesPostRequestDto, _$identity);

  /// Serializes this ApiV1StepsStepIdSharesPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdSharesPostRequestDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ApiV1StepsStepIdSharesPostRequestDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdSharesPostRequestDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdSharesPostRequestDtoCopyWith(
          ApiV1StepsStepIdSharesPostRequestDto value,
          $Res Function(ApiV1StepsStepIdSharesPostRequestDto) _then) =
      _$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class _$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdSharesPostRequestDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdSharesPostRequestDto _self;
  final $Res Function(ApiV1StepsStepIdSharesPostRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdSharesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_self.copyWith(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdSharesPostRequestDto].
extension ApiV1StepsStepIdSharesPostRequestDtoPatterns
    on ApiV1StepsStepIdSharesPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdSharesPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdSharesPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdSharesPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostRequestDto() when $default != null:
        return $default(_that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostRequestDto():
        return $default(_that.type);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdSharesPostRequestDto() when $default != null:
        return $default(_that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdSharesPostRequestDto
    implements ApiV1StepsStepIdSharesPostRequestDto {
  _ApiV1StepsStepIdSharesPostRequestDto({@JsonKey(name: 'type') this.type});
  factory _ApiV1StepsStepIdSharesPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdSharesPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'type')
  final InteractionTypeDto? type;

  /// Create a copy of ApiV1StepsStepIdSharesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdSharesPostRequestDtoCopyWith<
          _ApiV1StepsStepIdSharesPostRequestDto>
      get copyWith => __$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl<
          _ApiV1StepsStepIdSharesPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdSharesPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdSharesPostRequestDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ApiV1StepsStepIdSharesPostRequestDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdSharesPostRequestDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdSharesPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdSharesPostRequestDtoCopyWith(
          _ApiV1StepsStepIdSharesPostRequestDto value,
          $Res Function(_ApiV1StepsStepIdSharesPostRequestDto) _then) =
      __$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class __$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdSharesPostRequestDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdSharesPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdSharesPostRequestDto _self;
  final $Res Function(_ApiV1StepsStepIdSharesPostRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdSharesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_ApiV1StepsStepIdSharesPostRequestDto(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdInteractionsGetResponseDto {
  @JsonKey(name: 'isSteppedWith')
  bool? get isSteppedWith;
  @JsonKey(name: 'isLiked')
  bool? get isLiked;
  @JsonKey(name: 'totalLikes')
  int? get totalLikes;

  /// Create a copy of ApiV1StepsStepIdInteractionsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith<
          ApiV1StepsStepIdInteractionsGetResponseDto>
      get copyWith => _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl<
              ApiV1StepsStepIdInteractionsGetResponseDto>(
          this as ApiV1StepsStepIdInteractionsGetResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdInteractionsGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdInteractionsGetResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdInteractionsGetResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith(
          ApiV1StepsStepIdInteractionsGetResponseDto value,
          $Res Function(ApiV1StepsStepIdInteractionsGetResponseDto) _then) =
      _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl(
      this._self, this._then);

  final ApiV1StepsStepIdInteractionsGetResponseDto _self;
  final $Res Function(ApiV1StepsStepIdInteractionsGetResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdInteractionsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_self.copyWith(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdInteractionsGetResponseDto].
extension ApiV1StepsStepIdInteractionsGetResponseDtoPatterns
    on ApiV1StepsStepIdInteractionsGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdInteractionsGetResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdInteractionsGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdInteractionsGetResponseDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdInteractionsGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdInteractionsGetResponseDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdInteractionsGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdInteractionsGetResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdInteractionsGetResponseDto():
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
            @JsonKey(name: 'isLiked') bool? isLiked,
            @JsonKey(name: 'totalLikes') int? totalLikes)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdInteractionsGetResponseDto() when $default != null:
        return $default(_that.isSteppedWith, _that.isLiked, _that.totalLikes);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdInteractionsGetResponseDto
    implements ApiV1StepsStepIdInteractionsGetResponseDto {
  _ApiV1StepsStepIdInteractionsGetResponseDto(
      {@JsonKey(name: 'isSteppedWith') this.isSteppedWith,
      @JsonKey(name: 'isLiked') this.isLiked,
      @JsonKey(name: 'totalLikes') this.totalLikes});
  factory _ApiV1StepsStepIdInteractionsGetResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdInteractionsGetResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'isSteppedWith')
  final bool? isSteppedWith;
  @override
  @JsonKey(name: 'isLiked')
  final bool? isLiked;
  @override
  @JsonKey(name: 'totalLikes')
  final int? totalLikes;

  /// Create a copy of ApiV1StepsStepIdInteractionsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith<
          _ApiV1StepsStepIdInteractionsGetResponseDto>
      get copyWith => __$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdInteractionsGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdInteractionsGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdInteractionsGetResponseDto &&
            (identical(other.isSteppedWith, isSteppedWith) ||
                other.isSteppedWith == isSteppedWith) &&
            (identical(other.isLiked, isLiked) || other.isLiked == isLiked) &&
            (identical(other.totalLikes, totalLikes) ||
                other.totalLikes == totalLikes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, isSteppedWith, isLiked, totalLikes);

  @override
  String toString() {
    return 'ApiV1StepsStepIdInteractionsGetResponseDto(isSteppedWith: $isSteppedWith, isLiked: $isLiked, totalLikes: $totalLikes)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith(
          _ApiV1StepsStepIdInteractionsGetResponseDto value,
          $Res Function(_ApiV1StepsStepIdInteractionsGetResponseDto) _then) =
      __$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'isSteppedWith') bool? isSteppedWith,
      @JsonKey(name: 'isLiked') bool? isLiked,
      @JsonKey(name: 'totalLikes') int? totalLikes});
}

/// @nodoc
class __$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdInteractionsGetResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1StepsStepIdInteractionsGetResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdInteractionsGetResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdInteractionsGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isSteppedWith = freezed,
    Object? isLiked = freezed,
    Object? totalLikes = freezed,
  }) {
    return _then(_ApiV1StepsStepIdInteractionsGetResponseDto(
      isSteppedWith: freezed == isSteppedWith
          ? _self.isSteppedWith
          : isSteppedWith // ignore: cast_nullable_to_non_nullable
              as bool?,
      isLiked: freezed == isLiked
          ? _self.isLiked
          : isLiked // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalLikes: freezed == totalLikes
          ? _self.totalLikes
          : totalLikes // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsCommentsCommentIdHeartsPostRequestDto {
  @JsonKey(name: 'type')
  InteractionTypeDto? get type;

  /// Create a copy of ApiV1StepsCommentsCommentIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith<
          ApiV1StepsCommentsCommentIdHeartsPostRequestDto>
      get copyWith => _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl<
              ApiV1StepsCommentsCommentIdHeartsPostRequestDto>(
          this as ApiV1StepsCommentsCommentIdHeartsPostRequestDto, _$identity);

  /// Serializes this ApiV1StepsCommentsCommentIdHeartsPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsCommentsCommentIdHeartsPostRequestDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ApiV1StepsCommentsCommentIdHeartsPostRequestDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith<
    $Res> {
  factory $ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith(
          ApiV1StepsCommentsCommentIdHeartsPostRequestDto value,
          $Res Function(ApiV1StepsCommentsCommentIdHeartsPostRequestDto)
              _then) =
      _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith<$Res> {
  _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl(
      this._self, this._then);

  final ApiV1StepsCommentsCommentIdHeartsPostRequestDto _self;
  final $Res Function(ApiV1StepsCommentsCommentIdHeartsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsCommentsCommentIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_self.copyWith(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsCommentsCommentIdHeartsPostRequestDto].
extension ApiV1StepsCommentsCommentIdHeartsPostRequestDtoPatterns
    on ApiV1StepsCommentsCommentIdHeartsPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsCommentsCommentIdHeartsPostRequestDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsCommentsCommentIdHeartsPostRequestDto()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsCommentsCommentIdHeartsPostRequestDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsCommentsCommentIdHeartsPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsCommentsCommentIdHeartsPostRequestDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsCommentsCommentIdHeartsPostRequestDto()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsCommentsCommentIdHeartsPostRequestDto()
          when $default != null:
        return $default(_that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'type') InteractionTypeDto? type) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsCommentsCommentIdHeartsPostRequestDto():
        return $default(_that.type);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'type') InteractionTypeDto? type)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsCommentsCommentIdHeartsPostRequestDto()
          when $default != null:
        return $default(_that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsCommentsCommentIdHeartsPostRequestDto
    implements ApiV1StepsCommentsCommentIdHeartsPostRequestDto {
  _ApiV1StepsCommentsCommentIdHeartsPostRequestDto(
      {@JsonKey(name: 'type') this.type});
  factory _ApiV1StepsCommentsCommentIdHeartsPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'type')
  final InteractionTypeDto? type;

  /// Create a copy of ApiV1StepsCommentsCommentIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith<
          _ApiV1StepsCommentsCommentIdHeartsPostRequestDto>
      get copyWith =>
          __$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl<
                  _ApiV1StepsCommentsCommentIdHeartsPostRequestDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsCommentsCommentIdHeartsPostRequestDto &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ApiV1StepsCommentsCommentIdHeartsPostRequestDto(type: $type)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith<
        $Res>
    implements $ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith(
          _ApiV1StepsCommentsCommentIdHeartsPostRequestDto value,
          $Res Function(_ApiV1StepsCommentsCommentIdHeartsPostRequestDto)
              _then) =
      __$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'type') InteractionTypeDto? type});
}

/// @nodoc
class __$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWith<$Res> {
  __$ApiV1StepsCommentsCommentIdHeartsPostRequestDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1StepsCommentsCommentIdHeartsPostRequestDto _self;
  final $Res Function(_ApiV1StepsCommentsCommentIdHeartsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsCommentsCommentIdHeartsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_ApiV1StepsCommentsCommentIdHeartsPostRequestDto(
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as InteractionTypeDto?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1UsersUserIdFollowPostResponseDto {
  @JsonKey(name: 'status')
  FollowingStatusEnumDto get status;
  @JsonKey(name: 'message')
  String? get message;

  /// Create a copy of ApiV1UsersUserIdFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1UsersUserIdFollowPostResponseDtoCopyWith<
          ApiV1UsersUserIdFollowPostResponseDto>
      get copyWith => _$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl<
              ApiV1UsersUserIdFollowPostResponseDto>(
          this as ApiV1UsersUserIdFollowPostResponseDto, _$identity);

  /// Serializes this ApiV1UsersUserIdFollowPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1UsersUserIdFollowPostResponseDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'ApiV1UsersUserIdFollowPostResponseDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class $ApiV1UsersUserIdFollowPostResponseDtoCopyWith<$Res> {
  factory $ApiV1UsersUserIdFollowPostResponseDtoCopyWith(
          ApiV1UsersUserIdFollowPostResponseDto value,
          $Res Function(ApiV1UsersUserIdFollowPostResponseDto) _then) =
      _$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class _$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1UsersUserIdFollowPostResponseDtoCopyWith<$Res> {
  _$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1UsersUserIdFollowPostResponseDto _self;
  final $Res Function(ApiV1UsersUserIdFollowPostResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1UsersUserIdFollowPostResponseDto].
extension ApiV1UsersUserIdFollowPostResponseDtoPatterns
    on ApiV1UsersUserIdFollowPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdFollowPostResponseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdFollowPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1UsersUserIdFollowPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowPostResponseDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowPostResponseDto():
        return $default(_that.status, _that.message);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowPostResponseDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1UsersUserIdFollowPostResponseDto
    implements ApiV1UsersUserIdFollowPostResponseDto {
  _ApiV1UsersUserIdFollowPostResponseDto(
      {@JsonKey(name: 'status') required this.status,
      @JsonKey(name: 'message') this.message});
  factory _ApiV1UsersUserIdFollowPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1UsersUserIdFollowPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'status')
  final FollowingStatusEnumDto status;
  @override
  @JsonKey(name: 'message')
  final String? message;

  /// Create a copy of ApiV1UsersUserIdFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1UsersUserIdFollowPostResponseDtoCopyWith<
          _ApiV1UsersUserIdFollowPostResponseDto>
      get copyWith => __$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl<
          _ApiV1UsersUserIdFollowPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1UsersUserIdFollowPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1UsersUserIdFollowPostResponseDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'ApiV1UsersUserIdFollowPostResponseDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1UsersUserIdFollowPostResponseDtoCopyWith<$Res>
    implements $ApiV1UsersUserIdFollowPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1UsersUserIdFollowPostResponseDtoCopyWith(
          _ApiV1UsersUserIdFollowPostResponseDto value,
          $Res Function(_ApiV1UsersUserIdFollowPostResponseDto) _then) =
      __$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class __$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1UsersUserIdFollowPostResponseDtoCopyWith<$Res> {
  __$ApiV1UsersUserIdFollowPostResponseDtoCopyWithImpl(this._self, this._then);

  final _ApiV1UsersUserIdFollowPostResponseDto _self;
  final $Res Function(_ApiV1UsersUserIdFollowPostResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_ApiV1UsersUserIdFollowPostResponseDto(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1UsersUserIdFollowDeleteResponseDto {
  @JsonKey(name: 'status')
  FollowingStatusEnumDto get status;
  @JsonKey(name: 'message')
  String? get message;

  /// Create a copy of ApiV1UsersUserIdFollowDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith<
          ApiV1UsersUserIdFollowDeleteResponseDto>
      get copyWith => _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl<
              ApiV1UsersUserIdFollowDeleteResponseDto>(
          this as ApiV1UsersUserIdFollowDeleteResponseDto, _$identity);

  /// Serializes this ApiV1UsersUserIdFollowDeleteResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1UsersUserIdFollowDeleteResponseDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'ApiV1UsersUserIdFollowDeleteResponseDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class $ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith<$Res> {
  factory $ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith(
          ApiV1UsersUserIdFollowDeleteResponseDto value,
          $Res Function(ApiV1UsersUserIdFollowDeleteResponseDto) _then) =
      _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl<$Res>
    implements $ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith<$Res> {
  _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1UsersUserIdFollowDeleteResponseDto _self;
  final $Res Function(ApiV1UsersUserIdFollowDeleteResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdFollowDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1UsersUserIdFollowDeleteResponseDto].
extension ApiV1UsersUserIdFollowDeleteResponseDtoPatterns
    on ApiV1UsersUserIdFollowDeleteResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdFollowDeleteResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowDeleteResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdFollowDeleteResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowDeleteResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1UsersUserIdFollowDeleteResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowDeleteResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowDeleteResponseDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowDeleteResponseDto():
        return $default(_that.status, _that.message);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowDeleteResponseDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1UsersUserIdFollowDeleteResponseDto
    implements ApiV1UsersUserIdFollowDeleteResponseDto {
  _ApiV1UsersUserIdFollowDeleteResponseDto(
      {@JsonKey(name: 'status') required this.status,
      @JsonKey(name: 'message') this.message});
  factory _ApiV1UsersUserIdFollowDeleteResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1UsersUserIdFollowDeleteResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'status')
  final FollowingStatusEnumDto status;
  @override
  @JsonKey(name: 'message')
  final String? message;

  /// Create a copy of ApiV1UsersUserIdFollowDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith<
          _ApiV1UsersUserIdFollowDeleteResponseDto>
      get copyWith => __$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl<
          _ApiV1UsersUserIdFollowDeleteResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1UsersUserIdFollowDeleteResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1UsersUserIdFollowDeleteResponseDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'ApiV1UsersUserIdFollowDeleteResponseDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith<$Res>
    implements $ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith<$Res> {
  factory _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith(
          _ApiV1UsersUserIdFollowDeleteResponseDto value,
          $Res Function(_ApiV1UsersUserIdFollowDeleteResponseDto) _then) =
      __$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class __$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWith<$Res> {
  __$ApiV1UsersUserIdFollowDeleteResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1UsersUserIdFollowDeleteResponseDto _self;
  final $Res Function(_ApiV1UsersUserIdFollowDeleteResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdFollowDeleteResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_ApiV1UsersUserIdFollowDeleteResponseDto(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1UsersUserIdRejectFollowPostResponseDto {
  @JsonKey(name: 'status')
  FollowingStatusEnumDto get status;
  @JsonKey(name: 'message')
  String? get message;

  /// Create a copy of ApiV1UsersUserIdRejectFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith<
          ApiV1UsersUserIdRejectFollowPostResponseDto>
      get copyWith => _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl<
              ApiV1UsersUserIdRejectFollowPostResponseDto>(
          this as ApiV1UsersUserIdRejectFollowPostResponseDto, _$identity);

  /// Serializes this ApiV1UsersUserIdRejectFollowPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1UsersUserIdRejectFollowPostResponseDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'ApiV1UsersUserIdRejectFollowPostResponseDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class $ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith<
    $Res> {
  factory $ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith(
          ApiV1UsersUserIdRejectFollowPostResponseDto value,
          $Res Function(ApiV1UsersUserIdRejectFollowPostResponseDto) _then) =
      _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith<$Res> {
  _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl(
      this._self, this._then);

  final ApiV1UsersUserIdRejectFollowPostResponseDto _self;
  final $Res Function(ApiV1UsersUserIdRejectFollowPostResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdRejectFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1UsersUserIdRejectFollowPostResponseDto].
extension ApiV1UsersUserIdRejectFollowPostResponseDtoPatterns
    on ApiV1UsersUserIdRejectFollowPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdRejectFollowPostResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdRejectFollowPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdRejectFollowPostResponseDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdRejectFollowPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1UsersUserIdRejectFollowPostResponseDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdRejectFollowPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdRejectFollowPostResponseDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdRejectFollowPostResponseDto():
        return $default(_that.status, _that.message);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'status') FollowingStatusEnumDto status,
            @JsonKey(name: 'message') String? message)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdRejectFollowPostResponseDto() when $default != null:
        return $default(_that.status, _that.message);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1UsersUserIdRejectFollowPostResponseDto
    implements ApiV1UsersUserIdRejectFollowPostResponseDto {
  _ApiV1UsersUserIdRejectFollowPostResponseDto(
      {@JsonKey(name: 'status') required this.status,
      @JsonKey(name: 'message') this.message});
  factory _ApiV1UsersUserIdRejectFollowPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1UsersUserIdRejectFollowPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'status')
  final FollowingStatusEnumDto status;
  @override
  @JsonKey(name: 'message')
  final String? message;

  /// Create a copy of ApiV1UsersUserIdRejectFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith<
          _ApiV1UsersUserIdRejectFollowPostResponseDto>
      get copyWith =>
          __$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl<
              _ApiV1UsersUserIdRejectFollowPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1UsersUserIdRejectFollowPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1UsersUserIdRejectFollowPostResponseDto &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, message);

  @override
  String toString() {
    return 'ApiV1UsersUserIdRejectFollowPostResponseDto(status: $status, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith<$Res>
    implements $ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith(
          _ApiV1UsersUserIdRejectFollowPostResponseDto value,
          $Res Function(_ApiV1UsersUserIdRejectFollowPostResponseDto) _then) =
      __$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'status') FollowingStatusEnumDto status,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class __$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWith<$Res> {
  __$ApiV1UsersUserIdRejectFollowPostResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1UsersUserIdRejectFollowPostResponseDto _self;
  final $Res Function(_ApiV1UsersUserIdRejectFollowPostResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdRejectFollowPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
    Object? message = freezed,
  }) {
    return _then(_ApiV1UsersUserIdRejectFollowPostResponseDto(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1UsersUserIdFollowStatusGetResponseDto {
  @JsonKey(name: 'status')
  FollowingStatusEnumDto get status;

  /// Create a copy of ApiV1UsersUserIdFollowStatusGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith<
          ApiV1UsersUserIdFollowStatusGetResponseDto>
      get copyWith => _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl<
              ApiV1UsersUserIdFollowStatusGetResponseDto>(
          this as ApiV1UsersUserIdFollowStatusGetResponseDto, _$identity);

  /// Serializes this ApiV1UsersUserIdFollowStatusGetResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1UsersUserIdFollowStatusGetResponseDto &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status);

  @override
  String toString() {
    return 'ApiV1UsersUserIdFollowStatusGetResponseDto(status: $status)';
  }
}

/// @nodoc
abstract mixin class $ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith<$Res> {
  factory $ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith(
          ApiV1UsersUserIdFollowStatusGetResponseDto value,
          $Res Function(ApiV1UsersUserIdFollowStatusGetResponseDto) _then) =
      _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'status') FollowingStatusEnumDto status});
}

/// @nodoc
class _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl<$Res>
    implements $ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith<$Res> {
  _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl(
      this._self, this._then);

  final ApiV1UsersUserIdFollowStatusGetResponseDto _self;
  final $Res Function(ApiV1UsersUserIdFollowStatusGetResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdFollowStatusGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1UsersUserIdFollowStatusGetResponseDto].
extension ApiV1UsersUserIdFollowStatusGetResponseDtoPatterns
    on ApiV1UsersUserIdFollowStatusGetResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdFollowStatusGetResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowStatusGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1UsersUserIdFollowStatusGetResponseDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowStatusGetResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1UsersUserIdFollowStatusGetResponseDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowStatusGetResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowStatusGetResponseDto() when $default != null:
        return $default(_that.status);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'status') FollowingStatusEnumDto status)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowStatusGetResponseDto():
        return $default(_that.status);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'status') FollowingStatusEnumDto status)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1UsersUserIdFollowStatusGetResponseDto() when $default != null:
        return $default(_that.status);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1UsersUserIdFollowStatusGetResponseDto
    implements ApiV1UsersUserIdFollowStatusGetResponseDto {
  _ApiV1UsersUserIdFollowStatusGetResponseDto(
      {@JsonKey(name: 'status') required this.status});
  factory _ApiV1UsersUserIdFollowStatusGetResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1UsersUserIdFollowStatusGetResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'status')
  final FollowingStatusEnumDto status;

  /// Create a copy of ApiV1UsersUserIdFollowStatusGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith<
          _ApiV1UsersUserIdFollowStatusGetResponseDto>
      get copyWith => __$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl<
          _ApiV1UsersUserIdFollowStatusGetResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1UsersUserIdFollowStatusGetResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1UsersUserIdFollowStatusGetResponseDto &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status);

  @override
  String toString() {
    return 'ApiV1UsersUserIdFollowStatusGetResponseDto(status: $status)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith<$Res>
    implements $ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith<$Res> {
  factory _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith(
          _ApiV1UsersUserIdFollowStatusGetResponseDto value,
          $Res Function(_ApiV1UsersUserIdFollowStatusGetResponseDto) _then) =
      __$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'status') FollowingStatusEnumDto status});
}

/// @nodoc
class __$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWith<$Res> {
  __$ApiV1UsersUserIdFollowStatusGetResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1UsersUserIdFollowStatusGetResponseDto _self;
  final $Res Function(_ApiV1UsersUserIdFollowStatusGetResponseDto) _then;

  /// Create a copy of ApiV1UsersUserIdFollowStatusGetResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
  }) {
    return _then(_ApiV1UsersUserIdFollowStatusGetResponseDto(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FollowingStatusEnumDto,
    ));
  }
}

/// @nodoc
mixin _$ApiV1CommentsParentCommentIdRepliesPostResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdated')
  DateTime? get lastUpdated;
  @JsonKey(name: 'deletedDate')
  DateTime? get deletedDate;
  @JsonKey(name: 'user')
  UserDto? get user;
  @JsonKey(name: 'parentCommentId')
  String? get parentCommentId;
  @JsonKey(name: 'responseToUser')
  UserDto2Dto? get responseToUser;
  @JsonKey(name: 'responseToCommentId')
  String? get responseToCommentId;
  @JsonKey(name: 'heartCount')
  int? get heartCount;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith<
          ApiV1CommentsParentCommentIdRepliesPostResponseDto>
      get copyWith =>
          _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl<
                  ApiV1CommentsParentCommentIdRepliesPostResponseDto>(
              this as ApiV1CommentsParentCommentIdRepliesPostResponseDto,
              _$identity);

  /// Serializes this ApiV1CommentsParentCommentIdRepliesPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1CommentsParentCommentIdRepliesPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.deletedDate, deletedDate) ||
                other.deletedDate == deletedDate) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.parentCommentId, parentCommentId) ||
                other.parentCommentId == parentCommentId) &&
            (identical(other.responseToUser, responseToUser) ||
                other.responseToUser == responseToUser) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdDate,
      lastUpdated,
      deletedDate,
      user,
      parentCommentId,
      responseToUser,
      responseToCommentId,
      heartCount,
      heartedByUser);

  @override
  String toString() {
    return 'ApiV1CommentsParentCommentIdRepliesPostResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, deletedDate: $deletedDate, user: $user, parentCommentId: $parentCommentId, responseToUser: $responseToUser, responseToCommentId: $responseToCommentId, heartCount: $heartCount, heartedByUser: $heartedByUser)';
  }
}

/// @nodoc
abstract mixin class $ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith<
    $Res> {
  factory $ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith(
          ApiV1CommentsParentCommentIdRepliesPostResponseDto value,
          $Res Function(ApiV1CommentsParentCommentIdRepliesPostResponseDto)
              _then) =
      _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'deletedDate') DateTime? deletedDate,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'parentCommentId') String? parentCommentId,
      @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser});

  $UserDtoCopyWith<$Res>? get user;
  $UserDto2DtoCopyWith<$Res>? get responseToUser;
}

/// @nodoc
class _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl<$Res>
    implements
        $ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith<$Res> {
  _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl(
      this._self, this._then);

  final ApiV1CommentsParentCommentIdRepliesPostResponseDto _self;
  final $Res Function(ApiV1CommentsParentCommentIdRepliesPostResponseDto) _then;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? deletedDate = freezed,
    Object? user = freezed,
    Object? parentCommentId = freezed,
    Object? responseToUser = freezed,
    Object? responseToCommentId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedDate: freezed == deletedDate
          ? _self.deletedDate
          : deletedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      parentCommentId: freezed == parentCommentId
          ? _self.parentCommentId
          : parentCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToUser: freezed == responseToUser
          ? _self.responseToUser
          : responseToUser // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get responseToUser {
    if (_self.responseToUser == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.responseToUser!, (value) {
      return _then(_self.copyWith(responseToUser: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1CommentsParentCommentIdRepliesPostResponseDto].
extension ApiV1CommentsParentCommentIdRepliesPostResponseDtoPatterns
    on ApiV1CommentsParentCommentIdRepliesPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1CommentsParentCommentIdRepliesPostResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostResponseDto()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1CommentsParentCommentIdRepliesPostResponseDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(
            _ApiV1CommentsParentCommentIdRepliesPostResponseDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostResponseDto()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'deletedDate') DateTime? deletedDate,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'parentCommentId') String? parentCommentId,
            @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostResponseDto()
          when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.deletedDate,
            _that.user,
            _that.parentCommentId,
            _that.responseToUser,
            _that.responseToCommentId,
            _that.heartCount,
            _that.heartedByUser);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'deletedDate') DateTime? deletedDate,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'parentCommentId') String? parentCommentId,
            @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostResponseDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.deletedDate,
            _that.user,
            _that.parentCommentId,
            _that.responseToUser,
            _that.responseToCommentId,
            _that.heartCount,
            _that.heartedByUser);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
            @JsonKey(name: 'deletedDate') DateTime? deletedDate,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'parentCommentId') String? parentCommentId,
            @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostResponseDto()
          when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdDate,
            _that.lastUpdated,
            _that.deletedDate,
            _that.user,
            _that.parentCommentId,
            _that.responseToUser,
            _that.responseToCommentId,
            _that.heartCount,
            _that.heartedByUser);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1CommentsParentCommentIdRepliesPostResponseDto
    implements ApiV1CommentsParentCommentIdRepliesPostResponseDto {
  _ApiV1CommentsParentCommentIdRepliesPostResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdated') this.lastUpdated,
      @JsonKey(name: 'deletedDate') this.deletedDate,
      @JsonKey(name: 'user') this.user,
      @JsonKey(name: 'parentCommentId') this.parentCommentId,
      @JsonKey(name: 'responseToUser') this.responseToUser,
      @JsonKey(name: 'responseToCommentId') this.responseToCommentId,
      @JsonKey(name: 'heartCount') this.heartCount,
      @JsonKey(name: 'heartedByUser') this.heartedByUser});
  factory _ApiV1CommentsParentCommentIdRepliesPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdated')
  final DateTime? lastUpdated;
  @override
  @JsonKey(name: 'deletedDate')
  final DateTime? deletedDate;
  @override
  @JsonKey(name: 'user')
  final UserDto? user;
  @override
  @JsonKey(name: 'parentCommentId')
  final String? parentCommentId;
  @override
  @JsonKey(name: 'responseToUser')
  final UserDto2Dto? responseToUser;
  @override
  @JsonKey(name: 'responseToCommentId')
  final String? responseToCommentId;
  @override
  @JsonKey(name: 'heartCount')
  final int? heartCount;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith<
          _ApiV1CommentsParentCommentIdRepliesPostResponseDto>
      get copyWith =>
          __$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl<
                  _ApiV1CommentsParentCommentIdRepliesPostResponseDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1CommentsParentCommentIdRepliesPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.deletedDate, deletedDate) ||
                other.deletedDate == deletedDate) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.parentCommentId, parentCommentId) ||
                other.parentCommentId == parentCommentId) &&
            (identical(other.responseToUser, responseToUser) ||
                other.responseToUser == responseToUser) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdDate,
      lastUpdated,
      deletedDate,
      user,
      parentCommentId,
      responseToUser,
      responseToCommentId,
      heartCount,
      heartedByUser);

  @override
  String toString() {
    return 'ApiV1CommentsParentCommentIdRepliesPostResponseDto(id: $id, content: $content, createdDate: $createdDate, lastUpdated: $lastUpdated, deletedDate: $deletedDate, user: $user, parentCommentId: $parentCommentId, responseToUser: $responseToUser, responseToCommentId: $responseToCommentId, heartCount: $heartCount, heartedByUser: $heartedByUser)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith<
        $Res>
    implements
        $ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith(
          _ApiV1CommentsParentCommentIdRepliesPostResponseDto value,
          $Res Function(_ApiV1CommentsParentCommentIdRepliesPostResponseDto)
              _then) =
      __$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdated') DateTime? lastUpdated,
      @JsonKey(name: 'deletedDate') DateTime? deletedDate,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'parentCommentId') String? parentCommentId,
      @JsonKey(name: 'responseToUser') UserDto2Dto? responseToUser,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser});

  @override
  $UserDtoCopyWith<$Res>? get user;
  @override
  $UserDto2DtoCopyWith<$Res>? get responseToUser;
}

/// @nodoc
class __$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl<$Res>
    implements
        _$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWith<$Res> {
  __$ApiV1CommentsParentCommentIdRepliesPostResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1CommentsParentCommentIdRepliesPostResponseDto _self;
  final $Res Function(_ApiV1CommentsParentCommentIdRepliesPostResponseDto)
      _then;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdDate = freezed,
    Object? lastUpdated = freezed,
    Object? deletedDate = freezed,
    Object? user = freezed,
    Object? parentCommentId = freezed,
    Object? responseToUser = freezed,
    Object? responseToCommentId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
  }) {
    return _then(_ApiV1CommentsParentCommentIdRepliesPostResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdated: freezed == lastUpdated
          ? _self.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedDate: freezed == deletedDate
          ? _self.deletedDate
          : deletedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      parentCommentId: freezed == parentCommentId
          ? _self.parentCommentId
          : parentCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToUser: freezed == responseToUser
          ? _self.responseToUser
          : responseToUser // ignore: cast_nullable_to_non_nullable
              as UserDto2Dto?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDto2DtoCopyWith<$Res>? get responseToUser {
    if (_self.responseToUser == null) {
      return null;
    }

    return $UserDto2DtoCopyWith<$Res>(_self.responseToUser!, (value) {
      return _then(_self.copyWith(responseToUser: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1CommentsParentCommentIdRepliesPostRequestDto {
  @JsonKey(name: 'content')
  String get content;
  @JsonKey(name: 'responseToUserId')
  String? get responseToUserId;
  @JsonKey(name: 'responseToCommentId')
  String? get responseToCommentId;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith<
          ApiV1CommentsParentCommentIdRepliesPostRequestDto>
      get copyWith =>
          _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl<
                  ApiV1CommentsParentCommentIdRepliesPostRequestDto>(
              this as ApiV1CommentsParentCommentIdRepliesPostRequestDto,
              _$identity);

  /// Serializes this ApiV1CommentsParentCommentIdRepliesPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1CommentsParentCommentIdRepliesPostRequestDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.responseToUserId, responseToUserId) ||
                other.responseToUserId == responseToUserId) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, content, responseToUserId, responseToCommentId);

  @override
  String toString() {
    return 'ApiV1CommentsParentCommentIdRepliesPostRequestDto(content: $content, responseToUserId: $responseToUserId, responseToCommentId: $responseToCommentId)';
  }
}

/// @nodoc
abstract mixin class $ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith<
    $Res> {
  factory $ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith(
          ApiV1CommentsParentCommentIdRepliesPostRequestDto value,
          $Res Function(ApiV1CommentsParentCommentIdRepliesPostRequestDto)
              _then) =
      _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'responseToUserId') String? responseToUserId,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId});
}

/// @nodoc
class _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl<$Res>
    implements
        $ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith<$Res> {
  _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl(
      this._self, this._then);

  final ApiV1CommentsParentCommentIdRepliesPostRequestDto _self;
  final $Res Function(ApiV1CommentsParentCommentIdRepliesPostRequestDto) _then;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
    Object? responseToUserId = freezed,
    Object? responseToCommentId = freezed,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      responseToUserId: freezed == responseToUserId
          ? _self.responseToUserId
          : responseToUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1CommentsParentCommentIdRepliesPostRequestDto].
extension ApiV1CommentsParentCommentIdRepliesPostRequestDtoPatterns
    on ApiV1CommentsParentCommentIdRepliesPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1CommentsParentCommentIdRepliesPostRequestDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostRequestDto()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1CommentsParentCommentIdRepliesPostRequestDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1CommentsParentCommentIdRepliesPostRequestDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostRequestDto()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'responseToUserId') String? responseToUserId,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostRequestDto()
          when $default != null:
        return $default(
            _that.content, _that.responseToUserId, _that.responseToCommentId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'responseToUserId') String? responseToUserId,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostRequestDto():
        return $default(
            _that.content, _that.responseToUserId, _that.responseToCommentId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'content') String content,
            @JsonKey(name: 'responseToUserId') String? responseToUserId,
            @JsonKey(name: 'responseToCommentId') String? responseToCommentId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1CommentsParentCommentIdRepliesPostRequestDto()
          when $default != null:
        return $default(
            _that.content, _that.responseToUserId, _that.responseToCommentId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1CommentsParentCommentIdRepliesPostRequestDto
    implements ApiV1CommentsParentCommentIdRepliesPostRequestDto {
  _ApiV1CommentsParentCommentIdRepliesPostRequestDto(
      {@JsonKey(name: 'content') required this.content,
      @JsonKey(name: 'responseToUserId') this.responseToUserId,
      @JsonKey(name: 'responseToCommentId') this.responseToCommentId});
  factory _ApiV1CommentsParentCommentIdRepliesPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;
  @override
  @JsonKey(name: 'responseToUserId')
  final String? responseToUserId;
  @override
  @JsonKey(name: 'responseToCommentId')
  final String? responseToCommentId;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith<
          _ApiV1CommentsParentCommentIdRepliesPostRequestDto>
      get copyWith =>
          __$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl<
                  _ApiV1CommentsParentCommentIdRepliesPostRequestDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1CommentsParentCommentIdRepliesPostRequestDto &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.responseToUserId, responseToUserId) ||
                other.responseToUserId == responseToUserId) &&
            (identical(other.responseToCommentId, responseToCommentId) ||
                other.responseToCommentId == responseToCommentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, content, responseToUserId, responseToCommentId);

  @override
  String toString() {
    return 'ApiV1CommentsParentCommentIdRepliesPostRequestDto(content: $content, responseToUserId: $responseToUserId, responseToCommentId: $responseToCommentId)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith<
        $Res>
    implements
        $ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith(
          _ApiV1CommentsParentCommentIdRepliesPostRequestDto value,
          $Res Function(_ApiV1CommentsParentCommentIdRepliesPostRequestDto)
              _then) =
      __$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'content') String content,
      @JsonKey(name: 'responseToUserId') String? responseToUserId,
      @JsonKey(name: 'responseToCommentId') String? responseToCommentId});
}

/// @nodoc
class __$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl<$Res>
    implements
        _$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWith<$Res> {
  __$ApiV1CommentsParentCommentIdRepliesPostRequestDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1CommentsParentCommentIdRepliesPostRequestDto _self;
  final $Res Function(_ApiV1CommentsParentCommentIdRepliesPostRequestDto) _then;

  /// Create a copy of ApiV1CommentsParentCommentIdRepliesPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
    Object? responseToUserId = freezed,
    Object? responseToCommentId = freezed,
  }) {
    return _then(_ApiV1CommentsParentCommentIdRepliesPostRequestDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      responseToUserId: freezed == responseToUserId
          ? _self.responseToUserId
          : responseToUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      responseToCommentId: freezed == responseToCommentId
          ? _self.responseToCommentId
          : responseToCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdCommentsPostResponseDto {
  @JsonKey(name: 'id')
  String? get id;
  @JsonKey(name: 'content')
  String? get content;
  @JsonKey(name: 'createdAt')
  DateTime? get createdAt;
  @JsonKey(name: 'updatedAt')
  DateTime? get updatedAt;
  @JsonKey(name: 'deletedAt')
  DateTime? get deletedAt;
  @JsonKey(name: 'user')
  UserDto? get user;
  @JsonKey(name: 'stepId')
  String? get stepId;
  @JsonKey(name: 'heartCount')
  int? get heartCount;
  @JsonKey(name: 'heartedByUser')
  bool? get heartedByUser;
  @JsonKey(name: 'replyCount')
  int? get replyCount;

  /// Create a copy of ApiV1StepsStepIdCommentsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdCommentsPostResponseDtoCopyWith<
          ApiV1StepsStepIdCommentsPostResponseDto>
      get copyWith => _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl<
              ApiV1StepsStepIdCommentsPostResponseDto>(
          this as ApiV1StepsStepIdCommentsPostResponseDto, _$identity);

  /// Serializes this ApiV1StepsStepIdCommentsPostResponseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdCommentsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.deletedAt, deletedAt) ||
                other.deletedAt == deletedAt) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.replyCount, replyCount) ||
                other.replyCount == replyCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdAt,
      updatedAt,
      deletedAt,
      user,
      stepId,
      heartCount,
      heartedByUser,
      replyCount);

  @override
  String toString() {
    return 'ApiV1StepsStepIdCommentsPostResponseDto(id: $id, content: $content, createdAt: $createdAt, updatedAt: $updatedAt, deletedAt: $deletedAt, user: $user, stepId: $stepId, heartCount: $heartCount, heartedByUser: $heartedByUser, replyCount: $replyCount)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdCommentsPostResponseDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdCommentsPostResponseDtoCopyWith(
          ApiV1StepsStepIdCommentsPostResponseDto value,
          $Res Function(ApiV1StepsStepIdCommentsPostResponseDto) _then) =
      _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdAt') DateTime? createdAt,
      @JsonKey(name: 'updatedAt') DateTime? updatedAt,
      @JsonKey(name: 'deletedAt') DateTime? deletedAt,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'replyCount') int? replyCount});

  $UserDtoCopyWith<$Res>? get user;
}

/// @nodoc
class _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdCommentsPostResponseDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdCommentsPostResponseDto _self;
  final $Res Function(ApiV1StepsStepIdCommentsPostResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdCommentsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? deletedAt = freezed,
    Object? user = freezed,
    Object? stepId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
    Object? replyCount = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _self.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedAt: freezed == deletedAt
          ? _self.deletedAt
          : deletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      replyCount: freezed == replyCount
          ? _self.replyCount
          : replyCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdCommentsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdCommentsPostResponseDto].
extension ApiV1StepsStepIdCommentsPostResponseDtoPatterns
    on ApiV1StepsStepIdCommentsPostResponseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdCommentsPostResponseDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdCommentsPostResponseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostResponseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdCommentsPostResponseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostResponseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdAt') DateTime? createdAt,
            @JsonKey(name: 'updatedAt') DateTime? updatedAt,
            @JsonKey(name: 'deletedAt') DateTime? deletedAt,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'replyCount') int? replyCount)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdAt,
            _that.updatedAt,
            _that.deletedAt,
            _that.user,
            _that.stepId,
            _that.heartCount,
            _that.heartedByUser,
            _that.replyCount);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdAt') DateTime? createdAt,
            @JsonKey(name: 'updatedAt') DateTime? updatedAt,
            @JsonKey(name: 'deletedAt') DateTime? deletedAt,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'replyCount') int? replyCount)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostResponseDto():
        return $default(
            _that.id,
            _that.content,
            _that.createdAt,
            _that.updatedAt,
            _that.deletedAt,
            _that.user,
            _that.stepId,
            _that.heartCount,
            _that.heartedByUser,
            _that.replyCount);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') String? id,
            @JsonKey(name: 'content') String? content,
            @JsonKey(name: 'createdAt') DateTime? createdAt,
            @JsonKey(name: 'updatedAt') DateTime? updatedAt,
            @JsonKey(name: 'deletedAt') DateTime? deletedAt,
            @JsonKey(name: 'user') UserDto? user,
            @JsonKey(name: 'stepId') String? stepId,
            @JsonKey(name: 'heartCount') int? heartCount,
            @JsonKey(name: 'heartedByUser') bool? heartedByUser,
            @JsonKey(name: 'replyCount') int? replyCount)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostResponseDto() when $default != null:
        return $default(
            _that.id,
            _that.content,
            _that.createdAt,
            _that.updatedAt,
            _that.deletedAt,
            _that.user,
            _that.stepId,
            _that.heartCount,
            _that.heartedByUser,
            _that.replyCount);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdCommentsPostResponseDto
    implements ApiV1StepsStepIdCommentsPostResponseDto {
  _ApiV1StepsStepIdCommentsPostResponseDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'content') this.content,
      @JsonKey(name: 'createdAt') this.createdAt,
      @JsonKey(name: 'updatedAt') this.updatedAt,
      @JsonKey(name: 'deletedAt') this.deletedAt,
      @JsonKey(name: 'user') this.user,
      @JsonKey(name: 'stepId') this.stepId,
      @JsonKey(name: 'heartCount') this.heartCount,
      @JsonKey(name: 'heartedByUser') this.heartedByUser,
      @JsonKey(name: 'replyCount') this.replyCount});
  factory _ApiV1StepsStepIdCommentsPostResponseDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdCommentsPostResponseDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final String? id;
  @override
  @JsonKey(name: 'content')
  final String? content;
  @override
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @override
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @override
  @JsonKey(name: 'deletedAt')
  final DateTime? deletedAt;
  @override
  @JsonKey(name: 'user')
  final UserDto? user;
  @override
  @JsonKey(name: 'stepId')
  final String? stepId;
  @override
  @JsonKey(name: 'heartCount')
  final int? heartCount;
  @override
  @JsonKey(name: 'heartedByUser')
  final bool? heartedByUser;
  @override
  @JsonKey(name: 'replyCount')
  final int? replyCount;

  /// Create a copy of ApiV1StepsStepIdCommentsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWith<
          _ApiV1StepsStepIdCommentsPostResponseDto>
      get copyWith => __$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl<
          _ApiV1StepsStepIdCommentsPostResponseDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdCommentsPostResponseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdCommentsPostResponseDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.deletedAt, deletedAt) ||
                other.deletedAt == deletedAt) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.stepId, stepId) || other.stepId == stepId) &&
            (identical(other.heartCount, heartCount) ||
                other.heartCount == heartCount) &&
            (identical(other.heartedByUser, heartedByUser) ||
                other.heartedByUser == heartedByUser) &&
            (identical(other.replyCount, replyCount) ||
                other.replyCount == replyCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      content,
      createdAt,
      updatedAt,
      deletedAt,
      user,
      stepId,
      heartCount,
      heartedByUser,
      replyCount);

  @override
  String toString() {
    return 'ApiV1StepsStepIdCommentsPostResponseDto(id: $id, content: $content, createdAt: $createdAt, updatedAt: $updatedAt, deletedAt: $deletedAt, user: $user, stepId: $stepId, heartCount: $heartCount, heartedByUser: $heartedByUser, replyCount: $replyCount)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdCommentsPostResponseDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWith(
          _ApiV1StepsStepIdCommentsPostResponseDto value,
          $Res Function(_ApiV1StepsStepIdCommentsPostResponseDto) _then) =
      __$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'content') String? content,
      @JsonKey(name: 'createdAt') DateTime? createdAt,
      @JsonKey(name: 'updatedAt') DateTime? updatedAt,
      @JsonKey(name: 'deletedAt') DateTime? deletedAt,
      @JsonKey(name: 'user') UserDto? user,
      @JsonKey(name: 'stepId') String? stepId,
      @JsonKey(name: 'heartCount') int? heartCount,
      @JsonKey(name: 'heartedByUser') bool? heartedByUser,
      @JsonKey(name: 'replyCount') int? replyCount});

  @override
  $UserDtoCopyWith<$Res>? get user;
}

/// @nodoc
class __$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdCommentsPostResponseDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdCommentsPostResponseDtoCopyWithImpl(
      this._self, this._then);

  final _ApiV1StepsStepIdCommentsPostResponseDto _self;
  final $Res Function(_ApiV1StepsStepIdCommentsPostResponseDto) _then;

  /// Create a copy of ApiV1StepsStepIdCommentsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? deletedAt = freezed,
    Object? user = freezed,
    Object? stepId = freezed,
    Object? heartCount = freezed,
    Object? heartedByUser = freezed,
    Object? replyCount = freezed,
  }) {
    return _then(_ApiV1StepsStepIdCommentsPostResponseDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _self.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedAt: freezed == deletedAt
          ? _self.deletedAt
          : deletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto?,
      stepId: freezed == stepId
          ? _self.stepId
          : stepId // ignore: cast_nullable_to_non_nullable
              as String?,
      heartCount: freezed == heartCount
          ? _self.heartCount
          : heartCount // ignore: cast_nullable_to_non_nullable
              as int?,
      heartedByUser: freezed == heartedByUser
          ? _self.heartedByUser
          : heartedByUser // ignore: cast_nullable_to_non_nullable
              as bool?,
      replyCount: freezed == replyCount
          ? _self.replyCount
          : replyCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ApiV1StepsStepIdCommentsPostResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res>? get user {
    if (_self.user == null) {
      return null;
    }

    return $UserDtoCopyWith<$Res>(_self.user!, (value) {
      return _then(_self.copyWith(user: value));
    });
  }
}

/// @nodoc
mixin _$ApiV1StepsStepIdCommentsPostRequestDto {
  @JsonKey(name: 'content')
  String get content;

  /// Create a copy of ApiV1StepsStepIdCommentsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiV1StepsStepIdCommentsPostRequestDtoCopyWith<
          ApiV1StepsStepIdCommentsPostRequestDto>
      get copyWith => _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl<
              ApiV1StepsStepIdCommentsPostRequestDto>(
          this as ApiV1StepsStepIdCommentsPostRequestDto, _$identity);

  /// Serializes this ApiV1StepsStepIdCommentsPostRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiV1StepsStepIdCommentsPostRequestDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'ApiV1StepsStepIdCommentsPostRequestDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class $ApiV1StepsStepIdCommentsPostRequestDtoCopyWith<$Res> {
  factory $ApiV1StepsStepIdCommentsPostRequestDtoCopyWith(
          ApiV1StepsStepIdCommentsPostRequestDto value,
          $Res Function(ApiV1StepsStepIdCommentsPostRequestDto) _then) =
      _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl<$Res>
    implements $ApiV1StepsStepIdCommentsPostRequestDtoCopyWith<$Res> {
  _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl(this._self, this._then);

  final ApiV1StepsStepIdCommentsPostRequestDto _self;
  final $Res Function(ApiV1StepsStepIdCommentsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdCommentsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_self.copyWith(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ApiV1StepsStepIdCommentsPostRequestDto].
extension ApiV1StepsStepIdCommentsPostRequestDtoPatterns
    on ApiV1StepsStepIdCommentsPostRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdCommentsPostRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ApiV1StepsStepIdCommentsPostRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ApiV1StepsStepIdCommentsPostRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostRequestDto() when $default != null:
        return $default(_that.content);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'content') String content) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostRequestDto():
        return $default(_that.content);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'content') String content)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ApiV1StepsStepIdCommentsPostRequestDto() when $default != null:
        return $default(_that.content);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ApiV1StepsStepIdCommentsPostRequestDto
    implements ApiV1StepsStepIdCommentsPostRequestDto {
  _ApiV1StepsStepIdCommentsPostRequestDto(
      {@JsonKey(name: 'content') required this.content});
  factory _ApiV1StepsStepIdCommentsPostRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$ApiV1StepsStepIdCommentsPostRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'content')
  final String content;

  /// Create a copy of ApiV1StepsStepIdCommentsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWith<
          _ApiV1StepsStepIdCommentsPostRequestDto>
      get copyWith => __$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl<
          _ApiV1StepsStepIdCommentsPostRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ApiV1StepsStepIdCommentsPostRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiV1StepsStepIdCommentsPostRequestDto &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, content);

  @override
  String toString() {
    return 'ApiV1StepsStepIdCommentsPostRequestDto(content: $content)';
  }
}

/// @nodoc
abstract mixin class _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWith<$Res>
    implements $ApiV1StepsStepIdCommentsPostRequestDtoCopyWith<$Res> {
  factory _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWith(
          _ApiV1StepsStepIdCommentsPostRequestDto value,
          $Res Function(_ApiV1StepsStepIdCommentsPostRequestDto) _then) =
      __$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'content') String content});
}

/// @nodoc
class __$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl<$Res>
    implements _$ApiV1StepsStepIdCommentsPostRequestDtoCopyWith<$Res> {
  __$ApiV1StepsStepIdCommentsPostRequestDtoCopyWithImpl(this._self, this._then);

  final _ApiV1StepsStepIdCommentsPostRequestDto _self;
  final $Res Function(_ApiV1StepsStepIdCommentsPostRequestDto) _then;

  /// Create a copy of ApiV1StepsStepIdCommentsPostRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = null,
  }) {
    return _then(_ApiV1StepsStepIdCommentsPostRequestDto(
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on
