// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ebridge.openapi.dtos.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$AcademicYearApiDto {
  @JsonKey(name: 'academicYearId')
  int? get academicYearId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'startDate')
  String? get startDate;
  @JsonKey(name: 'endDate')
  String? get endDate;

  /// Create a copy of AcademicYearApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AcademicYearApiDtoCopyWith<AcademicYearApiDto> get copyWith =>
      _$AcademicYearApiDtoCopyWithImpl<AcademicYearApiDto>(
          this as AcademicYearApiDto, _$identity);

  /// Serializes this AcademicYearApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AcademicYearApiDto &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, academicYearId, branchId, name, startDate, endDate);

  @override
  String toString() {
    return 'AcademicYearApiDto(academicYearId: $academicYearId, branchId: $branchId, name: $name, startDate: $startDate, endDate: $endDate)';
  }
}

/// @nodoc
abstract mixin class $AcademicYearApiDtoCopyWith<$Res> {
  factory $AcademicYearApiDtoCopyWith(
          AcademicYearApiDto value, $Res Function(AcademicYearApiDto) _then) =
      _$AcademicYearApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate});
}

/// @nodoc
class _$AcademicYearApiDtoCopyWithImpl<$Res>
    implements $AcademicYearApiDtoCopyWith<$Res> {
  _$AcademicYearApiDtoCopyWithImpl(this._self, this._then);

  final AcademicYearApiDto _self;
  final $Res Function(AcademicYearApiDto) _then;

  /// Create a copy of AcademicYearApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? academicYearId = freezed,
    Object? branchId = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
  }) {
    return _then(_self.copyWith(
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AcademicYearApiDto].
extension AcademicYearApiDtoPatterns on AcademicYearApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AcademicYearApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AcademicYearApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AcademicYearApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AcademicYearApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AcademicYearApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AcademicYearApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AcademicYearApiDto() when $default != null:
        return $default(_that.academicYearId, _that.branchId, _that.name,
            _that.startDate, _that.endDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AcademicYearApiDto():
        return $default(_that.academicYearId, _that.branchId, _that.name,
            _that.startDate, _that.endDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AcademicYearApiDto() when $default != null:
        return $default(_that.academicYearId, _that.branchId, _that.name,
            _that.startDate, _that.endDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AcademicYearApiDto implements AcademicYearApiDto {
  _AcademicYearApiDto(
      {@JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate});
  factory _AcademicYearApiDto.fromJson(Map<String, dynamic> json) =>
      _$AcademicYearApiDtoFromJson(json);

  @override
  @JsonKey(name: 'academicYearId')
  final int? academicYearId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'startDate')
  final String? startDate;
  @override
  @JsonKey(name: 'endDate')
  final String? endDate;

  /// Create a copy of AcademicYearApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AcademicYearApiDtoCopyWith<_AcademicYearApiDto> get copyWith =>
      __$AcademicYearApiDtoCopyWithImpl<_AcademicYearApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AcademicYearApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AcademicYearApiDto &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, academicYearId, branchId, name, startDate, endDate);

  @override
  String toString() {
    return 'AcademicYearApiDto(academicYearId: $academicYearId, branchId: $branchId, name: $name, startDate: $startDate, endDate: $endDate)';
  }
}

/// @nodoc
abstract mixin class _$AcademicYearApiDtoCopyWith<$Res>
    implements $AcademicYearApiDtoCopyWith<$Res> {
  factory _$AcademicYearApiDtoCopyWith(
          _AcademicYearApiDto value, $Res Function(_AcademicYearApiDto) _then) =
      __$AcademicYearApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate});
}

/// @nodoc
class __$AcademicYearApiDtoCopyWithImpl<$Res>
    implements _$AcademicYearApiDtoCopyWith<$Res> {
  __$AcademicYearApiDtoCopyWithImpl(this._self, this._then);

  final _AcademicYearApiDto _self;
  final $Res Function(_AcademicYearApiDto) _then;

  /// Create a copy of AcademicYearApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? academicYearId = freezed,
    Object? branchId = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
  }) {
    return _then(_AcademicYearApiDto(
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$AccountApiDto {
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'identifier')
  String? get identifier;
  @JsonKey(name: 'contacts')
  List<ContactApiDto>? get contacts;
  @JsonKey(name: 'identifierType')
  int? get identifierType;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of AccountApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AccountApiDtoCopyWith<AccountApiDto> get copyWith =>
      _$AccountApiDtoCopyWithImpl<AccountApiDto>(
          this as AccountApiDto, _$identity);

  /// Serializes this AccountApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AccountApiDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            const DeepCollectionEquality().equals(other.contacts, contacts) &&
            (identical(other.identifierType, identifierType) ||
                other.identifierType == identifierType) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      name,
      identifier,
      const DeepCollectionEquality().hash(contacts),
      identifierType,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AccountApiDto(accountId: $accountId, name: $name, identifier: $identifier, contacts: $contacts, identifierType: $identifierType, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $AccountApiDtoCopyWith<$Res> {
  factory $AccountApiDtoCopyWith(
          AccountApiDto value, $Res Function(AccountApiDto) _then) =
      _$AccountApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
      @JsonKey(name: 'identifierType') int? identifierType,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$AccountApiDtoCopyWithImpl<$Res>
    implements $AccountApiDtoCopyWith<$Res> {
  _$AccountApiDtoCopyWithImpl(this._self, this._then);

  final AccountApiDto _self;
  final $Res Function(AccountApiDto) _then;

  /// Create a copy of AccountApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contacts = freezed,
    Object? identifierType = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _self.contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<ContactApiDto>?,
      identifierType: freezed == identifierType
          ? _self.identifierType
          : identifierType // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AccountApiDto].
extension AccountApiDtoPatterns on AccountApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AccountApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AccountApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AccountApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
            @JsonKey(name: 'identifierType') int? identifierType,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto() when $default != null:
        return $default(
            _that.accountId,
            _that.name,
            _that.identifier,
            _that.contacts,
            _that.identifierType,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
            @JsonKey(name: 'identifierType') int? identifierType,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto():
        return $default(
            _that.accountId,
            _that.name,
            _that.identifier,
            _that.contacts,
            _that.identifierType,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
            @JsonKey(name: 'identifierType') int? identifierType,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto() when $default != null:
        return $default(
            _that.accountId,
            _that.name,
            _that.identifier,
            _that.contacts,
            _that.identifierType,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AccountApiDto implements AccountApiDto {
  _AccountApiDto(
      {@JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'identifier') this.identifier,
      @JsonKey(name: 'contacts') final List<ContactApiDto>? contacts,
      @JsonKey(name: 'identifierType') this.identifierType,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _contacts = contacts;
  factory _AccountApiDto.fromJson(Map<String, dynamic> json) =>
      _$AccountApiDtoFromJson(json);

  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'identifier')
  final String? identifier;
  final List<ContactApiDto>? _contacts;
  @override
  @JsonKey(name: 'contacts')
  List<ContactApiDto>? get contacts {
    final value = _contacts;
    if (value == null) return null;
    if (_contacts is EqualUnmodifiableListView) return _contacts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'identifierType')
  final int? identifierType;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of AccountApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AccountApiDtoCopyWith<_AccountApiDto> get copyWith =>
      __$AccountApiDtoCopyWithImpl<_AccountApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AccountApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AccountApiDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            const DeepCollectionEquality().equals(other._contacts, _contacts) &&
            (identical(other.identifierType, identifierType) ||
                other.identifierType == identifierType) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      name,
      identifier,
      const DeepCollectionEquality().hash(_contacts),
      identifierType,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AccountApiDto(accountId: $accountId, name: $name, identifier: $identifier, contacts: $contacts, identifierType: $identifierType, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$AccountApiDtoCopyWith<$Res>
    implements $AccountApiDtoCopyWith<$Res> {
  factory _$AccountApiDtoCopyWith(
          _AccountApiDto value, $Res Function(_AccountApiDto) _then) =
      __$AccountApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
      @JsonKey(name: 'identifierType') int? identifierType,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$AccountApiDtoCopyWithImpl<$Res>
    implements _$AccountApiDtoCopyWith<$Res> {
  __$AccountApiDtoCopyWithImpl(this._self, this._then);

  final _AccountApiDto _self;
  final $Res Function(_AccountApiDto) _then;

  /// Create a copy of AccountApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? accountId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contacts = freezed,
    Object? identifierType = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_AccountApiDto(
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _self._contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<ContactApiDto>?,
      identifierType: freezed == identifierType
          ? _self.identifierType
          : identifierType // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$AccountApiDto2Dto {
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'identifier')
  String? get identifier;
  @JsonKey(name: 'contacts')
  List<ContactApiDto>? get contacts;
  @JsonKey(name: 'identifierType')
  int? get identifierType;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of AccountApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AccountApiDto2DtoCopyWith<AccountApiDto2Dto> get copyWith =>
      _$AccountApiDto2DtoCopyWithImpl<AccountApiDto2Dto>(
          this as AccountApiDto2Dto, _$identity);

  /// Serializes this AccountApiDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AccountApiDto2Dto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            const DeepCollectionEquality().equals(other.contacts, contacts) &&
            (identical(other.identifierType, identifierType) ||
                other.identifierType == identifierType) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      name,
      identifier,
      const DeepCollectionEquality().hash(contacts),
      identifierType,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AccountApiDto2Dto(accountId: $accountId, name: $name, identifier: $identifier, contacts: $contacts, identifierType: $identifierType, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $AccountApiDto2DtoCopyWith<$Res> {
  factory $AccountApiDto2DtoCopyWith(
          AccountApiDto2Dto value, $Res Function(AccountApiDto2Dto) _then) =
      _$AccountApiDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
      @JsonKey(name: 'identifierType') int? identifierType,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$AccountApiDto2DtoCopyWithImpl<$Res>
    implements $AccountApiDto2DtoCopyWith<$Res> {
  _$AccountApiDto2DtoCopyWithImpl(this._self, this._then);

  final AccountApiDto2Dto _self;
  final $Res Function(AccountApiDto2Dto) _then;

  /// Create a copy of AccountApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contacts = freezed,
    Object? identifierType = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _self.contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<ContactApiDto>?,
      identifierType: freezed == identifierType
          ? _self.identifierType
          : identifierType // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AccountApiDto2Dto].
extension AccountApiDto2DtoPatterns on AccountApiDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AccountApiDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AccountApiDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AccountApiDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
            @JsonKey(name: 'identifierType') int? identifierType,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto2Dto() when $default != null:
        return $default(
            _that.accountId,
            _that.name,
            _that.identifier,
            _that.contacts,
            _that.identifierType,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
            @JsonKey(name: 'identifierType') int? identifierType,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto2Dto():
        return $default(
            _that.accountId,
            _that.name,
            _that.identifier,
            _that.contacts,
            _that.identifierType,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
            @JsonKey(name: 'identifierType') int? identifierType,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountApiDto2Dto() when $default != null:
        return $default(
            _that.accountId,
            _that.name,
            _that.identifier,
            _that.contacts,
            _that.identifierType,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AccountApiDto2Dto implements AccountApiDto2Dto {
  _AccountApiDto2Dto(
      {@JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'identifier') this.identifier,
      @JsonKey(name: 'contacts') final List<ContactApiDto>? contacts,
      @JsonKey(name: 'identifierType') this.identifierType,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _contacts = contacts;
  factory _AccountApiDto2Dto.fromJson(Map<String, dynamic> json) =>
      _$AccountApiDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'identifier')
  final String? identifier;
  final List<ContactApiDto>? _contacts;
  @override
  @JsonKey(name: 'contacts')
  List<ContactApiDto>? get contacts {
    final value = _contacts;
    if (value == null) return null;
    if (_contacts is EqualUnmodifiableListView) return _contacts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'identifierType')
  final int? identifierType;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of AccountApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AccountApiDto2DtoCopyWith<_AccountApiDto2Dto> get copyWith =>
      __$AccountApiDto2DtoCopyWithImpl<_AccountApiDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AccountApiDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AccountApiDto2Dto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            const DeepCollectionEquality().equals(other._contacts, _contacts) &&
            (identical(other.identifierType, identifierType) ||
                other.identifierType == identifierType) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      name,
      identifier,
      const DeepCollectionEquality().hash(_contacts),
      identifierType,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AccountApiDto2Dto(accountId: $accountId, name: $name, identifier: $identifier, contacts: $contacts, identifierType: $identifierType, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$AccountApiDto2DtoCopyWith<$Res>
    implements $AccountApiDto2DtoCopyWith<$Res> {
  factory _$AccountApiDto2DtoCopyWith(
          _AccountApiDto2Dto value, $Res Function(_AccountApiDto2Dto) _then) =
      __$AccountApiDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contacts') List<ContactApiDto>? contacts,
      @JsonKey(name: 'identifierType') int? identifierType,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$AccountApiDto2DtoCopyWithImpl<$Res>
    implements _$AccountApiDto2DtoCopyWith<$Res> {
  __$AccountApiDto2DtoCopyWithImpl(this._self, this._then);

  final _AccountApiDto2Dto _self;
  final $Res Function(_AccountApiDto2Dto) _then;

  /// Create a copy of AccountApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? accountId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contacts = freezed,
    Object? identifierType = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_AccountApiDto2Dto(
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _self._contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<ContactApiDto>?,
      identifierType: freezed == identifierType
          ? _self.identifierType
          : identifierType // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$AccountDeviceSessionApiDto {
  @JsonKey(name: 'accountDeviceSessionId')
  int get accountDeviceSessionId;
  @JsonKey(name: 'accountId')
  int get accountId;
  @JsonKey(name: 'pushNotificationToken')
  String? get pushNotificationToken;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'os')
  String? get os;
  @JsonKey(name: 'osVersion')
  String? get osVersion;
  @JsonKey(name: 'deviceId')
  String get deviceId;
  @JsonKey(name: 'model')
  String? get model;
  @JsonKey(name: 'manufacturer')
  String? get manufacturer;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of AccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AccountDeviceSessionApiDtoCopyWith<AccountDeviceSessionApiDto>
      get copyWith =>
          _$AccountDeviceSessionApiDtoCopyWithImpl<AccountDeviceSessionApiDto>(
              this as AccountDeviceSessionApiDto, _$identity);

  /// Serializes this AccountDeviceSessionApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AccountDeviceSessionApiDto &&
            (identical(other.accountDeviceSessionId, accountDeviceSessionId) ||
                other.accountDeviceSessionId == accountDeviceSessionId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.pushNotificationToken, pushNotificationToken) ||
                other.pushNotificationToken == pushNotificationToken) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.os, os) || other.os == os) &&
            (identical(other.osVersion, osVersion) ||
                other.osVersion == osVersion) &&
            (identical(other.deviceId, deviceId) ||
                other.deviceId == deviceId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.manufacturer, manufacturer) ||
                other.manufacturer == manufacturer) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountDeviceSessionId,
      accountId,
      pushNotificationToken,
      name,
      os,
      osVersion,
      deviceId,
      model,
      manufacturer,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AccountDeviceSessionApiDto(accountDeviceSessionId: $accountDeviceSessionId, accountId: $accountId, pushNotificationToken: $pushNotificationToken, name: $name, os: $os, osVersion: $osVersion, deviceId: $deviceId, model: $model, manufacturer: $manufacturer, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $AccountDeviceSessionApiDtoCopyWith<$Res> {
  factory $AccountDeviceSessionApiDtoCopyWith(AccountDeviceSessionApiDto value,
          $Res Function(AccountDeviceSessionApiDto) _then) =
      _$AccountDeviceSessionApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'accountDeviceSessionId') int accountDeviceSessionId,
      @JsonKey(name: 'accountId') int accountId,
      @JsonKey(name: 'pushNotificationToken') String? pushNotificationToken,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'os') String? os,
      @JsonKey(name: 'osVersion') String? osVersion,
      @JsonKey(name: 'deviceId') String deviceId,
      @JsonKey(name: 'model') String? model,
      @JsonKey(name: 'manufacturer') String? manufacturer,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$AccountDeviceSessionApiDtoCopyWithImpl<$Res>
    implements $AccountDeviceSessionApiDtoCopyWith<$Res> {
  _$AccountDeviceSessionApiDtoCopyWithImpl(this._self, this._then);

  final AccountDeviceSessionApiDto _self;
  final $Res Function(AccountDeviceSessionApiDto) _then;

  /// Create a copy of AccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountDeviceSessionId = null,
    Object? accountId = null,
    Object? pushNotificationToken = freezed,
    Object? name = freezed,
    Object? os = freezed,
    Object? osVersion = freezed,
    Object? deviceId = null,
    Object? model = freezed,
    Object? manufacturer = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      accountDeviceSessionId: null == accountDeviceSessionId
          ? _self.accountDeviceSessionId
          : accountDeviceSessionId // ignore: cast_nullable_to_non_nullable
              as int,
      accountId: null == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int,
      pushNotificationToken: freezed == pushNotificationToken
          ? _self.pushNotificationToken
          : pushNotificationToken // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      os: freezed == os
          ? _self.os
          : os // ignore: cast_nullable_to_non_nullable
              as String?,
      osVersion: freezed == osVersion
          ? _self.osVersion
          : osVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      deviceId: null == deviceId
          ? _self.deviceId
          : deviceId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      manufacturer: freezed == manufacturer
          ? _self.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AccountDeviceSessionApiDto].
extension AccountDeviceSessionApiDtoPatterns on AccountDeviceSessionApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AccountDeviceSessionApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AccountDeviceSessionApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AccountDeviceSessionApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountDeviceSessionId') int accountDeviceSessionId,
            @JsonKey(name: 'accountId') int accountId,
            @JsonKey(name: 'pushNotificationToken')
            String? pushNotificationToken,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'os') String? os,
            @JsonKey(name: 'osVersion') String? osVersion,
            @JsonKey(name: 'deviceId') String deviceId,
            @JsonKey(name: 'model') String? model,
            @JsonKey(name: 'manufacturer') String? manufacturer,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiDto() when $default != null:
        return $default(
            _that.accountDeviceSessionId,
            _that.accountId,
            _that.pushNotificationToken,
            _that.name,
            _that.os,
            _that.osVersion,
            _that.deviceId,
            _that.model,
            _that.manufacturer,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountDeviceSessionId') int accountDeviceSessionId,
            @JsonKey(name: 'accountId') int accountId,
            @JsonKey(name: 'pushNotificationToken')
            String? pushNotificationToken,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'os') String? os,
            @JsonKey(name: 'osVersion') String? osVersion,
            @JsonKey(name: 'deviceId') String deviceId,
            @JsonKey(name: 'model') String? model,
            @JsonKey(name: 'manufacturer') String? manufacturer,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiDto():
        return $default(
            _that.accountDeviceSessionId,
            _that.accountId,
            _that.pushNotificationToken,
            _that.name,
            _that.os,
            _that.osVersion,
            _that.deviceId,
            _that.model,
            _that.manufacturer,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'accountDeviceSessionId') int accountDeviceSessionId,
            @JsonKey(name: 'accountId') int accountId,
            @JsonKey(name: 'pushNotificationToken')
            String? pushNotificationToken,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'os') String? os,
            @JsonKey(name: 'osVersion') String? osVersion,
            @JsonKey(name: 'deviceId') String deviceId,
            @JsonKey(name: 'model') String? model,
            @JsonKey(name: 'manufacturer') String? manufacturer,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiDto() when $default != null:
        return $default(
            _that.accountDeviceSessionId,
            _that.accountId,
            _that.pushNotificationToken,
            _that.name,
            _that.os,
            _that.osVersion,
            _that.deviceId,
            _that.model,
            _that.manufacturer,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AccountDeviceSessionApiDto implements AccountDeviceSessionApiDto {
  _AccountDeviceSessionApiDto(
      {@JsonKey(name: 'accountDeviceSessionId')
      required this.accountDeviceSessionId,
      @JsonKey(name: 'accountId') required this.accountId,
      @JsonKey(name: 'pushNotificationToken') this.pushNotificationToken,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'os') this.os,
      @JsonKey(name: 'osVersion') this.osVersion,
      @JsonKey(name: 'deviceId') required this.deviceId,
      @JsonKey(name: 'model') this.model,
      @JsonKey(name: 'manufacturer') this.manufacturer,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _AccountDeviceSessionApiDto.fromJson(Map<String, dynamic> json) =>
      _$AccountDeviceSessionApiDtoFromJson(json);

  @override
  @JsonKey(name: 'accountDeviceSessionId')
  final int accountDeviceSessionId;
  @override
  @JsonKey(name: 'accountId')
  final int accountId;
  @override
  @JsonKey(name: 'pushNotificationToken')
  final String? pushNotificationToken;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'os')
  final String? os;
  @override
  @JsonKey(name: 'osVersion')
  final String? osVersion;
  @override
  @JsonKey(name: 'deviceId')
  final String deviceId;
  @override
  @JsonKey(name: 'model')
  final String? model;
  @override
  @JsonKey(name: 'manufacturer')
  final String? manufacturer;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of AccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AccountDeviceSessionApiDtoCopyWith<_AccountDeviceSessionApiDto>
      get copyWith => __$AccountDeviceSessionApiDtoCopyWithImpl<
          _AccountDeviceSessionApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AccountDeviceSessionApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AccountDeviceSessionApiDto &&
            (identical(other.accountDeviceSessionId, accountDeviceSessionId) ||
                other.accountDeviceSessionId == accountDeviceSessionId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.pushNotificationToken, pushNotificationToken) ||
                other.pushNotificationToken == pushNotificationToken) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.os, os) || other.os == os) &&
            (identical(other.osVersion, osVersion) ||
                other.osVersion == osVersion) &&
            (identical(other.deviceId, deviceId) ||
                other.deviceId == deviceId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.manufacturer, manufacturer) ||
                other.manufacturer == manufacturer) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountDeviceSessionId,
      accountId,
      pushNotificationToken,
      name,
      os,
      osVersion,
      deviceId,
      model,
      manufacturer,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AccountDeviceSessionApiDto(accountDeviceSessionId: $accountDeviceSessionId, accountId: $accountId, pushNotificationToken: $pushNotificationToken, name: $name, os: $os, osVersion: $osVersion, deviceId: $deviceId, model: $model, manufacturer: $manufacturer, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$AccountDeviceSessionApiDtoCopyWith<$Res>
    implements $AccountDeviceSessionApiDtoCopyWith<$Res> {
  factory _$AccountDeviceSessionApiDtoCopyWith(
          _AccountDeviceSessionApiDto value,
          $Res Function(_AccountDeviceSessionApiDto) _then) =
      __$AccountDeviceSessionApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'accountDeviceSessionId') int accountDeviceSessionId,
      @JsonKey(name: 'accountId') int accountId,
      @JsonKey(name: 'pushNotificationToken') String? pushNotificationToken,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'os') String? os,
      @JsonKey(name: 'osVersion') String? osVersion,
      @JsonKey(name: 'deviceId') String deviceId,
      @JsonKey(name: 'model') String? model,
      @JsonKey(name: 'manufacturer') String? manufacturer,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$AccountDeviceSessionApiDtoCopyWithImpl<$Res>
    implements _$AccountDeviceSessionApiDtoCopyWith<$Res> {
  __$AccountDeviceSessionApiDtoCopyWithImpl(this._self, this._then);

  final _AccountDeviceSessionApiDto _self;
  final $Res Function(_AccountDeviceSessionApiDto) _then;

  /// Create a copy of AccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? accountDeviceSessionId = null,
    Object? accountId = null,
    Object? pushNotificationToken = freezed,
    Object? name = freezed,
    Object? os = freezed,
    Object? osVersion = freezed,
    Object? deviceId = null,
    Object? model = freezed,
    Object? manufacturer = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_AccountDeviceSessionApiDto(
      accountDeviceSessionId: null == accountDeviceSessionId
          ? _self.accountDeviceSessionId
          : accountDeviceSessionId // ignore: cast_nullable_to_non_nullable
              as int,
      accountId: null == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int,
      pushNotificationToken: freezed == pushNotificationToken
          ? _self.pushNotificationToken
          : pushNotificationToken // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      os: freezed == os
          ? _self.os
          : os // ignore: cast_nullable_to_non_nullable
              as String?,
      osVersion: freezed == osVersion
          ? _self.osVersion
          : osVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      deviceId: null == deviceId
          ? _self.deviceId
          : deviceId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      manufacturer: freezed == manufacturer
          ? _self.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$AccountDeviceSessionApiPutDto {
  @JsonKey(name: 'pushNotificationToken')
  String? get pushNotificationToken;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'os')
  String? get os;
  @JsonKey(name: 'osVersion')
  String? get osVersion;
  @JsonKey(name: 'model')
  String? get model;
  @JsonKey(name: 'manufacturer')
  String? get manufacturer;

  /// Create a copy of AccountDeviceSessionApiPutDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AccountDeviceSessionApiPutDtoCopyWith<AccountDeviceSessionApiPutDto>
      get copyWith => _$AccountDeviceSessionApiPutDtoCopyWithImpl<
              AccountDeviceSessionApiPutDto>(
          this as AccountDeviceSessionApiPutDto, _$identity);

  /// Serializes this AccountDeviceSessionApiPutDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AccountDeviceSessionApiPutDto &&
            (identical(other.pushNotificationToken, pushNotificationToken) ||
                other.pushNotificationToken == pushNotificationToken) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.os, os) || other.os == os) &&
            (identical(other.osVersion, osVersion) ||
                other.osVersion == osVersion) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.manufacturer, manufacturer) ||
                other.manufacturer == manufacturer));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, pushNotificationToken, name, os,
      osVersion, model, manufacturer);

  @override
  String toString() {
    return 'AccountDeviceSessionApiPutDto(pushNotificationToken: $pushNotificationToken, name: $name, os: $os, osVersion: $osVersion, model: $model, manufacturer: $manufacturer)';
  }
}

/// @nodoc
abstract mixin class $AccountDeviceSessionApiPutDtoCopyWith<$Res> {
  factory $AccountDeviceSessionApiPutDtoCopyWith(
          AccountDeviceSessionApiPutDto value,
          $Res Function(AccountDeviceSessionApiPutDto) _then) =
      _$AccountDeviceSessionApiPutDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'pushNotificationToken') String? pushNotificationToken,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'os') String? os,
      @JsonKey(name: 'osVersion') String? osVersion,
      @JsonKey(name: 'model') String? model,
      @JsonKey(name: 'manufacturer') String? manufacturer});
}

/// @nodoc
class _$AccountDeviceSessionApiPutDtoCopyWithImpl<$Res>
    implements $AccountDeviceSessionApiPutDtoCopyWith<$Res> {
  _$AccountDeviceSessionApiPutDtoCopyWithImpl(this._self, this._then);

  final AccountDeviceSessionApiPutDto _self;
  final $Res Function(AccountDeviceSessionApiPutDto) _then;

  /// Create a copy of AccountDeviceSessionApiPutDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pushNotificationToken = freezed,
    Object? name = freezed,
    Object? os = freezed,
    Object? osVersion = freezed,
    Object? model = freezed,
    Object? manufacturer = freezed,
  }) {
    return _then(_self.copyWith(
      pushNotificationToken: freezed == pushNotificationToken
          ? _self.pushNotificationToken
          : pushNotificationToken // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      os: freezed == os
          ? _self.os
          : os // ignore: cast_nullable_to_non_nullable
              as String?,
      osVersion: freezed == osVersion
          ? _self.osVersion
          : osVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      manufacturer: freezed == manufacturer
          ? _self.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AccountDeviceSessionApiPutDto].
extension AccountDeviceSessionApiPutDtoPatterns
    on AccountDeviceSessionApiPutDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AccountDeviceSessionApiPutDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiPutDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AccountDeviceSessionApiPutDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiPutDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AccountDeviceSessionApiPutDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiPutDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'pushNotificationToken')
            String? pushNotificationToken,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'os') String? os,
            @JsonKey(name: 'osVersion') String? osVersion,
            @JsonKey(name: 'model') String? model,
            @JsonKey(name: 'manufacturer') String? manufacturer)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiPutDto() when $default != null:
        return $default(_that.pushNotificationToken, _that.name, _that.os,
            _that.osVersion, _that.model, _that.manufacturer);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'pushNotificationToken')
            String? pushNotificationToken,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'os') String? os,
            @JsonKey(name: 'osVersion') String? osVersion,
            @JsonKey(name: 'model') String? model,
            @JsonKey(name: 'manufacturer') String? manufacturer)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiPutDto():
        return $default(_that.pushNotificationToken, _that.name, _that.os,
            _that.osVersion, _that.model, _that.manufacturer);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'pushNotificationToken')
            String? pushNotificationToken,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'os') String? os,
            @JsonKey(name: 'osVersion') String? osVersion,
            @JsonKey(name: 'model') String? model,
            @JsonKey(name: 'manufacturer') String? manufacturer)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountDeviceSessionApiPutDto() when $default != null:
        return $default(_that.pushNotificationToken, _that.name, _that.os,
            _that.osVersion, _that.model, _that.manufacturer);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AccountDeviceSessionApiPutDto implements AccountDeviceSessionApiPutDto {
  _AccountDeviceSessionApiPutDto(
      {@JsonKey(name: 'pushNotificationToken') this.pushNotificationToken,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'os') this.os,
      @JsonKey(name: 'osVersion') this.osVersion,
      @JsonKey(name: 'model') this.model,
      @JsonKey(name: 'manufacturer') this.manufacturer});
  factory _AccountDeviceSessionApiPutDto.fromJson(Map<String, dynamic> json) =>
      _$AccountDeviceSessionApiPutDtoFromJson(json);

  @override
  @JsonKey(name: 'pushNotificationToken')
  final String? pushNotificationToken;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'os')
  final String? os;
  @override
  @JsonKey(name: 'osVersion')
  final String? osVersion;
  @override
  @JsonKey(name: 'model')
  final String? model;
  @override
  @JsonKey(name: 'manufacturer')
  final String? manufacturer;

  /// Create a copy of AccountDeviceSessionApiPutDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AccountDeviceSessionApiPutDtoCopyWith<_AccountDeviceSessionApiPutDto>
      get copyWith => __$AccountDeviceSessionApiPutDtoCopyWithImpl<
          _AccountDeviceSessionApiPutDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AccountDeviceSessionApiPutDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AccountDeviceSessionApiPutDto &&
            (identical(other.pushNotificationToken, pushNotificationToken) ||
                other.pushNotificationToken == pushNotificationToken) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.os, os) || other.os == os) &&
            (identical(other.osVersion, osVersion) ||
                other.osVersion == osVersion) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.manufacturer, manufacturer) ||
                other.manufacturer == manufacturer));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, pushNotificationToken, name, os,
      osVersion, model, manufacturer);

  @override
  String toString() {
    return 'AccountDeviceSessionApiPutDto(pushNotificationToken: $pushNotificationToken, name: $name, os: $os, osVersion: $osVersion, model: $model, manufacturer: $manufacturer)';
  }
}

/// @nodoc
abstract mixin class _$AccountDeviceSessionApiPutDtoCopyWith<$Res>
    implements $AccountDeviceSessionApiPutDtoCopyWith<$Res> {
  factory _$AccountDeviceSessionApiPutDtoCopyWith(
          _AccountDeviceSessionApiPutDto value,
          $Res Function(_AccountDeviceSessionApiPutDto) _then) =
      __$AccountDeviceSessionApiPutDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'pushNotificationToken') String? pushNotificationToken,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'os') String? os,
      @JsonKey(name: 'osVersion') String? osVersion,
      @JsonKey(name: 'model') String? model,
      @JsonKey(name: 'manufacturer') String? manufacturer});
}

/// @nodoc
class __$AccountDeviceSessionApiPutDtoCopyWithImpl<$Res>
    implements _$AccountDeviceSessionApiPutDtoCopyWith<$Res> {
  __$AccountDeviceSessionApiPutDtoCopyWithImpl(this._self, this._then);

  final _AccountDeviceSessionApiPutDto _self;
  final $Res Function(_AccountDeviceSessionApiPutDto) _then;

  /// Create a copy of AccountDeviceSessionApiPutDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? pushNotificationToken = freezed,
    Object? name = freezed,
    Object? os = freezed,
    Object? osVersion = freezed,
    Object? model = freezed,
    Object? manufacturer = freezed,
  }) {
    return _then(_AccountDeviceSessionApiPutDto(
      pushNotificationToken: freezed == pushNotificationToken
          ? _self.pushNotificationToken
          : pushNotificationToken // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      os: freezed == os
          ? _self.os
          : os // ignore: cast_nullable_to_non_nullable
              as String?,
      osVersion: freezed == osVersion
          ? _self.osVersion
          : osVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      manufacturer: freezed == manufacturer
          ? _self.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$AccountImageApiDto {
  @JsonKey(name: 'imageUrlResult')
  ImageUrlResultDto? get imageUrlResult;

  /// Create a copy of AccountImageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AccountImageApiDtoCopyWith<AccountImageApiDto> get copyWith =>
      _$AccountImageApiDtoCopyWithImpl<AccountImageApiDto>(
          this as AccountImageApiDto, _$identity);

  /// Serializes this AccountImageApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AccountImageApiDto &&
            (identical(other.imageUrlResult, imageUrlResult) ||
                other.imageUrlResult == imageUrlResult));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, imageUrlResult);

  @override
  String toString() {
    return 'AccountImageApiDto(imageUrlResult: $imageUrlResult)';
  }
}

/// @nodoc
abstract mixin class $AccountImageApiDtoCopyWith<$Res> {
  factory $AccountImageApiDtoCopyWith(
          AccountImageApiDto value, $Res Function(AccountImageApiDto) _then) =
      _$AccountImageApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'imageUrlResult') ImageUrlResultDto? imageUrlResult});

  $ImageUrlResultDtoCopyWith<$Res>? get imageUrlResult;
}

/// @nodoc
class _$AccountImageApiDtoCopyWithImpl<$Res>
    implements $AccountImageApiDtoCopyWith<$Res> {
  _$AccountImageApiDtoCopyWithImpl(this._self, this._then);

  final AccountImageApiDto _self;
  final $Res Function(AccountImageApiDto) _then;

  /// Create a copy of AccountImageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? imageUrlResult = freezed,
  }) {
    return _then(_self.copyWith(
      imageUrlResult: freezed == imageUrlResult
          ? _self.imageUrlResult
          : imageUrlResult // ignore: cast_nullable_to_non_nullable
              as ImageUrlResultDto?,
    ));
  }

  /// Create a copy of AccountImageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ImageUrlResultDtoCopyWith<$Res>? get imageUrlResult {
    if (_self.imageUrlResult == null) {
      return null;
    }

    return $ImageUrlResultDtoCopyWith<$Res>(_self.imageUrlResult!, (value) {
      return _then(_self.copyWith(imageUrlResult: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AccountImageApiDto].
extension AccountImageApiDtoPatterns on AccountImageApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AccountImageApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountImageApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AccountImageApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountImageApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AccountImageApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountImageApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'imageUrlResult') ImageUrlResultDto? imageUrlResult)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AccountImageApiDto() when $default != null:
        return $default(_that.imageUrlResult);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'imageUrlResult') ImageUrlResultDto? imageUrlResult)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountImageApiDto():
        return $default(_that.imageUrlResult);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'imageUrlResult') ImageUrlResultDto? imageUrlResult)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AccountImageApiDto() when $default != null:
        return $default(_that.imageUrlResult);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AccountImageApiDto implements AccountImageApiDto {
  _AccountImageApiDto({@JsonKey(name: 'imageUrlResult') this.imageUrlResult});
  factory _AccountImageApiDto.fromJson(Map<String, dynamic> json) =>
      _$AccountImageApiDtoFromJson(json);

  @override
  @JsonKey(name: 'imageUrlResult')
  final ImageUrlResultDto? imageUrlResult;

  /// Create a copy of AccountImageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AccountImageApiDtoCopyWith<_AccountImageApiDto> get copyWith =>
      __$AccountImageApiDtoCopyWithImpl<_AccountImageApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AccountImageApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AccountImageApiDto &&
            (identical(other.imageUrlResult, imageUrlResult) ||
                other.imageUrlResult == imageUrlResult));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, imageUrlResult);

  @override
  String toString() {
    return 'AccountImageApiDto(imageUrlResult: $imageUrlResult)';
  }
}

/// @nodoc
abstract mixin class _$AccountImageApiDtoCopyWith<$Res>
    implements $AccountImageApiDtoCopyWith<$Res> {
  factory _$AccountImageApiDtoCopyWith(
          _AccountImageApiDto value, $Res Function(_AccountImageApiDto) _then) =
      __$AccountImageApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'imageUrlResult') ImageUrlResultDto? imageUrlResult});

  @override
  $ImageUrlResultDtoCopyWith<$Res>? get imageUrlResult;
}

/// @nodoc
class __$AccountImageApiDtoCopyWithImpl<$Res>
    implements _$AccountImageApiDtoCopyWith<$Res> {
  __$AccountImageApiDtoCopyWithImpl(this._self, this._then);

  final _AccountImageApiDto _self;
  final $Res Function(_AccountImageApiDto) _then;

  /// Create a copy of AccountImageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? imageUrlResult = freezed,
  }) {
    return _then(_AccountImageApiDto(
      imageUrlResult: freezed == imageUrlResult
          ? _self.imageUrlResult
          : imageUrlResult // ignore: cast_nullable_to_non_nullable
              as ImageUrlResultDto?,
    ));
  }

  /// Create a copy of AccountImageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ImageUrlResultDtoCopyWith<$Res>? get imageUrlResult {
    if (_self.imageUrlResult == null) {
      return null;
    }

    return $ImageUrlResultDtoCopyWith<$Res>(_self.imageUrlResult!, (value) {
      return _then(_self.copyWith(imageUrlResult: value));
    });
  }
}

/// @nodoc
mixin _$AddressApiDto {
  @JsonKey(name: 'addressId')
  int? get addressId;
  @JsonKey(name: 'address1')
  String? get address1;
  @JsonKey(name: 'address2')
  String? get address2;
  @JsonKey(name: 'city')
  String? get city;
  @JsonKey(name: 'state')
  String? get state;
  @JsonKey(name: 'zipCode')
  String? get zipCode;
  @JsonKey(name: 'countryId')
  int? get countryId;
  @JsonKey(name: 'country')
  CountryApiDto? get country;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of AddressApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AddressApiDtoCopyWith<AddressApiDto> get copyWith =>
      _$AddressApiDtoCopyWithImpl<AddressApiDto>(
          this as AddressApiDto, _$identity);

  /// Serializes this AddressApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AddressApiDto &&
            (identical(other.addressId, addressId) ||
                other.addressId == addressId) &&
            (identical(other.address1, address1) ||
                other.address1 == address1) &&
            (identical(other.address2, address2) ||
                other.address2 == address2) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.zipCode, zipCode) || other.zipCode == zipCode) &&
            (identical(other.countryId, countryId) ||
                other.countryId == countryId) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      addressId,
      address1,
      address2,
      city,
      state,
      zipCode,
      countryId,
      country,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AddressApiDto(addressId: $addressId, address1: $address1, address2: $address2, city: $city, state: $state, zipCode: $zipCode, countryId: $countryId, country: $country, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $AddressApiDtoCopyWith<$Res> {
  factory $AddressApiDtoCopyWith(
          AddressApiDto value, $Res Function(AddressApiDto) _then) =
      _$AddressApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'addressId') int? addressId,
      @JsonKey(name: 'address1') String? address1,
      @JsonKey(name: 'address2') String? address2,
      @JsonKey(name: 'city') String? city,
      @JsonKey(name: 'state') String? state,
      @JsonKey(name: 'zipCode') String? zipCode,
      @JsonKey(name: 'countryId') int? countryId,
      @JsonKey(name: 'country') CountryApiDto? country,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $CountryApiDtoCopyWith<$Res>? get country;
}

/// @nodoc
class _$AddressApiDtoCopyWithImpl<$Res>
    implements $AddressApiDtoCopyWith<$Res> {
  _$AddressApiDtoCopyWithImpl(this._self, this._then);

  final AddressApiDto _self;
  final $Res Function(AddressApiDto) _then;

  /// Create a copy of AddressApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addressId = freezed,
    Object? address1 = freezed,
    Object? address2 = freezed,
    Object? city = freezed,
    Object? state = freezed,
    Object? zipCode = freezed,
    Object? countryId = freezed,
    Object? country = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      addressId: freezed == addressId
          ? _self.addressId
          : addressId // ignore: cast_nullable_to_non_nullable
              as int?,
      address1: freezed == address1
          ? _self.address1
          : address1 // ignore: cast_nullable_to_non_nullable
              as String?,
      address2: freezed == address2
          ? _self.address2
          : address2 // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      state: freezed == state
          ? _self.state
          : state // ignore: cast_nullable_to_non_nullable
              as String?,
      zipCode: freezed == zipCode
          ? _self.zipCode
          : zipCode // ignore: cast_nullable_to_non_nullable
              as String?,
      countryId: freezed == countryId
          ? _self.countryId
          : countryId // ignore: cast_nullable_to_non_nullable
              as int?,
      country: freezed == country
          ? _self.country
          : country // ignore: cast_nullable_to_non_nullable
              as CountryApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of AddressApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CountryApiDtoCopyWith<$Res>? get country {
    if (_self.country == null) {
      return null;
    }

    return $CountryApiDtoCopyWith<$Res>(_self.country!, (value) {
      return _then(_self.copyWith(country: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AddressApiDto].
extension AddressApiDtoPatterns on AddressApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AddressApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AddressApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AddressApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AddressApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'addressId') int? addressId,
            @JsonKey(name: 'address1') String? address1,
            @JsonKey(name: 'address2') String? address2,
            @JsonKey(name: 'city') String? city,
            @JsonKey(name: 'state') String? state,
            @JsonKey(name: 'zipCode') String? zipCode,
            @JsonKey(name: 'countryId') int? countryId,
            @JsonKey(name: 'country') CountryApiDto? country,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AddressApiDto() when $default != null:
        return $default(
            _that.addressId,
            _that.address1,
            _that.address2,
            _that.city,
            _that.state,
            _that.zipCode,
            _that.countryId,
            _that.country,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'addressId') int? addressId,
            @JsonKey(name: 'address1') String? address1,
            @JsonKey(name: 'address2') String? address2,
            @JsonKey(name: 'city') String? city,
            @JsonKey(name: 'state') String? state,
            @JsonKey(name: 'zipCode') String? zipCode,
            @JsonKey(name: 'countryId') int? countryId,
            @JsonKey(name: 'country') CountryApiDto? country,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressApiDto():
        return $default(
            _that.addressId,
            _that.address1,
            _that.address2,
            _that.city,
            _that.state,
            _that.zipCode,
            _that.countryId,
            _that.country,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'addressId') int? addressId,
            @JsonKey(name: 'address1') String? address1,
            @JsonKey(name: 'address2') String? address2,
            @JsonKey(name: 'city') String? city,
            @JsonKey(name: 'state') String? state,
            @JsonKey(name: 'zipCode') String? zipCode,
            @JsonKey(name: 'countryId') int? countryId,
            @JsonKey(name: 'country') CountryApiDto? country,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AddressApiDto() when $default != null:
        return $default(
            _that.addressId,
            _that.address1,
            _that.address2,
            _that.city,
            _that.state,
            _that.zipCode,
            _that.countryId,
            _that.country,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AddressApiDto implements AddressApiDto {
  _AddressApiDto(
      {@JsonKey(name: 'addressId') this.addressId,
      @JsonKey(name: 'address1') this.address1,
      @JsonKey(name: 'address2') this.address2,
      @JsonKey(name: 'city') this.city,
      @JsonKey(name: 'state') this.state,
      @JsonKey(name: 'zipCode') this.zipCode,
      @JsonKey(name: 'countryId') this.countryId,
      @JsonKey(name: 'country') this.country,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _AddressApiDto.fromJson(Map<String, dynamic> json) =>
      _$AddressApiDtoFromJson(json);

  @override
  @JsonKey(name: 'addressId')
  final int? addressId;
  @override
  @JsonKey(name: 'address1')
  final String? address1;
  @override
  @JsonKey(name: 'address2')
  final String? address2;
  @override
  @JsonKey(name: 'city')
  final String? city;
  @override
  @JsonKey(name: 'state')
  final String? state;
  @override
  @JsonKey(name: 'zipCode')
  final String? zipCode;
  @override
  @JsonKey(name: 'countryId')
  final int? countryId;
  @override
  @JsonKey(name: 'country')
  final CountryApiDto? country;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of AddressApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AddressApiDtoCopyWith<_AddressApiDto> get copyWith =>
      __$AddressApiDtoCopyWithImpl<_AddressApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AddressApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddressApiDto &&
            (identical(other.addressId, addressId) ||
                other.addressId == addressId) &&
            (identical(other.address1, address1) ||
                other.address1 == address1) &&
            (identical(other.address2, address2) ||
                other.address2 == address2) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.zipCode, zipCode) || other.zipCode == zipCode) &&
            (identical(other.countryId, countryId) ||
                other.countryId == countryId) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      addressId,
      address1,
      address2,
      city,
      state,
      zipCode,
      countryId,
      country,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AddressApiDto(addressId: $addressId, address1: $address1, address2: $address2, city: $city, state: $state, zipCode: $zipCode, countryId: $countryId, country: $country, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$AddressApiDtoCopyWith<$Res>
    implements $AddressApiDtoCopyWith<$Res> {
  factory _$AddressApiDtoCopyWith(
          _AddressApiDto value, $Res Function(_AddressApiDto) _then) =
      __$AddressApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'addressId') int? addressId,
      @JsonKey(name: 'address1') String? address1,
      @JsonKey(name: 'address2') String? address2,
      @JsonKey(name: 'city') String? city,
      @JsonKey(name: 'state') String? state,
      @JsonKey(name: 'zipCode') String? zipCode,
      @JsonKey(name: 'countryId') int? countryId,
      @JsonKey(name: 'country') CountryApiDto? country,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $CountryApiDtoCopyWith<$Res>? get country;
}

/// @nodoc
class __$AddressApiDtoCopyWithImpl<$Res>
    implements _$AddressApiDtoCopyWith<$Res> {
  __$AddressApiDtoCopyWithImpl(this._self, this._then);

  final _AddressApiDto _self;
  final $Res Function(_AddressApiDto) _then;

  /// Create a copy of AddressApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? addressId = freezed,
    Object? address1 = freezed,
    Object? address2 = freezed,
    Object? city = freezed,
    Object? state = freezed,
    Object? zipCode = freezed,
    Object? countryId = freezed,
    Object? country = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_AddressApiDto(
      addressId: freezed == addressId
          ? _self.addressId
          : addressId // ignore: cast_nullable_to_non_nullable
              as int?,
      address1: freezed == address1
          ? _self.address1
          : address1 // ignore: cast_nullable_to_non_nullable
              as String?,
      address2: freezed == address2
          ? _self.address2
          : address2 // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      state: freezed == state
          ? _self.state
          : state // ignore: cast_nullable_to_non_nullable
              as String?,
      zipCode: freezed == zipCode
          ? _self.zipCode
          : zipCode // ignore: cast_nullable_to_non_nullable
              as String?,
      countryId: freezed == countryId
          ? _self.countryId
          : countryId // ignore: cast_nullable_to_non_nullable
              as int?,
      country: freezed == country
          ? _self.country
          : country // ignore: cast_nullable_to_non_nullable
              as CountryApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of AddressApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CountryApiDtoCopyWith<$Res>? get country {
    if (_self.country == null) {
      return null;
    }

    return $CountryApiDtoCopyWith<$Res>(_self.country!, (value) {
      return _then(_self.copyWith(country: value));
    });
  }
}

/// @nodoc
mixin _$AttendanceRecordDTODto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'classId')
  int? get classId;
  @JsonKey(name: 'date')
  String? get date;
  @JsonKey(name: 'isPresent')
  bool? get isPresent;
  @JsonKey(name: 'status')
  String? get status;
  @JsonKey(name: 'isWeekend')
  bool? get isWeekend;
  @JsonKey(name: 'isClassClosure')
  bool? get isClassClosure;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;
  @JsonKey(name: 'createdBy')
  String? get createdBy;
  @JsonKey(name: 'updatedBy')
  String? get updatedBy;

  /// Create a copy of AttendanceRecordDTODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AttendanceRecordDTODtoCopyWith<AttendanceRecordDTODto> get copyWith =>
      _$AttendanceRecordDTODtoCopyWithImpl<AttendanceRecordDTODto>(
          this as AttendanceRecordDTODto, _$identity);

  /// Serializes this AttendanceRecordDTODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AttendanceRecordDTODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.isPresent, isPresent) ||
                other.isPresent == isPresent) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isWeekend, isWeekend) ||
                other.isWeekend == isWeekend) &&
            (identical(other.isClassClosure, isClassClosure) ||
                other.isClassClosure == isClassClosure) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.updatedBy, updatedBy) ||
                other.updatedBy == updatedBy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      studentId,
      classId,
      date,
      isPresent,
      status,
      isWeekend,
      isClassClosure,
      remarks,
      createdDate,
      updatedDate,
      createdBy,
      updatedBy);

  @override
  String toString() {
    return 'AttendanceRecordDTODto(id: $id, studentId: $studentId, classId: $classId, date: $date, isPresent: $isPresent, status: $status, isWeekend: $isWeekend, isClassClosure: $isClassClosure, remarks: $remarks, createdDate: $createdDate, updatedDate: $updatedDate, createdBy: $createdBy, updatedBy: $updatedBy)';
  }
}

/// @nodoc
abstract mixin class $AttendanceRecordDTODtoCopyWith<$Res> {
  factory $AttendanceRecordDTODtoCopyWith(AttendanceRecordDTODto value,
          $Res Function(AttendanceRecordDTODto) _then) =
      _$AttendanceRecordDTODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'date') String? date,
      @JsonKey(name: 'isPresent') bool? isPresent,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'isWeekend') bool? isWeekend,
      @JsonKey(name: 'isClassClosure') bool? isClassClosure,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'updatedBy') String? updatedBy});
}

/// @nodoc
class _$AttendanceRecordDTODtoCopyWithImpl<$Res>
    implements $AttendanceRecordDTODtoCopyWith<$Res> {
  _$AttendanceRecordDTODtoCopyWithImpl(this._self, this._then);

  final AttendanceRecordDTODto _self;
  final $Res Function(AttendanceRecordDTODto) _then;

  /// Create a copy of AttendanceRecordDTODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? classId = freezed,
    Object? date = freezed,
    Object? isPresent = freezed,
    Object? status = freezed,
    Object? isWeekend = freezed,
    Object? isClassClosure = freezed,
    Object? remarks = freezed,
    Object? createdDate = freezed,
    Object? updatedDate = freezed,
    Object? createdBy = freezed,
    Object? updatedBy = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      date: freezed == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
      isPresent: freezed == isPresent
          ? _self.isPresent
          : isPresent // ignore: cast_nullable_to_non_nullable
              as bool?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      isWeekend: freezed == isWeekend
          ? _self.isWeekend
          : isWeekend // ignore: cast_nullable_to_non_nullable
              as bool?,
      isClassClosure: freezed == isClassClosure
          ? _self.isClassClosure
          : isClassClosure // ignore: cast_nullable_to_non_nullable
              as bool?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedBy: freezed == updatedBy
          ? _self.updatedBy
          : updatedBy // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AttendanceRecordDTODto].
extension AttendanceRecordDTODtoPatterns on AttendanceRecordDTODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AttendanceRecordDTODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendanceRecordDTODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AttendanceRecordDTODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceRecordDTODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AttendanceRecordDTODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceRecordDTODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'date') String? date,
            @JsonKey(name: 'isPresent') bool? isPresent,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'isWeekend') bool? isWeekend,
            @JsonKey(name: 'isClassClosure') bool? isClassClosure,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'updatedBy') String? updatedBy)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AttendanceRecordDTODto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.classId,
            _that.date,
            _that.isPresent,
            _that.status,
            _that.isWeekend,
            _that.isClassClosure,
            _that.remarks,
            _that.createdDate,
            _that.updatedDate,
            _that.createdBy,
            _that.updatedBy);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'date') String? date,
            @JsonKey(name: 'isPresent') bool? isPresent,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'isWeekend') bool? isWeekend,
            @JsonKey(name: 'isClassClosure') bool? isClassClosure,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'updatedBy') String? updatedBy)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceRecordDTODto():
        return $default(
            _that.id,
            _that.studentId,
            _that.classId,
            _that.date,
            _that.isPresent,
            _that.status,
            _that.isWeekend,
            _that.isClassClosure,
            _that.remarks,
            _that.createdDate,
            _that.updatedDate,
            _that.createdBy,
            _that.updatedBy);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'date') String? date,
            @JsonKey(name: 'isPresent') bool? isPresent,
            @JsonKey(name: 'status') String? status,
            @JsonKey(name: 'isWeekend') bool? isWeekend,
            @JsonKey(name: 'isClassClosure') bool? isClassClosure,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate,
            @JsonKey(name: 'createdBy') String? createdBy,
            @JsonKey(name: 'updatedBy') String? updatedBy)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AttendanceRecordDTODto() when $default != null:
        return $default(
            _that.id,
            _that.studentId,
            _that.classId,
            _that.date,
            _that.isPresent,
            _that.status,
            _that.isWeekend,
            _that.isClassClosure,
            _that.remarks,
            _that.createdDate,
            _that.updatedDate,
            _that.createdBy,
            _that.updatedBy);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AttendanceRecordDTODto implements AttendanceRecordDTODto {
  _AttendanceRecordDTODto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'date') this.date,
      @JsonKey(name: 'isPresent') this.isPresent,
      @JsonKey(name: 'status') this.status,
      @JsonKey(name: 'isWeekend') this.isWeekend,
      @JsonKey(name: 'isClassClosure') this.isClassClosure,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'updatedDate') this.updatedDate,
      @JsonKey(name: 'createdBy') this.createdBy,
      @JsonKey(name: 'updatedBy') this.updatedBy});
  factory _AttendanceRecordDTODto.fromJson(Map<String, dynamic> json) =>
      _$AttendanceRecordDTODtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'classId')
  final int? classId;
  @override
  @JsonKey(name: 'date')
  final String? date;
  @override
  @JsonKey(name: 'isPresent')
  final bool? isPresent;
  @override
  @JsonKey(name: 'status')
  final String? status;
  @override
  @JsonKey(name: 'isWeekend')
  final bool? isWeekend;
  @override
  @JsonKey(name: 'isClassClosure')
  final bool? isClassClosure;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;
  @override
  @JsonKey(name: 'createdBy')
  final String? createdBy;
  @override
  @JsonKey(name: 'updatedBy')
  final String? updatedBy;

  /// Create a copy of AttendanceRecordDTODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AttendanceRecordDTODtoCopyWith<_AttendanceRecordDTODto> get copyWith =>
      __$AttendanceRecordDTODtoCopyWithImpl<_AttendanceRecordDTODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AttendanceRecordDTODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AttendanceRecordDTODto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.isPresent, isPresent) ||
                other.isPresent == isPresent) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isWeekend, isWeekend) ||
                other.isWeekend == isWeekend) &&
            (identical(other.isClassClosure, isClassClosure) ||
                other.isClassClosure == isClassClosure) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.updatedBy, updatedBy) ||
                other.updatedBy == updatedBy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      studentId,
      classId,
      date,
      isPresent,
      status,
      isWeekend,
      isClassClosure,
      remarks,
      createdDate,
      updatedDate,
      createdBy,
      updatedBy);

  @override
  String toString() {
    return 'AttendanceRecordDTODto(id: $id, studentId: $studentId, classId: $classId, date: $date, isPresent: $isPresent, status: $status, isWeekend: $isWeekend, isClassClosure: $isClassClosure, remarks: $remarks, createdDate: $createdDate, updatedDate: $updatedDate, createdBy: $createdBy, updatedBy: $updatedBy)';
  }
}

/// @nodoc
abstract mixin class _$AttendanceRecordDTODtoCopyWith<$Res>
    implements $AttendanceRecordDTODtoCopyWith<$Res> {
  factory _$AttendanceRecordDTODtoCopyWith(_AttendanceRecordDTODto value,
          $Res Function(_AttendanceRecordDTODto) _then) =
      __$AttendanceRecordDTODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'date') String? date,
      @JsonKey(name: 'isPresent') bool? isPresent,
      @JsonKey(name: 'status') String? status,
      @JsonKey(name: 'isWeekend') bool? isWeekend,
      @JsonKey(name: 'isClassClosure') bool? isClassClosure,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate,
      @JsonKey(name: 'createdBy') String? createdBy,
      @JsonKey(name: 'updatedBy') String? updatedBy});
}

/// @nodoc
class __$AttendanceRecordDTODtoCopyWithImpl<$Res>
    implements _$AttendanceRecordDTODtoCopyWith<$Res> {
  __$AttendanceRecordDTODtoCopyWithImpl(this._self, this._then);

  final _AttendanceRecordDTODto _self;
  final $Res Function(_AttendanceRecordDTODto) _then;

  /// Create a copy of AttendanceRecordDTODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? studentId = freezed,
    Object? classId = freezed,
    Object? date = freezed,
    Object? isPresent = freezed,
    Object? status = freezed,
    Object? isWeekend = freezed,
    Object? isClassClosure = freezed,
    Object? remarks = freezed,
    Object? createdDate = freezed,
    Object? updatedDate = freezed,
    Object? createdBy = freezed,
    Object? updatedBy = freezed,
  }) {
    return _then(_AttendanceRecordDTODto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      date: freezed == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
      isPresent: freezed == isPresent
          ? _self.isPresent
          : isPresent // ignore: cast_nullable_to_non_nullable
              as bool?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      isWeekend: freezed == isWeekend
          ? _self.isWeekend
          : isWeekend // ignore: cast_nullable_to_non_nullable
              as bool?,
      isClassClosure: freezed == isClassClosure
          ? _self.isClassClosure
          : isClassClosure // ignore: cast_nullable_to_non_nullable
              as bool?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdBy: freezed == createdBy
          ? _self.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedBy: freezed == updatedBy
          ? _self.updatedBy
          : updatedBy // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$AuthorisedPersonDeactivationReasonApiDto {
  @JsonKey(name: 'authorisedPersonDeactivationReasonId')
  int? get authorisedPersonDeactivationReasonId;
  @JsonKey(name: 'authorisedPersonId')
  int? get authorisedPersonId;
  @JsonKey(name: 'activated')
  bool? get activated;
  @JsonKey(name: 'reason')
  String? get reason;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of AuthorisedPersonDeactivationReasonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AuthorisedPersonDeactivationReasonApiDtoCopyWith<
          AuthorisedPersonDeactivationReasonApiDto>
      get copyWith => _$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl<
              AuthorisedPersonDeactivationReasonApiDto>(
          this as AuthorisedPersonDeactivationReasonApiDto, _$identity);

  /// Serializes this AuthorisedPersonDeactivationReasonApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AuthorisedPersonDeactivationReasonApiDto &&
            (identical(other.authorisedPersonDeactivationReasonId,
                    authorisedPersonDeactivationReasonId) ||
                other.authorisedPersonDeactivationReasonId ==
                    authorisedPersonDeactivationReasonId) &&
            (identical(other.authorisedPersonId, authorisedPersonId) ||
                other.authorisedPersonId == authorisedPersonId) &&
            (identical(other.activated, activated) ||
                other.activated == activated) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      authorisedPersonDeactivationReasonId,
      authorisedPersonId,
      activated,
      reason,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AuthorisedPersonDeactivationReasonApiDto(authorisedPersonDeactivationReasonId: $authorisedPersonDeactivationReasonId, authorisedPersonId: $authorisedPersonId, activated: $activated, reason: $reason, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $AuthorisedPersonDeactivationReasonApiDtoCopyWith<$Res> {
  factory $AuthorisedPersonDeactivationReasonApiDtoCopyWith(
          AuthorisedPersonDeactivationReasonApiDto value,
          $Res Function(AuthorisedPersonDeactivationReasonApiDto) _then) =
      _$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'authorisedPersonDeactivationReasonId')
      int? authorisedPersonDeactivationReasonId,
      @JsonKey(name: 'authorisedPersonId') int? authorisedPersonId,
      @JsonKey(name: 'activated') bool? activated,
      @JsonKey(name: 'reason') String? reason,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl<$Res>
    implements $AuthorisedPersonDeactivationReasonApiDtoCopyWith<$Res> {
  _$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl(
      this._self, this._then);

  final AuthorisedPersonDeactivationReasonApiDto _self;
  final $Res Function(AuthorisedPersonDeactivationReasonApiDto) _then;

  /// Create a copy of AuthorisedPersonDeactivationReasonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? authorisedPersonDeactivationReasonId = freezed,
    Object? authorisedPersonId = freezed,
    Object? activated = freezed,
    Object? reason = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      authorisedPersonDeactivationReasonId: freezed ==
              authorisedPersonDeactivationReasonId
          ? _self.authorisedPersonDeactivationReasonId
          : authorisedPersonDeactivationReasonId // ignore: cast_nullable_to_non_nullable
              as int?,
      authorisedPersonId: freezed == authorisedPersonId
          ? _self.authorisedPersonId
          : authorisedPersonId // ignore: cast_nullable_to_non_nullable
              as int?,
      activated: freezed == activated
          ? _self.activated
          : activated // ignore: cast_nullable_to_non_nullable
              as bool?,
      reason: freezed == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AuthorisedPersonDeactivationReasonApiDto].
extension AuthorisedPersonDeactivationReasonApiDtoPatterns
    on AuthorisedPersonDeactivationReasonApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AuthorisedPersonDeactivationReasonApiDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonDeactivationReasonApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AuthorisedPersonDeactivationReasonApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonDeactivationReasonApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AuthorisedPersonDeactivationReasonApiDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonDeactivationReasonApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorisedPersonDeactivationReasonId')
            int? authorisedPersonDeactivationReasonId,
            @JsonKey(name: 'authorisedPersonId') int? authorisedPersonId,
            @JsonKey(name: 'activated') bool? activated,
            @JsonKey(name: 'reason') String? reason,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonDeactivationReasonApiDto() when $default != null:
        return $default(
            _that.authorisedPersonDeactivationReasonId,
            _that.authorisedPersonId,
            _that.activated,
            _that.reason,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'authorisedPersonDeactivationReasonId')
            int? authorisedPersonDeactivationReasonId,
            @JsonKey(name: 'authorisedPersonId') int? authorisedPersonId,
            @JsonKey(name: 'activated') bool? activated,
            @JsonKey(name: 'reason') String? reason,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonDeactivationReasonApiDto():
        return $default(
            _that.authorisedPersonDeactivationReasonId,
            _that.authorisedPersonId,
            _that.activated,
            _that.reason,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'authorisedPersonDeactivationReasonId')
            int? authorisedPersonDeactivationReasonId,
            @JsonKey(name: 'authorisedPersonId') int? authorisedPersonId,
            @JsonKey(name: 'activated') bool? activated,
            @JsonKey(name: 'reason') String? reason,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonDeactivationReasonApiDto() when $default != null:
        return $default(
            _that.authorisedPersonDeactivationReasonId,
            _that.authorisedPersonId,
            _that.activated,
            _that.reason,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AuthorisedPersonDeactivationReasonApiDto
    implements AuthorisedPersonDeactivationReasonApiDto {
  _AuthorisedPersonDeactivationReasonApiDto(
      {@JsonKey(name: 'authorisedPersonDeactivationReasonId')
      this.authorisedPersonDeactivationReasonId,
      @JsonKey(name: 'authorisedPersonId') this.authorisedPersonId,
      @JsonKey(name: 'activated') this.activated,
      @JsonKey(name: 'reason') this.reason,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _AuthorisedPersonDeactivationReasonApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$AuthorisedPersonDeactivationReasonApiDtoFromJson(json);

  @override
  @JsonKey(name: 'authorisedPersonDeactivationReasonId')
  final int? authorisedPersonDeactivationReasonId;
  @override
  @JsonKey(name: 'authorisedPersonId')
  final int? authorisedPersonId;
  @override
  @JsonKey(name: 'activated')
  final bool? activated;
  @override
  @JsonKey(name: 'reason')
  final String? reason;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of AuthorisedPersonDeactivationReasonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AuthorisedPersonDeactivationReasonApiDtoCopyWith<
          _AuthorisedPersonDeactivationReasonApiDto>
      get copyWith => __$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl<
          _AuthorisedPersonDeactivationReasonApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AuthorisedPersonDeactivationReasonApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AuthorisedPersonDeactivationReasonApiDto &&
            (identical(other.authorisedPersonDeactivationReasonId,
                    authorisedPersonDeactivationReasonId) ||
                other.authorisedPersonDeactivationReasonId ==
                    authorisedPersonDeactivationReasonId) &&
            (identical(other.authorisedPersonId, authorisedPersonId) ||
                other.authorisedPersonId == authorisedPersonId) &&
            (identical(other.activated, activated) ||
                other.activated == activated) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      authorisedPersonDeactivationReasonId,
      authorisedPersonId,
      activated,
      reason,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'AuthorisedPersonDeactivationReasonApiDto(authorisedPersonDeactivationReasonId: $authorisedPersonDeactivationReasonId, authorisedPersonId: $authorisedPersonId, activated: $activated, reason: $reason, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$AuthorisedPersonDeactivationReasonApiDtoCopyWith<$Res>
    implements $AuthorisedPersonDeactivationReasonApiDtoCopyWith<$Res> {
  factory _$AuthorisedPersonDeactivationReasonApiDtoCopyWith(
          _AuthorisedPersonDeactivationReasonApiDto value,
          $Res Function(_AuthorisedPersonDeactivationReasonApiDto) _then) =
      __$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'authorisedPersonDeactivationReasonId')
      int? authorisedPersonDeactivationReasonId,
      @JsonKey(name: 'authorisedPersonId') int? authorisedPersonId,
      @JsonKey(name: 'activated') bool? activated,
      @JsonKey(name: 'reason') String? reason,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl<$Res>
    implements _$AuthorisedPersonDeactivationReasonApiDtoCopyWith<$Res> {
  __$AuthorisedPersonDeactivationReasonApiDtoCopyWithImpl(
      this._self, this._then);

  final _AuthorisedPersonDeactivationReasonApiDto _self;
  final $Res Function(_AuthorisedPersonDeactivationReasonApiDto) _then;

  /// Create a copy of AuthorisedPersonDeactivationReasonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? authorisedPersonDeactivationReasonId = freezed,
    Object? authorisedPersonId = freezed,
    Object? activated = freezed,
    Object? reason = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_AuthorisedPersonDeactivationReasonApiDto(
      authorisedPersonDeactivationReasonId: freezed ==
              authorisedPersonDeactivationReasonId
          ? _self.authorisedPersonDeactivationReasonId
          : authorisedPersonDeactivationReasonId // ignore: cast_nullable_to_non_nullable
              as int?,
      authorisedPersonId: freezed == authorisedPersonId
          ? _self.authorisedPersonId
          : authorisedPersonId // ignore: cast_nullable_to_non_nullable
              as int?,
      activated: freezed == activated
          ? _self.activated
          : activated // ignore: cast_nullable_to_non_nullable
              as bool?,
      reason: freezed == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$AuthorisedPersonReasonApiDtoRequestDto {
  @JsonKey(name: 'reason')
  String get reason;

  /// Create a copy of AuthorisedPersonReasonApiDtoRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AuthorisedPersonReasonApiDtoRequestDtoCopyWith<
          AuthorisedPersonReasonApiDtoRequestDto>
      get copyWith => _$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl<
              AuthorisedPersonReasonApiDtoRequestDto>(
          this as AuthorisedPersonReasonApiDtoRequestDto, _$identity);

  /// Serializes this AuthorisedPersonReasonApiDtoRequestDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AuthorisedPersonReasonApiDtoRequestDto &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @override
  String toString() {
    return 'AuthorisedPersonReasonApiDtoRequestDto(reason: $reason)';
  }
}

/// @nodoc
abstract mixin class $AuthorisedPersonReasonApiDtoRequestDtoCopyWith<$Res> {
  factory $AuthorisedPersonReasonApiDtoRequestDtoCopyWith(
          AuthorisedPersonReasonApiDtoRequestDto value,
          $Res Function(AuthorisedPersonReasonApiDtoRequestDto) _then) =
      _$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'reason') String reason});
}

/// @nodoc
class _$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl<$Res>
    implements $AuthorisedPersonReasonApiDtoRequestDtoCopyWith<$Res> {
  _$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl(this._self, this._then);

  final AuthorisedPersonReasonApiDtoRequestDto _self;
  final $Res Function(AuthorisedPersonReasonApiDtoRequestDto) _then;

  /// Create a copy of AuthorisedPersonReasonApiDtoRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = null,
  }) {
    return _then(_self.copyWith(
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [AuthorisedPersonReasonApiDtoRequestDto].
extension AuthorisedPersonReasonApiDtoRequestDtoPatterns
    on AuthorisedPersonReasonApiDtoRequestDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AuthorisedPersonReasonApiDtoRequestDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonReasonApiDtoRequestDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AuthorisedPersonReasonApiDtoRequestDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonReasonApiDtoRequestDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AuthorisedPersonReasonApiDtoRequestDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonReasonApiDtoRequestDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'reason') String reason)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonReasonApiDtoRequestDto() when $default != null:
        return $default(_that.reason);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'reason') String reason) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonReasonApiDtoRequestDto():
        return $default(_that.reason);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'reason') String reason)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AuthorisedPersonReasonApiDtoRequestDto() when $default != null:
        return $default(_that.reason);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AuthorisedPersonReasonApiDtoRequestDto
    implements AuthorisedPersonReasonApiDtoRequestDto {
  _AuthorisedPersonReasonApiDtoRequestDto(
      {@JsonKey(name: 'reason') required this.reason});
  factory _AuthorisedPersonReasonApiDtoRequestDto.fromJson(
          Map<String, dynamic> json) =>
      _$AuthorisedPersonReasonApiDtoRequestDtoFromJson(json);

  @override
  @JsonKey(name: 'reason')
  final String reason;

  /// Create a copy of AuthorisedPersonReasonApiDtoRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AuthorisedPersonReasonApiDtoRequestDtoCopyWith<
          _AuthorisedPersonReasonApiDtoRequestDto>
      get copyWith => __$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl<
          _AuthorisedPersonReasonApiDtoRequestDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AuthorisedPersonReasonApiDtoRequestDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AuthorisedPersonReasonApiDtoRequestDto &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @override
  String toString() {
    return 'AuthorisedPersonReasonApiDtoRequestDto(reason: $reason)';
  }
}

/// @nodoc
abstract mixin class _$AuthorisedPersonReasonApiDtoRequestDtoCopyWith<$Res>
    implements $AuthorisedPersonReasonApiDtoRequestDtoCopyWith<$Res> {
  factory _$AuthorisedPersonReasonApiDtoRequestDtoCopyWith(
          _AuthorisedPersonReasonApiDtoRequestDto value,
          $Res Function(_AuthorisedPersonReasonApiDtoRequestDto) _then) =
      __$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'reason') String reason});
}

/// @nodoc
class __$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl<$Res>
    implements _$AuthorisedPersonReasonApiDtoRequestDtoCopyWith<$Res> {
  __$AuthorisedPersonReasonApiDtoRequestDtoCopyWithImpl(this._self, this._then);

  final _AuthorisedPersonReasonApiDtoRequestDto _self;
  final $Res Function(_AuthorisedPersonReasonApiDtoRequestDto) _then;

  /// Create a copy of AuthorisedPersonReasonApiDtoRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? reason = null,
  }) {
    return _then(_AuthorisedPersonReasonApiDtoRequestDto(
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$BranchApiDto {
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'code')
  String? get code;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'account')
  AccountApiDto? get account;
  @JsonKey(name: 'companyId')
  int? get companyId;
  @JsonKey(name: 'company')
  CompanyApiDto? get company;
  @JsonKey(name: 'defaultCurrencyId')
  int? get defaultCurrencyId;
  @JsonKey(name: 'govtRegName')
  String? get govtRegName;
  @JsonKey(name: 'govtRegNo')
  String? get govtRegNo;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BranchApiDtoCopyWith<BranchApiDto> get copyWith =>
      _$BranchApiDtoCopyWithImpl<BranchApiDto>(
          this as BranchApiDto, _$identity);

  /// Serializes this BranchApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BranchApiDto &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.companyId, companyId) ||
                other.companyId == companyId) &&
            (identical(other.company, company) || other.company == company) &&
            (identical(other.defaultCurrencyId, defaultCurrencyId) ||
                other.defaultCurrencyId == defaultCurrencyId) &&
            (identical(other.govtRegName, govtRegName) ||
                other.govtRegName == govtRegName) &&
            (identical(other.govtRegNo, govtRegNo) ||
                other.govtRegNo == govtRegNo) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      branchId,
      code,
      name,
      accountId,
      account,
      companyId,
      company,
      defaultCurrencyId,
      govtRegName,
      govtRegNo,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'BranchApiDto(branchId: $branchId, code: $code, name: $name, accountId: $accountId, account: $account, companyId: $companyId, company: $company, defaultCurrencyId: $defaultCurrencyId, govtRegName: $govtRegName, govtRegNo: $govtRegNo, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $BranchApiDtoCopyWith<$Res> {
  factory $BranchApiDtoCopyWith(
          BranchApiDto value, $Res Function(BranchApiDto) _then) =
      _$BranchApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto? account,
      @JsonKey(name: 'companyId') int? companyId,
      @JsonKey(name: 'company') CompanyApiDto? company,
      @JsonKey(name: 'defaultCurrencyId') int? defaultCurrencyId,
      @JsonKey(name: 'govtRegName') String? govtRegName,
      @JsonKey(name: 'govtRegNo') String? govtRegNo,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $AccountApiDtoCopyWith<$Res>? get account;
  $CompanyApiDtoCopyWith<$Res>? get company;
}

/// @nodoc
class _$BranchApiDtoCopyWithImpl<$Res> implements $BranchApiDtoCopyWith<$Res> {
  _$BranchApiDtoCopyWithImpl(this._self, this._then);

  final BranchApiDto _self;
  final $Res Function(BranchApiDto) _then;

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? branchId = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
    Object? companyId = freezed,
    Object? company = freezed,
    Object? defaultCurrencyId = freezed,
    Object? govtRegName = freezed,
    Object? govtRegNo = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto?,
      companyId: freezed == companyId
          ? _self.companyId
          : companyId // ignore: cast_nullable_to_non_nullable
              as int?,
      company: freezed == company
          ? _self.company
          : company // ignore: cast_nullable_to_non_nullable
              as CompanyApiDto?,
      defaultCurrencyId: freezed == defaultCurrencyId
          ? _self.defaultCurrencyId
          : defaultCurrencyId // ignore: cast_nullable_to_non_nullable
              as int?,
      govtRegName: freezed == govtRegName
          ? _self.govtRegName
          : govtRegName // ignore: cast_nullable_to_non_nullable
              as String?,
      govtRegNo: freezed == govtRegNo
          ? _self.govtRegNo
          : govtRegNo // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompanyApiDtoCopyWith<$Res>? get company {
    if (_self.company == null) {
      return null;
    }

    return $CompanyApiDtoCopyWith<$Res>(_self.company!, (value) {
      return _then(_self.copyWith(company: value));
    });
  }
}

/// Adds pattern-matching-related methods to [BranchApiDto].
extension BranchApiDtoPatterns on BranchApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BranchApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BranchApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BranchApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BranchApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BranchApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BranchApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto? account,
            @JsonKey(name: 'companyId') int? companyId,
            @JsonKey(name: 'company') CompanyApiDto? company,
            @JsonKey(name: 'defaultCurrencyId') int? defaultCurrencyId,
            @JsonKey(name: 'govtRegName') String? govtRegName,
            @JsonKey(name: 'govtRegNo') String? govtRegNo,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BranchApiDto() when $default != null:
        return $default(
            _that.branchId,
            _that.code,
            _that.name,
            _that.accountId,
            _that.account,
            _that.companyId,
            _that.company,
            _that.defaultCurrencyId,
            _that.govtRegName,
            _that.govtRegNo,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto? account,
            @JsonKey(name: 'companyId') int? companyId,
            @JsonKey(name: 'company') CompanyApiDto? company,
            @JsonKey(name: 'defaultCurrencyId') int? defaultCurrencyId,
            @JsonKey(name: 'govtRegName') String? govtRegName,
            @JsonKey(name: 'govtRegNo') String? govtRegNo,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BranchApiDto():
        return $default(
            _that.branchId,
            _that.code,
            _that.name,
            _that.accountId,
            _that.account,
            _that.companyId,
            _that.company,
            _that.defaultCurrencyId,
            _that.govtRegName,
            _that.govtRegNo,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto? account,
            @JsonKey(name: 'companyId') int? companyId,
            @JsonKey(name: 'company') CompanyApiDto? company,
            @JsonKey(name: 'defaultCurrencyId') int? defaultCurrencyId,
            @JsonKey(name: 'govtRegName') String? govtRegName,
            @JsonKey(name: 'govtRegNo') String? govtRegNo,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BranchApiDto() when $default != null:
        return $default(
            _that.branchId,
            _that.code,
            _that.name,
            _that.accountId,
            _that.account,
            _that.companyId,
            _that.company,
            _that.defaultCurrencyId,
            _that.govtRegName,
            _that.govtRegNo,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BranchApiDto implements BranchApiDto {
  _BranchApiDto(
      {@JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'code') this.code,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'account') this.account,
      @JsonKey(name: 'companyId') this.companyId,
      @JsonKey(name: 'company') this.company,
      @JsonKey(name: 'defaultCurrencyId') this.defaultCurrencyId,
      @JsonKey(name: 'govtRegName') this.govtRegName,
      @JsonKey(name: 'govtRegNo') this.govtRegNo,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _BranchApiDto.fromJson(Map<String, dynamic> json) =>
      _$BranchApiDtoFromJson(json);

  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'code')
  final String? code;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'account')
  final AccountApiDto? account;
  @override
  @JsonKey(name: 'companyId')
  final int? companyId;
  @override
  @JsonKey(name: 'company')
  final CompanyApiDto? company;
  @override
  @JsonKey(name: 'defaultCurrencyId')
  final int? defaultCurrencyId;
  @override
  @JsonKey(name: 'govtRegName')
  final String? govtRegName;
  @override
  @JsonKey(name: 'govtRegNo')
  final String? govtRegNo;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BranchApiDtoCopyWith<_BranchApiDto> get copyWith =>
      __$BranchApiDtoCopyWithImpl<_BranchApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BranchApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BranchApiDto &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.companyId, companyId) ||
                other.companyId == companyId) &&
            (identical(other.company, company) || other.company == company) &&
            (identical(other.defaultCurrencyId, defaultCurrencyId) ||
                other.defaultCurrencyId == defaultCurrencyId) &&
            (identical(other.govtRegName, govtRegName) ||
                other.govtRegName == govtRegName) &&
            (identical(other.govtRegNo, govtRegNo) ||
                other.govtRegNo == govtRegNo) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      branchId,
      code,
      name,
      accountId,
      account,
      companyId,
      company,
      defaultCurrencyId,
      govtRegName,
      govtRegNo,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'BranchApiDto(branchId: $branchId, code: $code, name: $name, accountId: $accountId, account: $account, companyId: $companyId, company: $company, defaultCurrencyId: $defaultCurrencyId, govtRegName: $govtRegName, govtRegNo: $govtRegNo, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$BranchApiDtoCopyWith<$Res>
    implements $BranchApiDtoCopyWith<$Res> {
  factory _$BranchApiDtoCopyWith(
          _BranchApiDto value, $Res Function(_BranchApiDto) _then) =
      __$BranchApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto? account,
      @JsonKey(name: 'companyId') int? companyId,
      @JsonKey(name: 'company') CompanyApiDto? company,
      @JsonKey(name: 'defaultCurrencyId') int? defaultCurrencyId,
      @JsonKey(name: 'govtRegName') String? govtRegName,
      @JsonKey(name: 'govtRegNo') String? govtRegNo,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $AccountApiDtoCopyWith<$Res>? get account;
  @override
  $CompanyApiDtoCopyWith<$Res>? get company;
}

/// @nodoc
class __$BranchApiDtoCopyWithImpl<$Res>
    implements _$BranchApiDtoCopyWith<$Res> {
  __$BranchApiDtoCopyWithImpl(this._self, this._then);

  final _BranchApiDto _self;
  final $Res Function(_BranchApiDto) _then;

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? branchId = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
    Object? companyId = freezed,
    Object? company = freezed,
    Object? defaultCurrencyId = freezed,
    Object? govtRegName = freezed,
    Object? govtRegNo = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_BranchApiDto(
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto?,
      companyId: freezed == companyId
          ? _self.companyId
          : companyId // ignore: cast_nullable_to_non_nullable
              as int?,
      company: freezed == company
          ? _self.company
          : company // ignore: cast_nullable_to_non_nullable
              as CompanyApiDto?,
      defaultCurrencyId: freezed == defaultCurrencyId
          ? _self.defaultCurrencyId
          : defaultCurrencyId // ignore: cast_nullable_to_non_nullable
              as int?,
      govtRegName: freezed == govtRegName
          ? _self.govtRegName
          : govtRegName // ignore: cast_nullable_to_non_nullable
              as String?,
      govtRegNo: freezed == govtRegNo
          ? _self.govtRegNo
          : govtRegNo // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }

  /// Create a copy of BranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompanyApiDtoCopyWith<$Res>? get company {
    if (_self.company == null) {
      return null;
    }

    return $CompanyApiDtoCopyWith<$Res>(_self.company!, (value) {
      return _then(_self.copyWith(company: value));
    });
  }
}

/// @nodoc
mixin _$CalendarItemApiDto {
  @JsonKey(name: 'id')
  int? get id;
  @JsonKey(name: 'subject')
  String? get subject;
  @JsonKey(name: 'location')
  String? get location;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'startTime')
  DateTime? get startTime;
  @JsonKey(name: 'endTime')
  DateTime? get endTime;
  @JsonKey(name: 'isAllDay')
  bool? get isAllDay;
  @JsonKey(name: 'calendarItemType')
  int? get calendarItemType;
  @JsonKey(name: 'recurrenceRule')
  String? get recurrenceRule;
  @JsonKey(name: 'recurrenceException')
  String? get recurrenceException;
  @JsonKey(name: 'recurrenceId')
  int? get recurrenceId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'academicYearId')
  int? get academicYearId;
  @JsonKey(name: 'academicTermId')
  int? get academicTermId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of CalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CalendarItemApiDtoCopyWith<CalendarItemApiDto> get copyWith =>
      _$CalendarItemApiDtoCopyWithImpl<CalendarItemApiDto>(
          this as CalendarItemApiDto, _$identity);

  /// Serializes this CalendarItemApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CalendarItemApiDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.subject, subject) || other.subject == subject) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime) &&
            (identical(other.endTime, endTime) || other.endTime == endTime) &&
            (identical(other.isAllDay, isAllDay) ||
                other.isAllDay == isAllDay) &&
            (identical(other.calendarItemType, calendarItemType) ||
                other.calendarItemType == calendarItemType) &&
            (identical(other.recurrenceRule, recurrenceRule) ||
                other.recurrenceRule == recurrenceRule) &&
            (identical(other.recurrenceException, recurrenceException) ||
                other.recurrenceException == recurrenceException) &&
            (identical(other.recurrenceId, recurrenceId) ||
                other.recurrenceId == recurrenceId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicTermId, academicTermId) ||
                other.academicTermId == academicTermId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        subject,
        location,
        description,
        startTime,
        endTime,
        isAllDay,
        calendarItemType,
        recurrenceRule,
        recurrenceException,
        recurrenceId,
        branchId,
        academicYearId,
        academicTermId,
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'CalendarItemApiDto(id: $id, subject: $subject, location: $location, description: $description, startTime: $startTime, endTime: $endTime, isAllDay: $isAllDay, calendarItemType: $calendarItemType, recurrenceRule: $recurrenceRule, recurrenceException: $recurrenceException, recurrenceId: $recurrenceId, branchId: $branchId, academicYearId: $academicYearId, academicTermId: $academicTermId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $CalendarItemApiDtoCopyWith<$Res> {
  factory $CalendarItemApiDtoCopyWith(
          CalendarItemApiDto value, $Res Function(CalendarItemApiDto) _then) =
      _$CalendarItemApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'subject') String? subject,
      @JsonKey(name: 'location') String? location,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'startTime') DateTime? startTime,
      @JsonKey(name: 'endTime') DateTime? endTime,
      @JsonKey(name: 'isAllDay') bool? isAllDay,
      @JsonKey(name: 'calendarItemType') int? calendarItemType,
      @JsonKey(name: 'recurrenceRule') String? recurrenceRule,
      @JsonKey(name: 'recurrenceException') String? recurrenceException,
      @JsonKey(name: 'recurrenceId') int? recurrenceId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'academicTermId') int? academicTermId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$CalendarItemApiDtoCopyWithImpl<$Res>
    implements $CalendarItemApiDtoCopyWith<$Res> {
  _$CalendarItemApiDtoCopyWithImpl(this._self, this._then);

  final CalendarItemApiDto _self;
  final $Res Function(CalendarItemApiDto) _then;

  /// Create a copy of CalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? subject = freezed,
    Object? location = freezed,
    Object? description = freezed,
    Object? startTime = freezed,
    Object? endTime = freezed,
    Object? isAllDay = freezed,
    Object? calendarItemType = freezed,
    Object? recurrenceRule = freezed,
    Object? recurrenceException = freezed,
    Object? recurrenceId = freezed,
    Object? branchId = freezed,
    Object? academicYearId = freezed,
    Object? academicTermId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      subject: freezed == subject
          ? _self.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as String?,
      location: freezed == location
          ? _self.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      startTime: freezed == startTime
          ? _self.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endTime: freezed == endTime
          ? _self.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isAllDay: freezed == isAllDay
          ? _self.isAllDay
          : isAllDay // ignore: cast_nullable_to_non_nullable
              as bool?,
      calendarItemType: freezed == calendarItemType
          ? _self.calendarItemType
          : calendarItemType // ignore: cast_nullable_to_non_nullable
              as int?,
      recurrenceRule: freezed == recurrenceRule
          ? _self.recurrenceRule
          : recurrenceRule // ignore: cast_nullable_to_non_nullable
              as String?,
      recurrenceException: freezed == recurrenceException
          ? _self.recurrenceException
          : recurrenceException // ignore: cast_nullable_to_non_nullable
              as String?,
      recurrenceId: freezed == recurrenceId
          ? _self.recurrenceId
          : recurrenceId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicTermId: freezed == academicTermId
          ? _self.academicTermId
          : academicTermId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CalendarItemApiDto].
extension CalendarItemApiDtoPatterns on CalendarItemApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CalendarItemApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CalendarItemApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CalendarItemApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CalendarItemApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'subject') String? subject,
            @JsonKey(name: 'location') String? location,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'startTime') DateTime? startTime,
            @JsonKey(name: 'endTime') DateTime? endTime,
            @JsonKey(name: 'isAllDay') bool? isAllDay,
            @JsonKey(name: 'calendarItemType') int? calendarItemType,
            @JsonKey(name: 'recurrenceRule') String? recurrenceRule,
            @JsonKey(name: 'recurrenceException') String? recurrenceException,
            @JsonKey(name: 'recurrenceId') int? recurrenceId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicTermId') int? academicTermId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CalendarItemApiDto() when $default != null:
        return $default(
            _that.id,
            _that.subject,
            _that.location,
            _that.description,
            _that.startTime,
            _that.endTime,
            _that.isAllDay,
            _that.calendarItemType,
            _that.recurrenceRule,
            _that.recurrenceException,
            _that.recurrenceId,
            _that.branchId,
            _that.academicYearId,
            _that.academicTermId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'subject') String? subject,
            @JsonKey(name: 'location') String? location,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'startTime') DateTime? startTime,
            @JsonKey(name: 'endTime') DateTime? endTime,
            @JsonKey(name: 'isAllDay') bool? isAllDay,
            @JsonKey(name: 'calendarItemType') int? calendarItemType,
            @JsonKey(name: 'recurrenceRule') String? recurrenceRule,
            @JsonKey(name: 'recurrenceException') String? recurrenceException,
            @JsonKey(name: 'recurrenceId') int? recurrenceId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicTermId') int? academicTermId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemApiDto():
        return $default(
            _that.id,
            _that.subject,
            _that.location,
            _that.description,
            _that.startTime,
            _that.endTime,
            _that.isAllDay,
            _that.calendarItemType,
            _that.recurrenceRule,
            _that.recurrenceException,
            _that.recurrenceId,
            _that.branchId,
            _that.academicYearId,
            _that.academicTermId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'id') int? id,
            @JsonKey(name: 'subject') String? subject,
            @JsonKey(name: 'location') String? location,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'startTime') DateTime? startTime,
            @JsonKey(name: 'endTime') DateTime? endTime,
            @JsonKey(name: 'isAllDay') bool? isAllDay,
            @JsonKey(name: 'calendarItemType') int? calendarItemType,
            @JsonKey(name: 'recurrenceRule') String? recurrenceRule,
            @JsonKey(name: 'recurrenceException') String? recurrenceException,
            @JsonKey(name: 'recurrenceId') int? recurrenceId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicTermId') int? academicTermId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CalendarItemApiDto() when $default != null:
        return $default(
            _that.id,
            _that.subject,
            _that.location,
            _that.description,
            _that.startTime,
            _that.endTime,
            _that.isAllDay,
            _that.calendarItemType,
            _that.recurrenceRule,
            _that.recurrenceException,
            _that.recurrenceId,
            _that.branchId,
            _that.academicYearId,
            _that.academicTermId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CalendarItemApiDto implements CalendarItemApiDto {
  _CalendarItemApiDto(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'subject') this.subject,
      @JsonKey(name: 'location') this.location,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'startTime') this.startTime,
      @JsonKey(name: 'endTime') this.endTime,
      @JsonKey(name: 'isAllDay') this.isAllDay,
      @JsonKey(name: 'calendarItemType') this.calendarItemType,
      @JsonKey(name: 'recurrenceRule') this.recurrenceRule,
      @JsonKey(name: 'recurrenceException') this.recurrenceException,
      @JsonKey(name: 'recurrenceId') this.recurrenceId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'academicTermId') this.academicTermId,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _CalendarItemApiDto.fromJson(Map<String, dynamic> json) =>
      _$CalendarItemApiDtoFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'subject')
  final String? subject;
  @override
  @JsonKey(name: 'location')
  final String? location;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'startTime')
  final DateTime? startTime;
  @override
  @JsonKey(name: 'endTime')
  final DateTime? endTime;
  @override
  @JsonKey(name: 'isAllDay')
  final bool? isAllDay;
  @override
  @JsonKey(name: 'calendarItemType')
  final int? calendarItemType;
  @override
  @JsonKey(name: 'recurrenceRule')
  final String? recurrenceRule;
  @override
  @JsonKey(name: 'recurrenceException')
  final String? recurrenceException;
  @override
  @JsonKey(name: 'recurrenceId')
  final int? recurrenceId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'academicYearId')
  final int? academicYearId;
  @override
  @JsonKey(name: 'academicTermId')
  final int? academicTermId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of CalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CalendarItemApiDtoCopyWith<_CalendarItemApiDto> get copyWith =>
      __$CalendarItemApiDtoCopyWithImpl<_CalendarItemApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CalendarItemApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CalendarItemApiDto &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.subject, subject) || other.subject == subject) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime) &&
            (identical(other.endTime, endTime) || other.endTime == endTime) &&
            (identical(other.isAllDay, isAllDay) ||
                other.isAllDay == isAllDay) &&
            (identical(other.calendarItemType, calendarItemType) ||
                other.calendarItemType == calendarItemType) &&
            (identical(other.recurrenceRule, recurrenceRule) ||
                other.recurrenceRule == recurrenceRule) &&
            (identical(other.recurrenceException, recurrenceException) ||
                other.recurrenceException == recurrenceException) &&
            (identical(other.recurrenceId, recurrenceId) ||
                other.recurrenceId == recurrenceId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicTermId, academicTermId) ||
                other.academicTermId == academicTermId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        subject,
        location,
        description,
        startTime,
        endTime,
        isAllDay,
        calendarItemType,
        recurrenceRule,
        recurrenceException,
        recurrenceId,
        branchId,
        academicYearId,
        academicTermId,
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'CalendarItemApiDto(id: $id, subject: $subject, location: $location, description: $description, startTime: $startTime, endTime: $endTime, isAllDay: $isAllDay, calendarItemType: $calendarItemType, recurrenceRule: $recurrenceRule, recurrenceException: $recurrenceException, recurrenceId: $recurrenceId, branchId: $branchId, academicYearId: $academicYearId, academicTermId: $academicTermId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$CalendarItemApiDtoCopyWith<$Res>
    implements $CalendarItemApiDtoCopyWith<$Res> {
  factory _$CalendarItemApiDtoCopyWith(
          _CalendarItemApiDto value, $Res Function(_CalendarItemApiDto) _then) =
      __$CalendarItemApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'subject') String? subject,
      @JsonKey(name: 'location') String? location,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'startTime') DateTime? startTime,
      @JsonKey(name: 'endTime') DateTime? endTime,
      @JsonKey(name: 'isAllDay') bool? isAllDay,
      @JsonKey(name: 'calendarItemType') int? calendarItemType,
      @JsonKey(name: 'recurrenceRule') String? recurrenceRule,
      @JsonKey(name: 'recurrenceException') String? recurrenceException,
      @JsonKey(name: 'recurrenceId') int? recurrenceId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'academicTermId') int? academicTermId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$CalendarItemApiDtoCopyWithImpl<$Res>
    implements _$CalendarItemApiDtoCopyWith<$Res> {
  __$CalendarItemApiDtoCopyWithImpl(this._self, this._then);

  final _CalendarItemApiDto _self;
  final $Res Function(_CalendarItemApiDto) _then;

  /// Create a copy of CalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? subject = freezed,
    Object? location = freezed,
    Object? description = freezed,
    Object? startTime = freezed,
    Object? endTime = freezed,
    Object? isAllDay = freezed,
    Object? calendarItemType = freezed,
    Object? recurrenceRule = freezed,
    Object? recurrenceException = freezed,
    Object? recurrenceId = freezed,
    Object? branchId = freezed,
    Object? academicYearId = freezed,
    Object? academicTermId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_CalendarItemApiDto(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      subject: freezed == subject
          ? _self.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as String?,
      location: freezed == location
          ? _self.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      startTime: freezed == startTime
          ? _self.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endTime: freezed == endTime
          ? _self.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isAllDay: freezed == isAllDay
          ? _self.isAllDay
          : isAllDay // ignore: cast_nullable_to_non_nullable
              as bool?,
      calendarItemType: freezed == calendarItemType
          ? _self.calendarItemType
          : calendarItemType // ignore: cast_nullable_to_non_nullable
              as int?,
      recurrenceRule: freezed == recurrenceRule
          ? _self.recurrenceRule
          : recurrenceRule // ignore: cast_nullable_to_non_nullable
              as String?,
      recurrenceException: freezed == recurrenceException
          ? _self.recurrenceException
          : recurrenceException // ignore: cast_nullable_to_non_nullable
              as String?,
      recurrenceId: freezed == recurrenceId
          ? _self.recurrenceId
          : recurrenceId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicTermId: freezed == academicTermId
          ? _self.academicTermId
          : academicTermId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$ClassApiDto {
  @JsonKey(name: 'classId')
  int? get classId;
  @JsonKey(name: 'levelId')
  int? get levelId;
  @JsonKey(name: 'level')
  LevelApiDto? get level;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'startDate')
  String? get startDate;
  @JsonKey(name: 'endDate')
  String? get endDate;
  @JsonKey(name: 'maxCapacity')
  int? get maxCapacity;
  @JsonKey(name: 'mainTeacherId')
  int? get mainTeacherId;
  @JsonKey(name: 'mainTeacher')
  TeacherApiDto? get mainTeacher;
  @JsonKey(name: 'academicYearId')
  int? get academicYearId;
  @JsonKey(name: 'academicYear')
  AcademicYearApiDto? get academicYear;
  @JsonKey(name: 'classSubjects')
  List<ClassSubjectApiDto>? get classSubjects;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ClassApiDtoCopyWith<ClassApiDto> get copyWith =>
      _$ClassApiDtoCopyWithImpl<ClassApiDto>(this as ClassApiDto, _$identity);

  /// Serializes this ClassApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ClassApiDto &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.maxCapacity, maxCapacity) ||
                other.maxCapacity == maxCapacity) &&
            (identical(other.mainTeacherId, mainTeacherId) ||
                other.mainTeacherId == mainTeacherId) &&
            (identical(other.mainTeacher, mainTeacher) ||
                other.mainTeacher == mainTeacher) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicYear, academicYear) ||
                other.academicYear == academicYear) &&
            const DeepCollectionEquality()
                .equals(other.classSubjects, classSubjects) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      classId,
      levelId,
      level,
      name,
      startDate,
      endDate,
      maxCapacity,
      mainTeacherId,
      mainTeacher,
      academicYearId,
      academicYear,
      const DeepCollectionEquality().hash(classSubjects),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ClassApiDto(classId: $classId, levelId: $levelId, level: $level, name: $name, startDate: $startDate, endDate: $endDate, maxCapacity: $maxCapacity, mainTeacherId: $mainTeacherId, mainTeacher: $mainTeacher, academicYearId: $academicYearId, academicYear: $academicYear, classSubjects: $classSubjects, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $ClassApiDtoCopyWith<$Res> {
  factory $ClassApiDtoCopyWith(
          ClassApiDto value, $Res Function(ClassApiDto) _then) =
      _$ClassApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'level') LevelApiDto? level,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'maxCapacity') int? maxCapacity,
      @JsonKey(name: 'mainTeacherId') int? mainTeacherId,
      @JsonKey(name: 'mainTeacher') TeacherApiDto? mainTeacher,
      @JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
      @JsonKey(name: 'classSubjects') List<ClassSubjectApiDto>? classSubjects,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $LevelApiDtoCopyWith<$Res>? get level;
  $TeacherApiDtoCopyWith<$Res>? get mainTeacher;
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear;
}

/// @nodoc
class _$ClassApiDtoCopyWithImpl<$Res> implements $ClassApiDtoCopyWith<$Res> {
  _$ClassApiDtoCopyWithImpl(this._self, this._then);

  final ClassApiDto _self;
  final $Res Function(ClassApiDto) _then;

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? classId = freezed,
    Object? levelId = freezed,
    Object? level = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? maxCapacity = freezed,
    Object? mainTeacherId = freezed,
    Object? mainTeacher = freezed,
    Object? academicYearId = freezed,
    Object? academicYear = freezed,
    Object? classSubjects = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      level: freezed == level
          ? _self.level
          : level // ignore: cast_nullable_to_non_nullable
              as LevelApiDto?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      maxCapacity: freezed == maxCapacity
          ? _self.maxCapacity
          : maxCapacity // ignore: cast_nullable_to_non_nullable
              as int?,
      mainTeacherId: freezed == mainTeacherId
          ? _self.mainTeacherId
          : mainTeacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      mainTeacher: freezed == mainTeacher
          ? _self.mainTeacher
          : mainTeacher // ignore: cast_nullable_to_non_nullable
              as TeacherApiDto?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYear: freezed == academicYear
          ? _self.academicYear
          : academicYear // ignore: cast_nullable_to_non_nullable
              as AcademicYearApiDto?,
      classSubjects: freezed == classSubjects
          ? _self.classSubjects
          : classSubjects // ignore: cast_nullable_to_non_nullable
              as List<ClassSubjectApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LevelApiDtoCopyWith<$Res>? get level {
    if (_self.level == null) {
      return null;
    }

    return $LevelApiDtoCopyWith<$Res>(_self.level!, (value) {
      return _then(_self.copyWith(level: value));
    });
  }

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TeacherApiDtoCopyWith<$Res>? get mainTeacher {
    if (_self.mainTeacher == null) {
      return null;
    }

    return $TeacherApiDtoCopyWith<$Res>(_self.mainTeacher!, (value) {
      return _then(_self.copyWith(mainTeacher: value));
    });
  }

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear {
    if (_self.academicYear == null) {
      return null;
    }

    return $AcademicYearApiDtoCopyWith<$Res>(_self.academicYear!, (value) {
      return _then(_self.copyWith(academicYear: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ClassApiDto].
extension ClassApiDtoPatterns on ClassApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ClassApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ClassApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ClassApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'level') LevelApiDto? level,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'maxCapacity') int? maxCapacity,
            @JsonKey(name: 'mainTeacherId') int? mainTeacherId,
            @JsonKey(name: 'mainTeacher') TeacherApiDto? mainTeacher,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
            @JsonKey(name: 'classSubjects')
            List<ClassSubjectApiDto>? classSubjects,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassApiDto() when $default != null:
        return $default(
            _that.classId,
            _that.levelId,
            _that.level,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.maxCapacity,
            _that.mainTeacherId,
            _that.mainTeacher,
            _that.academicYearId,
            _that.academicYear,
            _that.classSubjects,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'level') LevelApiDto? level,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'maxCapacity') int? maxCapacity,
            @JsonKey(name: 'mainTeacherId') int? mainTeacherId,
            @JsonKey(name: 'mainTeacher') TeacherApiDto? mainTeacher,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
            @JsonKey(name: 'classSubjects')
            List<ClassSubjectApiDto>? classSubjects,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassApiDto():
        return $default(
            _that.classId,
            _that.levelId,
            _that.level,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.maxCapacity,
            _that.mainTeacherId,
            _that.mainTeacher,
            _that.academicYearId,
            _that.academicYear,
            _that.classSubjects,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'level') LevelApiDto? level,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'maxCapacity') int? maxCapacity,
            @JsonKey(name: 'mainTeacherId') int? mainTeacherId,
            @JsonKey(name: 'mainTeacher') TeacherApiDto? mainTeacher,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
            @JsonKey(name: 'classSubjects')
            List<ClassSubjectApiDto>? classSubjects,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassApiDto() when $default != null:
        return $default(
            _that.classId,
            _that.levelId,
            _that.level,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.maxCapacity,
            _that.mainTeacherId,
            _that.mainTeacher,
            _that.academicYearId,
            _that.academicYear,
            _that.classSubjects,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ClassApiDto implements ClassApiDto {
  _ClassApiDto(
      {@JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'levelId') this.levelId,
      @JsonKey(name: 'level') this.level,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'maxCapacity') this.maxCapacity,
      @JsonKey(name: 'mainTeacherId') this.mainTeacherId,
      @JsonKey(name: 'mainTeacher') this.mainTeacher,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'academicYear') this.academicYear,
      @JsonKey(name: 'classSubjects')
      final List<ClassSubjectApiDto>? classSubjects,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _classSubjects = classSubjects;
  factory _ClassApiDto.fromJson(Map<String, dynamic> json) =>
      _$ClassApiDtoFromJson(json);

  @override
  @JsonKey(name: 'classId')
  final int? classId;
  @override
  @JsonKey(name: 'levelId')
  final int? levelId;
  @override
  @JsonKey(name: 'level')
  final LevelApiDto? level;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'startDate')
  final String? startDate;
  @override
  @JsonKey(name: 'endDate')
  final String? endDate;
  @override
  @JsonKey(name: 'maxCapacity')
  final int? maxCapacity;
  @override
  @JsonKey(name: 'mainTeacherId')
  final int? mainTeacherId;
  @override
  @JsonKey(name: 'mainTeacher')
  final TeacherApiDto? mainTeacher;
  @override
  @JsonKey(name: 'academicYearId')
  final int? academicYearId;
  @override
  @JsonKey(name: 'academicYear')
  final AcademicYearApiDto? academicYear;
  final List<ClassSubjectApiDto>? _classSubjects;
  @override
  @JsonKey(name: 'classSubjects')
  List<ClassSubjectApiDto>? get classSubjects {
    final value = _classSubjects;
    if (value == null) return null;
    if (_classSubjects is EqualUnmodifiableListView) return _classSubjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ClassApiDtoCopyWith<_ClassApiDto> get copyWith =>
      __$ClassApiDtoCopyWithImpl<_ClassApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ClassApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ClassApiDto &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.maxCapacity, maxCapacity) ||
                other.maxCapacity == maxCapacity) &&
            (identical(other.mainTeacherId, mainTeacherId) ||
                other.mainTeacherId == mainTeacherId) &&
            (identical(other.mainTeacher, mainTeacher) ||
                other.mainTeacher == mainTeacher) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicYear, academicYear) ||
                other.academicYear == academicYear) &&
            const DeepCollectionEquality()
                .equals(other._classSubjects, _classSubjects) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      classId,
      levelId,
      level,
      name,
      startDate,
      endDate,
      maxCapacity,
      mainTeacherId,
      mainTeacher,
      academicYearId,
      academicYear,
      const DeepCollectionEquality().hash(_classSubjects),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ClassApiDto(classId: $classId, levelId: $levelId, level: $level, name: $name, startDate: $startDate, endDate: $endDate, maxCapacity: $maxCapacity, mainTeacherId: $mainTeacherId, mainTeacher: $mainTeacher, academicYearId: $academicYearId, academicYear: $academicYear, classSubjects: $classSubjects, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$ClassApiDtoCopyWith<$Res>
    implements $ClassApiDtoCopyWith<$Res> {
  factory _$ClassApiDtoCopyWith(
          _ClassApiDto value, $Res Function(_ClassApiDto) _then) =
      __$ClassApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'level') LevelApiDto? level,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'maxCapacity') int? maxCapacity,
      @JsonKey(name: 'mainTeacherId') int? mainTeacherId,
      @JsonKey(name: 'mainTeacher') TeacherApiDto? mainTeacher,
      @JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
      @JsonKey(name: 'classSubjects') List<ClassSubjectApiDto>? classSubjects,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $LevelApiDtoCopyWith<$Res>? get level;
  @override
  $TeacherApiDtoCopyWith<$Res>? get mainTeacher;
  @override
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear;
}

/// @nodoc
class __$ClassApiDtoCopyWithImpl<$Res> implements _$ClassApiDtoCopyWith<$Res> {
  __$ClassApiDtoCopyWithImpl(this._self, this._then);

  final _ClassApiDto _self;
  final $Res Function(_ClassApiDto) _then;

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? classId = freezed,
    Object? levelId = freezed,
    Object? level = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? maxCapacity = freezed,
    Object? mainTeacherId = freezed,
    Object? mainTeacher = freezed,
    Object? academicYearId = freezed,
    Object? academicYear = freezed,
    Object? classSubjects = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_ClassApiDto(
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      level: freezed == level
          ? _self.level
          : level // ignore: cast_nullable_to_non_nullable
              as LevelApiDto?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      maxCapacity: freezed == maxCapacity
          ? _self.maxCapacity
          : maxCapacity // ignore: cast_nullable_to_non_nullable
              as int?,
      mainTeacherId: freezed == mainTeacherId
          ? _self.mainTeacherId
          : mainTeacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      mainTeacher: freezed == mainTeacher
          ? _self.mainTeacher
          : mainTeacher // ignore: cast_nullable_to_non_nullable
              as TeacherApiDto?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYear: freezed == academicYear
          ? _self.academicYear
          : academicYear // ignore: cast_nullable_to_non_nullable
              as AcademicYearApiDto?,
      classSubjects: freezed == classSubjects
          ? _self._classSubjects
          : classSubjects // ignore: cast_nullable_to_non_nullable
              as List<ClassSubjectApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LevelApiDtoCopyWith<$Res>? get level {
    if (_self.level == null) {
      return null;
    }

    return $LevelApiDtoCopyWith<$Res>(_self.level!, (value) {
      return _then(_self.copyWith(level: value));
    });
  }

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TeacherApiDtoCopyWith<$Res>? get mainTeacher {
    if (_self.mainTeacher == null) {
      return null;
    }

    return $TeacherApiDtoCopyWith<$Res>(_self.mainTeacher!, (value) {
      return _then(_self.copyWith(mainTeacher: value));
    });
  }

  /// Create a copy of ClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear {
    if (_self.academicYear == null) {
      return null;
    }

    return $AcademicYearApiDtoCopyWith<$Res>(_self.academicYear!, (value) {
      return _then(_self.copyWith(academicYear: value));
    });
  }
}

/// @nodoc
mixin _$ClassAttendanceDTODto {
  @JsonKey(name: 'classId')
  int? get classId;
  @JsonKey(name: 'className')
  String? get className;
  @JsonKey(name: 'students')
  List<StudentAttendanceDTODto>? get students;
  @JsonKey(name: 'sumPresent')
  int? get sumPresent;
  @JsonKey(name: 'sumSchoolDays')
  int? get sumSchoolDays;
  @JsonKey(name: 'classAttendanceRate')
  int? get classAttendanceRate;

  /// Create a copy of ClassAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ClassAttendanceDTODtoCopyWith<ClassAttendanceDTODto> get copyWith =>
      _$ClassAttendanceDTODtoCopyWithImpl<ClassAttendanceDTODto>(
          this as ClassAttendanceDTODto, _$identity);

  /// Serializes this ClassAttendanceDTODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ClassAttendanceDTODto &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className) &&
            const DeepCollectionEquality().equals(other.students, students) &&
            (identical(other.sumPresent, sumPresent) ||
                other.sumPresent == sumPresent) &&
            (identical(other.sumSchoolDays, sumSchoolDays) ||
                other.sumSchoolDays == sumSchoolDays) &&
            (identical(other.classAttendanceRate, classAttendanceRate) ||
                other.classAttendanceRate == classAttendanceRate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      classId,
      className,
      const DeepCollectionEquality().hash(students),
      sumPresent,
      sumSchoolDays,
      classAttendanceRate);

  @override
  String toString() {
    return 'ClassAttendanceDTODto(classId: $classId, className: $className, students: $students, sumPresent: $sumPresent, sumSchoolDays: $sumSchoolDays, classAttendanceRate: $classAttendanceRate)';
  }
}

/// @nodoc
abstract mixin class $ClassAttendanceDTODtoCopyWith<$Res> {
  factory $ClassAttendanceDTODtoCopyWith(ClassAttendanceDTODto value,
          $Res Function(ClassAttendanceDTODto) _then) =
      _$ClassAttendanceDTODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'className') String? className,
      @JsonKey(name: 'students') List<StudentAttendanceDTODto>? students,
      @JsonKey(name: 'sumPresent') int? sumPresent,
      @JsonKey(name: 'sumSchoolDays') int? sumSchoolDays,
      @JsonKey(name: 'classAttendanceRate') int? classAttendanceRate});
}

/// @nodoc
class _$ClassAttendanceDTODtoCopyWithImpl<$Res>
    implements $ClassAttendanceDTODtoCopyWith<$Res> {
  _$ClassAttendanceDTODtoCopyWithImpl(this._self, this._then);

  final ClassAttendanceDTODto _self;
  final $Res Function(ClassAttendanceDTODto) _then;

  /// Create a copy of ClassAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? classId = freezed,
    Object? className = freezed,
    Object? students = freezed,
    Object? sumPresent = freezed,
    Object? sumSchoolDays = freezed,
    Object? classAttendanceRate = freezed,
  }) {
    return _then(_self.copyWith(
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
      students: freezed == students
          ? _self.students
          : students // ignore: cast_nullable_to_non_nullable
              as List<StudentAttendanceDTODto>?,
      sumPresent: freezed == sumPresent
          ? _self.sumPresent
          : sumPresent // ignore: cast_nullable_to_non_nullable
              as int?,
      sumSchoolDays: freezed == sumSchoolDays
          ? _self.sumSchoolDays
          : sumSchoolDays // ignore: cast_nullable_to_non_nullable
              as int?,
      classAttendanceRate: freezed == classAttendanceRate
          ? _self.classAttendanceRate
          : classAttendanceRate // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ClassAttendanceDTODto].
extension ClassAttendanceDTODtoPatterns on ClassAttendanceDTODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ClassAttendanceDTODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassAttendanceDTODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ClassAttendanceDTODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassAttendanceDTODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ClassAttendanceDTODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassAttendanceDTODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'students') List<StudentAttendanceDTODto>? students,
            @JsonKey(name: 'sumPresent') int? sumPresent,
            @JsonKey(name: 'sumSchoolDays') int? sumSchoolDays,
            @JsonKey(name: 'classAttendanceRate') int? classAttendanceRate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassAttendanceDTODto() when $default != null:
        return $default(_that.classId, _that.className, _that.students,
            _that.sumPresent, _that.sumSchoolDays, _that.classAttendanceRate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'students') List<StudentAttendanceDTODto>? students,
            @JsonKey(name: 'sumPresent') int? sumPresent,
            @JsonKey(name: 'sumSchoolDays') int? sumSchoolDays,
            @JsonKey(name: 'classAttendanceRate') int? classAttendanceRate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassAttendanceDTODto():
        return $default(_that.classId, _that.className, _that.students,
            _that.sumPresent, _that.sumSchoolDays, _that.classAttendanceRate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'className') String? className,
            @JsonKey(name: 'students') List<StudentAttendanceDTODto>? students,
            @JsonKey(name: 'sumPresent') int? sumPresent,
            @JsonKey(name: 'sumSchoolDays') int? sumSchoolDays,
            @JsonKey(name: 'classAttendanceRate') int? classAttendanceRate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassAttendanceDTODto() when $default != null:
        return $default(_that.classId, _that.className, _that.students,
            _that.sumPresent, _that.sumSchoolDays, _that.classAttendanceRate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ClassAttendanceDTODto implements ClassAttendanceDTODto {
  _ClassAttendanceDTODto(
      {@JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'className') this.className,
      @JsonKey(name: 'students') final List<StudentAttendanceDTODto>? students,
      @JsonKey(name: 'sumPresent') this.sumPresent,
      @JsonKey(name: 'sumSchoolDays') this.sumSchoolDays,
      @JsonKey(name: 'classAttendanceRate') this.classAttendanceRate})
      : _students = students;
  factory _ClassAttendanceDTODto.fromJson(Map<String, dynamic> json) =>
      _$ClassAttendanceDTODtoFromJson(json);

  @override
  @JsonKey(name: 'classId')
  final int? classId;
  @override
  @JsonKey(name: 'className')
  final String? className;
  final List<StudentAttendanceDTODto>? _students;
  @override
  @JsonKey(name: 'students')
  List<StudentAttendanceDTODto>? get students {
    final value = _students;
    if (value == null) return null;
    if (_students is EqualUnmodifiableListView) return _students;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'sumPresent')
  final int? sumPresent;
  @override
  @JsonKey(name: 'sumSchoolDays')
  final int? sumSchoolDays;
  @override
  @JsonKey(name: 'classAttendanceRate')
  final int? classAttendanceRate;

  /// Create a copy of ClassAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ClassAttendanceDTODtoCopyWith<_ClassAttendanceDTODto> get copyWith =>
      __$ClassAttendanceDTODtoCopyWithImpl<_ClassAttendanceDTODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ClassAttendanceDTODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ClassAttendanceDTODto &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.className, className) ||
                other.className == className) &&
            const DeepCollectionEquality().equals(other._students, _students) &&
            (identical(other.sumPresent, sumPresent) ||
                other.sumPresent == sumPresent) &&
            (identical(other.sumSchoolDays, sumSchoolDays) ||
                other.sumSchoolDays == sumSchoolDays) &&
            (identical(other.classAttendanceRate, classAttendanceRate) ||
                other.classAttendanceRate == classAttendanceRate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      classId,
      className,
      const DeepCollectionEquality().hash(_students),
      sumPresent,
      sumSchoolDays,
      classAttendanceRate);

  @override
  String toString() {
    return 'ClassAttendanceDTODto(classId: $classId, className: $className, students: $students, sumPresent: $sumPresent, sumSchoolDays: $sumSchoolDays, classAttendanceRate: $classAttendanceRate)';
  }
}

/// @nodoc
abstract mixin class _$ClassAttendanceDTODtoCopyWith<$Res>
    implements $ClassAttendanceDTODtoCopyWith<$Res> {
  factory _$ClassAttendanceDTODtoCopyWith(_ClassAttendanceDTODto value,
          $Res Function(_ClassAttendanceDTODto) _then) =
      __$ClassAttendanceDTODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'className') String? className,
      @JsonKey(name: 'students') List<StudentAttendanceDTODto>? students,
      @JsonKey(name: 'sumPresent') int? sumPresent,
      @JsonKey(name: 'sumSchoolDays') int? sumSchoolDays,
      @JsonKey(name: 'classAttendanceRate') int? classAttendanceRate});
}

/// @nodoc
class __$ClassAttendanceDTODtoCopyWithImpl<$Res>
    implements _$ClassAttendanceDTODtoCopyWith<$Res> {
  __$ClassAttendanceDTODtoCopyWithImpl(this._self, this._then);

  final _ClassAttendanceDTODto _self;
  final $Res Function(_ClassAttendanceDTODto) _then;

  /// Create a copy of ClassAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? classId = freezed,
    Object? className = freezed,
    Object? students = freezed,
    Object? sumPresent = freezed,
    Object? sumSchoolDays = freezed,
    Object? classAttendanceRate = freezed,
  }) {
    return _then(_ClassAttendanceDTODto(
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      className: freezed == className
          ? _self.className
          : className // ignore: cast_nullable_to_non_nullable
              as String?,
      students: freezed == students
          ? _self._students
          : students // ignore: cast_nullable_to_non_nullable
              as List<StudentAttendanceDTODto>?,
      sumPresent: freezed == sumPresent
          ? _self.sumPresent
          : sumPresent // ignore: cast_nullable_to_non_nullable
              as int?,
      sumSchoolDays: freezed == sumSchoolDays
          ? _self.sumSchoolDays
          : sumSchoolDays // ignore: cast_nullable_to_non_nullable
              as int?,
      classAttendanceRate: freezed == classAttendanceRate
          ? _self.classAttendanceRate
          : classAttendanceRate // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ClassRefApiDto {
  @JsonKey(name: 'classId')
  int? get classId;
  @JsonKey(name: 'name')
  String? get name;

  /// Create a copy of ClassRefApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ClassRefApiDtoCopyWith<ClassRefApiDto> get copyWith =>
      _$ClassRefApiDtoCopyWithImpl<ClassRefApiDto>(
          this as ClassRefApiDto, _$identity);

  /// Serializes this ClassRefApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ClassRefApiDto &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, classId, name);

  @override
  String toString() {
    return 'ClassRefApiDto(classId: $classId, name: $name)';
  }
}

/// @nodoc
abstract mixin class $ClassRefApiDtoCopyWith<$Res> {
  factory $ClassRefApiDtoCopyWith(
          ClassRefApiDto value, $Res Function(ClassRefApiDto) _then) =
      _$ClassRefApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'name') String? name});
}

/// @nodoc
class _$ClassRefApiDtoCopyWithImpl<$Res>
    implements $ClassRefApiDtoCopyWith<$Res> {
  _$ClassRefApiDtoCopyWithImpl(this._self, this._then);

  final ClassRefApiDto _self;
  final $Res Function(ClassRefApiDto) _then;

  /// Create a copy of ClassRefApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? classId = freezed,
    Object? name = freezed,
  }) {
    return _then(_self.copyWith(
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ClassRefApiDto].
extension ClassRefApiDtoPatterns on ClassRefApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ClassRefApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassRefApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ClassRefApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassRefApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ClassRefApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassRefApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'name') String? name)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassRefApiDto() when $default != null:
        return $default(_that.classId, _that.name);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'name') String? name)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassRefApiDto():
        return $default(_that.classId, _that.name);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'name') String? name)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassRefApiDto() when $default != null:
        return $default(_that.classId, _that.name);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ClassRefApiDto implements ClassRefApiDto {
  _ClassRefApiDto(
      {@JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'name') this.name});
  factory _ClassRefApiDto.fromJson(Map<String, dynamic> json) =>
      _$ClassRefApiDtoFromJson(json);

  @override
  @JsonKey(name: 'classId')
  final int? classId;
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Create a copy of ClassRefApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ClassRefApiDtoCopyWith<_ClassRefApiDto> get copyWith =>
      __$ClassRefApiDtoCopyWithImpl<_ClassRefApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ClassRefApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ClassRefApiDto &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, classId, name);

  @override
  String toString() {
    return 'ClassRefApiDto(classId: $classId, name: $name)';
  }
}

/// @nodoc
abstract mixin class _$ClassRefApiDtoCopyWith<$Res>
    implements $ClassRefApiDtoCopyWith<$Res> {
  factory _$ClassRefApiDtoCopyWith(
          _ClassRefApiDto value, $Res Function(_ClassRefApiDto) _then) =
      __$ClassRefApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'name') String? name});
}

/// @nodoc
class __$ClassRefApiDtoCopyWithImpl<$Res>
    implements _$ClassRefApiDtoCopyWith<$Res> {
  __$ClassRefApiDtoCopyWithImpl(this._self, this._then);

  final _ClassRefApiDto _self;
  final $Res Function(_ClassRefApiDto) _then;

  /// Create a copy of ClassRefApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? classId = freezed,
    Object? name = freezed,
  }) {
    return _then(_ClassRefApiDto(
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ClassSubjectApiDto {
  @JsonKey(name: 'classSubjectId')
  int? get classSubjectId;
  @JsonKey(name: 'subjectId')
  int? get subjectId;
  @JsonKey(name: 'subject')
  SubjectApiDto? get subject;
  @JsonKey(name: 'classId')
  int? get classId;
  @JsonKey(name: 'class')
  ClassRefApiDto? get classField;
  @JsonKey(name: 'teacherId')
  int? get teacherId;
  @JsonKey(name: 'teacher')
  TeacherApiDto? get teacher;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ClassSubjectApiDtoCopyWith<ClassSubjectApiDto> get copyWith =>
      _$ClassSubjectApiDtoCopyWithImpl<ClassSubjectApiDto>(
          this as ClassSubjectApiDto, _$identity);

  /// Serializes this ClassSubjectApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ClassSubjectApiDto &&
            (identical(other.classSubjectId, classSubjectId) ||
                other.classSubjectId == classSubjectId) &&
            (identical(other.subjectId, subjectId) ||
                other.subjectId == subjectId) &&
            (identical(other.subject, subject) || other.subject == subject) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.classField, classField) ||
                other.classField == classField) &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.teacher, teacher) || other.teacher == teacher) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      classSubjectId,
      subjectId,
      subject,
      classId,
      classField,
      teacherId,
      teacher,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ClassSubjectApiDto(classSubjectId: $classSubjectId, subjectId: $subjectId, subject: $subject, classId: $classId, classField: $classField, teacherId: $teacherId, teacher: $teacher, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $ClassSubjectApiDtoCopyWith<$Res> {
  factory $ClassSubjectApiDtoCopyWith(
          ClassSubjectApiDto value, $Res Function(ClassSubjectApiDto) _then) =
      _$ClassSubjectApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'classSubjectId') int? classSubjectId,
      @JsonKey(name: 'subjectId') int? subjectId,
      @JsonKey(name: 'subject') SubjectApiDto? subject,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'class') ClassRefApiDto? classField,
      @JsonKey(name: 'teacherId') int? teacherId,
      @JsonKey(name: 'teacher') TeacherApiDto? teacher,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $SubjectApiDtoCopyWith<$Res>? get subject;
  $ClassRefApiDtoCopyWith<$Res>? get classField;
  $TeacherApiDtoCopyWith<$Res>? get teacher;
}

/// @nodoc
class _$ClassSubjectApiDtoCopyWithImpl<$Res>
    implements $ClassSubjectApiDtoCopyWith<$Res> {
  _$ClassSubjectApiDtoCopyWithImpl(this._self, this._then);

  final ClassSubjectApiDto _self;
  final $Res Function(ClassSubjectApiDto) _then;

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? classSubjectId = freezed,
    Object? subjectId = freezed,
    Object? subject = freezed,
    Object? classId = freezed,
    Object? classField = freezed,
    Object? teacherId = freezed,
    Object? teacher = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      classSubjectId: freezed == classSubjectId
          ? _self.classSubjectId
          : classSubjectId // ignore: cast_nullable_to_non_nullable
              as int?,
      subjectId: freezed == subjectId
          ? _self.subjectId
          : subjectId // ignore: cast_nullable_to_non_nullable
              as int?,
      subject: freezed == subject
          ? _self.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as SubjectApiDto?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      classField: freezed == classField
          ? _self.classField
          : classField // ignore: cast_nullable_to_non_nullable
              as ClassRefApiDto?,
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      teacher: freezed == teacher
          ? _self.teacher
          : teacher // ignore: cast_nullable_to_non_nullable
              as TeacherApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SubjectApiDtoCopyWith<$Res>? get subject {
    if (_self.subject == null) {
      return null;
    }

    return $SubjectApiDtoCopyWith<$Res>(_self.subject!, (value) {
      return _then(_self.copyWith(subject: value));
    });
  }

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClassRefApiDtoCopyWith<$Res>? get classField {
    if (_self.classField == null) {
      return null;
    }

    return $ClassRefApiDtoCopyWith<$Res>(_self.classField!, (value) {
      return _then(_self.copyWith(classField: value));
    });
  }

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TeacherApiDtoCopyWith<$Res>? get teacher {
    if (_self.teacher == null) {
      return null;
    }

    return $TeacherApiDtoCopyWith<$Res>(_self.teacher!, (value) {
      return _then(_self.copyWith(teacher: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ClassSubjectApiDto].
extension ClassSubjectApiDtoPatterns on ClassSubjectApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ClassSubjectApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassSubjectApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ClassSubjectApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassSubjectApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ClassSubjectApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassSubjectApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'classSubjectId') int? classSubjectId,
            @JsonKey(name: 'subjectId') int? subjectId,
            @JsonKey(name: 'subject') SubjectApiDto? subject,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'class') ClassRefApiDto? classField,
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'teacher') TeacherApiDto? teacher,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ClassSubjectApiDto() when $default != null:
        return $default(
            _that.classSubjectId,
            _that.subjectId,
            _that.subject,
            _that.classId,
            _that.classField,
            _that.teacherId,
            _that.teacher,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'classSubjectId') int? classSubjectId,
            @JsonKey(name: 'subjectId') int? subjectId,
            @JsonKey(name: 'subject') SubjectApiDto? subject,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'class') ClassRefApiDto? classField,
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'teacher') TeacherApiDto? teacher,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassSubjectApiDto():
        return $default(
            _that.classSubjectId,
            _that.subjectId,
            _that.subject,
            _that.classId,
            _that.classField,
            _that.teacherId,
            _that.teacher,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'classSubjectId') int? classSubjectId,
            @JsonKey(name: 'subjectId') int? subjectId,
            @JsonKey(name: 'subject') SubjectApiDto? subject,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'class') ClassRefApiDto? classField,
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'teacher') TeacherApiDto? teacher,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ClassSubjectApiDto() when $default != null:
        return $default(
            _that.classSubjectId,
            _that.subjectId,
            _that.subject,
            _that.classId,
            _that.classField,
            _that.teacherId,
            _that.teacher,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ClassSubjectApiDto implements ClassSubjectApiDto {
  _ClassSubjectApiDto(
      {@JsonKey(name: 'classSubjectId') this.classSubjectId,
      @JsonKey(name: 'subjectId') this.subjectId,
      @JsonKey(name: 'subject') this.subject,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'class') this.classField,
      @JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'teacher') this.teacher,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _ClassSubjectApiDto.fromJson(Map<String, dynamic> json) =>
      _$ClassSubjectApiDtoFromJson(json);

  @override
  @JsonKey(name: 'classSubjectId')
  final int? classSubjectId;
  @override
  @JsonKey(name: 'subjectId')
  final int? subjectId;
  @override
  @JsonKey(name: 'subject')
  final SubjectApiDto? subject;
  @override
  @JsonKey(name: 'classId')
  final int? classId;
  @override
  @JsonKey(name: 'class')
  final ClassRefApiDto? classField;
  @override
  @JsonKey(name: 'teacherId')
  final int? teacherId;
  @override
  @JsonKey(name: 'teacher')
  final TeacherApiDto? teacher;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ClassSubjectApiDtoCopyWith<_ClassSubjectApiDto> get copyWith =>
      __$ClassSubjectApiDtoCopyWithImpl<_ClassSubjectApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ClassSubjectApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ClassSubjectApiDto &&
            (identical(other.classSubjectId, classSubjectId) ||
                other.classSubjectId == classSubjectId) &&
            (identical(other.subjectId, subjectId) ||
                other.subjectId == subjectId) &&
            (identical(other.subject, subject) || other.subject == subject) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.classField, classField) ||
                other.classField == classField) &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.teacher, teacher) || other.teacher == teacher) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      classSubjectId,
      subjectId,
      subject,
      classId,
      classField,
      teacherId,
      teacher,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ClassSubjectApiDto(classSubjectId: $classSubjectId, subjectId: $subjectId, subject: $subject, classId: $classId, classField: $classField, teacherId: $teacherId, teacher: $teacher, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$ClassSubjectApiDtoCopyWith<$Res>
    implements $ClassSubjectApiDtoCopyWith<$Res> {
  factory _$ClassSubjectApiDtoCopyWith(
          _ClassSubjectApiDto value, $Res Function(_ClassSubjectApiDto) _then) =
      __$ClassSubjectApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'classSubjectId') int? classSubjectId,
      @JsonKey(name: 'subjectId') int? subjectId,
      @JsonKey(name: 'subject') SubjectApiDto? subject,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'class') ClassRefApiDto? classField,
      @JsonKey(name: 'teacherId') int? teacherId,
      @JsonKey(name: 'teacher') TeacherApiDto? teacher,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $SubjectApiDtoCopyWith<$Res>? get subject;
  @override
  $ClassRefApiDtoCopyWith<$Res>? get classField;
  @override
  $TeacherApiDtoCopyWith<$Res>? get teacher;
}

/// @nodoc
class __$ClassSubjectApiDtoCopyWithImpl<$Res>
    implements _$ClassSubjectApiDtoCopyWith<$Res> {
  __$ClassSubjectApiDtoCopyWithImpl(this._self, this._then);

  final _ClassSubjectApiDto _self;
  final $Res Function(_ClassSubjectApiDto) _then;

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? classSubjectId = freezed,
    Object? subjectId = freezed,
    Object? subject = freezed,
    Object? classId = freezed,
    Object? classField = freezed,
    Object? teacherId = freezed,
    Object? teacher = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_ClassSubjectApiDto(
      classSubjectId: freezed == classSubjectId
          ? _self.classSubjectId
          : classSubjectId // ignore: cast_nullable_to_non_nullable
              as int?,
      subjectId: freezed == subjectId
          ? _self.subjectId
          : subjectId // ignore: cast_nullable_to_non_nullable
              as int?,
      subject: freezed == subject
          ? _self.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as SubjectApiDto?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      classField: freezed == classField
          ? _self.classField
          : classField // ignore: cast_nullable_to_non_nullable
              as ClassRefApiDto?,
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      teacher: freezed == teacher
          ? _self.teacher
          : teacher // ignore: cast_nullable_to_non_nullable
              as TeacherApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SubjectApiDtoCopyWith<$Res>? get subject {
    if (_self.subject == null) {
      return null;
    }

    return $SubjectApiDtoCopyWith<$Res>(_self.subject!, (value) {
      return _then(_self.copyWith(subject: value));
    });
  }

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClassRefApiDtoCopyWith<$Res>? get classField {
    if (_self.classField == null) {
      return null;
    }

    return $ClassRefApiDtoCopyWith<$Res>(_self.classField!, (value) {
      return _then(_self.copyWith(classField: value));
    });
  }

  /// Create a copy of ClassSubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TeacherApiDtoCopyWith<$Res>? get teacher {
    if (_self.teacher == null) {
      return null;
    }

    return $TeacherApiDtoCopyWith<$Res>(_self.teacher!, (value) {
      return _then(_self.copyWith(teacher: value));
    });
  }
}

/// @nodoc
mixin _$CompanyApiDto {
  @JsonKey(name: 'companyId')
  int? get companyId;
  @JsonKey(name: 'code')
  String? get code;
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'account')
  AccountApiDto? get account;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of CompanyApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompanyApiDtoCopyWith<CompanyApiDto> get copyWith =>
      _$CompanyApiDtoCopyWithImpl<CompanyApiDto>(
          this as CompanyApiDto, _$identity);

  /// Serializes this CompanyApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompanyApiDto &&
            (identical(other.companyId, companyId) ||
                other.companyId == companyId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      companyId,
      code,
      accountId,
      account,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'CompanyApiDto(companyId: $companyId, code: $code, accountId: $accountId, account: $account, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $CompanyApiDtoCopyWith<$Res> {
  factory $CompanyApiDtoCopyWith(
          CompanyApiDto value, $Res Function(CompanyApiDto) _then) =
      _$CompanyApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'companyId') int? companyId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto? account,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $AccountApiDtoCopyWith<$Res>? get account;
}

/// @nodoc
class _$CompanyApiDtoCopyWithImpl<$Res>
    implements $CompanyApiDtoCopyWith<$Res> {
  _$CompanyApiDtoCopyWithImpl(this._self, this._then);

  final CompanyApiDto _self;
  final $Res Function(CompanyApiDto) _then;

  /// Create a copy of CompanyApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? companyId = freezed,
    Object? code = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      companyId: freezed == companyId
          ? _self.companyId
          : companyId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of CompanyApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CompanyApiDto].
extension CompanyApiDtoPatterns on CompanyApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CompanyApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompanyApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CompanyApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompanyApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CompanyApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompanyApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'companyId') int? companyId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto? account,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompanyApiDto() when $default != null:
        return $default(
            _that.companyId,
            _that.code,
            _that.accountId,
            _that.account,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'companyId') int? companyId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto? account,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompanyApiDto():
        return $default(
            _that.companyId,
            _that.code,
            _that.accountId,
            _that.account,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'companyId') int? companyId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto? account,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompanyApiDto() when $default != null:
        return $default(
            _that.companyId,
            _that.code,
            _that.accountId,
            _that.account,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CompanyApiDto implements CompanyApiDto {
  _CompanyApiDto(
      {@JsonKey(name: 'companyId') this.companyId,
      @JsonKey(name: 'code') this.code,
      @JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'account') this.account,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _CompanyApiDto.fromJson(Map<String, dynamic> json) =>
      _$CompanyApiDtoFromJson(json);

  @override
  @JsonKey(name: 'companyId')
  final int? companyId;
  @override
  @JsonKey(name: 'code')
  final String? code;
  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'account')
  final AccountApiDto? account;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of CompanyApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CompanyApiDtoCopyWith<_CompanyApiDto> get copyWith =>
      __$CompanyApiDtoCopyWithImpl<_CompanyApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompanyApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CompanyApiDto &&
            (identical(other.companyId, companyId) ||
                other.companyId == companyId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      companyId,
      code,
      accountId,
      account,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'CompanyApiDto(companyId: $companyId, code: $code, accountId: $accountId, account: $account, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$CompanyApiDtoCopyWith<$Res>
    implements $CompanyApiDtoCopyWith<$Res> {
  factory _$CompanyApiDtoCopyWith(
          _CompanyApiDto value, $Res Function(_CompanyApiDto) _then) =
      __$CompanyApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'companyId') int? companyId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto? account,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $AccountApiDtoCopyWith<$Res>? get account;
}

/// @nodoc
class __$CompanyApiDtoCopyWithImpl<$Res>
    implements _$CompanyApiDtoCopyWith<$Res> {
  __$CompanyApiDtoCopyWithImpl(this._self, this._then);

  final _CompanyApiDto _self;
  final $Res Function(_CompanyApiDto) _then;

  /// Create a copy of CompanyApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? companyId = freezed,
    Object? code = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_CompanyApiDto(
      companyId: freezed == companyId
          ? _self.companyId
          : companyId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of CompanyApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// @nodoc
mixin _$ContactApiDto {
  @JsonKey(name: 'contactId')
  int? get contactId;
  @JsonKey(name: 'contactType')
  int? get contactType;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'email')
  String? get email;
  @JsonKey(name: 'phoneNumber')
  String? get phoneNumber;
  @JsonKey(name: 'addressId')
  int? get addressId;
  @JsonKey(name: 'address')
  AddressApiDto? get address;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of ContactApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ContactApiDtoCopyWith<ContactApiDto> get copyWith =>
      _$ContactApiDtoCopyWithImpl<ContactApiDto>(
          this as ContactApiDto, _$identity);

  /// Serializes this ContactApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ContactApiDto &&
            (identical(other.contactId, contactId) ||
                other.contactId == contactId) &&
            (identical(other.contactType, contactType) ||
                other.contactType == contactType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.addressId, addressId) ||
                other.addressId == addressId) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      contactId,
      contactType,
      name,
      email,
      phoneNumber,
      addressId,
      address,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ContactApiDto(contactId: $contactId, contactType: $contactType, name: $name, email: $email, phoneNumber: $phoneNumber, addressId: $addressId, address: $address, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $ContactApiDtoCopyWith<$Res> {
  factory $ContactApiDtoCopyWith(
          ContactApiDto value, $Res Function(ContactApiDto) _then) =
      _$ContactApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'contactId') int? contactId,
      @JsonKey(name: 'contactType') int? contactType,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'addressId') int? addressId,
      @JsonKey(name: 'address') AddressApiDto? address,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $AddressApiDtoCopyWith<$Res>? get address;
}

/// @nodoc
class _$ContactApiDtoCopyWithImpl<$Res>
    implements $ContactApiDtoCopyWith<$Res> {
  _$ContactApiDtoCopyWithImpl(this._self, this._then);

  final ContactApiDto _self;
  final $Res Function(ContactApiDto) _then;

  /// Create a copy of ContactApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contactId = freezed,
    Object? contactType = freezed,
    Object? name = freezed,
    Object? email = freezed,
    Object? phoneNumber = freezed,
    Object? addressId = freezed,
    Object? address = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      contactId: freezed == contactId
          ? _self.contactId
          : contactId // ignore: cast_nullable_to_non_nullable
              as int?,
      contactType: freezed == contactType
          ? _self.contactType
          : contactType // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      addressId: freezed == addressId
          ? _self.addressId
          : addressId // ignore: cast_nullable_to_non_nullable
              as int?,
      address: freezed == address
          ? _self.address
          : address // ignore: cast_nullable_to_non_nullable
              as AddressApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ContactApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AddressApiDtoCopyWith<$Res>? get address {
    if (_self.address == null) {
      return null;
    }

    return $AddressApiDtoCopyWith<$Res>(_self.address!, (value) {
      return _then(_self.copyWith(address: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ContactApiDto].
extension ContactApiDtoPatterns on ContactApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ContactApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ContactApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ContactApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ContactApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'contactId') int? contactId,
            @JsonKey(name: 'contactType') int? contactType,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'addressId') int? addressId,
            @JsonKey(name: 'address') AddressApiDto? address,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ContactApiDto() when $default != null:
        return $default(
            _that.contactId,
            _that.contactType,
            _that.name,
            _that.email,
            _that.phoneNumber,
            _that.addressId,
            _that.address,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'contactId') int? contactId,
            @JsonKey(name: 'contactType') int? contactType,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'addressId') int? addressId,
            @JsonKey(name: 'address') AddressApiDto? address,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactApiDto():
        return $default(
            _that.contactId,
            _that.contactType,
            _that.name,
            _that.email,
            _that.phoneNumber,
            _that.addressId,
            _that.address,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'contactId') int? contactId,
            @JsonKey(name: 'contactType') int? contactType,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'addressId') int? addressId,
            @JsonKey(name: 'address') AddressApiDto? address,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContactApiDto() when $default != null:
        return $default(
            _that.contactId,
            _that.contactType,
            _that.name,
            _that.email,
            _that.phoneNumber,
            _that.addressId,
            _that.address,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ContactApiDto implements ContactApiDto {
  _ContactApiDto(
      {@JsonKey(name: 'contactId') this.contactId,
      @JsonKey(name: 'contactType') this.contactType,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'email') this.email,
      @JsonKey(name: 'phoneNumber') this.phoneNumber,
      @JsonKey(name: 'addressId') this.addressId,
      @JsonKey(name: 'address') this.address,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _ContactApiDto.fromJson(Map<String, dynamic> json) =>
      _$ContactApiDtoFromJson(json);

  @override
  @JsonKey(name: 'contactId')
  final int? contactId;
  @override
  @JsonKey(name: 'contactType')
  final int? contactType;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'email')
  final String? email;
  @override
  @JsonKey(name: 'phoneNumber')
  final String? phoneNumber;
  @override
  @JsonKey(name: 'addressId')
  final int? addressId;
  @override
  @JsonKey(name: 'address')
  final AddressApiDto? address;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of ContactApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ContactApiDtoCopyWith<_ContactApiDto> get copyWith =>
      __$ContactApiDtoCopyWithImpl<_ContactApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ContactApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ContactApiDto &&
            (identical(other.contactId, contactId) ||
                other.contactId == contactId) &&
            (identical(other.contactType, contactType) ||
                other.contactType == contactType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.addressId, addressId) ||
                other.addressId == addressId) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      contactId,
      contactType,
      name,
      email,
      phoneNumber,
      addressId,
      address,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ContactApiDto(contactId: $contactId, contactType: $contactType, name: $name, email: $email, phoneNumber: $phoneNumber, addressId: $addressId, address: $address, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$ContactApiDtoCopyWith<$Res>
    implements $ContactApiDtoCopyWith<$Res> {
  factory _$ContactApiDtoCopyWith(
          _ContactApiDto value, $Res Function(_ContactApiDto) _then) =
      __$ContactApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'contactId') int? contactId,
      @JsonKey(name: 'contactType') int? contactType,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'addressId') int? addressId,
      @JsonKey(name: 'address') AddressApiDto? address,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $AddressApiDtoCopyWith<$Res>? get address;
}

/// @nodoc
class __$ContactApiDtoCopyWithImpl<$Res>
    implements _$ContactApiDtoCopyWith<$Res> {
  __$ContactApiDtoCopyWithImpl(this._self, this._then);

  final _ContactApiDto _self;
  final $Res Function(_ContactApiDto) _then;

  /// Create a copy of ContactApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? contactId = freezed,
    Object? contactType = freezed,
    Object? name = freezed,
    Object? email = freezed,
    Object? phoneNumber = freezed,
    Object? addressId = freezed,
    Object? address = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_ContactApiDto(
      contactId: freezed == contactId
          ? _self.contactId
          : contactId // ignore: cast_nullable_to_non_nullable
              as int?,
      contactType: freezed == contactType
          ? _self.contactType
          : contactType // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      addressId: freezed == addressId
          ? _self.addressId
          : addressId // ignore: cast_nullable_to_non_nullable
              as int?,
      address: freezed == address
          ? _self.address
          : address // ignore: cast_nullable_to_non_nullable
              as AddressApiDto?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of ContactApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AddressApiDtoCopyWith<$Res>? get address {
    if (_self.address == null) {
      return null;
    }

    return $AddressApiDtoCopyWith<$Res>(_self.address!, (value) {
      return _then(_self.copyWith(address: value));
    });
  }
}

/// @nodoc
mixin _$ContentApiDto {
  @JsonKey(name: 'studentContentId')
  int? get studentContentId;
  @JsonKey(name: 'students')
  List<int>? get students;
  @JsonKey(name: 'classes')
  List<int>? get classes;
  @JsonKey(name: 'levels')
  List<int>? get levels;
  @JsonKey(name: 'learningDomains')
  List<int>? get learningDomains;
  @JsonKey(name: 'contentTitle')
  String? get contentTitle;
  @JsonKey(name: 'contentBody')
  String? get contentBody;
  @JsonKey(name: 'activityDateTime')
  DateTime? get activityDateTime;
  @JsonKey(name: 'contentType')
  int? get contentType;
  @JsonKey(name: 'publishDate')
  DateTime? get publishDate;
  @JsonKey(name: 'includeFutureEnrolment')
  bool? get includeFutureEnrolment;
  @JsonKey(name: 'attachmentFolderClassId')
  int? get attachmentFolderClassId;
  @JsonKey(name: 'attachmentFolder')
  String? get attachmentFolder;
  @JsonKey(name: 'defaultUrl')
  String? get defaultUrl;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of ContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ContentApiDtoCopyWith<ContentApiDto> get copyWith =>
      _$ContentApiDtoCopyWithImpl<ContentApiDto>(
          this as ContentApiDto, _$identity);

  /// Serializes this ContentApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ContentApiDto &&
            (identical(other.studentContentId, studentContentId) ||
                other.studentContentId == studentContentId) &&
            const DeepCollectionEquality().equals(other.students, students) &&
            const DeepCollectionEquality().equals(other.classes, classes) &&
            const DeepCollectionEquality().equals(other.levels, levels) &&
            const DeepCollectionEquality()
                .equals(other.learningDomains, learningDomains) &&
            (identical(other.contentTitle, contentTitle) ||
                other.contentTitle == contentTitle) &&
            (identical(other.contentBody, contentBody) ||
                other.contentBody == contentBody) &&
            (identical(other.activityDateTime, activityDateTime) ||
                other.activityDateTime == activityDateTime) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.publishDate, publishDate) ||
                other.publishDate == publishDate) &&
            (identical(other.includeFutureEnrolment, includeFutureEnrolment) ||
                other.includeFutureEnrolment == includeFutureEnrolment) &&
            (identical(
                    other.attachmentFolderClassId, attachmentFolderClassId) ||
                other.attachmentFolderClassId == attachmentFolderClassId) &&
            (identical(other.attachmentFolder, attachmentFolder) ||
                other.attachmentFolder == attachmentFolder) &&
            (identical(other.defaultUrl, defaultUrl) ||
                other.defaultUrl == defaultUrl) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        studentContentId,
        const DeepCollectionEquality().hash(students),
        const DeepCollectionEquality().hash(classes),
        const DeepCollectionEquality().hash(levels),
        const DeepCollectionEquality().hash(learningDomains),
        contentTitle,
        contentBody,
        activityDateTime,
        contentType,
        publishDate,
        includeFutureEnrolment,
        attachmentFolderClassId,
        attachmentFolder,
        defaultUrl,
        branchId,
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'ContentApiDto(studentContentId: $studentContentId, students: $students, classes: $classes, levels: $levels, learningDomains: $learningDomains, contentTitle: $contentTitle, contentBody: $contentBody, activityDateTime: $activityDateTime, contentType: $contentType, publishDate: $publishDate, includeFutureEnrolment: $includeFutureEnrolment, attachmentFolderClassId: $attachmentFolderClassId, attachmentFolder: $attachmentFolder, defaultUrl: $defaultUrl, branchId: $branchId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $ContentApiDtoCopyWith<$Res> {
  factory $ContentApiDtoCopyWith(
          ContentApiDto value, $Res Function(ContentApiDto) _then) =
      _$ContentApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentContentId') int? studentContentId,
      @JsonKey(name: 'students') List<int>? students,
      @JsonKey(name: 'classes') List<int>? classes,
      @JsonKey(name: 'levels') List<int>? levels,
      @JsonKey(name: 'learningDomains') List<int>? learningDomains,
      @JsonKey(name: 'contentTitle') String? contentTitle,
      @JsonKey(name: 'contentBody') String? contentBody,
      @JsonKey(name: 'activityDateTime') DateTime? activityDateTime,
      @JsonKey(name: 'contentType') int? contentType,
      @JsonKey(name: 'publishDate') DateTime? publishDate,
      @JsonKey(name: 'includeFutureEnrolment') bool? includeFutureEnrolment,
      @JsonKey(name: 'attachmentFolderClassId') int? attachmentFolderClassId,
      @JsonKey(name: 'attachmentFolder') String? attachmentFolder,
      @JsonKey(name: 'defaultUrl') String? defaultUrl,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$ContentApiDtoCopyWithImpl<$Res>
    implements $ContentApiDtoCopyWith<$Res> {
  _$ContentApiDtoCopyWithImpl(this._self, this._then);

  final ContentApiDto _self;
  final $Res Function(ContentApiDto) _then;

  /// Create a copy of ContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentContentId = freezed,
    Object? students = freezed,
    Object? classes = freezed,
    Object? levels = freezed,
    Object? learningDomains = freezed,
    Object? contentTitle = freezed,
    Object? contentBody = freezed,
    Object? activityDateTime = freezed,
    Object? contentType = freezed,
    Object? publishDate = freezed,
    Object? includeFutureEnrolment = freezed,
    Object? attachmentFolderClassId = freezed,
    Object? attachmentFolder = freezed,
    Object? defaultUrl = freezed,
    Object? branchId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      studentContentId: freezed == studentContentId
          ? _self.studentContentId
          : studentContentId // ignore: cast_nullable_to_non_nullable
              as int?,
      students: freezed == students
          ? _self.students
          : students // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      classes: freezed == classes
          ? _self.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      levels: freezed == levels
          ? _self.levels
          : levels // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      learningDomains: freezed == learningDomains
          ? _self.learningDomains
          : learningDomains // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      contentTitle: freezed == contentTitle
          ? _self.contentTitle
          : contentTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      contentBody: freezed == contentBody
          ? _self.contentBody
          : contentBody // ignore: cast_nullable_to_non_nullable
              as String?,
      activityDateTime: freezed == activityDateTime
          ? _self.activityDateTime
          : activityDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as int?,
      publishDate: freezed == publishDate
          ? _self.publishDate
          : publishDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      includeFutureEnrolment: freezed == includeFutureEnrolment
          ? _self.includeFutureEnrolment
          : includeFutureEnrolment // ignore: cast_nullable_to_non_nullable
              as bool?,
      attachmentFolderClassId: freezed == attachmentFolderClassId
          ? _self.attachmentFolderClassId
          : attachmentFolderClassId // ignore: cast_nullable_to_non_nullable
              as int?,
      attachmentFolder: freezed == attachmentFolder
          ? _self.attachmentFolder
          : attachmentFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultUrl: freezed == defaultUrl
          ? _self.defaultUrl
          : defaultUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ContentApiDto].
extension ContentApiDtoPatterns on ContentApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ContentApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ContentApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ContentApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContentApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ContentApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContentApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentContentId') int? studentContentId,
            @JsonKey(name: 'students') List<int>? students,
            @JsonKey(name: 'classes') List<int>? classes,
            @JsonKey(name: 'levels') List<int>? levels,
            @JsonKey(name: 'learningDomains') List<int>? learningDomains,
            @JsonKey(name: 'contentTitle') String? contentTitle,
            @JsonKey(name: 'contentBody') String? contentBody,
            @JsonKey(name: 'activityDateTime') DateTime? activityDateTime,
            @JsonKey(name: 'contentType') int? contentType,
            @JsonKey(name: 'publishDate') DateTime? publishDate,
            @JsonKey(name: 'includeFutureEnrolment')
            bool? includeFutureEnrolment,
            @JsonKey(name: 'attachmentFolderClassId')
            int? attachmentFolderClassId,
            @JsonKey(name: 'attachmentFolder') String? attachmentFolder,
            @JsonKey(name: 'defaultUrl') String? defaultUrl,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ContentApiDto() when $default != null:
        return $default(
            _that.studentContentId,
            _that.students,
            _that.classes,
            _that.levels,
            _that.learningDomains,
            _that.contentTitle,
            _that.contentBody,
            _that.activityDateTime,
            _that.contentType,
            _that.publishDate,
            _that.includeFutureEnrolment,
            _that.attachmentFolderClassId,
            _that.attachmentFolder,
            _that.defaultUrl,
            _that.branchId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentContentId') int? studentContentId,
            @JsonKey(name: 'students') List<int>? students,
            @JsonKey(name: 'classes') List<int>? classes,
            @JsonKey(name: 'levels') List<int>? levels,
            @JsonKey(name: 'learningDomains') List<int>? learningDomains,
            @JsonKey(name: 'contentTitle') String? contentTitle,
            @JsonKey(name: 'contentBody') String? contentBody,
            @JsonKey(name: 'activityDateTime') DateTime? activityDateTime,
            @JsonKey(name: 'contentType') int? contentType,
            @JsonKey(name: 'publishDate') DateTime? publishDate,
            @JsonKey(name: 'includeFutureEnrolment')
            bool? includeFutureEnrolment,
            @JsonKey(name: 'attachmentFolderClassId')
            int? attachmentFolderClassId,
            @JsonKey(name: 'attachmentFolder') String? attachmentFolder,
            @JsonKey(name: 'defaultUrl') String? defaultUrl,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContentApiDto():
        return $default(
            _that.studentContentId,
            _that.students,
            _that.classes,
            _that.levels,
            _that.learningDomains,
            _that.contentTitle,
            _that.contentBody,
            _that.activityDateTime,
            _that.contentType,
            _that.publishDate,
            _that.includeFutureEnrolment,
            _that.attachmentFolderClassId,
            _that.attachmentFolder,
            _that.defaultUrl,
            _that.branchId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentContentId') int? studentContentId,
            @JsonKey(name: 'students') List<int>? students,
            @JsonKey(name: 'classes') List<int>? classes,
            @JsonKey(name: 'levels') List<int>? levels,
            @JsonKey(name: 'learningDomains') List<int>? learningDomains,
            @JsonKey(name: 'contentTitle') String? contentTitle,
            @JsonKey(name: 'contentBody') String? contentBody,
            @JsonKey(name: 'activityDateTime') DateTime? activityDateTime,
            @JsonKey(name: 'contentType') int? contentType,
            @JsonKey(name: 'publishDate') DateTime? publishDate,
            @JsonKey(name: 'includeFutureEnrolment')
            bool? includeFutureEnrolment,
            @JsonKey(name: 'attachmentFolderClassId')
            int? attachmentFolderClassId,
            @JsonKey(name: 'attachmentFolder') String? attachmentFolder,
            @JsonKey(name: 'defaultUrl') String? defaultUrl,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ContentApiDto() when $default != null:
        return $default(
            _that.studentContentId,
            _that.students,
            _that.classes,
            _that.levels,
            _that.learningDomains,
            _that.contentTitle,
            _that.contentBody,
            _that.activityDateTime,
            _that.contentType,
            _that.publishDate,
            _that.includeFutureEnrolment,
            _that.attachmentFolderClassId,
            _that.attachmentFolder,
            _that.defaultUrl,
            _that.branchId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ContentApiDto implements ContentApiDto {
  _ContentApiDto(
      {@JsonKey(name: 'studentContentId') this.studentContentId,
      @JsonKey(name: 'students') final List<int>? students,
      @JsonKey(name: 'classes') final List<int>? classes,
      @JsonKey(name: 'levels') final List<int>? levels,
      @JsonKey(name: 'learningDomains') final List<int>? learningDomains,
      @JsonKey(name: 'contentTitle') this.contentTitle,
      @JsonKey(name: 'contentBody') this.contentBody,
      @JsonKey(name: 'activityDateTime') this.activityDateTime,
      @JsonKey(name: 'contentType') this.contentType,
      @JsonKey(name: 'publishDate') this.publishDate,
      @JsonKey(name: 'includeFutureEnrolment') this.includeFutureEnrolment,
      @JsonKey(name: 'attachmentFolderClassId') this.attachmentFolderClassId,
      @JsonKey(name: 'attachmentFolder') this.attachmentFolder,
      @JsonKey(name: 'defaultUrl') this.defaultUrl,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _students = students,
        _classes = classes,
        _levels = levels,
        _learningDomains = learningDomains;
  factory _ContentApiDto.fromJson(Map<String, dynamic> json) =>
      _$ContentApiDtoFromJson(json);

  @override
  @JsonKey(name: 'studentContentId')
  final int? studentContentId;
  final List<int>? _students;
  @override
  @JsonKey(name: 'students')
  List<int>? get students {
    final value = _students;
    if (value == null) return null;
    if (_students is EqualUnmodifiableListView) return _students;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int>? _classes;
  @override
  @JsonKey(name: 'classes')
  List<int>? get classes {
    final value = _classes;
    if (value == null) return null;
    if (_classes is EqualUnmodifiableListView) return _classes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int>? _levels;
  @override
  @JsonKey(name: 'levels')
  List<int>? get levels {
    final value = _levels;
    if (value == null) return null;
    if (_levels is EqualUnmodifiableListView) return _levels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int>? _learningDomains;
  @override
  @JsonKey(name: 'learningDomains')
  List<int>? get learningDomains {
    final value = _learningDomains;
    if (value == null) return null;
    if (_learningDomains is EqualUnmodifiableListView) return _learningDomains;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'contentTitle')
  final String? contentTitle;
  @override
  @JsonKey(name: 'contentBody')
  final String? contentBody;
  @override
  @JsonKey(name: 'activityDateTime')
  final DateTime? activityDateTime;
  @override
  @JsonKey(name: 'contentType')
  final int? contentType;
  @override
  @JsonKey(name: 'publishDate')
  final DateTime? publishDate;
  @override
  @JsonKey(name: 'includeFutureEnrolment')
  final bool? includeFutureEnrolment;
  @override
  @JsonKey(name: 'attachmentFolderClassId')
  final int? attachmentFolderClassId;
  @override
  @JsonKey(name: 'attachmentFolder')
  final String? attachmentFolder;
  @override
  @JsonKey(name: 'defaultUrl')
  final String? defaultUrl;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of ContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ContentApiDtoCopyWith<_ContentApiDto> get copyWith =>
      __$ContentApiDtoCopyWithImpl<_ContentApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ContentApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ContentApiDto &&
            (identical(other.studentContentId, studentContentId) ||
                other.studentContentId == studentContentId) &&
            const DeepCollectionEquality().equals(other._students, _students) &&
            const DeepCollectionEquality().equals(other._classes, _classes) &&
            const DeepCollectionEquality().equals(other._levels, _levels) &&
            const DeepCollectionEquality()
                .equals(other._learningDomains, _learningDomains) &&
            (identical(other.contentTitle, contentTitle) ||
                other.contentTitle == contentTitle) &&
            (identical(other.contentBody, contentBody) ||
                other.contentBody == contentBody) &&
            (identical(other.activityDateTime, activityDateTime) ||
                other.activityDateTime == activityDateTime) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.publishDate, publishDate) ||
                other.publishDate == publishDate) &&
            (identical(other.includeFutureEnrolment, includeFutureEnrolment) ||
                other.includeFutureEnrolment == includeFutureEnrolment) &&
            (identical(
                    other.attachmentFolderClassId, attachmentFolderClassId) ||
                other.attachmentFolderClassId == attachmentFolderClassId) &&
            (identical(other.attachmentFolder, attachmentFolder) ||
                other.attachmentFolder == attachmentFolder) &&
            (identical(other.defaultUrl, defaultUrl) ||
                other.defaultUrl == defaultUrl) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        studentContentId,
        const DeepCollectionEquality().hash(_students),
        const DeepCollectionEquality().hash(_classes),
        const DeepCollectionEquality().hash(_levels),
        const DeepCollectionEquality().hash(_learningDomains),
        contentTitle,
        contentBody,
        activityDateTime,
        contentType,
        publishDate,
        includeFutureEnrolment,
        attachmentFolderClassId,
        attachmentFolder,
        defaultUrl,
        branchId,
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'ContentApiDto(studentContentId: $studentContentId, students: $students, classes: $classes, levels: $levels, learningDomains: $learningDomains, contentTitle: $contentTitle, contentBody: $contentBody, activityDateTime: $activityDateTime, contentType: $contentType, publishDate: $publishDate, includeFutureEnrolment: $includeFutureEnrolment, attachmentFolderClassId: $attachmentFolderClassId, attachmentFolder: $attachmentFolder, defaultUrl: $defaultUrl, branchId: $branchId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$ContentApiDtoCopyWith<$Res>
    implements $ContentApiDtoCopyWith<$Res> {
  factory _$ContentApiDtoCopyWith(
          _ContentApiDto value, $Res Function(_ContentApiDto) _then) =
      __$ContentApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentContentId') int? studentContentId,
      @JsonKey(name: 'students') List<int>? students,
      @JsonKey(name: 'classes') List<int>? classes,
      @JsonKey(name: 'levels') List<int>? levels,
      @JsonKey(name: 'learningDomains') List<int>? learningDomains,
      @JsonKey(name: 'contentTitle') String? contentTitle,
      @JsonKey(name: 'contentBody') String? contentBody,
      @JsonKey(name: 'activityDateTime') DateTime? activityDateTime,
      @JsonKey(name: 'contentType') int? contentType,
      @JsonKey(name: 'publishDate') DateTime? publishDate,
      @JsonKey(name: 'includeFutureEnrolment') bool? includeFutureEnrolment,
      @JsonKey(name: 'attachmentFolderClassId') int? attachmentFolderClassId,
      @JsonKey(name: 'attachmentFolder') String? attachmentFolder,
      @JsonKey(name: 'defaultUrl') String? defaultUrl,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$ContentApiDtoCopyWithImpl<$Res>
    implements _$ContentApiDtoCopyWith<$Res> {
  __$ContentApiDtoCopyWithImpl(this._self, this._then);

  final _ContentApiDto _self;
  final $Res Function(_ContentApiDto) _then;

  /// Create a copy of ContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentContentId = freezed,
    Object? students = freezed,
    Object? classes = freezed,
    Object? levels = freezed,
    Object? learningDomains = freezed,
    Object? contentTitle = freezed,
    Object? contentBody = freezed,
    Object? activityDateTime = freezed,
    Object? contentType = freezed,
    Object? publishDate = freezed,
    Object? includeFutureEnrolment = freezed,
    Object? attachmentFolderClassId = freezed,
    Object? attachmentFolder = freezed,
    Object? defaultUrl = freezed,
    Object? branchId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_ContentApiDto(
      studentContentId: freezed == studentContentId
          ? _self.studentContentId
          : studentContentId // ignore: cast_nullable_to_non_nullable
              as int?,
      students: freezed == students
          ? _self._students
          : students // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      classes: freezed == classes
          ? _self._classes
          : classes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      levels: freezed == levels
          ? _self._levels
          : levels // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      learningDomains: freezed == learningDomains
          ? _self._learningDomains
          : learningDomains // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      contentTitle: freezed == contentTitle
          ? _self.contentTitle
          : contentTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      contentBody: freezed == contentBody
          ? _self.contentBody
          : contentBody // ignore: cast_nullable_to_non_nullable
              as String?,
      activityDateTime: freezed == activityDateTime
          ? _self.activityDateTime
          : activityDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      contentType: freezed == contentType
          ? _self.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as int?,
      publishDate: freezed == publishDate
          ? _self.publishDate
          : publishDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      includeFutureEnrolment: freezed == includeFutureEnrolment
          ? _self.includeFutureEnrolment
          : includeFutureEnrolment // ignore: cast_nullable_to_non_nullable
              as bool?,
      attachmentFolderClassId: freezed == attachmentFolderClassId
          ? _self.attachmentFolderClassId
          : attachmentFolderClassId // ignore: cast_nullable_to_non_nullable
              as int?,
      attachmentFolder: freezed == attachmentFolder
          ? _self.attachmentFolder
          : attachmentFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultUrl: freezed == defaultUrl
          ? _self.defaultUrl
          : defaultUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$ConversationApiDto {
  @JsonKey(name: 'conversationId')
  int? get conversationId;
  @JsonKey(name: 'topic')
  String get topic;
  @JsonKey(name: 'isClosed')
  bool? get isClosed;
  @JsonKey(name: 'dateClosed')
  DateTime? get dateClosed;
  @JsonKey(name: 'initiatorAccountId')
  int? get initiatorAccountId;
  @JsonKey(name: 'recipientAccountId')
  int? get recipientAccountId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of ConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ConversationApiDtoCopyWith<ConversationApiDto> get copyWith =>
      _$ConversationApiDtoCopyWithImpl<ConversationApiDto>(
          this as ConversationApiDto, _$identity);

  /// Serializes this ConversationApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConversationApiDto &&
            (identical(other.conversationId, conversationId) ||
                other.conversationId == conversationId) &&
            (identical(other.topic, topic) || other.topic == topic) &&
            (identical(other.isClosed, isClosed) ||
                other.isClosed == isClosed) &&
            (identical(other.dateClosed, dateClosed) ||
                other.dateClosed == dateClosed) &&
            (identical(other.initiatorAccountId, initiatorAccountId) ||
                other.initiatorAccountId == initiatorAccountId) &&
            (identical(other.recipientAccountId, recipientAccountId) ||
                other.recipientAccountId == recipientAccountId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      conversationId,
      topic,
      isClosed,
      dateClosed,
      initiatorAccountId,
      recipientAccountId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ConversationApiDto(conversationId: $conversationId, topic: $topic, isClosed: $isClosed, dateClosed: $dateClosed, initiatorAccountId: $initiatorAccountId, recipientAccountId: $recipientAccountId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $ConversationApiDtoCopyWith<$Res> {
  factory $ConversationApiDtoCopyWith(
          ConversationApiDto value, $Res Function(ConversationApiDto) _then) =
      _$ConversationApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'conversationId') int? conversationId,
      @JsonKey(name: 'topic') String topic,
      @JsonKey(name: 'isClosed') bool? isClosed,
      @JsonKey(name: 'dateClosed') DateTime? dateClosed,
      @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
      @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$ConversationApiDtoCopyWithImpl<$Res>
    implements $ConversationApiDtoCopyWith<$Res> {
  _$ConversationApiDtoCopyWithImpl(this._self, this._then);

  final ConversationApiDto _self;
  final $Res Function(ConversationApiDto) _then;

  /// Create a copy of ConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? conversationId = freezed,
    Object? topic = null,
    Object? isClosed = freezed,
    Object? dateClosed = freezed,
    Object? initiatorAccountId = freezed,
    Object? recipientAccountId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      conversationId: freezed == conversationId
          ? _self.conversationId
          : conversationId // ignore: cast_nullable_to_non_nullable
              as int?,
      topic: null == topic
          ? _self.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as String,
      isClosed: freezed == isClosed
          ? _self.isClosed
          : isClosed // ignore: cast_nullable_to_non_nullable
              as bool?,
      dateClosed: freezed == dateClosed
          ? _self.dateClosed
          : dateClosed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      initiatorAccountId: freezed == initiatorAccountId
          ? _self.initiatorAccountId
          : initiatorAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      recipientAccountId: freezed == recipientAccountId
          ? _self.recipientAccountId
          : recipientAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ConversationApiDto].
extension ConversationApiDtoPatterns on ConversationApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ConversationApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ConversationApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ConversationApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'topic') String topic,
            @JsonKey(name: 'isClosed') bool? isClosed,
            @JsonKey(name: 'dateClosed') DateTime? dateClosed,
            @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationApiDto() when $default != null:
        return $default(
            _that.conversationId,
            _that.topic,
            _that.isClosed,
            _that.dateClosed,
            _that.initiatorAccountId,
            _that.recipientAccountId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'topic') String topic,
            @JsonKey(name: 'isClosed') bool? isClosed,
            @JsonKey(name: 'dateClosed') DateTime? dateClosed,
            @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationApiDto():
        return $default(
            _that.conversationId,
            _that.topic,
            _that.isClosed,
            _that.dateClosed,
            _that.initiatorAccountId,
            _that.recipientAccountId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'topic') String topic,
            @JsonKey(name: 'isClosed') bool? isClosed,
            @JsonKey(name: 'dateClosed') DateTime? dateClosed,
            @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationApiDto() when $default != null:
        return $default(
            _that.conversationId,
            _that.topic,
            _that.isClosed,
            _that.dateClosed,
            _that.initiatorAccountId,
            _that.recipientAccountId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ConversationApiDto implements ConversationApiDto {
  _ConversationApiDto(
      {@JsonKey(name: 'conversationId') this.conversationId,
      @JsonKey(name: 'topic') required this.topic,
      @JsonKey(name: 'isClosed') this.isClosed,
      @JsonKey(name: 'dateClosed') this.dateClosed,
      @JsonKey(name: 'initiatorAccountId') this.initiatorAccountId,
      @JsonKey(name: 'recipientAccountId') this.recipientAccountId,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _ConversationApiDto.fromJson(Map<String, dynamic> json) =>
      _$ConversationApiDtoFromJson(json);

  @override
  @JsonKey(name: 'conversationId')
  final int? conversationId;
  @override
  @JsonKey(name: 'topic')
  final String topic;
  @override
  @JsonKey(name: 'isClosed')
  final bool? isClosed;
  @override
  @JsonKey(name: 'dateClosed')
  final DateTime? dateClosed;
  @override
  @JsonKey(name: 'initiatorAccountId')
  final int? initiatorAccountId;
  @override
  @JsonKey(name: 'recipientAccountId')
  final int? recipientAccountId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of ConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ConversationApiDtoCopyWith<_ConversationApiDto> get copyWith =>
      __$ConversationApiDtoCopyWithImpl<_ConversationApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ConversationApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ConversationApiDto &&
            (identical(other.conversationId, conversationId) ||
                other.conversationId == conversationId) &&
            (identical(other.topic, topic) || other.topic == topic) &&
            (identical(other.isClosed, isClosed) ||
                other.isClosed == isClosed) &&
            (identical(other.dateClosed, dateClosed) ||
                other.dateClosed == dateClosed) &&
            (identical(other.initiatorAccountId, initiatorAccountId) ||
                other.initiatorAccountId == initiatorAccountId) &&
            (identical(other.recipientAccountId, recipientAccountId) ||
                other.recipientAccountId == recipientAccountId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      conversationId,
      topic,
      isClosed,
      dateClosed,
      initiatorAccountId,
      recipientAccountId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ConversationApiDto(conversationId: $conversationId, topic: $topic, isClosed: $isClosed, dateClosed: $dateClosed, initiatorAccountId: $initiatorAccountId, recipientAccountId: $recipientAccountId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$ConversationApiDtoCopyWith<$Res>
    implements $ConversationApiDtoCopyWith<$Res> {
  factory _$ConversationApiDtoCopyWith(
          _ConversationApiDto value, $Res Function(_ConversationApiDto) _then) =
      __$ConversationApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'conversationId') int? conversationId,
      @JsonKey(name: 'topic') String topic,
      @JsonKey(name: 'isClosed') bool? isClosed,
      @JsonKey(name: 'dateClosed') DateTime? dateClosed,
      @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
      @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$ConversationApiDtoCopyWithImpl<$Res>
    implements _$ConversationApiDtoCopyWith<$Res> {
  __$ConversationApiDtoCopyWithImpl(this._self, this._then);

  final _ConversationApiDto _self;
  final $Res Function(_ConversationApiDto) _then;

  /// Create a copy of ConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? conversationId = freezed,
    Object? topic = null,
    Object? isClosed = freezed,
    Object? dateClosed = freezed,
    Object? initiatorAccountId = freezed,
    Object? recipientAccountId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_ConversationApiDto(
      conversationId: freezed == conversationId
          ? _self.conversationId
          : conversationId // ignore: cast_nullable_to_non_nullable
              as int?,
      topic: null == topic
          ? _self.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as String,
      isClosed: freezed == isClosed
          ? _self.isClosed
          : isClosed // ignore: cast_nullable_to_non_nullable
              as bool?,
      dateClosed: freezed == dateClosed
          ? _self.dateClosed
          : dateClosed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      initiatorAccountId: freezed == initiatorAccountId
          ? _self.initiatorAccountId
          : initiatorAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      recipientAccountId: freezed == recipientAccountId
          ? _self.recipientAccountId
          : recipientAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$ConversationCloseDto {
  @JsonKey(name: 'dateClosed')
  DateTime? get dateClosed;

  /// Create a copy of ConversationCloseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ConversationCloseDtoCopyWith<ConversationCloseDto> get copyWith =>
      _$ConversationCloseDtoCopyWithImpl<ConversationCloseDto>(
          this as ConversationCloseDto, _$identity);

  /// Serializes this ConversationCloseDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConversationCloseDto &&
            (identical(other.dateClosed, dateClosed) ||
                other.dateClosed == dateClosed));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, dateClosed);

  @override
  String toString() {
    return 'ConversationCloseDto(dateClosed: $dateClosed)';
  }
}

/// @nodoc
abstract mixin class $ConversationCloseDtoCopyWith<$Res> {
  factory $ConversationCloseDtoCopyWith(ConversationCloseDto value,
          $Res Function(ConversationCloseDto) _then) =
      _$ConversationCloseDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'dateClosed') DateTime? dateClosed});
}

/// @nodoc
class _$ConversationCloseDtoCopyWithImpl<$Res>
    implements $ConversationCloseDtoCopyWith<$Res> {
  _$ConversationCloseDtoCopyWithImpl(this._self, this._then);

  final ConversationCloseDto _self;
  final $Res Function(ConversationCloseDto) _then;

  /// Create a copy of ConversationCloseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateClosed = freezed,
  }) {
    return _then(_self.copyWith(
      dateClosed: freezed == dateClosed
          ? _self.dateClosed
          : dateClosed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ConversationCloseDto].
extension ConversationCloseDtoPatterns on ConversationCloseDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ConversationCloseDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationCloseDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ConversationCloseDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationCloseDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ConversationCloseDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationCloseDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'dateClosed') DateTime? dateClosed)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationCloseDto() when $default != null:
        return $default(_that.dateClosed);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'dateClosed') DateTime? dateClosed)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationCloseDto():
        return $default(_that.dateClosed);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'dateClosed') DateTime? dateClosed)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationCloseDto() when $default != null:
        return $default(_that.dateClosed);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ConversationCloseDto implements ConversationCloseDto {
  _ConversationCloseDto({@JsonKey(name: 'dateClosed') this.dateClosed});
  factory _ConversationCloseDto.fromJson(Map<String, dynamic> json) =>
      _$ConversationCloseDtoFromJson(json);

  @override
  @JsonKey(name: 'dateClosed')
  final DateTime? dateClosed;

  /// Create a copy of ConversationCloseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ConversationCloseDtoCopyWith<_ConversationCloseDto> get copyWith =>
      __$ConversationCloseDtoCopyWithImpl<_ConversationCloseDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ConversationCloseDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ConversationCloseDto &&
            (identical(other.dateClosed, dateClosed) ||
                other.dateClosed == dateClosed));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, dateClosed);

  @override
  String toString() {
    return 'ConversationCloseDto(dateClosed: $dateClosed)';
  }
}

/// @nodoc
abstract mixin class _$ConversationCloseDtoCopyWith<$Res>
    implements $ConversationCloseDtoCopyWith<$Res> {
  factory _$ConversationCloseDtoCopyWith(_ConversationCloseDto value,
          $Res Function(_ConversationCloseDto) _then) =
      __$ConversationCloseDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'dateClosed') DateTime? dateClosed});
}

/// @nodoc
class __$ConversationCloseDtoCopyWithImpl<$Res>
    implements _$ConversationCloseDtoCopyWith<$Res> {
  __$ConversationCloseDtoCopyWithImpl(this._self, this._then);

  final _ConversationCloseDto _self;
  final $Res Function(_ConversationCloseDto) _then;

  /// Create a copy of ConversationCloseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? dateClosed = freezed,
  }) {
    return _then(_ConversationCloseDto(
      dateClosed: freezed == dateClosed
          ? _self.dateClosed
          : dateClosed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$ConversationMessageApiDto {
  @JsonKey(name: 'conversationMessageId')
  int? get conversationMessageId;
  @JsonKey(name: 'message')
  String get message;
  @JsonKey(name: 'senderAccountId')
  int? get senderAccountId;
  @JsonKey(name: 'isRead')
  bool? get isRead;
  @JsonKey(name: 'conversationId')
  int? get conversationId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of ConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ConversationMessageApiDtoCopyWith<ConversationMessageApiDto> get copyWith =>
      _$ConversationMessageApiDtoCopyWithImpl<ConversationMessageApiDto>(
          this as ConversationMessageApiDto, _$identity);

  /// Serializes this ConversationMessageApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConversationMessageApiDto &&
            (identical(other.conversationMessageId, conversationMessageId) ||
                other.conversationMessageId == conversationMessageId) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.senderAccountId, senderAccountId) ||
                other.senderAccountId == senderAccountId) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.conversationId, conversationId) ||
                other.conversationId == conversationId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      conversationMessageId,
      message,
      senderAccountId,
      isRead,
      conversationId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ConversationMessageApiDto(conversationMessageId: $conversationMessageId, message: $message, senderAccountId: $senderAccountId, isRead: $isRead, conversationId: $conversationId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $ConversationMessageApiDtoCopyWith<$Res> {
  factory $ConversationMessageApiDtoCopyWith(ConversationMessageApiDto value,
          $Res Function(ConversationMessageApiDto) _then) =
      _$ConversationMessageApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'conversationMessageId') int? conversationMessageId,
      @JsonKey(name: 'message') String message,
      @JsonKey(name: 'senderAccountId') int? senderAccountId,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'conversationId') int? conversationId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$ConversationMessageApiDtoCopyWithImpl<$Res>
    implements $ConversationMessageApiDtoCopyWith<$Res> {
  _$ConversationMessageApiDtoCopyWithImpl(this._self, this._then);

  final ConversationMessageApiDto _self;
  final $Res Function(ConversationMessageApiDto) _then;

  /// Create a copy of ConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? conversationMessageId = freezed,
    Object? message = null,
    Object? senderAccountId = freezed,
    Object? isRead = freezed,
    Object? conversationId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      conversationMessageId: freezed == conversationMessageId
          ? _self.conversationMessageId
          : conversationMessageId // ignore: cast_nullable_to_non_nullable
              as int?,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      senderAccountId: freezed == senderAccountId
          ? _self.senderAccountId
          : senderAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      conversationId: freezed == conversationId
          ? _self.conversationId
          : conversationId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ConversationMessageApiDto].
extension ConversationMessageApiDtoPatterns on ConversationMessageApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ConversationMessageApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ConversationMessageApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ConversationMessageApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'conversationMessageId') int? conversationMessageId,
            @JsonKey(name: 'message') String message,
            @JsonKey(name: 'senderAccountId') int? senderAccountId,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageApiDto() when $default != null:
        return $default(
            _that.conversationMessageId,
            _that.message,
            _that.senderAccountId,
            _that.isRead,
            _that.conversationId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'conversationMessageId') int? conversationMessageId,
            @JsonKey(name: 'message') String message,
            @JsonKey(name: 'senderAccountId') int? senderAccountId,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageApiDto():
        return $default(
            _that.conversationMessageId,
            _that.message,
            _that.senderAccountId,
            _that.isRead,
            _that.conversationId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'conversationMessageId') int? conversationMessageId,
            @JsonKey(name: 'message') String message,
            @JsonKey(name: 'senderAccountId') int? senderAccountId,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageApiDto() when $default != null:
        return $default(
            _that.conversationMessageId,
            _that.message,
            _that.senderAccountId,
            _that.isRead,
            _that.conversationId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ConversationMessageApiDto implements ConversationMessageApiDto {
  _ConversationMessageApiDto(
      {@JsonKey(name: 'conversationMessageId') this.conversationMessageId,
      @JsonKey(name: 'message') required this.message,
      @JsonKey(name: 'senderAccountId') this.senderAccountId,
      @JsonKey(name: 'isRead') this.isRead,
      @JsonKey(name: 'conversationId') this.conversationId,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _ConversationMessageApiDto.fromJson(Map<String, dynamic> json) =>
      _$ConversationMessageApiDtoFromJson(json);

  @override
  @JsonKey(name: 'conversationMessageId')
  final int? conversationMessageId;
  @override
  @JsonKey(name: 'message')
  final String message;
  @override
  @JsonKey(name: 'senderAccountId')
  final int? senderAccountId;
  @override
  @JsonKey(name: 'isRead')
  final bool? isRead;
  @override
  @JsonKey(name: 'conversationId')
  final int? conversationId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of ConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ConversationMessageApiDtoCopyWith<_ConversationMessageApiDto>
      get copyWith =>
          __$ConversationMessageApiDtoCopyWithImpl<_ConversationMessageApiDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ConversationMessageApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ConversationMessageApiDto &&
            (identical(other.conversationMessageId, conversationMessageId) ||
                other.conversationMessageId == conversationMessageId) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.senderAccountId, senderAccountId) ||
                other.senderAccountId == senderAccountId) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.conversationId, conversationId) ||
                other.conversationId == conversationId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      conversationMessageId,
      message,
      senderAccountId,
      isRead,
      conversationId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'ConversationMessageApiDto(conversationMessageId: $conversationMessageId, message: $message, senderAccountId: $senderAccountId, isRead: $isRead, conversationId: $conversationId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$ConversationMessageApiDtoCopyWith<$Res>
    implements $ConversationMessageApiDtoCopyWith<$Res> {
  factory _$ConversationMessageApiDtoCopyWith(_ConversationMessageApiDto value,
          $Res Function(_ConversationMessageApiDto) _then) =
      __$ConversationMessageApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'conversationMessageId') int? conversationMessageId,
      @JsonKey(name: 'message') String message,
      @JsonKey(name: 'senderAccountId') int? senderAccountId,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'conversationId') int? conversationId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$ConversationMessageApiDtoCopyWithImpl<$Res>
    implements _$ConversationMessageApiDtoCopyWith<$Res> {
  __$ConversationMessageApiDtoCopyWithImpl(this._self, this._then);

  final _ConversationMessageApiDto _self;
  final $Res Function(_ConversationMessageApiDto) _then;

  /// Create a copy of ConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? conversationMessageId = freezed,
    Object? message = null,
    Object? senderAccountId = freezed,
    Object? isRead = freezed,
    Object? conversationId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_ConversationMessageApiDto(
      conversationMessageId: freezed == conversationMessageId
          ? _self.conversationMessageId
          : conversationMessageId // ignore: cast_nullable_to_non_nullable
              as int?,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      senderAccountId: freezed == senderAccountId
          ? _self.senderAccountId
          : senderAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      conversationId: freezed == conversationId
          ? _self.conversationId
          : conversationId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$ConversationMessageMutationDto {
  @JsonKey(name: 'message')
  String get message;
  @JsonKey(name: 'conversationId')
  int? get conversationId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;

  /// Create a copy of ConversationMessageMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ConversationMessageMutationDtoCopyWith<ConversationMessageMutationDto>
      get copyWith => _$ConversationMessageMutationDtoCopyWithImpl<
              ConversationMessageMutationDto>(
          this as ConversationMessageMutationDto, _$identity);

  /// Serializes this ConversationMessageMutationDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConversationMessageMutationDto &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.conversationId, conversationId) ||
                other.conversationId == conversationId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, message, conversationId, isDeleted);

  @override
  String toString() {
    return 'ConversationMessageMutationDto(message: $message, conversationId: $conversationId, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class $ConversationMessageMutationDtoCopyWith<$Res> {
  factory $ConversationMessageMutationDtoCopyWith(
          ConversationMessageMutationDto value,
          $Res Function(ConversationMessageMutationDto) _then) =
      _$ConversationMessageMutationDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'message') String message,
      @JsonKey(name: 'conversationId') int? conversationId,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class _$ConversationMessageMutationDtoCopyWithImpl<$Res>
    implements $ConversationMessageMutationDtoCopyWith<$Res> {
  _$ConversationMessageMutationDtoCopyWithImpl(this._self, this._then);

  final ConversationMessageMutationDto _self;
  final $Res Function(ConversationMessageMutationDto) _then;

  /// Create a copy of ConversationMessageMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? conversationId = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_self.copyWith(
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      conversationId: freezed == conversationId
          ? _self.conversationId
          : conversationId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ConversationMessageMutationDto].
extension ConversationMessageMutationDtoPatterns
    on ConversationMessageMutationDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ConversationMessageMutationDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageMutationDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ConversationMessageMutationDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageMutationDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ConversationMessageMutationDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageMutationDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'message') String message,
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageMutationDto() when $default != null:
        return $default(_that.message, _that.conversationId, _that.isDeleted);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'message') String message,
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'isDeleted') bool? isDeleted)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageMutationDto():
        return $default(_that.message, _that.conversationId, _that.isDeleted);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'message') String message,
            @JsonKey(name: 'conversationId') int? conversationId,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageMutationDto() when $default != null:
        return $default(_that.message, _that.conversationId, _that.isDeleted);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ConversationMessageMutationDto
    implements ConversationMessageMutationDto {
  _ConversationMessageMutationDto(
      {@JsonKey(name: 'message') required this.message,
      @JsonKey(name: 'conversationId') this.conversationId,
      @JsonKey(name: 'isDeleted') this.isDeleted});
  factory _ConversationMessageMutationDto.fromJson(Map<String, dynamic> json) =>
      _$ConversationMessageMutationDtoFromJson(json);

  @override
  @JsonKey(name: 'message')
  final String message;
  @override
  @JsonKey(name: 'conversationId')
  final int? conversationId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;

  /// Create a copy of ConversationMessageMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ConversationMessageMutationDtoCopyWith<_ConversationMessageMutationDto>
      get copyWith => __$ConversationMessageMutationDtoCopyWithImpl<
          _ConversationMessageMutationDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ConversationMessageMutationDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ConversationMessageMutationDto &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.conversationId, conversationId) ||
                other.conversationId == conversationId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, message, conversationId, isDeleted);

  @override
  String toString() {
    return 'ConversationMessageMutationDto(message: $message, conversationId: $conversationId, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class _$ConversationMessageMutationDtoCopyWith<$Res>
    implements $ConversationMessageMutationDtoCopyWith<$Res> {
  factory _$ConversationMessageMutationDtoCopyWith(
          _ConversationMessageMutationDto value,
          $Res Function(_ConversationMessageMutationDto) _then) =
      __$ConversationMessageMutationDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'message') String message,
      @JsonKey(name: 'conversationId') int? conversationId,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class __$ConversationMessageMutationDtoCopyWithImpl<$Res>
    implements _$ConversationMessageMutationDtoCopyWith<$Res> {
  __$ConversationMessageMutationDtoCopyWithImpl(this._self, this._then);

  final _ConversationMessageMutationDto _self;
  final $Res Function(_ConversationMessageMutationDto) _then;

  /// Create a copy of ConversationMessageMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? message = null,
    Object? conversationId = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_ConversationMessageMutationDto(
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      conversationId: freezed == conversationId
          ? _self.conversationId
          : conversationId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ConversationMessageReadStatusDto {
  @JsonKey(name: 'isRead')
  bool? get isRead;

  /// Create a copy of ConversationMessageReadStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ConversationMessageReadStatusDtoCopyWith<ConversationMessageReadStatusDto>
      get copyWith => _$ConversationMessageReadStatusDtoCopyWithImpl<
              ConversationMessageReadStatusDto>(
          this as ConversationMessageReadStatusDto, _$identity);

  /// Serializes this ConversationMessageReadStatusDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConversationMessageReadStatusDto &&
            (identical(other.isRead, isRead) || other.isRead == isRead));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, isRead);

  @override
  String toString() {
    return 'ConversationMessageReadStatusDto(isRead: $isRead)';
  }
}

/// @nodoc
abstract mixin class $ConversationMessageReadStatusDtoCopyWith<$Res> {
  factory $ConversationMessageReadStatusDtoCopyWith(
          ConversationMessageReadStatusDto value,
          $Res Function(ConversationMessageReadStatusDto) _then) =
      _$ConversationMessageReadStatusDtoCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'isRead') bool? isRead});
}

/// @nodoc
class _$ConversationMessageReadStatusDtoCopyWithImpl<$Res>
    implements $ConversationMessageReadStatusDtoCopyWith<$Res> {
  _$ConversationMessageReadStatusDtoCopyWithImpl(this._self, this._then);

  final ConversationMessageReadStatusDto _self;
  final $Res Function(ConversationMessageReadStatusDto) _then;

  /// Create a copy of ConversationMessageReadStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRead = freezed,
  }) {
    return _then(_self.copyWith(
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ConversationMessageReadStatusDto].
extension ConversationMessageReadStatusDtoPatterns
    on ConversationMessageReadStatusDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ConversationMessageReadStatusDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageReadStatusDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ConversationMessageReadStatusDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageReadStatusDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ConversationMessageReadStatusDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageReadStatusDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'isRead') bool? isRead)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageReadStatusDto() when $default != null:
        return $default(_that.isRead);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'isRead') bool? isRead) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageReadStatusDto():
        return $default(_that.isRead);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'isRead') bool? isRead)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMessageReadStatusDto() when $default != null:
        return $default(_that.isRead);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ConversationMessageReadStatusDto
    implements ConversationMessageReadStatusDto {
  _ConversationMessageReadStatusDto({@JsonKey(name: 'isRead') this.isRead});
  factory _ConversationMessageReadStatusDto.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationMessageReadStatusDtoFromJson(json);

  @override
  @JsonKey(name: 'isRead')
  final bool? isRead;

  /// Create a copy of ConversationMessageReadStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ConversationMessageReadStatusDtoCopyWith<_ConversationMessageReadStatusDto>
      get copyWith => __$ConversationMessageReadStatusDtoCopyWithImpl<
          _ConversationMessageReadStatusDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ConversationMessageReadStatusDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ConversationMessageReadStatusDto &&
            (identical(other.isRead, isRead) || other.isRead == isRead));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, isRead);

  @override
  String toString() {
    return 'ConversationMessageReadStatusDto(isRead: $isRead)';
  }
}

/// @nodoc
abstract mixin class _$ConversationMessageReadStatusDtoCopyWith<$Res>
    implements $ConversationMessageReadStatusDtoCopyWith<$Res> {
  factory _$ConversationMessageReadStatusDtoCopyWith(
          _ConversationMessageReadStatusDto value,
          $Res Function(_ConversationMessageReadStatusDto) _then) =
      __$ConversationMessageReadStatusDtoCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'isRead') bool? isRead});
}

/// @nodoc
class __$ConversationMessageReadStatusDtoCopyWithImpl<$Res>
    implements _$ConversationMessageReadStatusDtoCopyWith<$Res> {
  __$ConversationMessageReadStatusDtoCopyWithImpl(this._self, this._then);

  final _ConversationMessageReadStatusDto _self;
  final $Res Function(_ConversationMessageReadStatusDto) _then;

  /// Create a copy of ConversationMessageReadStatusDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isRead = freezed,
  }) {
    return _then(_ConversationMessageReadStatusDto(
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ConversationMutationDto {
  @JsonKey(name: 'topic')
  String get topic;
  @JsonKey(name: 'isClosed')
  bool? get isClosed;
  @JsonKey(name: 'dateClosed')
  DateTime? get dateClosed;
  @JsonKey(name: 'initiatorAccountId')
  int? get initiatorAccountId;
  @JsonKey(name: 'recipientAccountId')
  int? get recipientAccountId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;

  /// Create a copy of ConversationMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ConversationMutationDtoCopyWith<ConversationMutationDto> get copyWith =>
      _$ConversationMutationDtoCopyWithImpl<ConversationMutationDto>(
          this as ConversationMutationDto, _$identity);

  /// Serializes this ConversationMutationDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConversationMutationDto &&
            (identical(other.topic, topic) || other.topic == topic) &&
            (identical(other.isClosed, isClosed) ||
                other.isClosed == isClosed) &&
            (identical(other.dateClosed, dateClosed) ||
                other.dateClosed == dateClosed) &&
            (identical(other.initiatorAccountId, initiatorAccountId) ||
                other.initiatorAccountId == initiatorAccountId) &&
            (identical(other.recipientAccountId, recipientAccountId) ||
                other.recipientAccountId == recipientAccountId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, topic, isClosed, dateClosed,
      initiatorAccountId, recipientAccountId, isDeleted);

  @override
  String toString() {
    return 'ConversationMutationDto(topic: $topic, isClosed: $isClosed, dateClosed: $dateClosed, initiatorAccountId: $initiatorAccountId, recipientAccountId: $recipientAccountId, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class $ConversationMutationDtoCopyWith<$Res> {
  factory $ConversationMutationDtoCopyWith(ConversationMutationDto value,
          $Res Function(ConversationMutationDto) _then) =
      _$ConversationMutationDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'topic') String topic,
      @JsonKey(name: 'isClosed') bool? isClosed,
      @JsonKey(name: 'dateClosed') DateTime? dateClosed,
      @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
      @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class _$ConversationMutationDtoCopyWithImpl<$Res>
    implements $ConversationMutationDtoCopyWith<$Res> {
  _$ConversationMutationDtoCopyWithImpl(this._self, this._then);

  final ConversationMutationDto _self;
  final $Res Function(ConversationMutationDto) _then;

  /// Create a copy of ConversationMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? topic = null,
    Object? isClosed = freezed,
    Object? dateClosed = freezed,
    Object? initiatorAccountId = freezed,
    Object? recipientAccountId = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_self.copyWith(
      topic: null == topic
          ? _self.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as String,
      isClosed: freezed == isClosed
          ? _self.isClosed
          : isClosed // ignore: cast_nullable_to_non_nullable
              as bool?,
      dateClosed: freezed == dateClosed
          ? _self.dateClosed
          : dateClosed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      initiatorAccountId: freezed == initiatorAccountId
          ? _self.initiatorAccountId
          : initiatorAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      recipientAccountId: freezed == recipientAccountId
          ? _self.recipientAccountId
          : recipientAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ConversationMutationDto].
extension ConversationMutationDtoPatterns on ConversationMutationDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ConversationMutationDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMutationDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ConversationMutationDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMutationDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ConversationMutationDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMutationDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'topic') String topic,
            @JsonKey(name: 'isClosed') bool? isClosed,
            @JsonKey(name: 'dateClosed') DateTime? dateClosed,
            @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ConversationMutationDto() when $default != null:
        return $default(
            _that.topic,
            _that.isClosed,
            _that.dateClosed,
            _that.initiatorAccountId,
            _that.recipientAccountId,
            _that.isDeleted);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'topic') String topic,
            @JsonKey(name: 'isClosed') bool? isClosed,
            @JsonKey(name: 'dateClosed') DateTime? dateClosed,
            @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMutationDto():
        return $default(
            _that.topic,
            _that.isClosed,
            _that.dateClosed,
            _that.initiatorAccountId,
            _that.recipientAccountId,
            _that.isDeleted);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'topic') String topic,
            @JsonKey(name: 'isClosed') bool? isClosed,
            @JsonKey(name: 'dateClosed') DateTime? dateClosed,
            @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ConversationMutationDto() when $default != null:
        return $default(
            _that.topic,
            _that.isClosed,
            _that.dateClosed,
            _that.initiatorAccountId,
            _that.recipientAccountId,
            _that.isDeleted);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ConversationMutationDto implements ConversationMutationDto {
  _ConversationMutationDto(
      {@JsonKey(name: 'topic') required this.topic,
      @JsonKey(name: 'isClosed') this.isClosed,
      @JsonKey(name: 'dateClosed') this.dateClosed,
      @JsonKey(name: 'initiatorAccountId') this.initiatorAccountId,
      @JsonKey(name: 'recipientAccountId') this.recipientAccountId,
      @JsonKey(name: 'isDeleted') this.isDeleted});
  factory _ConversationMutationDto.fromJson(Map<String, dynamic> json) =>
      _$ConversationMutationDtoFromJson(json);

  @override
  @JsonKey(name: 'topic')
  final String topic;
  @override
  @JsonKey(name: 'isClosed')
  final bool? isClosed;
  @override
  @JsonKey(name: 'dateClosed')
  final DateTime? dateClosed;
  @override
  @JsonKey(name: 'initiatorAccountId')
  final int? initiatorAccountId;
  @override
  @JsonKey(name: 'recipientAccountId')
  final int? recipientAccountId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;

  /// Create a copy of ConversationMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ConversationMutationDtoCopyWith<_ConversationMutationDto> get copyWith =>
      __$ConversationMutationDtoCopyWithImpl<_ConversationMutationDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ConversationMutationDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ConversationMutationDto &&
            (identical(other.topic, topic) || other.topic == topic) &&
            (identical(other.isClosed, isClosed) ||
                other.isClosed == isClosed) &&
            (identical(other.dateClosed, dateClosed) ||
                other.dateClosed == dateClosed) &&
            (identical(other.initiatorAccountId, initiatorAccountId) ||
                other.initiatorAccountId == initiatorAccountId) &&
            (identical(other.recipientAccountId, recipientAccountId) ||
                other.recipientAccountId == recipientAccountId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, topic, isClosed, dateClosed,
      initiatorAccountId, recipientAccountId, isDeleted);

  @override
  String toString() {
    return 'ConversationMutationDto(topic: $topic, isClosed: $isClosed, dateClosed: $dateClosed, initiatorAccountId: $initiatorAccountId, recipientAccountId: $recipientAccountId, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class _$ConversationMutationDtoCopyWith<$Res>
    implements $ConversationMutationDtoCopyWith<$Res> {
  factory _$ConversationMutationDtoCopyWith(_ConversationMutationDto value,
          $Res Function(_ConversationMutationDto) _then) =
      __$ConversationMutationDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'topic') String topic,
      @JsonKey(name: 'isClosed') bool? isClosed,
      @JsonKey(name: 'dateClosed') DateTime? dateClosed,
      @JsonKey(name: 'initiatorAccountId') int? initiatorAccountId,
      @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class __$ConversationMutationDtoCopyWithImpl<$Res>
    implements _$ConversationMutationDtoCopyWith<$Res> {
  __$ConversationMutationDtoCopyWithImpl(this._self, this._then);

  final _ConversationMutationDto _self;
  final $Res Function(_ConversationMutationDto) _then;

  /// Create a copy of ConversationMutationDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? topic = null,
    Object? isClosed = freezed,
    Object? dateClosed = freezed,
    Object? initiatorAccountId = freezed,
    Object? recipientAccountId = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_ConversationMutationDto(
      topic: null == topic
          ? _self.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as String,
      isClosed: freezed == isClosed
          ? _self.isClosed
          : isClosed // ignore: cast_nullable_to_non_nullable
              as bool?,
      dateClosed: freezed == dateClosed
          ? _self.dateClosed
          : dateClosed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      initiatorAccountId: freezed == initiatorAccountId
          ? _self.initiatorAccountId
          : initiatorAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      recipientAccountId: freezed == recipientAccountId
          ? _self.recipientAccountId
          : recipientAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$CountryApiDto {
  @JsonKey(name: 'countryId')
  int? get countryId;
  @JsonKey(name: 'isO2')
  String? get isO2;
  @JsonKey(name: 'isO3')
  String? get isO3;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'citizenship')
  String? get citizenship;
  @JsonKey(name: 'idd')
  String? get idd;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of CountryApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CountryApiDtoCopyWith<CountryApiDto> get copyWith =>
      _$CountryApiDtoCopyWithImpl<CountryApiDto>(
          this as CountryApiDto, _$identity);

  /// Serializes this CountryApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CountryApiDto &&
            (identical(other.countryId, countryId) ||
                other.countryId == countryId) &&
            (identical(other.isO2, isO2) || other.isO2 == isO2) &&
            (identical(other.isO3, isO3) || other.isO3 == isO3) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.citizenship, citizenship) ||
                other.citizenship == citizenship) &&
            (identical(other.idd, idd) || other.idd == idd) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      countryId,
      isO2,
      isO3,
      name,
      citizenship,
      idd,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'CountryApiDto(countryId: $countryId, isO2: $isO2, isO3: $isO3, name: $name, citizenship: $citizenship, idd: $idd, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $CountryApiDtoCopyWith<$Res> {
  factory $CountryApiDtoCopyWith(
          CountryApiDto value, $Res Function(CountryApiDto) _then) =
      _$CountryApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'countryId') int? countryId,
      @JsonKey(name: 'isO2') String? isO2,
      @JsonKey(name: 'isO3') String? isO3,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'citizenship') String? citizenship,
      @JsonKey(name: 'idd') String? idd,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$CountryApiDtoCopyWithImpl<$Res>
    implements $CountryApiDtoCopyWith<$Res> {
  _$CountryApiDtoCopyWithImpl(this._self, this._then);

  final CountryApiDto _self;
  final $Res Function(CountryApiDto) _then;

  /// Create a copy of CountryApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? countryId = freezed,
    Object? isO2 = freezed,
    Object? isO3 = freezed,
    Object? name = freezed,
    Object? citizenship = freezed,
    Object? idd = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      countryId: freezed == countryId
          ? _self.countryId
          : countryId // ignore: cast_nullable_to_non_nullable
              as int?,
      isO2: freezed == isO2
          ? _self.isO2
          : isO2 // ignore: cast_nullable_to_non_nullable
              as String?,
      isO3: freezed == isO3
          ? _self.isO3
          : isO3 // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      citizenship: freezed == citizenship
          ? _self.citizenship
          : citizenship // ignore: cast_nullable_to_non_nullable
              as String?,
      idd: freezed == idd
          ? _self.idd
          : idd // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CountryApiDto].
extension CountryApiDtoPatterns on CountryApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CountryApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CountryApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CountryApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CountryApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CountryApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CountryApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'countryId') int? countryId,
            @JsonKey(name: 'isO2') String? isO2,
            @JsonKey(name: 'isO3') String? isO3,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'citizenship') String? citizenship,
            @JsonKey(name: 'idd') String? idd,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CountryApiDto() when $default != null:
        return $default(
            _that.countryId,
            _that.isO2,
            _that.isO3,
            _that.name,
            _that.citizenship,
            _that.idd,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'countryId') int? countryId,
            @JsonKey(name: 'isO2') String? isO2,
            @JsonKey(name: 'isO3') String? isO3,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'citizenship') String? citizenship,
            @JsonKey(name: 'idd') String? idd,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CountryApiDto():
        return $default(
            _that.countryId,
            _that.isO2,
            _that.isO3,
            _that.name,
            _that.citizenship,
            _that.idd,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'countryId') int? countryId,
            @JsonKey(name: 'isO2') String? isO2,
            @JsonKey(name: 'isO3') String? isO3,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'citizenship') String? citizenship,
            @JsonKey(name: 'idd') String? idd,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CountryApiDto() when $default != null:
        return $default(
            _that.countryId,
            _that.isO2,
            _that.isO3,
            _that.name,
            _that.citizenship,
            _that.idd,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CountryApiDto implements CountryApiDto {
  _CountryApiDto(
      {@JsonKey(name: 'countryId') this.countryId,
      @JsonKey(name: 'isO2') this.isO2,
      @JsonKey(name: 'isO3') this.isO3,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'citizenship') this.citizenship,
      @JsonKey(name: 'idd') this.idd,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _CountryApiDto.fromJson(Map<String, dynamic> json) =>
      _$CountryApiDtoFromJson(json);

  @override
  @JsonKey(name: 'countryId')
  final int? countryId;
  @override
  @JsonKey(name: 'isO2')
  final String? isO2;
  @override
  @JsonKey(name: 'isO3')
  final String? isO3;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'citizenship')
  final String? citizenship;
  @override
  @JsonKey(name: 'idd')
  final String? idd;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of CountryApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CountryApiDtoCopyWith<_CountryApiDto> get copyWith =>
      __$CountryApiDtoCopyWithImpl<_CountryApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CountryApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CountryApiDto &&
            (identical(other.countryId, countryId) ||
                other.countryId == countryId) &&
            (identical(other.isO2, isO2) || other.isO2 == isO2) &&
            (identical(other.isO3, isO3) || other.isO3 == isO3) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.citizenship, citizenship) ||
                other.citizenship == citizenship) &&
            (identical(other.idd, idd) || other.idd == idd) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      countryId,
      isO2,
      isO3,
      name,
      citizenship,
      idd,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'CountryApiDto(countryId: $countryId, isO2: $isO2, isO3: $isO3, name: $name, citizenship: $citizenship, idd: $idd, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$CountryApiDtoCopyWith<$Res>
    implements $CountryApiDtoCopyWith<$Res> {
  factory _$CountryApiDtoCopyWith(
          _CountryApiDto value, $Res Function(_CountryApiDto) _then) =
      __$CountryApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'countryId') int? countryId,
      @JsonKey(name: 'isO2') String? isO2,
      @JsonKey(name: 'isO3') String? isO3,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'citizenship') String? citizenship,
      @JsonKey(name: 'idd') String? idd,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$CountryApiDtoCopyWithImpl<$Res>
    implements _$CountryApiDtoCopyWith<$Res> {
  __$CountryApiDtoCopyWithImpl(this._self, this._then);

  final _CountryApiDto _self;
  final $Res Function(_CountryApiDto) _then;

  /// Create a copy of CountryApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? countryId = freezed,
    Object? isO2 = freezed,
    Object? isO3 = freezed,
    Object? name = freezed,
    Object? citizenship = freezed,
    Object? idd = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_CountryApiDto(
      countryId: freezed == countryId
          ? _self.countryId
          : countryId // ignore: cast_nullable_to_non_nullable
              as int?,
      isO2: freezed == isO2
          ? _self.isO2
          : isO2 // ignore: cast_nullable_to_non_nullable
              as String?,
      isO3: freezed == isO3
          ? _self.isO3
          : isO3 // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      citizenship: freezed == citizenship
          ? _self.citizenship
          : citizenship // ignore: cast_nullable_to_non_nullable
              as String?,
      idd: freezed == idd
          ? _self.idd
          : idd // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$CurrentUserInfoDto {
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'account')
  AccountApiDto2Dto? get account;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'fullName')
  String? get fullName;
  @JsonKey(name: 'email')
  String? get email;
  @JsonKey(name: 'emailConfirmed')
  bool? get emailConfirmed;
  @JsonKey(name: 'lastActiveBranchId')
  int? get lastActiveBranchId;
  @JsonKey(name: 'branchRoles')
  List<UserBranchRoleDto>? get branchRoles;

  /// Create a copy of CurrentUserInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CurrentUserInfoDtoCopyWith<CurrentUserInfoDto> get copyWith =>
      _$CurrentUserInfoDtoCopyWithImpl<CurrentUserInfoDto>(
          this as CurrentUserInfoDto, _$identity);

  /// Serializes this CurrentUserInfoDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CurrentUserInfoDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.fullName, fullName) ||
                other.fullName == fullName) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.emailConfirmed, emailConfirmed) ||
                other.emailConfirmed == emailConfirmed) &&
            (identical(other.lastActiveBranchId, lastActiveBranchId) ||
                other.lastActiveBranchId == lastActiveBranchId) &&
            const DeepCollectionEquality()
                .equals(other.branchRoles, branchRoles));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      account,
      userId,
      fullName,
      email,
      emailConfirmed,
      lastActiveBranchId,
      const DeepCollectionEquality().hash(branchRoles));

  @override
  String toString() {
    return 'CurrentUserInfoDto(accountId: $accountId, account: $account, userId: $userId, fullName: $fullName, email: $email, emailConfirmed: $emailConfirmed, lastActiveBranchId: $lastActiveBranchId, branchRoles: $branchRoles)';
  }
}

/// @nodoc
abstract mixin class $CurrentUserInfoDtoCopyWith<$Res> {
  factory $CurrentUserInfoDtoCopyWith(
          CurrentUserInfoDto value, $Res Function(CurrentUserInfoDto) _then) =
      _$CurrentUserInfoDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto2Dto? account,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'fullName') String? fullName,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'emailConfirmed') bool? emailConfirmed,
      @JsonKey(name: 'lastActiveBranchId') int? lastActiveBranchId,
      @JsonKey(name: 'branchRoles') List<UserBranchRoleDto>? branchRoles});

  $AccountApiDto2DtoCopyWith<$Res>? get account;
}

/// @nodoc
class _$CurrentUserInfoDtoCopyWithImpl<$Res>
    implements $CurrentUserInfoDtoCopyWith<$Res> {
  _$CurrentUserInfoDtoCopyWithImpl(this._self, this._then);

  final CurrentUserInfoDto _self;
  final $Res Function(CurrentUserInfoDto) _then;

  /// Create a copy of CurrentUserInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountId = freezed,
    Object? account = freezed,
    Object? userId = freezed,
    Object? fullName = freezed,
    Object? email = freezed,
    Object? emailConfirmed = freezed,
    Object? lastActiveBranchId = freezed,
    Object? branchRoles = freezed,
  }) {
    return _then(_self.copyWith(
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto2Dto?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      fullName: freezed == fullName
          ? _self.fullName
          : fullName // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      emailConfirmed: freezed == emailConfirmed
          ? _self.emailConfirmed
          : emailConfirmed // ignore: cast_nullable_to_non_nullable
              as bool?,
      lastActiveBranchId: freezed == lastActiveBranchId
          ? _self.lastActiveBranchId
          : lastActiveBranchId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchRoles: freezed == branchRoles
          ? _self.branchRoles
          : branchRoles // ignore: cast_nullable_to_non_nullable
              as List<UserBranchRoleDto>?,
    ));
  }

  /// Create a copy of CurrentUserInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDto2DtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDto2DtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CurrentUserInfoDto].
extension CurrentUserInfoDtoPatterns on CurrentUserInfoDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CurrentUserInfoDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CurrentUserInfoDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CurrentUserInfoDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CurrentUserInfoDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CurrentUserInfoDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CurrentUserInfoDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'fullName') String? fullName,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'emailConfirmed') bool? emailConfirmed,
            @JsonKey(name: 'lastActiveBranchId') int? lastActiveBranchId,
            @JsonKey(name: 'branchRoles') List<UserBranchRoleDto>? branchRoles)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CurrentUserInfoDto() when $default != null:
        return $default(
            _that.accountId,
            _that.account,
            _that.userId,
            _that.fullName,
            _that.email,
            _that.emailConfirmed,
            _that.lastActiveBranchId,
            _that.branchRoles);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'fullName') String? fullName,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'emailConfirmed') bool? emailConfirmed,
            @JsonKey(name: 'lastActiveBranchId') int? lastActiveBranchId,
            @JsonKey(name: 'branchRoles') List<UserBranchRoleDto>? branchRoles)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CurrentUserInfoDto():
        return $default(
            _that.accountId,
            _that.account,
            _that.userId,
            _that.fullName,
            _that.email,
            _that.emailConfirmed,
            _that.lastActiveBranchId,
            _that.branchRoles);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'fullName') String? fullName,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'emailConfirmed') bool? emailConfirmed,
            @JsonKey(name: 'lastActiveBranchId') int? lastActiveBranchId,
            @JsonKey(name: 'branchRoles') List<UserBranchRoleDto>? branchRoles)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CurrentUserInfoDto() when $default != null:
        return $default(
            _that.accountId,
            _that.account,
            _that.userId,
            _that.fullName,
            _that.email,
            _that.emailConfirmed,
            _that.lastActiveBranchId,
            _that.branchRoles);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CurrentUserInfoDto implements CurrentUserInfoDto {
  _CurrentUserInfoDto(
      {@JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'account') this.account,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'fullName') this.fullName,
      @JsonKey(name: 'email') this.email,
      @JsonKey(name: 'emailConfirmed') this.emailConfirmed,
      @JsonKey(name: 'lastActiveBranchId') this.lastActiveBranchId,
      @JsonKey(name: 'branchRoles') final List<UserBranchRoleDto>? branchRoles})
      : _branchRoles = branchRoles;
  factory _CurrentUserInfoDto.fromJson(Map<String, dynamic> json) =>
      _$CurrentUserInfoDtoFromJson(json);

  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'account')
  final AccountApiDto2Dto? account;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'fullName')
  final String? fullName;
  @override
  @JsonKey(name: 'email')
  final String? email;
  @override
  @JsonKey(name: 'emailConfirmed')
  final bool? emailConfirmed;
  @override
  @JsonKey(name: 'lastActiveBranchId')
  final int? lastActiveBranchId;
  final List<UserBranchRoleDto>? _branchRoles;
  @override
  @JsonKey(name: 'branchRoles')
  List<UserBranchRoleDto>? get branchRoles {
    final value = _branchRoles;
    if (value == null) return null;
    if (_branchRoles is EqualUnmodifiableListView) return _branchRoles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of CurrentUserInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CurrentUserInfoDtoCopyWith<_CurrentUserInfoDto> get copyWith =>
      __$CurrentUserInfoDtoCopyWithImpl<_CurrentUserInfoDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CurrentUserInfoDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CurrentUserInfoDto &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.fullName, fullName) ||
                other.fullName == fullName) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.emailConfirmed, emailConfirmed) ||
                other.emailConfirmed == emailConfirmed) &&
            (identical(other.lastActiveBranchId, lastActiveBranchId) ||
                other.lastActiveBranchId == lastActiveBranchId) &&
            const DeepCollectionEquality()
                .equals(other._branchRoles, _branchRoles));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      account,
      userId,
      fullName,
      email,
      emailConfirmed,
      lastActiveBranchId,
      const DeepCollectionEquality().hash(_branchRoles));

  @override
  String toString() {
    return 'CurrentUserInfoDto(accountId: $accountId, account: $account, userId: $userId, fullName: $fullName, email: $email, emailConfirmed: $emailConfirmed, lastActiveBranchId: $lastActiveBranchId, branchRoles: $branchRoles)';
  }
}

/// @nodoc
abstract mixin class _$CurrentUserInfoDtoCopyWith<$Res>
    implements $CurrentUserInfoDtoCopyWith<$Res> {
  factory _$CurrentUserInfoDtoCopyWith(
          _CurrentUserInfoDto value, $Res Function(_CurrentUserInfoDto) _then) =
      __$CurrentUserInfoDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto2Dto? account,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'fullName') String? fullName,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'emailConfirmed') bool? emailConfirmed,
      @JsonKey(name: 'lastActiveBranchId') int? lastActiveBranchId,
      @JsonKey(name: 'branchRoles') List<UserBranchRoleDto>? branchRoles});

  @override
  $AccountApiDto2DtoCopyWith<$Res>? get account;
}

/// @nodoc
class __$CurrentUserInfoDtoCopyWithImpl<$Res>
    implements _$CurrentUserInfoDtoCopyWith<$Res> {
  __$CurrentUserInfoDtoCopyWithImpl(this._self, this._then);

  final _CurrentUserInfoDto _self;
  final $Res Function(_CurrentUserInfoDto) _then;

  /// Create a copy of CurrentUserInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? accountId = freezed,
    Object? account = freezed,
    Object? userId = freezed,
    Object? fullName = freezed,
    Object? email = freezed,
    Object? emailConfirmed = freezed,
    Object? lastActiveBranchId = freezed,
    Object? branchRoles = freezed,
  }) {
    return _then(_CurrentUserInfoDto(
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto2Dto?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      fullName: freezed == fullName
          ? _self.fullName
          : fullName // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      emailConfirmed: freezed == emailConfirmed
          ? _self.emailConfirmed
          : emailConfirmed // ignore: cast_nullable_to_non_nullable
              as bool?,
      lastActiveBranchId: freezed == lastActiveBranchId
          ? _self.lastActiveBranchId
          : lastActiveBranchId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchRoles: freezed == branchRoles
          ? _self._branchRoles
          : branchRoles // ignore: cast_nullable_to_non_nullable
              as List<UserBranchRoleDto>?,
    ));
  }

  /// Create a copy of CurrentUserInfoDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDto2DtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDto2DtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// @nodoc
mixin _$EmployeeApiDto {
  @JsonKey(name: 'employeeType')
  int? get employeeType;
  @JsonKey(name: 'code')
  String? get code;
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'account')
  AccountApiDto2Dto? get account;

  /// Create a copy of EmployeeApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmployeeApiDtoCopyWith<EmployeeApiDto> get copyWith =>
      _$EmployeeApiDtoCopyWithImpl<EmployeeApiDto>(
          this as EmployeeApiDto, _$identity);

  /// Serializes this EmployeeApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmployeeApiDto &&
            (identical(other.employeeType, employeeType) ||
                other.employeeType == employeeType) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, employeeType, code, accountId, account);

  @override
  String toString() {
    return 'EmployeeApiDto(employeeType: $employeeType, code: $code, accountId: $accountId, account: $account)';
  }
}

/// @nodoc
abstract mixin class $EmployeeApiDtoCopyWith<$Res> {
  factory $EmployeeApiDtoCopyWith(
          EmployeeApiDto value, $Res Function(EmployeeApiDto) _then) =
      _$EmployeeApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'employeeType') int? employeeType,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto2Dto? account});

  $AccountApiDto2DtoCopyWith<$Res>? get account;
}

/// @nodoc
class _$EmployeeApiDtoCopyWithImpl<$Res>
    implements $EmployeeApiDtoCopyWith<$Res> {
  _$EmployeeApiDtoCopyWithImpl(this._self, this._then);

  final EmployeeApiDto _self;
  final $Res Function(EmployeeApiDto) _then;

  /// Create a copy of EmployeeApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? employeeType = freezed,
    Object? code = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
  }) {
    return _then(_self.copyWith(
      employeeType: freezed == employeeType
          ? _self.employeeType
          : employeeType // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto2Dto?,
    ));
  }

  /// Create a copy of EmployeeApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDto2DtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDto2DtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// Adds pattern-matching-related methods to [EmployeeApiDto].
extension EmployeeApiDtoPatterns on EmployeeApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_EmployeeApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EmployeeApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_EmployeeApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmployeeApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_EmployeeApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmployeeApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'employeeType') int? employeeType,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EmployeeApiDto() when $default != null:
        return $default(
            _that.employeeType, _that.code, _that.accountId, _that.account);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'employeeType') int? employeeType,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmployeeApiDto():
        return $default(
            _that.employeeType, _that.code, _that.accountId, _that.account);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'employeeType') int? employeeType,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmployeeApiDto() when $default != null:
        return $default(
            _that.employeeType, _that.code, _that.accountId, _that.account);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _EmployeeApiDto implements EmployeeApiDto {
  _EmployeeApiDto(
      {@JsonKey(name: 'employeeType') this.employeeType,
      @JsonKey(name: 'code') this.code,
      @JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'account') this.account});
  factory _EmployeeApiDto.fromJson(Map<String, dynamic> json) =>
      _$EmployeeApiDtoFromJson(json);

  @override
  @JsonKey(name: 'employeeType')
  final int? employeeType;
  @override
  @JsonKey(name: 'code')
  final String? code;
  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'account')
  final AccountApiDto2Dto? account;

  /// Create a copy of EmployeeApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EmployeeApiDtoCopyWith<_EmployeeApiDto> get copyWith =>
      __$EmployeeApiDtoCopyWithImpl<_EmployeeApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmployeeApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EmployeeApiDto &&
            (identical(other.employeeType, employeeType) ||
                other.employeeType == employeeType) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, employeeType, code, accountId, account);

  @override
  String toString() {
    return 'EmployeeApiDto(employeeType: $employeeType, code: $code, accountId: $accountId, account: $account)';
  }
}

/// @nodoc
abstract mixin class _$EmployeeApiDtoCopyWith<$Res>
    implements $EmployeeApiDtoCopyWith<$Res> {
  factory _$EmployeeApiDtoCopyWith(
          _EmployeeApiDto value, $Res Function(_EmployeeApiDto) _then) =
      __$EmployeeApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'employeeType') int? employeeType,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto2Dto? account});

  @override
  $AccountApiDto2DtoCopyWith<$Res>? get account;
}

/// @nodoc
class __$EmployeeApiDtoCopyWithImpl<$Res>
    implements _$EmployeeApiDtoCopyWith<$Res> {
  __$EmployeeApiDtoCopyWithImpl(this._self, this._then);

  final _EmployeeApiDto _self;
  final $Res Function(_EmployeeApiDto) _then;

  /// Create a copy of EmployeeApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? employeeType = freezed,
    Object? code = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
  }) {
    return _then(_EmployeeApiDto(
      employeeType: freezed == employeeType
          ? _self.employeeType
          : employeeType // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto2Dto?,
    ));
  }

  /// Create a copy of EmployeeApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDto2DtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDto2DtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// @nodoc
mixin _$EnrolmentApiDto {
  @JsonKey(name: 'enrolmentId')
  int? get enrolmentId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'classId')
  int? get classId;
  @JsonKey(name: 'class')
  ClassApiDto? get classField;
  @JsonKey(name: 'academicYearId')
  int? get academicYearId;
  @JsonKey(name: 'academicYear')
  AcademicYearApiDto? get academicYear;
  @JsonKey(name: 'enrolmentDate')
  String? get enrolmentDate;
  @JsonKey(name: 'startDate')
  String? get startDate;
  @JsonKey(name: 'endDate')
  String? get endDate;
  @JsonKey(name: 'status')
  int? get status;

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnrolmentApiDtoCopyWith<EnrolmentApiDto> get copyWith =>
      _$EnrolmentApiDtoCopyWithImpl<EnrolmentApiDto>(
          this as EnrolmentApiDto, _$identity);

  /// Serializes this EnrolmentApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnrolmentApiDto &&
            (identical(other.enrolmentId, enrolmentId) ||
                other.enrolmentId == enrolmentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.classField, classField) ||
                other.classField == classField) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicYear, academicYear) ||
                other.academicYear == academicYear) &&
            (identical(other.enrolmentDate, enrolmentDate) ||
                other.enrolmentDate == enrolmentDate) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      enrolmentId,
      branchId,
      studentId,
      classId,
      classField,
      academicYearId,
      academicYear,
      enrolmentDate,
      startDate,
      endDate,
      status);

  @override
  String toString() {
    return 'EnrolmentApiDto(enrolmentId: $enrolmentId, branchId: $branchId, studentId: $studentId, classId: $classId, classField: $classField, academicYearId: $academicYearId, academicYear: $academicYear, enrolmentDate: $enrolmentDate, startDate: $startDate, endDate: $endDate, status: $status)';
  }
}

/// @nodoc
abstract mixin class $EnrolmentApiDtoCopyWith<$Res> {
  factory $EnrolmentApiDtoCopyWith(
          EnrolmentApiDto value, $Res Function(EnrolmentApiDto) _then) =
      _$EnrolmentApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'enrolmentId') int? enrolmentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'class') ClassApiDto? classField,
      @JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
      @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'status') int? status});

  $ClassApiDtoCopyWith<$Res>? get classField;
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear;
}

/// @nodoc
class _$EnrolmentApiDtoCopyWithImpl<$Res>
    implements $EnrolmentApiDtoCopyWith<$Res> {
  _$EnrolmentApiDtoCopyWithImpl(this._self, this._then);

  final EnrolmentApiDto _self;
  final $Res Function(EnrolmentApiDto) _then;

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enrolmentId = freezed,
    Object? branchId = freezed,
    Object? studentId = freezed,
    Object? classId = freezed,
    Object? classField = freezed,
    Object? academicYearId = freezed,
    Object? academicYear = freezed,
    Object? enrolmentDate = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? status = freezed,
  }) {
    return _then(_self.copyWith(
      enrolmentId: freezed == enrolmentId
          ? _self.enrolmentId
          : enrolmentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      classField: freezed == classField
          ? _self.classField
          : classField // ignore: cast_nullable_to_non_nullable
              as ClassApiDto?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYear: freezed == academicYear
          ? _self.academicYear
          : academicYear // ignore: cast_nullable_to_non_nullable
              as AcademicYearApiDto?,
      enrolmentDate: freezed == enrolmentDate
          ? _self.enrolmentDate
          : enrolmentDate // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClassApiDtoCopyWith<$Res>? get classField {
    if (_self.classField == null) {
      return null;
    }

    return $ClassApiDtoCopyWith<$Res>(_self.classField!, (value) {
      return _then(_self.copyWith(classField: value));
    });
  }

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear {
    if (_self.academicYear == null) {
      return null;
    }

    return $AcademicYearApiDtoCopyWith<$Res>(_self.academicYear!, (value) {
      return _then(_self.copyWith(academicYear: value));
    });
  }
}

/// Adds pattern-matching-related methods to [EnrolmentApiDto].
extension EnrolmentApiDtoPatterns on EnrolmentApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_EnrolmentApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EnrolmentApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_EnrolmentApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EnrolmentApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_EnrolmentApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EnrolmentApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'enrolmentId') int? enrolmentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'class') ClassApiDto? classField,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
            @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'status') int? status)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EnrolmentApiDto() when $default != null:
        return $default(
            _that.enrolmentId,
            _that.branchId,
            _that.studentId,
            _that.classId,
            _that.classField,
            _that.academicYearId,
            _that.academicYear,
            _that.enrolmentDate,
            _that.startDate,
            _that.endDate,
            _that.status);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'enrolmentId') int? enrolmentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'class') ClassApiDto? classField,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
            @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'status') int? status)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EnrolmentApiDto():
        return $default(
            _that.enrolmentId,
            _that.branchId,
            _that.studentId,
            _that.classId,
            _that.classField,
            _that.academicYearId,
            _that.academicYear,
            _that.enrolmentDate,
            _that.startDate,
            _that.endDate,
            _that.status);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'enrolmentId') int? enrolmentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'class') ClassApiDto? classField,
            @JsonKey(name: 'academicYearId') int? academicYearId,
            @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
            @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'status') int? status)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EnrolmentApiDto() when $default != null:
        return $default(
            _that.enrolmentId,
            _that.branchId,
            _that.studentId,
            _that.classId,
            _that.classField,
            _that.academicYearId,
            _that.academicYear,
            _that.enrolmentDate,
            _that.startDate,
            _that.endDate,
            _that.status);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _EnrolmentApiDto implements EnrolmentApiDto {
  _EnrolmentApiDto(
      {@JsonKey(name: 'enrolmentId') this.enrolmentId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'class') this.classField,
      @JsonKey(name: 'academicYearId') this.academicYearId,
      @JsonKey(name: 'academicYear') this.academicYear,
      @JsonKey(name: 'enrolmentDate') this.enrolmentDate,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'status') this.status});
  factory _EnrolmentApiDto.fromJson(Map<String, dynamic> json) =>
      _$EnrolmentApiDtoFromJson(json);

  @override
  @JsonKey(name: 'enrolmentId')
  final int? enrolmentId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'classId')
  final int? classId;
  @override
  @JsonKey(name: 'class')
  final ClassApiDto? classField;
  @override
  @JsonKey(name: 'academicYearId')
  final int? academicYearId;
  @override
  @JsonKey(name: 'academicYear')
  final AcademicYearApiDto? academicYear;
  @override
  @JsonKey(name: 'enrolmentDate')
  final String? enrolmentDate;
  @override
  @JsonKey(name: 'startDate')
  final String? startDate;
  @override
  @JsonKey(name: 'endDate')
  final String? endDate;
  @override
  @JsonKey(name: 'status')
  final int? status;

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EnrolmentApiDtoCopyWith<_EnrolmentApiDto> get copyWith =>
      __$EnrolmentApiDtoCopyWithImpl<_EnrolmentApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EnrolmentApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EnrolmentApiDto &&
            (identical(other.enrolmentId, enrolmentId) ||
                other.enrolmentId == enrolmentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.classField, classField) ||
                other.classField == classField) &&
            (identical(other.academicYearId, academicYearId) ||
                other.academicYearId == academicYearId) &&
            (identical(other.academicYear, academicYear) ||
                other.academicYear == academicYear) &&
            (identical(other.enrolmentDate, enrolmentDate) ||
                other.enrolmentDate == enrolmentDate) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      enrolmentId,
      branchId,
      studentId,
      classId,
      classField,
      academicYearId,
      academicYear,
      enrolmentDate,
      startDate,
      endDate,
      status);

  @override
  String toString() {
    return 'EnrolmentApiDto(enrolmentId: $enrolmentId, branchId: $branchId, studentId: $studentId, classId: $classId, classField: $classField, academicYearId: $academicYearId, academicYear: $academicYear, enrolmentDate: $enrolmentDate, startDate: $startDate, endDate: $endDate, status: $status)';
  }
}

/// @nodoc
abstract mixin class _$EnrolmentApiDtoCopyWith<$Res>
    implements $EnrolmentApiDtoCopyWith<$Res> {
  factory _$EnrolmentApiDtoCopyWith(
          _EnrolmentApiDto value, $Res Function(_EnrolmentApiDto) _then) =
      __$EnrolmentApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'enrolmentId') int? enrolmentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'class') ClassApiDto? classField,
      @JsonKey(name: 'academicYearId') int? academicYearId,
      @JsonKey(name: 'academicYear') AcademicYearApiDto? academicYear,
      @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'status') int? status});

  @override
  $ClassApiDtoCopyWith<$Res>? get classField;
  @override
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear;
}

/// @nodoc
class __$EnrolmentApiDtoCopyWithImpl<$Res>
    implements _$EnrolmentApiDtoCopyWith<$Res> {
  __$EnrolmentApiDtoCopyWithImpl(this._self, this._then);

  final _EnrolmentApiDto _self;
  final $Res Function(_EnrolmentApiDto) _then;

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? enrolmentId = freezed,
    Object? branchId = freezed,
    Object? studentId = freezed,
    Object? classId = freezed,
    Object? classField = freezed,
    Object? academicYearId = freezed,
    Object? academicYear = freezed,
    Object? enrolmentDate = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? status = freezed,
  }) {
    return _then(_EnrolmentApiDto(
      enrolmentId: freezed == enrolmentId
          ? _self.enrolmentId
          : enrolmentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      classField: freezed == classField
          ? _self.classField
          : classField // ignore: cast_nullable_to_non_nullable
              as ClassApiDto?,
      academicYearId: freezed == academicYearId
          ? _self.academicYearId
          : academicYearId // ignore: cast_nullable_to_non_nullable
              as int?,
      academicYear: freezed == academicYear
          ? _self.academicYear
          : academicYear // ignore: cast_nullable_to_non_nullable
              as AcademicYearApiDto?,
      enrolmentDate: freezed == enrolmentDate
          ? _self.enrolmentDate
          : enrolmentDate // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClassApiDtoCopyWith<$Res>? get classField {
    if (_self.classField == null) {
      return null;
    }

    return $ClassApiDtoCopyWith<$Res>(_self.classField!, (value) {
      return _then(_self.copyWith(classField: value));
    });
  }

  /// Create a copy of EnrolmentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AcademicYearApiDtoCopyWith<$Res>? get academicYear {
    if (_self.academicYear == null) {
      return null;
    }

    return $AcademicYearApiDtoCopyWith<$Res>(_self.academicYear!, (value) {
      return _then(_self.copyWith(academicYear: value));
    });
  }
}

/// @nodoc
mixin _$ImageUrlResultDto {
  @JsonKey(name: 'url')
  String? get url;
  @JsonKey(name: 'fallbackUrl')
  String? get fallbackUrl;

  /// Create a copy of ImageUrlResultDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ImageUrlResultDtoCopyWith<ImageUrlResultDto> get copyWith =>
      _$ImageUrlResultDtoCopyWithImpl<ImageUrlResultDto>(
          this as ImageUrlResultDto, _$identity);

  /// Serializes this ImageUrlResultDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ImageUrlResultDto &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.fallbackUrl, fallbackUrl) ||
                other.fallbackUrl == fallbackUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url, fallbackUrl);

  @override
  String toString() {
    return 'ImageUrlResultDto(url: $url, fallbackUrl: $fallbackUrl)';
  }
}

/// @nodoc
abstract mixin class $ImageUrlResultDtoCopyWith<$Res> {
  factory $ImageUrlResultDtoCopyWith(
          ImageUrlResultDto value, $Res Function(ImageUrlResultDto) _then) =
      _$ImageUrlResultDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'url') String? url,
      @JsonKey(name: 'fallbackUrl') String? fallbackUrl});
}

/// @nodoc
class _$ImageUrlResultDtoCopyWithImpl<$Res>
    implements $ImageUrlResultDtoCopyWith<$Res> {
  _$ImageUrlResultDtoCopyWithImpl(this._self, this._then);

  final ImageUrlResultDto _self;
  final $Res Function(ImageUrlResultDto) _then;

  /// Create a copy of ImageUrlResultDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = freezed,
    Object? fallbackUrl = freezed,
  }) {
    return _then(_self.copyWith(
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      fallbackUrl: freezed == fallbackUrl
          ? _self.fallbackUrl
          : fallbackUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ImageUrlResultDto].
extension ImageUrlResultDtoPatterns on ImageUrlResultDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ImageUrlResultDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImageUrlResultDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ImageUrlResultDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageUrlResultDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ImageUrlResultDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageUrlResultDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'url') String? url,
            @JsonKey(name: 'fallbackUrl') String? fallbackUrl)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImageUrlResultDto() when $default != null:
        return $default(_that.url, _that.fallbackUrl);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'url') String? url,
            @JsonKey(name: 'fallbackUrl') String? fallbackUrl)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageUrlResultDto():
        return $default(_that.url, _that.fallbackUrl);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'url') String? url,
            @JsonKey(name: 'fallbackUrl') String? fallbackUrl)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImageUrlResultDto() when $default != null:
        return $default(_that.url, _that.fallbackUrl);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ImageUrlResultDto implements ImageUrlResultDto {
  _ImageUrlResultDto(
      {@JsonKey(name: 'url') this.url,
      @JsonKey(name: 'fallbackUrl') this.fallbackUrl});
  factory _ImageUrlResultDto.fromJson(Map<String, dynamic> json) =>
      _$ImageUrlResultDtoFromJson(json);

  @override
  @JsonKey(name: 'url')
  final String? url;
  @override
  @JsonKey(name: 'fallbackUrl')
  final String? fallbackUrl;

  /// Create a copy of ImageUrlResultDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ImageUrlResultDtoCopyWith<_ImageUrlResultDto> get copyWith =>
      __$ImageUrlResultDtoCopyWithImpl<_ImageUrlResultDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ImageUrlResultDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImageUrlResultDto &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.fallbackUrl, fallbackUrl) ||
                other.fallbackUrl == fallbackUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url, fallbackUrl);

  @override
  String toString() {
    return 'ImageUrlResultDto(url: $url, fallbackUrl: $fallbackUrl)';
  }
}

/// @nodoc
abstract mixin class _$ImageUrlResultDtoCopyWith<$Res>
    implements $ImageUrlResultDtoCopyWith<$Res> {
  factory _$ImageUrlResultDtoCopyWith(
          _ImageUrlResultDto value, $Res Function(_ImageUrlResultDto) _then) =
      __$ImageUrlResultDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'url') String? url,
      @JsonKey(name: 'fallbackUrl') String? fallbackUrl});
}

/// @nodoc
class __$ImageUrlResultDtoCopyWithImpl<$Res>
    implements _$ImageUrlResultDtoCopyWith<$Res> {
  __$ImageUrlResultDtoCopyWithImpl(this._self, this._then);

  final _ImageUrlResultDto _self;
  final $Res Function(_ImageUrlResultDto) _then;

  /// Create a copy of ImageUrlResultDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? url = freezed,
    Object? fallbackUrl = freezed,
  }) {
    return _then(_ImageUrlResultDto(
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      fallbackUrl: freezed == fallbackUrl
          ? _self.fallbackUrl
          : fallbackUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$InfantCareActivityApiDto {
  @JsonKey(name: 'infantCareActivityId')
  int? get infantCareActivityId;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'ageInMonths')
  int? get ageInMonths;
  @JsonKey(name: 'promotionDate')
  DateTime? get promotionDate;
  @JsonKey(name: 'lastFeedDateTime')
  DateTime? get lastFeedDateTime;
  @JsonKey(name: 'lastFeedTime')
  String? get lastFeedTime;
  @JsonKey(name: 'nextFeedDateTime')
  DateTime? get nextFeedDateTime;
  @JsonKey(name: 'nextFeedTime')
  String? get nextFeedTime;
  @JsonKey(name: 'feedRemarks')
  String? get feedRemarks;
  @JsonKey(name: 'feedPerformedBy')
  String? get feedPerformedBy;
  @JsonKey(name: 'lastDiaperDateTime')
  DateTime? get lastDiaperDateTime;
  @JsonKey(name: 'lastDiaperTime')
  String? get lastDiaperTime;
  @JsonKey(name: 'nextDiaperDateTime')
  DateTime? get nextDiaperDateTime;
  @JsonKey(name: 'nextDiaperTime')
  String? get nextDiaperTime;
  @JsonKey(name: 'diaperRemarks')
  String? get diaperRemarks;
  @JsonKey(name: 'diaperPerformedBy')
  String? get diaperPerformedBy;
  @JsonKey(name: 'napDateTime')
  DateTime? get napDateTime;
  @JsonKey(name: 'napTime')
  String? get napTime;
  @JsonKey(name: 'napDuration')
  int? get napDuration;
  @JsonKey(name: 'napPerformedBy')
  String? get napPerformedBy;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of InfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $InfantCareActivityApiDtoCopyWith<InfantCareActivityApiDto> get copyWith =>
      _$InfantCareActivityApiDtoCopyWithImpl<InfantCareActivityApiDto>(
          this as InfantCareActivityApiDto, _$identity);

  /// Serializes this InfantCareActivityApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InfantCareActivityApiDto &&
            (identical(other.infantCareActivityId, infantCareActivityId) ||
                other.infantCareActivityId == infantCareActivityId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.ageInMonths, ageInMonths) ||
                other.ageInMonths == ageInMonths) &&
            (identical(other.promotionDate, promotionDate) ||
                other.promotionDate == promotionDate) &&
            (identical(other.lastFeedDateTime, lastFeedDateTime) ||
                other.lastFeedDateTime == lastFeedDateTime) &&
            (identical(other.lastFeedTime, lastFeedTime) ||
                other.lastFeedTime == lastFeedTime) &&
            (identical(other.nextFeedDateTime, nextFeedDateTime) ||
                other.nextFeedDateTime == nextFeedDateTime) &&
            (identical(other.nextFeedTime, nextFeedTime) ||
                other.nextFeedTime == nextFeedTime) &&
            (identical(other.feedRemarks, feedRemarks) ||
                other.feedRemarks == feedRemarks) &&
            (identical(other.feedPerformedBy, feedPerformedBy) ||
                other.feedPerformedBy == feedPerformedBy) &&
            (identical(other.lastDiaperDateTime, lastDiaperDateTime) ||
                other.lastDiaperDateTime == lastDiaperDateTime) &&
            (identical(other.lastDiaperTime, lastDiaperTime) ||
                other.lastDiaperTime == lastDiaperTime) &&
            (identical(other.nextDiaperDateTime, nextDiaperDateTime) ||
                other.nextDiaperDateTime == nextDiaperDateTime) &&
            (identical(other.nextDiaperTime, nextDiaperTime) ||
                other.nextDiaperTime == nextDiaperTime) &&
            (identical(other.diaperRemarks, diaperRemarks) ||
                other.diaperRemarks == diaperRemarks) &&
            (identical(other.diaperPerformedBy, diaperPerformedBy) ||
                other.diaperPerformedBy == diaperPerformedBy) &&
            (identical(other.napDateTime, napDateTime) ||
                other.napDateTime == napDateTime) &&
            (identical(other.napTime, napTime) || other.napTime == napTime) &&
            (identical(other.napDuration, napDuration) ||
                other.napDuration == napDuration) &&
            (identical(other.napPerformedBy, napPerformedBy) ||
                other.napPerformedBy == napPerformedBy) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        infantCareActivityId,
        studentId,
        branchId,
        ageInMonths,
        promotionDate,
        lastFeedDateTime,
        lastFeedTime,
        nextFeedDateTime,
        nextFeedTime,
        feedRemarks,
        feedPerformedBy,
        lastDiaperDateTime,
        lastDiaperTime,
        nextDiaperDateTime,
        nextDiaperTime,
        diaperRemarks,
        diaperPerformedBy,
        napDateTime,
        napTime,
        napDuration,
        napPerformedBy,
        remarks,
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'InfantCareActivityApiDto(infantCareActivityId: $infantCareActivityId, studentId: $studentId, branchId: $branchId, ageInMonths: $ageInMonths, promotionDate: $promotionDate, lastFeedDateTime: $lastFeedDateTime, lastFeedTime: $lastFeedTime, nextFeedDateTime: $nextFeedDateTime, nextFeedTime: $nextFeedTime, feedRemarks: $feedRemarks, feedPerformedBy: $feedPerformedBy, lastDiaperDateTime: $lastDiaperDateTime, lastDiaperTime: $lastDiaperTime, nextDiaperDateTime: $nextDiaperDateTime, nextDiaperTime: $nextDiaperTime, diaperRemarks: $diaperRemarks, diaperPerformedBy: $diaperPerformedBy, napDateTime: $napDateTime, napTime: $napTime, napDuration: $napDuration, napPerformedBy: $napPerformedBy, remarks: $remarks, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $InfantCareActivityApiDtoCopyWith<$Res> {
  factory $InfantCareActivityApiDtoCopyWith(InfantCareActivityApiDto value,
          $Res Function(InfantCareActivityApiDto) _then) =
      _$InfantCareActivityApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'ageInMonths') int? ageInMonths,
      @JsonKey(name: 'promotionDate') DateTime? promotionDate,
      @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
      @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
      @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
      @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
      @JsonKey(name: 'feedRemarks') String? feedRemarks,
      @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
      @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
      @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
      @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
      @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
      @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
      @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
      @JsonKey(name: 'napDateTime') DateTime? napDateTime,
      @JsonKey(name: 'napTime') String? napTime,
      @JsonKey(name: 'napDuration') int? napDuration,
      @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$InfantCareActivityApiDtoCopyWithImpl<$Res>
    implements $InfantCareActivityApiDtoCopyWith<$Res> {
  _$InfantCareActivityApiDtoCopyWithImpl(this._self, this._then);

  final InfantCareActivityApiDto _self;
  final $Res Function(InfantCareActivityApiDto) _then;

  /// Create a copy of InfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? infantCareActivityId = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? ageInMonths = freezed,
    Object? promotionDate = freezed,
    Object? lastFeedDateTime = freezed,
    Object? lastFeedTime = freezed,
    Object? nextFeedDateTime = freezed,
    Object? nextFeedTime = freezed,
    Object? feedRemarks = freezed,
    Object? feedPerformedBy = freezed,
    Object? lastDiaperDateTime = freezed,
    Object? lastDiaperTime = freezed,
    Object? nextDiaperDateTime = freezed,
    Object? nextDiaperTime = freezed,
    Object? diaperRemarks = freezed,
    Object? diaperPerformedBy = freezed,
    Object? napDateTime = freezed,
    Object? napTime = freezed,
    Object? napDuration = freezed,
    Object? napPerformedBy = freezed,
    Object? remarks = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      infantCareActivityId: freezed == infantCareActivityId
          ? _self.infantCareActivityId
          : infantCareActivityId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      ageInMonths: freezed == ageInMonths
          ? _self.ageInMonths
          : ageInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      promotionDate: freezed == promotionDate
          ? _self.promotionDate
          : promotionDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedDateTime: freezed == lastFeedDateTime
          ? _self.lastFeedDateTime
          : lastFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedTime: freezed == lastFeedTime
          ? _self.lastFeedTime
          : lastFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextFeedDateTime: freezed == nextFeedDateTime
          ? _self.nextFeedDateTime
          : nextFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextFeedTime: freezed == nextFeedTime
          ? _self.nextFeedTime
          : nextFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      feedRemarks: freezed == feedRemarks
          ? _self.feedRemarks
          : feedRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      feedPerformedBy: freezed == feedPerformedBy
          ? _self.feedPerformedBy
          : feedPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      lastDiaperDateTime: freezed == lastDiaperDateTime
          ? _self.lastDiaperDateTime
          : lastDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastDiaperTime: freezed == lastDiaperTime
          ? _self.lastDiaperTime
          : lastDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextDiaperDateTime: freezed == nextDiaperDateTime
          ? _self.nextDiaperDateTime
          : nextDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextDiaperTime: freezed == nextDiaperTime
          ? _self.nextDiaperTime
          : nextDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperRemarks: freezed == diaperRemarks
          ? _self.diaperRemarks
          : diaperRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperPerformedBy: freezed == diaperPerformedBy
          ? _self.diaperPerformedBy
          : diaperPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      napDateTime: freezed == napDateTime
          ? _self.napDateTime
          : napDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      napTime: freezed == napTime
          ? _self.napTime
          : napTime // ignore: cast_nullable_to_non_nullable
              as String?,
      napDuration: freezed == napDuration
          ? _self.napDuration
          : napDuration // ignore: cast_nullable_to_non_nullable
              as int?,
      napPerformedBy: freezed == napPerformedBy
          ? _self.napPerformedBy
          : napPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [InfantCareActivityApiDto].
extension InfantCareActivityApiDtoPatterns on InfantCareActivityApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_InfantCareActivityApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_InfantCareActivityApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_InfantCareActivityApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'ageInMonths') int? ageInMonths,
            @JsonKey(name: 'promotionDate') DateTime? promotionDate,
            @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
            @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
            @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
            @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
            @JsonKey(name: 'feedRemarks') String? feedRemarks,
            @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
            @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
            @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
            @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
            @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
            @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
            @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
            @JsonKey(name: 'napDateTime') DateTime? napDateTime,
            @JsonKey(name: 'napTime') String? napTime,
            @JsonKey(name: 'napDuration') int? napDuration,
            @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityApiDto() when $default != null:
        return $default(
            _that.infantCareActivityId,
            _that.studentId,
            _that.branchId,
            _that.ageInMonths,
            _that.promotionDate,
            _that.lastFeedDateTime,
            _that.lastFeedTime,
            _that.nextFeedDateTime,
            _that.nextFeedTime,
            _that.feedRemarks,
            _that.feedPerformedBy,
            _that.lastDiaperDateTime,
            _that.lastDiaperTime,
            _that.nextDiaperDateTime,
            _that.nextDiaperTime,
            _that.diaperRemarks,
            _that.diaperPerformedBy,
            _that.napDateTime,
            _that.napTime,
            _that.napDuration,
            _that.napPerformedBy,
            _that.remarks,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'ageInMonths') int? ageInMonths,
            @JsonKey(name: 'promotionDate') DateTime? promotionDate,
            @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
            @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
            @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
            @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
            @JsonKey(name: 'feedRemarks') String? feedRemarks,
            @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
            @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
            @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
            @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
            @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
            @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
            @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
            @JsonKey(name: 'napDateTime') DateTime? napDateTime,
            @JsonKey(name: 'napTime') String? napTime,
            @JsonKey(name: 'napDuration') int? napDuration,
            @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityApiDto():
        return $default(
            _that.infantCareActivityId,
            _that.studentId,
            _that.branchId,
            _that.ageInMonths,
            _that.promotionDate,
            _that.lastFeedDateTime,
            _that.lastFeedTime,
            _that.nextFeedDateTime,
            _that.nextFeedTime,
            _that.feedRemarks,
            _that.feedPerformedBy,
            _that.lastDiaperDateTime,
            _that.lastDiaperTime,
            _that.nextDiaperDateTime,
            _that.nextDiaperTime,
            _that.diaperRemarks,
            _that.diaperPerformedBy,
            _that.napDateTime,
            _that.napTime,
            _that.napDuration,
            _that.napPerformedBy,
            _that.remarks,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'ageInMonths') int? ageInMonths,
            @JsonKey(name: 'promotionDate') DateTime? promotionDate,
            @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
            @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
            @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
            @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
            @JsonKey(name: 'feedRemarks') String? feedRemarks,
            @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
            @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
            @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
            @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
            @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
            @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
            @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
            @JsonKey(name: 'napDateTime') DateTime? napDateTime,
            @JsonKey(name: 'napTime') String? napTime,
            @JsonKey(name: 'napDuration') int? napDuration,
            @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityApiDto() when $default != null:
        return $default(
            _that.infantCareActivityId,
            _that.studentId,
            _that.branchId,
            _that.ageInMonths,
            _that.promotionDate,
            _that.lastFeedDateTime,
            _that.lastFeedTime,
            _that.nextFeedDateTime,
            _that.nextFeedTime,
            _that.feedRemarks,
            _that.feedPerformedBy,
            _that.lastDiaperDateTime,
            _that.lastDiaperTime,
            _that.nextDiaperDateTime,
            _that.nextDiaperTime,
            _that.diaperRemarks,
            _that.diaperPerformedBy,
            _that.napDateTime,
            _that.napTime,
            _that.napDuration,
            _that.napPerformedBy,
            _that.remarks,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _InfantCareActivityApiDto implements InfantCareActivityApiDto {
  _InfantCareActivityApiDto(
      {@JsonKey(name: 'infantCareActivityId') this.infantCareActivityId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'ageInMonths') this.ageInMonths,
      @JsonKey(name: 'promotionDate') this.promotionDate,
      @JsonKey(name: 'lastFeedDateTime') this.lastFeedDateTime,
      @JsonKey(name: 'lastFeedTime') this.lastFeedTime,
      @JsonKey(name: 'nextFeedDateTime') this.nextFeedDateTime,
      @JsonKey(name: 'nextFeedTime') this.nextFeedTime,
      @JsonKey(name: 'feedRemarks') this.feedRemarks,
      @JsonKey(name: 'feedPerformedBy') this.feedPerformedBy,
      @JsonKey(name: 'lastDiaperDateTime') this.lastDiaperDateTime,
      @JsonKey(name: 'lastDiaperTime') this.lastDiaperTime,
      @JsonKey(name: 'nextDiaperDateTime') this.nextDiaperDateTime,
      @JsonKey(name: 'nextDiaperTime') this.nextDiaperTime,
      @JsonKey(name: 'diaperRemarks') this.diaperRemarks,
      @JsonKey(name: 'diaperPerformedBy') this.diaperPerformedBy,
      @JsonKey(name: 'napDateTime') this.napDateTime,
      @JsonKey(name: 'napTime') this.napTime,
      @JsonKey(name: 'napDuration') this.napDuration,
      @JsonKey(name: 'napPerformedBy') this.napPerformedBy,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _InfantCareActivityApiDto.fromJson(Map<String, dynamic> json) =>
      _$InfantCareActivityApiDtoFromJson(json);

  @override
  @JsonKey(name: 'infantCareActivityId')
  final int? infantCareActivityId;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'ageInMonths')
  final int? ageInMonths;
  @override
  @JsonKey(name: 'promotionDate')
  final DateTime? promotionDate;
  @override
  @JsonKey(name: 'lastFeedDateTime')
  final DateTime? lastFeedDateTime;
  @override
  @JsonKey(name: 'lastFeedTime')
  final String? lastFeedTime;
  @override
  @JsonKey(name: 'nextFeedDateTime')
  final DateTime? nextFeedDateTime;
  @override
  @JsonKey(name: 'nextFeedTime')
  final String? nextFeedTime;
  @override
  @JsonKey(name: 'feedRemarks')
  final String? feedRemarks;
  @override
  @JsonKey(name: 'feedPerformedBy')
  final String? feedPerformedBy;
  @override
  @JsonKey(name: 'lastDiaperDateTime')
  final DateTime? lastDiaperDateTime;
  @override
  @JsonKey(name: 'lastDiaperTime')
  final String? lastDiaperTime;
  @override
  @JsonKey(name: 'nextDiaperDateTime')
  final DateTime? nextDiaperDateTime;
  @override
  @JsonKey(name: 'nextDiaperTime')
  final String? nextDiaperTime;
  @override
  @JsonKey(name: 'diaperRemarks')
  final String? diaperRemarks;
  @override
  @JsonKey(name: 'diaperPerformedBy')
  final String? diaperPerformedBy;
  @override
  @JsonKey(name: 'napDateTime')
  final DateTime? napDateTime;
  @override
  @JsonKey(name: 'napTime')
  final String? napTime;
  @override
  @JsonKey(name: 'napDuration')
  final int? napDuration;
  @override
  @JsonKey(name: 'napPerformedBy')
  final String? napPerformedBy;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of InfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$InfantCareActivityApiDtoCopyWith<_InfantCareActivityApiDto> get copyWith =>
      __$InfantCareActivityApiDtoCopyWithImpl<_InfantCareActivityApiDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$InfantCareActivityApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _InfantCareActivityApiDto &&
            (identical(other.infantCareActivityId, infantCareActivityId) ||
                other.infantCareActivityId == infantCareActivityId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.ageInMonths, ageInMonths) ||
                other.ageInMonths == ageInMonths) &&
            (identical(other.promotionDate, promotionDate) ||
                other.promotionDate == promotionDate) &&
            (identical(other.lastFeedDateTime, lastFeedDateTime) ||
                other.lastFeedDateTime == lastFeedDateTime) &&
            (identical(other.lastFeedTime, lastFeedTime) ||
                other.lastFeedTime == lastFeedTime) &&
            (identical(other.nextFeedDateTime, nextFeedDateTime) ||
                other.nextFeedDateTime == nextFeedDateTime) &&
            (identical(other.nextFeedTime, nextFeedTime) ||
                other.nextFeedTime == nextFeedTime) &&
            (identical(other.feedRemarks, feedRemarks) ||
                other.feedRemarks == feedRemarks) &&
            (identical(other.feedPerformedBy, feedPerformedBy) ||
                other.feedPerformedBy == feedPerformedBy) &&
            (identical(other.lastDiaperDateTime, lastDiaperDateTime) ||
                other.lastDiaperDateTime == lastDiaperDateTime) &&
            (identical(other.lastDiaperTime, lastDiaperTime) ||
                other.lastDiaperTime == lastDiaperTime) &&
            (identical(other.nextDiaperDateTime, nextDiaperDateTime) ||
                other.nextDiaperDateTime == nextDiaperDateTime) &&
            (identical(other.nextDiaperTime, nextDiaperTime) ||
                other.nextDiaperTime == nextDiaperTime) &&
            (identical(other.diaperRemarks, diaperRemarks) ||
                other.diaperRemarks == diaperRemarks) &&
            (identical(other.diaperPerformedBy, diaperPerformedBy) ||
                other.diaperPerformedBy == diaperPerformedBy) &&
            (identical(other.napDateTime, napDateTime) ||
                other.napDateTime == napDateTime) &&
            (identical(other.napTime, napTime) || other.napTime == napTime) &&
            (identical(other.napDuration, napDuration) ||
                other.napDuration == napDuration) &&
            (identical(other.napPerformedBy, napPerformedBy) ||
                other.napPerformedBy == napPerformedBy) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        infantCareActivityId,
        studentId,
        branchId,
        ageInMonths,
        promotionDate,
        lastFeedDateTime,
        lastFeedTime,
        nextFeedDateTime,
        nextFeedTime,
        feedRemarks,
        feedPerformedBy,
        lastDiaperDateTime,
        lastDiaperTime,
        nextDiaperDateTime,
        nextDiaperTime,
        diaperRemarks,
        diaperPerformedBy,
        napDateTime,
        napTime,
        napDuration,
        napPerformedBy,
        remarks,
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'InfantCareActivityApiDto(infantCareActivityId: $infantCareActivityId, studentId: $studentId, branchId: $branchId, ageInMonths: $ageInMonths, promotionDate: $promotionDate, lastFeedDateTime: $lastFeedDateTime, lastFeedTime: $lastFeedTime, nextFeedDateTime: $nextFeedDateTime, nextFeedTime: $nextFeedTime, feedRemarks: $feedRemarks, feedPerformedBy: $feedPerformedBy, lastDiaperDateTime: $lastDiaperDateTime, lastDiaperTime: $lastDiaperTime, nextDiaperDateTime: $nextDiaperDateTime, nextDiaperTime: $nextDiaperTime, diaperRemarks: $diaperRemarks, diaperPerformedBy: $diaperPerformedBy, napDateTime: $napDateTime, napTime: $napTime, napDuration: $napDuration, napPerformedBy: $napPerformedBy, remarks: $remarks, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$InfantCareActivityApiDtoCopyWith<$Res>
    implements $InfantCareActivityApiDtoCopyWith<$Res> {
  factory _$InfantCareActivityApiDtoCopyWith(_InfantCareActivityApiDto value,
          $Res Function(_InfantCareActivityApiDto) _then) =
      __$InfantCareActivityApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'ageInMonths') int? ageInMonths,
      @JsonKey(name: 'promotionDate') DateTime? promotionDate,
      @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
      @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
      @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
      @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
      @JsonKey(name: 'feedRemarks') String? feedRemarks,
      @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
      @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
      @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
      @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
      @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
      @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
      @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
      @JsonKey(name: 'napDateTime') DateTime? napDateTime,
      @JsonKey(name: 'napTime') String? napTime,
      @JsonKey(name: 'napDuration') int? napDuration,
      @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$InfantCareActivityApiDtoCopyWithImpl<$Res>
    implements _$InfantCareActivityApiDtoCopyWith<$Res> {
  __$InfantCareActivityApiDtoCopyWithImpl(this._self, this._then);

  final _InfantCareActivityApiDto _self;
  final $Res Function(_InfantCareActivityApiDto) _then;

  /// Create a copy of InfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? infantCareActivityId = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? ageInMonths = freezed,
    Object? promotionDate = freezed,
    Object? lastFeedDateTime = freezed,
    Object? lastFeedTime = freezed,
    Object? nextFeedDateTime = freezed,
    Object? nextFeedTime = freezed,
    Object? feedRemarks = freezed,
    Object? feedPerformedBy = freezed,
    Object? lastDiaperDateTime = freezed,
    Object? lastDiaperTime = freezed,
    Object? nextDiaperDateTime = freezed,
    Object? nextDiaperTime = freezed,
    Object? diaperRemarks = freezed,
    Object? diaperPerformedBy = freezed,
    Object? napDateTime = freezed,
    Object? napTime = freezed,
    Object? napDuration = freezed,
    Object? napPerformedBy = freezed,
    Object? remarks = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_InfantCareActivityApiDto(
      infantCareActivityId: freezed == infantCareActivityId
          ? _self.infantCareActivityId
          : infantCareActivityId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      ageInMonths: freezed == ageInMonths
          ? _self.ageInMonths
          : ageInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      promotionDate: freezed == promotionDate
          ? _self.promotionDate
          : promotionDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedDateTime: freezed == lastFeedDateTime
          ? _self.lastFeedDateTime
          : lastFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedTime: freezed == lastFeedTime
          ? _self.lastFeedTime
          : lastFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextFeedDateTime: freezed == nextFeedDateTime
          ? _self.nextFeedDateTime
          : nextFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextFeedTime: freezed == nextFeedTime
          ? _self.nextFeedTime
          : nextFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      feedRemarks: freezed == feedRemarks
          ? _self.feedRemarks
          : feedRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      feedPerformedBy: freezed == feedPerformedBy
          ? _self.feedPerformedBy
          : feedPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      lastDiaperDateTime: freezed == lastDiaperDateTime
          ? _self.lastDiaperDateTime
          : lastDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastDiaperTime: freezed == lastDiaperTime
          ? _self.lastDiaperTime
          : lastDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextDiaperDateTime: freezed == nextDiaperDateTime
          ? _self.nextDiaperDateTime
          : nextDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextDiaperTime: freezed == nextDiaperTime
          ? _self.nextDiaperTime
          : nextDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperRemarks: freezed == diaperRemarks
          ? _self.diaperRemarks
          : diaperRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperPerformedBy: freezed == diaperPerformedBy
          ? _self.diaperPerformedBy
          : diaperPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      napDateTime: freezed == napDateTime
          ? _self.napDateTime
          : napDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      napTime: freezed == napTime
          ? _self.napTime
          : napTime // ignore: cast_nullable_to_non_nullable
              as String?,
      napDuration: freezed == napDuration
          ? _self.napDuration
          : napDuration // ignore: cast_nullable_to_non_nullable
              as int?,
      napPerformedBy: freezed == napPerformedBy
          ? _self.napPerformedBy
          : napPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$InfantCareActivityLogApiDto {
  @JsonKey(name: 'infantCareActivityLogId')
  int? get infantCareActivityLogId;
  @JsonKey(name: 'infantCareActivityId')
  int? get infantCareActivityId;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'activityType')
  int? get activityType;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'performedBy')
  String? get performedBy;
  @JsonKey(name: 'performedAt')
  DateTime? get performedAt;
  @JsonKey(name: 'nextScheduledAt')
  DateTime? get nextScheduledAt;
  @JsonKey(name: 'additionalField')
  String? get additionalField;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of InfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $InfantCareActivityLogApiDtoCopyWith<InfantCareActivityLogApiDto>
      get copyWith => _$InfantCareActivityLogApiDtoCopyWithImpl<
              InfantCareActivityLogApiDto>(
          this as InfantCareActivityLogApiDto, _$identity);

  /// Serializes this InfantCareActivityLogApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InfantCareActivityLogApiDto &&
            (identical(
                    other.infantCareActivityLogId, infantCareActivityLogId) ||
                other.infantCareActivityLogId == infantCareActivityLogId) &&
            (identical(other.infantCareActivityId, infantCareActivityId) ||
                other.infantCareActivityId == infantCareActivityId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.activityType, activityType) ||
                other.activityType == activityType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.performedAt, performedAt) ||
                other.performedAt == performedAt) &&
            (identical(other.nextScheduledAt, nextScheduledAt) ||
                other.nextScheduledAt == nextScheduledAt) &&
            (identical(other.additionalField, additionalField) ||
                other.additionalField == additionalField) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      infantCareActivityLogId,
      infantCareActivityId,
      studentId,
      branchId,
      activityType,
      remarks,
      performedBy,
      performedAt,
      nextScheduledAt,
      additionalField,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'InfantCareActivityLogApiDto(infantCareActivityLogId: $infantCareActivityLogId, infantCareActivityId: $infantCareActivityId, studentId: $studentId, branchId: $branchId, activityType: $activityType, remarks: $remarks, performedBy: $performedBy, performedAt: $performedAt, nextScheduledAt: $nextScheduledAt, additionalField: $additionalField, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $InfantCareActivityLogApiDtoCopyWith<$Res> {
  factory $InfantCareActivityLogApiDtoCopyWith(
          InfantCareActivityLogApiDto value,
          $Res Function(InfantCareActivityLogApiDto) _then) =
      _$InfantCareActivityLogApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityLogId') int? infantCareActivityLogId,
      @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'activityType') int? activityType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'performedBy') String? performedBy,
      @JsonKey(name: 'performedAt') DateTime? performedAt,
      @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
      @JsonKey(name: 'additionalField') String? additionalField,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$InfantCareActivityLogApiDtoCopyWithImpl<$Res>
    implements $InfantCareActivityLogApiDtoCopyWith<$Res> {
  _$InfantCareActivityLogApiDtoCopyWithImpl(this._self, this._then);

  final InfantCareActivityLogApiDto _self;
  final $Res Function(InfantCareActivityLogApiDto) _then;

  /// Create a copy of InfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? infantCareActivityLogId = freezed,
    Object? infantCareActivityId = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? activityType = freezed,
    Object? remarks = freezed,
    Object? performedBy = freezed,
    Object? performedAt = freezed,
    Object? nextScheduledAt = freezed,
    Object? additionalField = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      infantCareActivityLogId: freezed == infantCareActivityLogId
          ? _self.infantCareActivityLogId
          : infantCareActivityLogId // ignore: cast_nullable_to_non_nullable
              as int?,
      infantCareActivityId: freezed == infantCareActivityId
          ? _self.infantCareActivityId
          : infantCareActivityId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      activityType: freezed == activityType
          ? _self.activityType
          : activityType // ignore: cast_nullable_to_non_nullable
              as int?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      performedAt: freezed == performedAt
          ? _self.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextScheduledAt: freezed == nextScheduledAt
          ? _self.nextScheduledAt
          : nextScheduledAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      additionalField: freezed == additionalField
          ? _self.additionalField
          : additionalField // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [InfantCareActivityLogApiDto].
extension InfantCareActivityLogApiDtoPatterns on InfantCareActivityLogApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_InfantCareActivityLogApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_InfantCareActivityLogApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_InfantCareActivityLogApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityLogId')
            int? infantCareActivityLogId,
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'activityType') int? activityType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'performedAt') DateTime? performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogApiDto() when $default != null:
        return $default(
            _that.infantCareActivityLogId,
            _that.infantCareActivityId,
            _that.studentId,
            _that.branchId,
            _that.activityType,
            _that.remarks,
            _that.performedBy,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.additionalField,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityLogId')
            int? infantCareActivityLogId,
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'activityType') int? activityType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'performedAt') DateTime? performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogApiDto():
        return $default(
            _that.infantCareActivityLogId,
            _that.infantCareActivityId,
            _that.studentId,
            _that.branchId,
            _that.activityType,
            _that.remarks,
            _that.performedBy,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.additionalField,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'infantCareActivityLogId')
            int? infantCareActivityLogId,
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'activityType') int? activityType,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'performedAt') DateTime? performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogApiDto() when $default != null:
        return $default(
            _that.infantCareActivityLogId,
            _that.infantCareActivityId,
            _that.studentId,
            _that.branchId,
            _that.activityType,
            _that.remarks,
            _that.performedBy,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.additionalField,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _InfantCareActivityLogApiDto implements InfantCareActivityLogApiDto {
  _InfantCareActivityLogApiDto(
      {@JsonKey(name: 'infantCareActivityLogId') this.infantCareActivityLogId,
      @JsonKey(name: 'infantCareActivityId') this.infantCareActivityId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'activityType') this.activityType,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'performedBy') this.performedBy,
      @JsonKey(name: 'performedAt') this.performedAt,
      @JsonKey(name: 'nextScheduledAt') this.nextScheduledAt,
      @JsonKey(name: 'additionalField') this.additionalField,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _InfantCareActivityLogApiDto.fromJson(Map<String, dynamic> json) =>
      _$InfantCareActivityLogApiDtoFromJson(json);

  @override
  @JsonKey(name: 'infantCareActivityLogId')
  final int? infantCareActivityLogId;
  @override
  @JsonKey(name: 'infantCareActivityId')
  final int? infantCareActivityId;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'activityType')
  final int? activityType;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'performedBy')
  final String? performedBy;
  @override
  @JsonKey(name: 'performedAt')
  final DateTime? performedAt;
  @override
  @JsonKey(name: 'nextScheduledAt')
  final DateTime? nextScheduledAt;
  @override
  @JsonKey(name: 'additionalField')
  final String? additionalField;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of InfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$InfantCareActivityLogApiDtoCopyWith<_InfantCareActivityLogApiDto>
      get copyWith => __$InfantCareActivityLogApiDtoCopyWithImpl<
          _InfantCareActivityLogApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$InfantCareActivityLogApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _InfantCareActivityLogApiDto &&
            (identical(
                    other.infantCareActivityLogId, infantCareActivityLogId) ||
                other.infantCareActivityLogId == infantCareActivityLogId) &&
            (identical(other.infantCareActivityId, infantCareActivityId) ||
                other.infantCareActivityId == infantCareActivityId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.activityType, activityType) ||
                other.activityType == activityType) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.performedAt, performedAt) ||
                other.performedAt == performedAt) &&
            (identical(other.nextScheduledAt, nextScheduledAt) ||
                other.nextScheduledAt == nextScheduledAt) &&
            (identical(other.additionalField, additionalField) ||
                other.additionalField == additionalField) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      infantCareActivityLogId,
      infantCareActivityId,
      studentId,
      branchId,
      activityType,
      remarks,
      performedBy,
      performedAt,
      nextScheduledAt,
      additionalField,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'InfantCareActivityLogApiDto(infantCareActivityLogId: $infantCareActivityLogId, infantCareActivityId: $infantCareActivityId, studentId: $studentId, branchId: $branchId, activityType: $activityType, remarks: $remarks, performedBy: $performedBy, performedAt: $performedAt, nextScheduledAt: $nextScheduledAt, additionalField: $additionalField, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$InfantCareActivityLogApiDtoCopyWith<$Res>
    implements $InfantCareActivityLogApiDtoCopyWith<$Res> {
  factory _$InfantCareActivityLogApiDtoCopyWith(
          _InfantCareActivityLogApiDto value,
          $Res Function(_InfantCareActivityLogApiDto) _then) =
      __$InfantCareActivityLogApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityLogId') int? infantCareActivityLogId,
      @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'activityType') int? activityType,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'performedBy') String? performedBy,
      @JsonKey(name: 'performedAt') DateTime? performedAt,
      @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
      @JsonKey(name: 'additionalField') String? additionalField,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$InfantCareActivityLogApiDtoCopyWithImpl<$Res>
    implements _$InfantCareActivityLogApiDtoCopyWith<$Res> {
  __$InfantCareActivityLogApiDtoCopyWithImpl(this._self, this._then);

  final _InfantCareActivityLogApiDto _self;
  final $Res Function(_InfantCareActivityLogApiDto) _then;

  /// Create a copy of InfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? infantCareActivityLogId = freezed,
    Object? infantCareActivityId = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? activityType = freezed,
    Object? remarks = freezed,
    Object? performedBy = freezed,
    Object? performedAt = freezed,
    Object? nextScheduledAt = freezed,
    Object? additionalField = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_InfantCareActivityLogApiDto(
      infantCareActivityLogId: freezed == infantCareActivityLogId
          ? _self.infantCareActivityLogId
          : infantCareActivityLogId // ignore: cast_nullable_to_non_nullable
              as int?,
      infantCareActivityId: freezed == infantCareActivityId
          ? _self.infantCareActivityId
          : infantCareActivityId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      activityType: freezed == activityType
          ? _self.activityType
          : activityType // ignore: cast_nullable_to_non_nullable
              as int?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      performedAt: freezed == performedAt
          ? _self.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextScheduledAt: freezed == nextScheduledAt
          ? _self.nextScheduledAt
          : nextScheduledAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      additionalField: freezed == additionalField
          ? _self.additionalField
          : additionalField // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$InfantCareActivityLogCreateDto {
  @JsonKey(name: 'infantCareActivityId')
  int? get infantCareActivityId;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'activityType')
  int get activityType;
  @JsonKey(name: 'performedAt')
  DateTime get performedAt;
  @JsonKey(name: 'nextScheduledAt')
  DateTime? get nextScheduledAt;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'performedBy')
  String? get performedBy;
  @JsonKey(name: 'additionalField')
  String? get additionalField;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;

  /// Create a copy of InfantCareActivityLogCreateDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $InfantCareActivityLogCreateDtoCopyWith<InfantCareActivityLogCreateDto>
      get copyWith => _$InfantCareActivityLogCreateDtoCopyWithImpl<
              InfantCareActivityLogCreateDto>(
          this as InfantCareActivityLogCreateDto, _$identity);

  /// Serializes this InfantCareActivityLogCreateDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InfantCareActivityLogCreateDto &&
            (identical(other.infantCareActivityId, infantCareActivityId) ||
                other.infantCareActivityId == infantCareActivityId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.activityType, activityType) ||
                other.activityType == activityType) &&
            (identical(other.performedAt, performedAt) ||
                other.performedAt == performedAt) &&
            (identical(other.nextScheduledAt, nextScheduledAt) ||
                other.nextScheduledAt == nextScheduledAt) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.additionalField, additionalField) ||
                other.additionalField == additionalField) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      infantCareActivityId,
      studentId,
      activityType,
      performedAt,
      nextScheduledAt,
      remarks,
      performedBy,
      additionalField,
      isDeleted);

  @override
  String toString() {
    return 'InfantCareActivityLogCreateDto(infantCareActivityId: $infantCareActivityId, studentId: $studentId, activityType: $activityType, performedAt: $performedAt, nextScheduledAt: $nextScheduledAt, remarks: $remarks, performedBy: $performedBy, additionalField: $additionalField, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class $InfantCareActivityLogCreateDtoCopyWith<$Res> {
  factory $InfantCareActivityLogCreateDtoCopyWith(
          InfantCareActivityLogCreateDto value,
          $Res Function(InfantCareActivityLogCreateDto) _then) =
      _$InfantCareActivityLogCreateDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'activityType') int activityType,
      @JsonKey(name: 'performedAt') DateTime performedAt,
      @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'performedBy') String? performedBy,
      @JsonKey(name: 'additionalField') String? additionalField,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class _$InfantCareActivityLogCreateDtoCopyWithImpl<$Res>
    implements $InfantCareActivityLogCreateDtoCopyWith<$Res> {
  _$InfantCareActivityLogCreateDtoCopyWithImpl(this._self, this._then);

  final InfantCareActivityLogCreateDto _self;
  final $Res Function(InfantCareActivityLogCreateDto) _then;

  /// Create a copy of InfantCareActivityLogCreateDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? infantCareActivityId = freezed,
    Object? studentId = freezed,
    Object? activityType = null,
    Object? performedAt = null,
    Object? nextScheduledAt = freezed,
    Object? remarks = freezed,
    Object? performedBy = freezed,
    Object? additionalField = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_self.copyWith(
      infantCareActivityId: freezed == infantCareActivityId
          ? _self.infantCareActivityId
          : infantCareActivityId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      activityType: null == activityType
          ? _self.activityType
          : activityType // ignore: cast_nullable_to_non_nullable
              as int,
      performedAt: null == performedAt
          ? _self.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      nextScheduledAt: freezed == nextScheduledAt
          ? _self.nextScheduledAt
          : nextScheduledAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalField: freezed == additionalField
          ? _self.additionalField
          : additionalField // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [InfantCareActivityLogCreateDto].
extension InfantCareActivityLogCreateDtoPatterns
    on InfantCareActivityLogCreateDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_InfantCareActivityLogCreateDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogCreateDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_InfantCareActivityLogCreateDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogCreateDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_InfantCareActivityLogCreateDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogCreateDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'activityType') int activityType,
            @JsonKey(name: 'performedAt') DateTime performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogCreateDto() when $default != null:
        return $default(
            _that.infantCareActivityId,
            _that.studentId,
            _that.activityType,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.remarks,
            _that.performedBy,
            _that.additionalField,
            _that.isDeleted);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'activityType') int activityType,
            @JsonKey(name: 'performedAt') DateTime performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogCreateDto():
        return $default(
            _that.infantCareActivityId,
            _that.studentId,
            _that.activityType,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.remarks,
            _that.performedBy,
            _that.additionalField,
            _that.isDeleted);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'activityType') int activityType,
            @JsonKey(name: 'performedAt') DateTime performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogCreateDto() when $default != null:
        return $default(
            _that.infantCareActivityId,
            _that.studentId,
            _that.activityType,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.remarks,
            _that.performedBy,
            _that.additionalField,
            _that.isDeleted);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _InfantCareActivityLogCreateDto
    implements InfantCareActivityLogCreateDto {
  _InfantCareActivityLogCreateDto(
      {@JsonKey(name: 'infantCareActivityId') this.infantCareActivityId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'activityType') required this.activityType,
      @JsonKey(name: 'performedAt') required this.performedAt,
      @JsonKey(name: 'nextScheduledAt') this.nextScheduledAt,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'performedBy') this.performedBy,
      @JsonKey(name: 'additionalField') this.additionalField,
      @JsonKey(name: 'isDeleted') this.isDeleted});
  factory _InfantCareActivityLogCreateDto.fromJson(Map<String, dynamic> json) =>
      _$InfantCareActivityLogCreateDtoFromJson(json);

  @override
  @JsonKey(name: 'infantCareActivityId')
  final int? infantCareActivityId;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'activityType')
  final int activityType;
  @override
  @JsonKey(name: 'performedAt')
  final DateTime performedAt;
  @override
  @JsonKey(name: 'nextScheduledAt')
  final DateTime? nextScheduledAt;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'performedBy')
  final String? performedBy;
  @override
  @JsonKey(name: 'additionalField')
  final String? additionalField;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;

  /// Create a copy of InfantCareActivityLogCreateDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$InfantCareActivityLogCreateDtoCopyWith<_InfantCareActivityLogCreateDto>
      get copyWith => __$InfantCareActivityLogCreateDtoCopyWithImpl<
          _InfantCareActivityLogCreateDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$InfantCareActivityLogCreateDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _InfantCareActivityLogCreateDto &&
            (identical(other.infantCareActivityId, infantCareActivityId) ||
                other.infantCareActivityId == infantCareActivityId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.activityType, activityType) ||
                other.activityType == activityType) &&
            (identical(other.performedAt, performedAt) ||
                other.performedAt == performedAt) &&
            (identical(other.nextScheduledAt, nextScheduledAt) ||
                other.nextScheduledAt == nextScheduledAt) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.additionalField, additionalField) ||
                other.additionalField == additionalField) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      infantCareActivityId,
      studentId,
      activityType,
      performedAt,
      nextScheduledAt,
      remarks,
      performedBy,
      additionalField,
      isDeleted);

  @override
  String toString() {
    return 'InfantCareActivityLogCreateDto(infantCareActivityId: $infantCareActivityId, studentId: $studentId, activityType: $activityType, performedAt: $performedAt, nextScheduledAt: $nextScheduledAt, remarks: $remarks, performedBy: $performedBy, additionalField: $additionalField, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class _$InfantCareActivityLogCreateDtoCopyWith<$Res>
    implements $InfantCareActivityLogCreateDtoCopyWith<$Res> {
  factory _$InfantCareActivityLogCreateDtoCopyWith(
          _InfantCareActivityLogCreateDto value,
          $Res Function(_InfantCareActivityLogCreateDto) _then) =
      __$InfantCareActivityLogCreateDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityId') int? infantCareActivityId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'activityType') int activityType,
      @JsonKey(name: 'performedAt') DateTime performedAt,
      @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'performedBy') String? performedBy,
      @JsonKey(name: 'additionalField') String? additionalField,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class __$InfantCareActivityLogCreateDtoCopyWithImpl<$Res>
    implements _$InfantCareActivityLogCreateDtoCopyWith<$Res> {
  __$InfantCareActivityLogCreateDtoCopyWithImpl(this._self, this._then);

  final _InfantCareActivityLogCreateDto _self;
  final $Res Function(_InfantCareActivityLogCreateDto) _then;

  /// Create a copy of InfantCareActivityLogCreateDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? infantCareActivityId = freezed,
    Object? studentId = freezed,
    Object? activityType = null,
    Object? performedAt = null,
    Object? nextScheduledAt = freezed,
    Object? remarks = freezed,
    Object? performedBy = freezed,
    Object? additionalField = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_InfantCareActivityLogCreateDto(
      infantCareActivityId: freezed == infantCareActivityId
          ? _self.infantCareActivityId
          : infantCareActivityId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      activityType: null == activityType
          ? _self.activityType
          : activityType // ignore: cast_nullable_to_non_nullable
              as int,
      performedAt: null == performedAt
          ? _self.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      nextScheduledAt: freezed == nextScheduledAt
          ? _self.nextScheduledAt
          : nextScheduledAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalField: freezed == additionalField
          ? _self.additionalField
          : additionalField // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$InfantCareActivityLogUpdateDto {
  @JsonKey(name: 'infantCareActivityLogId')
  int get infantCareActivityLogId;
  @JsonKey(name: 'activityType')
  int? get activityType;
  @JsonKey(name: 'performedAt')
  DateTime? get performedAt;
  @JsonKey(name: 'nextScheduledAt')
  DateTime? get nextScheduledAt;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'performedBy')
  String? get performedBy;
  @JsonKey(name: 'additionalField')
  String? get additionalField;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;

  /// Create a copy of InfantCareActivityLogUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $InfantCareActivityLogUpdateDtoCopyWith<InfantCareActivityLogUpdateDto>
      get copyWith => _$InfantCareActivityLogUpdateDtoCopyWithImpl<
              InfantCareActivityLogUpdateDto>(
          this as InfantCareActivityLogUpdateDto, _$identity);

  /// Serializes this InfantCareActivityLogUpdateDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InfantCareActivityLogUpdateDto &&
            (identical(
                    other.infantCareActivityLogId, infantCareActivityLogId) ||
                other.infantCareActivityLogId == infantCareActivityLogId) &&
            (identical(other.activityType, activityType) ||
                other.activityType == activityType) &&
            (identical(other.performedAt, performedAt) ||
                other.performedAt == performedAt) &&
            (identical(other.nextScheduledAt, nextScheduledAt) ||
                other.nextScheduledAt == nextScheduledAt) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.additionalField, additionalField) ||
                other.additionalField == additionalField) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      infantCareActivityLogId,
      activityType,
      performedAt,
      nextScheduledAt,
      remarks,
      performedBy,
      additionalField,
      isDeleted);

  @override
  String toString() {
    return 'InfantCareActivityLogUpdateDto(infantCareActivityLogId: $infantCareActivityLogId, activityType: $activityType, performedAt: $performedAt, nextScheduledAt: $nextScheduledAt, remarks: $remarks, performedBy: $performedBy, additionalField: $additionalField, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class $InfantCareActivityLogUpdateDtoCopyWith<$Res> {
  factory $InfantCareActivityLogUpdateDtoCopyWith(
          InfantCareActivityLogUpdateDto value,
          $Res Function(InfantCareActivityLogUpdateDto) _then) =
      _$InfantCareActivityLogUpdateDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityLogId') int infantCareActivityLogId,
      @JsonKey(name: 'activityType') int? activityType,
      @JsonKey(name: 'performedAt') DateTime? performedAt,
      @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'performedBy') String? performedBy,
      @JsonKey(name: 'additionalField') String? additionalField,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class _$InfantCareActivityLogUpdateDtoCopyWithImpl<$Res>
    implements $InfantCareActivityLogUpdateDtoCopyWith<$Res> {
  _$InfantCareActivityLogUpdateDtoCopyWithImpl(this._self, this._then);

  final InfantCareActivityLogUpdateDto _self;
  final $Res Function(InfantCareActivityLogUpdateDto) _then;

  /// Create a copy of InfantCareActivityLogUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? infantCareActivityLogId = null,
    Object? activityType = freezed,
    Object? performedAt = freezed,
    Object? nextScheduledAt = freezed,
    Object? remarks = freezed,
    Object? performedBy = freezed,
    Object? additionalField = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_self.copyWith(
      infantCareActivityLogId: null == infantCareActivityLogId
          ? _self.infantCareActivityLogId
          : infantCareActivityLogId // ignore: cast_nullable_to_non_nullable
              as int,
      activityType: freezed == activityType
          ? _self.activityType
          : activityType // ignore: cast_nullable_to_non_nullable
              as int?,
      performedAt: freezed == performedAt
          ? _self.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextScheduledAt: freezed == nextScheduledAt
          ? _self.nextScheduledAt
          : nextScheduledAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalField: freezed == additionalField
          ? _self.additionalField
          : additionalField // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [InfantCareActivityLogUpdateDto].
extension InfantCareActivityLogUpdateDtoPatterns
    on InfantCareActivityLogUpdateDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_InfantCareActivityLogUpdateDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogUpdateDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_InfantCareActivityLogUpdateDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogUpdateDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_InfantCareActivityLogUpdateDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogUpdateDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityLogId')
            int infantCareActivityLogId,
            @JsonKey(name: 'activityType') int? activityType,
            @JsonKey(name: 'performedAt') DateTime? performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogUpdateDto() when $default != null:
        return $default(
            _that.infantCareActivityLogId,
            _that.activityType,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.remarks,
            _that.performedBy,
            _that.additionalField,
            _that.isDeleted);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'infantCareActivityLogId')
            int infantCareActivityLogId,
            @JsonKey(name: 'activityType') int? activityType,
            @JsonKey(name: 'performedAt') DateTime? performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogUpdateDto():
        return $default(
            _that.infantCareActivityLogId,
            _that.activityType,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.remarks,
            _that.performedBy,
            _that.additionalField,
            _that.isDeleted);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'infantCareActivityLogId')
            int infantCareActivityLogId,
            @JsonKey(name: 'activityType') int? activityType,
            @JsonKey(name: 'performedAt') DateTime? performedAt,
            @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'performedBy') String? performedBy,
            @JsonKey(name: 'additionalField') String? additionalField,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivityLogUpdateDto() when $default != null:
        return $default(
            _that.infantCareActivityLogId,
            _that.activityType,
            _that.performedAt,
            _that.nextScheduledAt,
            _that.remarks,
            _that.performedBy,
            _that.additionalField,
            _that.isDeleted);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _InfantCareActivityLogUpdateDto
    implements InfantCareActivityLogUpdateDto {
  _InfantCareActivityLogUpdateDto(
      {@JsonKey(name: 'infantCareActivityLogId')
      required this.infantCareActivityLogId,
      @JsonKey(name: 'activityType') this.activityType,
      @JsonKey(name: 'performedAt') this.performedAt,
      @JsonKey(name: 'nextScheduledAt') this.nextScheduledAt,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'performedBy') this.performedBy,
      @JsonKey(name: 'additionalField') this.additionalField,
      @JsonKey(name: 'isDeleted') this.isDeleted});
  factory _InfantCareActivityLogUpdateDto.fromJson(Map<String, dynamic> json) =>
      _$InfantCareActivityLogUpdateDtoFromJson(json);

  @override
  @JsonKey(name: 'infantCareActivityLogId')
  final int infantCareActivityLogId;
  @override
  @JsonKey(name: 'activityType')
  final int? activityType;
  @override
  @JsonKey(name: 'performedAt')
  final DateTime? performedAt;
  @override
  @JsonKey(name: 'nextScheduledAt')
  final DateTime? nextScheduledAt;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'performedBy')
  final String? performedBy;
  @override
  @JsonKey(name: 'additionalField')
  final String? additionalField;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;

  /// Create a copy of InfantCareActivityLogUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$InfantCareActivityLogUpdateDtoCopyWith<_InfantCareActivityLogUpdateDto>
      get copyWith => __$InfantCareActivityLogUpdateDtoCopyWithImpl<
          _InfantCareActivityLogUpdateDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$InfantCareActivityLogUpdateDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _InfantCareActivityLogUpdateDto &&
            (identical(
                    other.infantCareActivityLogId, infantCareActivityLogId) ||
                other.infantCareActivityLogId == infantCareActivityLogId) &&
            (identical(other.activityType, activityType) ||
                other.activityType == activityType) &&
            (identical(other.performedAt, performedAt) ||
                other.performedAt == performedAt) &&
            (identical(other.nextScheduledAt, nextScheduledAt) ||
                other.nextScheduledAt == nextScheduledAt) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.additionalField, additionalField) ||
                other.additionalField == additionalField) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      infantCareActivityLogId,
      activityType,
      performedAt,
      nextScheduledAt,
      remarks,
      performedBy,
      additionalField,
      isDeleted);

  @override
  String toString() {
    return 'InfantCareActivityLogUpdateDto(infantCareActivityLogId: $infantCareActivityLogId, activityType: $activityType, performedAt: $performedAt, nextScheduledAt: $nextScheduledAt, remarks: $remarks, performedBy: $performedBy, additionalField: $additionalField, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class _$InfantCareActivityLogUpdateDtoCopyWith<$Res>
    implements $InfantCareActivityLogUpdateDtoCopyWith<$Res> {
  factory _$InfantCareActivityLogUpdateDtoCopyWith(
          _InfantCareActivityLogUpdateDto value,
          $Res Function(_InfantCareActivityLogUpdateDto) _then) =
      __$InfantCareActivityLogUpdateDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'infantCareActivityLogId') int infantCareActivityLogId,
      @JsonKey(name: 'activityType') int? activityType,
      @JsonKey(name: 'performedAt') DateTime? performedAt,
      @JsonKey(name: 'nextScheduledAt') DateTime? nextScheduledAt,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'performedBy') String? performedBy,
      @JsonKey(name: 'additionalField') String? additionalField,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class __$InfantCareActivityLogUpdateDtoCopyWithImpl<$Res>
    implements _$InfantCareActivityLogUpdateDtoCopyWith<$Res> {
  __$InfantCareActivityLogUpdateDtoCopyWithImpl(this._self, this._then);

  final _InfantCareActivityLogUpdateDto _self;
  final $Res Function(_InfantCareActivityLogUpdateDto) _then;

  /// Create a copy of InfantCareActivityLogUpdateDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? infantCareActivityLogId = null,
    Object? activityType = freezed,
    Object? performedAt = freezed,
    Object? nextScheduledAt = freezed,
    Object? remarks = freezed,
    Object? performedBy = freezed,
    Object? additionalField = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_InfantCareActivityLogUpdateDto(
      infantCareActivityLogId: null == infantCareActivityLogId
          ? _self.infantCareActivityLogId
          : infantCareActivityLogId // ignore: cast_nullable_to_non_nullable
              as int,
      activityType: freezed == activityType
          ? _self.activityType
          : activityType // ignore: cast_nullable_to_non_nullable
              as int?,
      performedAt: freezed == performedAt
          ? _self.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextScheduledAt: freezed == nextScheduledAt
          ? _self.nextScheduledAt
          : nextScheduledAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalField: freezed == additionalField
          ? _self.additionalField
          : additionalField // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$InfantCareActivitySaveDto {
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'promotionDate')
  DateTime? get promotionDate;
  @JsonKey(name: 'lastFeedDateTime')
  DateTime? get lastFeedDateTime;
  @JsonKey(name: 'lastFeedTime')
  String? get lastFeedTime;
  @JsonKey(name: 'nextFeedDateTime')
  DateTime? get nextFeedDateTime;
  @JsonKey(name: 'nextFeedTime')
  String? get nextFeedTime;
  @JsonKey(name: 'feedRemarks')
  String? get feedRemarks;
  @JsonKey(name: 'feedPerformedBy')
  String? get feedPerformedBy;
  @JsonKey(name: 'lastDiaperDateTime')
  DateTime? get lastDiaperDateTime;
  @JsonKey(name: 'lastDiaperTime')
  String? get lastDiaperTime;
  @JsonKey(name: 'nextDiaperDateTime')
  DateTime? get nextDiaperDateTime;
  @JsonKey(name: 'nextDiaperTime')
  String? get nextDiaperTime;
  @JsonKey(name: 'diaperRemarks')
  String? get diaperRemarks;
  @JsonKey(name: 'diaperPerformedBy')
  String? get diaperPerformedBy;
  @JsonKey(name: 'napDateTime')
  DateTime? get napDateTime;
  @JsonKey(name: 'napTime')
  String? get napTime;
  @JsonKey(name: 'napDuration')
  int? get napDuration;
  @JsonKey(name: 'napPerformedBy')
  String? get napPerformedBy;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;

  /// Create a copy of InfantCareActivitySaveDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $InfantCareActivitySaveDtoCopyWith<InfantCareActivitySaveDto> get copyWith =>
      _$InfantCareActivitySaveDtoCopyWithImpl<InfantCareActivitySaveDto>(
          this as InfantCareActivitySaveDto, _$identity);

  /// Serializes this InfantCareActivitySaveDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InfantCareActivitySaveDto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.promotionDate, promotionDate) ||
                other.promotionDate == promotionDate) &&
            (identical(other.lastFeedDateTime, lastFeedDateTime) ||
                other.lastFeedDateTime == lastFeedDateTime) &&
            (identical(other.lastFeedTime, lastFeedTime) ||
                other.lastFeedTime == lastFeedTime) &&
            (identical(other.nextFeedDateTime, nextFeedDateTime) ||
                other.nextFeedDateTime == nextFeedDateTime) &&
            (identical(other.nextFeedTime, nextFeedTime) ||
                other.nextFeedTime == nextFeedTime) &&
            (identical(other.feedRemarks, feedRemarks) ||
                other.feedRemarks == feedRemarks) &&
            (identical(other.feedPerformedBy, feedPerformedBy) ||
                other.feedPerformedBy == feedPerformedBy) &&
            (identical(other.lastDiaperDateTime, lastDiaperDateTime) ||
                other.lastDiaperDateTime == lastDiaperDateTime) &&
            (identical(other.lastDiaperTime, lastDiaperTime) ||
                other.lastDiaperTime == lastDiaperTime) &&
            (identical(other.nextDiaperDateTime, nextDiaperDateTime) ||
                other.nextDiaperDateTime == nextDiaperDateTime) &&
            (identical(other.nextDiaperTime, nextDiaperTime) ||
                other.nextDiaperTime == nextDiaperTime) &&
            (identical(other.diaperRemarks, diaperRemarks) ||
                other.diaperRemarks == diaperRemarks) &&
            (identical(other.diaperPerformedBy, diaperPerformedBy) ||
                other.diaperPerformedBy == diaperPerformedBy) &&
            (identical(other.napDateTime, napDateTime) ||
                other.napDateTime == napDateTime) &&
            (identical(other.napTime, napTime) || other.napTime == napTime) &&
            (identical(other.napDuration, napDuration) ||
                other.napDuration == napDuration) &&
            (identical(other.napPerformedBy, napPerformedBy) ||
                other.napPerformedBy == napPerformedBy) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        studentId,
        branchId,
        promotionDate,
        lastFeedDateTime,
        lastFeedTime,
        nextFeedDateTime,
        nextFeedTime,
        feedRemarks,
        feedPerformedBy,
        lastDiaperDateTime,
        lastDiaperTime,
        nextDiaperDateTime,
        nextDiaperTime,
        diaperRemarks,
        diaperPerformedBy,
        napDateTime,
        napTime,
        napDuration,
        napPerformedBy,
        remarks,
        isDeleted
      ]);

  @override
  String toString() {
    return 'InfantCareActivitySaveDto(studentId: $studentId, branchId: $branchId, promotionDate: $promotionDate, lastFeedDateTime: $lastFeedDateTime, lastFeedTime: $lastFeedTime, nextFeedDateTime: $nextFeedDateTime, nextFeedTime: $nextFeedTime, feedRemarks: $feedRemarks, feedPerformedBy: $feedPerformedBy, lastDiaperDateTime: $lastDiaperDateTime, lastDiaperTime: $lastDiaperTime, nextDiaperDateTime: $nextDiaperDateTime, nextDiaperTime: $nextDiaperTime, diaperRemarks: $diaperRemarks, diaperPerformedBy: $diaperPerformedBy, napDateTime: $napDateTime, napTime: $napTime, napDuration: $napDuration, napPerformedBy: $napPerformedBy, remarks: $remarks, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class $InfantCareActivitySaveDtoCopyWith<$Res> {
  factory $InfantCareActivitySaveDtoCopyWith(InfantCareActivitySaveDto value,
          $Res Function(InfantCareActivitySaveDto) _then) =
      _$InfantCareActivitySaveDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'promotionDate') DateTime? promotionDate,
      @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
      @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
      @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
      @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
      @JsonKey(name: 'feedRemarks') String? feedRemarks,
      @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
      @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
      @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
      @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
      @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
      @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
      @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
      @JsonKey(name: 'napDateTime') DateTime? napDateTime,
      @JsonKey(name: 'napTime') String? napTime,
      @JsonKey(name: 'napDuration') int? napDuration,
      @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class _$InfantCareActivitySaveDtoCopyWithImpl<$Res>
    implements $InfantCareActivitySaveDtoCopyWith<$Res> {
  _$InfantCareActivitySaveDtoCopyWithImpl(this._self, this._then);

  final InfantCareActivitySaveDto _self;
  final $Res Function(InfantCareActivitySaveDto) _then;

  /// Create a copy of InfantCareActivitySaveDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? promotionDate = freezed,
    Object? lastFeedDateTime = freezed,
    Object? lastFeedTime = freezed,
    Object? nextFeedDateTime = freezed,
    Object? nextFeedTime = freezed,
    Object? feedRemarks = freezed,
    Object? feedPerformedBy = freezed,
    Object? lastDiaperDateTime = freezed,
    Object? lastDiaperTime = freezed,
    Object? nextDiaperDateTime = freezed,
    Object? nextDiaperTime = freezed,
    Object? diaperRemarks = freezed,
    Object? diaperPerformedBy = freezed,
    Object? napDateTime = freezed,
    Object? napTime = freezed,
    Object? napDuration = freezed,
    Object? napPerformedBy = freezed,
    Object? remarks = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_self.copyWith(
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      promotionDate: freezed == promotionDate
          ? _self.promotionDate
          : promotionDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedDateTime: freezed == lastFeedDateTime
          ? _self.lastFeedDateTime
          : lastFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedTime: freezed == lastFeedTime
          ? _self.lastFeedTime
          : lastFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextFeedDateTime: freezed == nextFeedDateTime
          ? _self.nextFeedDateTime
          : nextFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextFeedTime: freezed == nextFeedTime
          ? _self.nextFeedTime
          : nextFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      feedRemarks: freezed == feedRemarks
          ? _self.feedRemarks
          : feedRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      feedPerformedBy: freezed == feedPerformedBy
          ? _self.feedPerformedBy
          : feedPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      lastDiaperDateTime: freezed == lastDiaperDateTime
          ? _self.lastDiaperDateTime
          : lastDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastDiaperTime: freezed == lastDiaperTime
          ? _self.lastDiaperTime
          : lastDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextDiaperDateTime: freezed == nextDiaperDateTime
          ? _self.nextDiaperDateTime
          : nextDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextDiaperTime: freezed == nextDiaperTime
          ? _self.nextDiaperTime
          : nextDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperRemarks: freezed == diaperRemarks
          ? _self.diaperRemarks
          : diaperRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperPerformedBy: freezed == diaperPerformedBy
          ? _self.diaperPerformedBy
          : diaperPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      napDateTime: freezed == napDateTime
          ? _self.napDateTime
          : napDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      napTime: freezed == napTime
          ? _self.napTime
          : napTime // ignore: cast_nullable_to_non_nullable
              as String?,
      napDuration: freezed == napDuration
          ? _self.napDuration
          : napDuration // ignore: cast_nullable_to_non_nullable
              as int?,
      napPerformedBy: freezed == napPerformedBy
          ? _self.napPerformedBy
          : napPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [InfantCareActivitySaveDto].
extension InfantCareActivitySaveDtoPatterns on InfantCareActivitySaveDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_InfantCareActivitySaveDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivitySaveDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_InfantCareActivitySaveDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivitySaveDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_InfantCareActivitySaveDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivitySaveDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'promotionDate') DateTime? promotionDate,
            @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
            @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
            @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
            @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
            @JsonKey(name: 'feedRemarks') String? feedRemarks,
            @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
            @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
            @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
            @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
            @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
            @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
            @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
            @JsonKey(name: 'napDateTime') DateTime? napDateTime,
            @JsonKey(name: 'napTime') String? napTime,
            @JsonKey(name: 'napDuration') int? napDuration,
            @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivitySaveDto() when $default != null:
        return $default(
            _that.studentId,
            _that.branchId,
            _that.promotionDate,
            _that.lastFeedDateTime,
            _that.lastFeedTime,
            _that.nextFeedDateTime,
            _that.nextFeedTime,
            _that.feedRemarks,
            _that.feedPerformedBy,
            _that.lastDiaperDateTime,
            _that.lastDiaperTime,
            _that.nextDiaperDateTime,
            _that.nextDiaperTime,
            _that.diaperRemarks,
            _that.diaperPerformedBy,
            _that.napDateTime,
            _that.napTime,
            _that.napDuration,
            _that.napPerformedBy,
            _that.remarks,
            _that.isDeleted);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'promotionDate') DateTime? promotionDate,
            @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
            @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
            @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
            @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
            @JsonKey(name: 'feedRemarks') String? feedRemarks,
            @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
            @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
            @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
            @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
            @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
            @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
            @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
            @JsonKey(name: 'napDateTime') DateTime? napDateTime,
            @JsonKey(name: 'napTime') String? napTime,
            @JsonKey(name: 'napDuration') int? napDuration,
            @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isDeleted') bool? isDeleted)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivitySaveDto():
        return $default(
            _that.studentId,
            _that.branchId,
            _that.promotionDate,
            _that.lastFeedDateTime,
            _that.lastFeedTime,
            _that.nextFeedDateTime,
            _that.nextFeedTime,
            _that.feedRemarks,
            _that.feedPerformedBy,
            _that.lastDiaperDateTime,
            _that.lastDiaperTime,
            _that.nextDiaperDateTime,
            _that.nextDiaperTime,
            _that.diaperRemarks,
            _that.diaperPerformedBy,
            _that.napDateTime,
            _that.napTime,
            _that.napDuration,
            _that.napPerformedBy,
            _that.remarks,
            _that.isDeleted);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'promotionDate') DateTime? promotionDate,
            @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
            @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
            @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
            @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
            @JsonKey(name: 'feedRemarks') String? feedRemarks,
            @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
            @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
            @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
            @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
            @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
            @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
            @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
            @JsonKey(name: 'napDateTime') DateTime? napDateTime,
            @JsonKey(name: 'napTime') String? napTime,
            @JsonKey(name: 'napDuration') int? napDuration,
            @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'isDeleted') bool? isDeleted)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _InfantCareActivitySaveDto() when $default != null:
        return $default(
            _that.studentId,
            _that.branchId,
            _that.promotionDate,
            _that.lastFeedDateTime,
            _that.lastFeedTime,
            _that.nextFeedDateTime,
            _that.nextFeedTime,
            _that.feedRemarks,
            _that.feedPerformedBy,
            _that.lastDiaperDateTime,
            _that.lastDiaperTime,
            _that.nextDiaperDateTime,
            _that.nextDiaperTime,
            _that.diaperRemarks,
            _that.diaperPerformedBy,
            _that.napDateTime,
            _that.napTime,
            _that.napDuration,
            _that.napPerformedBy,
            _that.remarks,
            _that.isDeleted);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _InfantCareActivitySaveDto implements InfantCareActivitySaveDto {
  _InfantCareActivitySaveDto(
      {@JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'promotionDate') this.promotionDate,
      @JsonKey(name: 'lastFeedDateTime') this.lastFeedDateTime,
      @JsonKey(name: 'lastFeedTime') this.lastFeedTime,
      @JsonKey(name: 'nextFeedDateTime') this.nextFeedDateTime,
      @JsonKey(name: 'nextFeedTime') this.nextFeedTime,
      @JsonKey(name: 'feedRemarks') this.feedRemarks,
      @JsonKey(name: 'feedPerformedBy') this.feedPerformedBy,
      @JsonKey(name: 'lastDiaperDateTime') this.lastDiaperDateTime,
      @JsonKey(name: 'lastDiaperTime') this.lastDiaperTime,
      @JsonKey(name: 'nextDiaperDateTime') this.nextDiaperDateTime,
      @JsonKey(name: 'nextDiaperTime') this.nextDiaperTime,
      @JsonKey(name: 'diaperRemarks') this.diaperRemarks,
      @JsonKey(name: 'diaperPerformedBy') this.diaperPerformedBy,
      @JsonKey(name: 'napDateTime') this.napDateTime,
      @JsonKey(name: 'napTime') this.napTime,
      @JsonKey(name: 'napDuration') this.napDuration,
      @JsonKey(name: 'napPerformedBy') this.napPerformedBy,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'isDeleted') this.isDeleted});
  factory _InfantCareActivitySaveDto.fromJson(Map<String, dynamic> json) =>
      _$InfantCareActivitySaveDtoFromJson(json);

  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'promotionDate')
  final DateTime? promotionDate;
  @override
  @JsonKey(name: 'lastFeedDateTime')
  final DateTime? lastFeedDateTime;
  @override
  @JsonKey(name: 'lastFeedTime')
  final String? lastFeedTime;
  @override
  @JsonKey(name: 'nextFeedDateTime')
  final DateTime? nextFeedDateTime;
  @override
  @JsonKey(name: 'nextFeedTime')
  final String? nextFeedTime;
  @override
  @JsonKey(name: 'feedRemarks')
  final String? feedRemarks;
  @override
  @JsonKey(name: 'feedPerformedBy')
  final String? feedPerformedBy;
  @override
  @JsonKey(name: 'lastDiaperDateTime')
  final DateTime? lastDiaperDateTime;
  @override
  @JsonKey(name: 'lastDiaperTime')
  final String? lastDiaperTime;
  @override
  @JsonKey(name: 'nextDiaperDateTime')
  final DateTime? nextDiaperDateTime;
  @override
  @JsonKey(name: 'nextDiaperTime')
  final String? nextDiaperTime;
  @override
  @JsonKey(name: 'diaperRemarks')
  final String? diaperRemarks;
  @override
  @JsonKey(name: 'diaperPerformedBy')
  final String? diaperPerformedBy;
  @override
  @JsonKey(name: 'napDateTime')
  final DateTime? napDateTime;
  @override
  @JsonKey(name: 'napTime')
  final String? napTime;
  @override
  @JsonKey(name: 'napDuration')
  final int? napDuration;
  @override
  @JsonKey(name: 'napPerformedBy')
  final String? napPerformedBy;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;

  /// Create a copy of InfantCareActivitySaveDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$InfantCareActivitySaveDtoCopyWith<_InfantCareActivitySaveDto>
      get copyWith =>
          __$InfantCareActivitySaveDtoCopyWithImpl<_InfantCareActivitySaveDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$InfantCareActivitySaveDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _InfantCareActivitySaveDto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.promotionDate, promotionDate) ||
                other.promotionDate == promotionDate) &&
            (identical(other.lastFeedDateTime, lastFeedDateTime) ||
                other.lastFeedDateTime == lastFeedDateTime) &&
            (identical(other.lastFeedTime, lastFeedTime) ||
                other.lastFeedTime == lastFeedTime) &&
            (identical(other.nextFeedDateTime, nextFeedDateTime) ||
                other.nextFeedDateTime == nextFeedDateTime) &&
            (identical(other.nextFeedTime, nextFeedTime) ||
                other.nextFeedTime == nextFeedTime) &&
            (identical(other.feedRemarks, feedRemarks) ||
                other.feedRemarks == feedRemarks) &&
            (identical(other.feedPerformedBy, feedPerformedBy) ||
                other.feedPerformedBy == feedPerformedBy) &&
            (identical(other.lastDiaperDateTime, lastDiaperDateTime) ||
                other.lastDiaperDateTime == lastDiaperDateTime) &&
            (identical(other.lastDiaperTime, lastDiaperTime) ||
                other.lastDiaperTime == lastDiaperTime) &&
            (identical(other.nextDiaperDateTime, nextDiaperDateTime) ||
                other.nextDiaperDateTime == nextDiaperDateTime) &&
            (identical(other.nextDiaperTime, nextDiaperTime) ||
                other.nextDiaperTime == nextDiaperTime) &&
            (identical(other.diaperRemarks, diaperRemarks) ||
                other.diaperRemarks == diaperRemarks) &&
            (identical(other.diaperPerformedBy, diaperPerformedBy) ||
                other.diaperPerformedBy == diaperPerformedBy) &&
            (identical(other.napDateTime, napDateTime) ||
                other.napDateTime == napDateTime) &&
            (identical(other.napTime, napTime) || other.napTime == napTime) &&
            (identical(other.napDuration, napDuration) ||
                other.napDuration == napDuration) &&
            (identical(other.napPerformedBy, napPerformedBy) ||
                other.napPerformedBy == napPerformedBy) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        studentId,
        branchId,
        promotionDate,
        lastFeedDateTime,
        lastFeedTime,
        nextFeedDateTime,
        nextFeedTime,
        feedRemarks,
        feedPerformedBy,
        lastDiaperDateTime,
        lastDiaperTime,
        nextDiaperDateTime,
        nextDiaperTime,
        diaperRemarks,
        diaperPerformedBy,
        napDateTime,
        napTime,
        napDuration,
        napPerformedBy,
        remarks,
        isDeleted
      ]);

  @override
  String toString() {
    return 'InfantCareActivitySaveDto(studentId: $studentId, branchId: $branchId, promotionDate: $promotionDate, lastFeedDateTime: $lastFeedDateTime, lastFeedTime: $lastFeedTime, nextFeedDateTime: $nextFeedDateTime, nextFeedTime: $nextFeedTime, feedRemarks: $feedRemarks, feedPerformedBy: $feedPerformedBy, lastDiaperDateTime: $lastDiaperDateTime, lastDiaperTime: $lastDiaperTime, nextDiaperDateTime: $nextDiaperDateTime, nextDiaperTime: $nextDiaperTime, diaperRemarks: $diaperRemarks, diaperPerformedBy: $diaperPerformedBy, napDateTime: $napDateTime, napTime: $napTime, napDuration: $napDuration, napPerformedBy: $napPerformedBy, remarks: $remarks, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class _$InfantCareActivitySaveDtoCopyWith<$Res>
    implements $InfantCareActivitySaveDtoCopyWith<$Res> {
  factory _$InfantCareActivitySaveDtoCopyWith(_InfantCareActivitySaveDto value,
          $Res Function(_InfantCareActivitySaveDto) _then) =
      __$InfantCareActivitySaveDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'promotionDate') DateTime? promotionDate,
      @JsonKey(name: 'lastFeedDateTime') DateTime? lastFeedDateTime,
      @JsonKey(name: 'lastFeedTime') String? lastFeedTime,
      @JsonKey(name: 'nextFeedDateTime') DateTime? nextFeedDateTime,
      @JsonKey(name: 'nextFeedTime') String? nextFeedTime,
      @JsonKey(name: 'feedRemarks') String? feedRemarks,
      @JsonKey(name: 'feedPerformedBy') String? feedPerformedBy,
      @JsonKey(name: 'lastDiaperDateTime') DateTime? lastDiaperDateTime,
      @JsonKey(name: 'lastDiaperTime') String? lastDiaperTime,
      @JsonKey(name: 'nextDiaperDateTime') DateTime? nextDiaperDateTime,
      @JsonKey(name: 'nextDiaperTime') String? nextDiaperTime,
      @JsonKey(name: 'diaperRemarks') String? diaperRemarks,
      @JsonKey(name: 'diaperPerformedBy') String? diaperPerformedBy,
      @JsonKey(name: 'napDateTime') DateTime? napDateTime,
      @JsonKey(name: 'napTime') String? napTime,
      @JsonKey(name: 'napDuration') int? napDuration,
      @JsonKey(name: 'napPerformedBy') String? napPerformedBy,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'isDeleted') bool? isDeleted});
}

/// @nodoc
class __$InfantCareActivitySaveDtoCopyWithImpl<$Res>
    implements _$InfantCareActivitySaveDtoCopyWith<$Res> {
  __$InfantCareActivitySaveDtoCopyWithImpl(this._self, this._then);

  final _InfantCareActivitySaveDto _self;
  final $Res Function(_InfantCareActivitySaveDto) _then;

  /// Create a copy of InfantCareActivitySaveDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? promotionDate = freezed,
    Object? lastFeedDateTime = freezed,
    Object? lastFeedTime = freezed,
    Object? nextFeedDateTime = freezed,
    Object? nextFeedTime = freezed,
    Object? feedRemarks = freezed,
    Object? feedPerformedBy = freezed,
    Object? lastDiaperDateTime = freezed,
    Object? lastDiaperTime = freezed,
    Object? nextDiaperDateTime = freezed,
    Object? nextDiaperTime = freezed,
    Object? diaperRemarks = freezed,
    Object? diaperPerformedBy = freezed,
    Object? napDateTime = freezed,
    Object? napTime = freezed,
    Object? napDuration = freezed,
    Object? napPerformedBy = freezed,
    Object? remarks = freezed,
    Object? isDeleted = freezed,
  }) {
    return _then(_InfantCareActivitySaveDto(
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      promotionDate: freezed == promotionDate
          ? _self.promotionDate
          : promotionDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedDateTime: freezed == lastFeedDateTime
          ? _self.lastFeedDateTime
          : lastFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastFeedTime: freezed == lastFeedTime
          ? _self.lastFeedTime
          : lastFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextFeedDateTime: freezed == nextFeedDateTime
          ? _self.nextFeedDateTime
          : nextFeedDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextFeedTime: freezed == nextFeedTime
          ? _self.nextFeedTime
          : nextFeedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      feedRemarks: freezed == feedRemarks
          ? _self.feedRemarks
          : feedRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      feedPerformedBy: freezed == feedPerformedBy
          ? _self.feedPerformedBy
          : feedPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      lastDiaperDateTime: freezed == lastDiaperDateTime
          ? _self.lastDiaperDateTime
          : lastDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastDiaperTime: freezed == lastDiaperTime
          ? _self.lastDiaperTime
          : lastDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      nextDiaperDateTime: freezed == nextDiaperDateTime
          ? _self.nextDiaperDateTime
          : nextDiaperDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      nextDiaperTime: freezed == nextDiaperTime
          ? _self.nextDiaperTime
          : nextDiaperTime // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperRemarks: freezed == diaperRemarks
          ? _self.diaperRemarks
          : diaperRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      diaperPerformedBy: freezed == diaperPerformedBy
          ? _self.diaperPerformedBy
          : diaperPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      napDateTime: freezed == napDateTime
          ? _self.napDateTime
          : napDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      napTime: freezed == napTime
          ? _self.napTime
          : napTime // ignore: cast_nullable_to_non_nullable
              as String?,
      napDuration: freezed == napDuration
          ? _self.napDuration
          : napDuration // ignore: cast_nullable_to_non_nullable
              as int?,
      napPerformedBy: freezed == napPerformedBy
          ? _self.napPerformedBy
          : napPerformedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$LevelApiDto {
  @JsonKey(name: 'levelId')
  int? get levelId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'code')
  String? get code;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'startDate')
  String? get startDate;
  @JsonKey(name: 'endDate')
  String? get endDate;
  @JsonKey(name: 'minAgeInMonths')
  int? get minAgeInMonths;
  @JsonKey(name: 'maxAgeInMonths')
  int? get maxAgeInMonths;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of LevelApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $LevelApiDtoCopyWith<LevelApiDto> get copyWith =>
      _$LevelApiDtoCopyWithImpl<LevelApiDto>(this as LevelApiDto, _$identity);

  /// Serializes this LevelApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LevelApiDto &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.minAgeInMonths, minAgeInMonths) ||
                other.minAgeInMonths == minAgeInMonths) &&
            (identical(other.maxAgeInMonths, maxAgeInMonths) ||
                other.maxAgeInMonths == maxAgeInMonths) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      levelId,
      branchId,
      code,
      name,
      startDate,
      endDate,
      minAgeInMonths,
      maxAgeInMonths,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'LevelApiDto(levelId: $levelId, branchId: $branchId, code: $code, name: $name, startDate: $startDate, endDate: $endDate, minAgeInMonths: $minAgeInMonths, maxAgeInMonths: $maxAgeInMonths, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $LevelApiDtoCopyWith<$Res> {
  factory $LevelApiDtoCopyWith(
          LevelApiDto value, $Res Function(LevelApiDto) _then) =
      _$LevelApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
      @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$LevelApiDtoCopyWithImpl<$Res> implements $LevelApiDtoCopyWith<$Res> {
  _$LevelApiDtoCopyWithImpl(this._self, this._then);

  final LevelApiDto _self;
  final $Res Function(LevelApiDto) _then;

  /// Create a copy of LevelApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? levelId = freezed,
    Object? branchId = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? minAgeInMonths = freezed,
    Object? maxAgeInMonths = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      minAgeInMonths: freezed == minAgeInMonths
          ? _self.minAgeInMonths
          : minAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      maxAgeInMonths: freezed == maxAgeInMonths
          ? _self.maxAgeInMonths
          : maxAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [LevelApiDto].
extension LevelApiDtoPatterns on LevelApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_LevelApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_LevelApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_LevelApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
            @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto() when $default != null:
        return $default(
            _that.levelId,
            _that.branchId,
            _that.code,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.minAgeInMonths,
            _that.maxAgeInMonths,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
            @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto():
        return $default(
            _that.levelId,
            _that.branchId,
            _that.code,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.minAgeInMonths,
            _that.maxAgeInMonths,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
            @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto() when $default != null:
        return $default(
            _that.levelId,
            _that.branchId,
            _that.code,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.minAgeInMonths,
            _that.maxAgeInMonths,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _LevelApiDto implements LevelApiDto {
  _LevelApiDto(
      {@JsonKey(name: 'levelId') this.levelId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'code') this.code,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'minAgeInMonths') this.minAgeInMonths,
      @JsonKey(name: 'maxAgeInMonths') this.maxAgeInMonths,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _LevelApiDto.fromJson(Map<String, dynamic> json) =>
      _$LevelApiDtoFromJson(json);

  @override
  @JsonKey(name: 'levelId')
  final int? levelId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'code')
  final String? code;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'startDate')
  final String? startDate;
  @override
  @JsonKey(name: 'endDate')
  final String? endDate;
  @override
  @JsonKey(name: 'minAgeInMonths')
  final int? minAgeInMonths;
  @override
  @JsonKey(name: 'maxAgeInMonths')
  final int? maxAgeInMonths;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of LevelApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$LevelApiDtoCopyWith<_LevelApiDto> get copyWith =>
      __$LevelApiDtoCopyWithImpl<_LevelApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$LevelApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LevelApiDto &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.minAgeInMonths, minAgeInMonths) ||
                other.minAgeInMonths == minAgeInMonths) &&
            (identical(other.maxAgeInMonths, maxAgeInMonths) ||
                other.maxAgeInMonths == maxAgeInMonths) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      levelId,
      branchId,
      code,
      name,
      startDate,
      endDate,
      minAgeInMonths,
      maxAgeInMonths,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'LevelApiDto(levelId: $levelId, branchId: $branchId, code: $code, name: $name, startDate: $startDate, endDate: $endDate, minAgeInMonths: $minAgeInMonths, maxAgeInMonths: $maxAgeInMonths, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$LevelApiDtoCopyWith<$Res>
    implements $LevelApiDtoCopyWith<$Res> {
  factory _$LevelApiDtoCopyWith(
          _LevelApiDto value, $Res Function(_LevelApiDto) _then) =
      __$LevelApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
      @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$LevelApiDtoCopyWithImpl<$Res> implements _$LevelApiDtoCopyWith<$Res> {
  __$LevelApiDtoCopyWithImpl(this._self, this._then);

  final _LevelApiDto _self;
  final $Res Function(_LevelApiDto) _then;

  /// Create a copy of LevelApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? levelId = freezed,
    Object? branchId = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? minAgeInMonths = freezed,
    Object? maxAgeInMonths = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_LevelApiDto(
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      minAgeInMonths: freezed == minAgeInMonths
          ? _self.minAgeInMonths
          : minAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      maxAgeInMonths: freezed == maxAgeInMonths
          ? _self.maxAgeInMonths
          : maxAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$LevelApiDto2Dto {
  @JsonKey(name: 'levelId')
  int? get levelId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'code')
  String? get code;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'startDate')
  String? get startDate;
  @JsonKey(name: 'endDate')
  String? get endDate;
  @JsonKey(name: 'minAgeInMonths')
  int? get minAgeInMonths;
  @JsonKey(name: 'maxAgeInMonths')
  int? get maxAgeInMonths;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of LevelApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $LevelApiDto2DtoCopyWith<LevelApiDto2Dto> get copyWith =>
      _$LevelApiDto2DtoCopyWithImpl<LevelApiDto2Dto>(
          this as LevelApiDto2Dto, _$identity);

  /// Serializes this LevelApiDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LevelApiDto2Dto &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.minAgeInMonths, minAgeInMonths) ||
                other.minAgeInMonths == minAgeInMonths) &&
            (identical(other.maxAgeInMonths, maxAgeInMonths) ||
                other.maxAgeInMonths == maxAgeInMonths) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      levelId,
      branchId,
      code,
      name,
      startDate,
      endDate,
      minAgeInMonths,
      maxAgeInMonths,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'LevelApiDto2Dto(levelId: $levelId, branchId: $branchId, code: $code, name: $name, startDate: $startDate, endDate: $endDate, minAgeInMonths: $minAgeInMonths, maxAgeInMonths: $maxAgeInMonths, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $LevelApiDto2DtoCopyWith<$Res> {
  factory $LevelApiDto2DtoCopyWith(
          LevelApiDto2Dto value, $Res Function(LevelApiDto2Dto) _then) =
      _$LevelApiDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
      @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$LevelApiDto2DtoCopyWithImpl<$Res>
    implements $LevelApiDto2DtoCopyWith<$Res> {
  _$LevelApiDto2DtoCopyWithImpl(this._self, this._then);

  final LevelApiDto2Dto _self;
  final $Res Function(LevelApiDto2Dto) _then;

  /// Create a copy of LevelApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? levelId = freezed,
    Object? branchId = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? minAgeInMonths = freezed,
    Object? maxAgeInMonths = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      minAgeInMonths: freezed == minAgeInMonths
          ? _self.minAgeInMonths
          : minAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      maxAgeInMonths: freezed == maxAgeInMonths
          ? _self.maxAgeInMonths
          : maxAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [LevelApiDto2Dto].
extension LevelApiDto2DtoPatterns on LevelApiDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_LevelApiDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_LevelApiDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_LevelApiDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
            @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto2Dto() when $default != null:
        return $default(
            _that.levelId,
            _that.branchId,
            _that.code,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.minAgeInMonths,
            _that.maxAgeInMonths,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
            @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto2Dto():
        return $default(
            _that.levelId,
            _that.branchId,
            _that.code,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.minAgeInMonths,
            _that.maxAgeInMonths,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'code') String? code,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
            @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LevelApiDto2Dto() when $default != null:
        return $default(
            _that.levelId,
            _that.branchId,
            _that.code,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.minAgeInMonths,
            _that.maxAgeInMonths,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _LevelApiDto2Dto implements LevelApiDto2Dto {
  _LevelApiDto2Dto(
      {@JsonKey(name: 'levelId') this.levelId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'code') this.code,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'minAgeInMonths') this.minAgeInMonths,
      @JsonKey(name: 'maxAgeInMonths') this.maxAgeInMonths,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _LevelApiDto2Dto.fromJson(Map<String, dynamic> json) =>
      _$LevelApiDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'levelId')
  final int? levelId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'code')
  final String? code;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'startDate')
  final String? startDate;
  @override
  @JsonKey(name: 'endDate')
  final String? endDate;
  @override
  @JsonKey(name: 'minAgeInMonths')
  final int? minAgeInMonths;
  @override
  @JsonKey(name: 'maxAgeInMonths')
  final int? maxAgeInMonths;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of LevelApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$LevelApiDto2DtoCopyWith<_LevelApiDto2Dto> get copyWith =>
      __$LevelApiDto2DtoCopyWithImpl<_LevelApiDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$LevelApiDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LevelApiDto2Dto &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.minAgeInMonths, minAgeInMonths) ||
                other.minAgeInMonths == minAgeInMonths) &&
            (identical(other.maxAgeInMonths, maxAgeInMonths) ||
                other.maxAgeInMonths == maxAgeInMonths) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      levelId,
      branchId,
      code,
      name,
      startDate,
      endDate,
      minAgeInMonths,
      maxAgeInMonths,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'LevelApiDto2Dto(levelId: $levelId, branchId: $branchId, code: $code, name: $name, startDate: $startDate, endDate: $endDate, minAgeInMonths: $minAgeInMonths, maxAgeInMonths: $maxAgeInMonths, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$LevelApiDto2DtoCopyWith<$Res>
    implements $LevelApiDto2DtoCopyWith<$Res> {
  factory _$LevelApiDto2DtoCopyWith(
          _LevelApiDto2Dto value, $Res Function(_LevelApiDto2Dto) _then) =
      __$LevelApiDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'minAgeInMonths') int? minAgeInMonths,
      @JsonKey(name: 'maxAgeInMonths') int? maxAgeInMonths,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$LevelApiDto2DtoCopyWithImpl<$Res>
    implements _$LevelApiDto2DtoCopyWith<$Res> {
  __$LevelApiDto2DtoCopyWithImpl(this._self, this._then);

  final _LevelApiDto2Dto _self;
  final $Res Function(_LevelApiDto2Dto) _then;

  /// Create a copy of LevelApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? levelId = freezed,
    Object? branchId = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? minAgeInMonths = freezed,
    Object? maxAgeInMonths = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_LevelApiDto2Dto(
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      minAgeInMonths: freezed == minAgeInMonths
          ? _self.minAgeInMonths
          : minAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      maxAgeInMonths: freezed == maxAgeInMonths
          ? _self.maxAgeInMonths
          : maxAgeInMonths // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$LookUpApiDto {
  @JsonKey(name: 'lookUpId')
  int? get lookUpId;
  @JsonKey(name: 'lookUpType')
  int? get lookUpType;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;

  /// Create a copy of LookUpApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $LookUpApiDtoCopyWith<LookUpApiDto> get copyWith =>
      _$LookUpApiDtoCopyWithImpl<LookUpApiDto>(
          this as LookUpApiDto, _$identity);

  /// Serializes this LookUpApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LookUpApiDto &&
            (identical(other.lookUpId, lookUpId) ||
                other.lookUpId == lookUpId) &&
            (identical(other.lookUpType, lookUpType) ||
                other.lookUpType == lookUpType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, lookUpId, lookUpType, name, isDeleted, createdDate);

  @override
  String toString() {
    return 'LookUpApiDto(lookUpId: $lookUpId, lookUpType: $lookUpType, name: $name, isDeleted: $isDeleted, createdDate: $createdDate)';
  }
}

/// @nodoc
abstract mixin class $LookUpApiDtoCopyWith<$Res> {
  factory $LookUpApiDtoCopyWith(
          LookUpApiDto value, $Res Function(LookUpApiDto) _then) =
      _$LookUpApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'lookUpId') int? lookUpId,
      @JsonKey(name: 'lookUpType') int? lookUpType,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdDate') DateTime? createdDate});
}

/// @nodoc
class _$LookUpApiDtoCopyWithImpl<$Res> implements $LookUpApiDtoCopyWith<$Res> {
  _$LookUpApiDtoCopyWithImpl(this._self, this._then);

  final LookUpApiDto _self;
  final $Res Function(LookUpApiDto) _then;

  /// Create a copy of LookUpApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lookUpId = freezed,
    Object? lookUpType = freezed,
    Object? name = freezed,
    Object? isDeleted = freezed,
    Object? createdDate = freezed,
  }) {
    return _then(_self.copyWith(
      lookUpId: freezed == lookUpId
          ? _self.lookUpId
          : lookUpId // ignore: cast_nullable_to_non_nullable
              as int?,
      lookUpType: freezed == lookUpType
          ? _self.lookUpType
          : lookUpType // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [LookUpApiDto].
extension LookUpApiDtoPatterns on LookUpApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_LookUpApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LookUpApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_LookUpApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LookUpApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_LookUpApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LookUpApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'lookUpId') int? lookUpId,
            @JsonKey(name: 'lookUpType') int? lookUpType,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdDate') DateTime? createdDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _LookUpApiDto() when $default != null:
        return $default(_that.lookUpId, _that.lookUpType, _that.name,
            _that.isDeleted, _that.createdDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'lookUpId') int? lookUpId,
            @JsonKey(name: 'lookUpType') int? lookUpType,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdDate') DateTime? createdDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LookUpApiDto():
        return $default(_that.lookUpId, _that.lookUpType, _that.name,
            _that.isDeleted, _that.createdDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'lookUpId') int? lookUpId,
            @JsonKey(name: 'lookUpType') int? lookUpType,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdDate') DateTime? createdDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _LookUpApiDto() when $default != null:
        return $default(_that.lookUpId, _that.lookUpType, _that.name,
            _that.isDeleted, _that.createdDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _LookUpApiDto implements LookUpApiDto {
  _LookUpApiDto(
      {@JsonKey(name: 'lookUpId') this.lookUpId,
      @JsonKey(name: 'lookUpType') this.lookUpType,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdDate') this.createdDate});
  factory _LookUpApiDto.fromJson(Map<String, dynamic> json) =>
      _$LookUpApiDtoFromJson(json);

  @override
  @JsonKey(name: 'lookUpId')
  final int? lookUpId;
  @override
  @JsonKey(name: 'lookUpType')
  final int? lookUpType;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;

  /// Create a copy of LookUpApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$LookUpApiDtoCopyWith<_LookUpApiDto> get copyWith =>
      __$LookUpApiDtoCopyWithImpl<_LookUpApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$LookUpApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LookUpApiDto &&
            (identical(other.lookUpId, lookUpId) ||
                other.lookUpId == lookUpId) &&
            (identical(other.lookUpType, lookUpType) ||
                other.lookUpType == lookUpType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, lookUpId, lookUpType, name, isDeleted, createdDate);

  @override
  String toString() {
    return 'LookUpApiDto(lookUpId: $lookUpId, lookUpType: $lookUpType, name: $name, isDeleted: $isDeleted, createdDate: $createdDate)';
  }
}

/// @nodoc
abstract mixin class _$LookUpApiDtoCopyWith<$Res>
    implements $LookUpApiDtoCopyWith<$Res> {
  factory _$LookUpApiDtoCopyWith(
          _LookUpApiDto value, $Res Function(_LookUpApiDto) _then) =
      __$LookUpApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'lookUpId') int? lookUpId,
      @JsonKey(name: 'lookUpType') int? lookUpType,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdDate') DateTime? createdDate});
}

/// @nodoc
class __$LookUpApiDtoCopyWithImpl<$Res>
    implements _$LookUpApiDtoCopyWith<$Res> {
  __$LookUpApiDtoCopyWithImpl(this._self, this._then);

  final _LookUpApiDto _self;
  final $Res Function(_LookUpApiDto) _then;

  /// Create a copy of LookUpApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? lookUpId = freezed,
    Object? lookUpType = freezed,
    Object? name = freezed,
    Object? isDeleted = freezed,
    Object? createdDate = freezed,
  }) {
    return _then(_LookUpApiDto(
      lookUpId: freezed == lookUpId
          ? _self.lookUpId
          : lookUpId // ignore: cast_nullable_to_non_nullable
              as int?,
      lookUpType: freezed == lookUpType
          ? _self.lookUpType
          : lookUpType // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$NotificationApiDto {
  @JsonKey(name: 'title')
  String? get title;
  @JsonKey(name: 'description')
  String? get description;
  @JsonKey(name: 'notificationType')
  int? get notificationType;
  @JsonKey(name: 'entityId')
  int? get entityId;
  @JsonKey(name: 'isPublic')
  bool? get isPublic;
  @JsonKey(name: 'isRead')
  bool? get isRead;
  @JsonKey(name: 'readDateTime')
  DateTime? get readDateTime;
  @JsonKey(name: 'notificationRecipientId')
  int? get notificationRecipientId;
  @JsonKey(name: 'recipientAccountId')
  int? get recipientAccountId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of NotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $NotificationApiDtoCopyWith<NotificationApiDto> get copyWith =>
      _$NotificationApiDtoCopyWithImpl<NotificationApiDto>(
          this as NotificationApiDto, _$identity);

  /// Serializes this NotificationApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NotificationApiDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.isPublic, isPublic) ||
                other.isPublic == isPublic) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.readDateTime, readDateTime) ||
                other.readDateTime == readDateTime) &&
            (identical(
                    other.notificationRecipientId, notificationRecipientId) ||
                other.notificationRecipientId == notificationRecipientId) &&
            (identical(other.recipientAccountId, recipientAccountId) ||
                other.recipientAccountId == recipientAccountId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      description,
      notificationType,
      entityId,
      isPublic,
      isRead,
      readDateTime,
      notificationRecipientId,
      recipientAccountId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'NotificationApiDto(title: $title, description: $description, notificationType: $notificationType, entityId: $entityId, isPublic: $isPublic, isRead: $isRead, readDateTime: $readDateTime, notificationRecipientId: $notificationRecipientId, recipientAccountId: $recipientAccountId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $NotificationApiDtoCopyWith<$Res> {
  factory $NotificationApiDtoCopyWith(
          NotificationApiDto value, $Res Function(NotificationApiDto) _then) =
      _$NotificationApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'notificationType') int? notificationType,
      @JsonKey(name: 'entityId') int? entityId,
      @JsonKey(name: 'isPublic') bool? isPublic,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'readDateTime') DateTime? readDateTime,
      @JsonKey(name: 'notificationRecipientId') int? notificationRecipientId,
      @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$NotificationApiDtoCopyWithImpl<$Res>
    implements $NotificationApiDtoCopyWith<$Res> {
  _$NotificationApiDtoCopyWithImpl(this._self, this._then);

  final NotificationApiDto _self;
  final $Res Function(NotificationApiDto) _then;

  /// Create a copy of NotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = freezed,
    Object? description = freezed,
    Object? notificationType = freezed,
    Object? entityId = freezed,
    Object? isPublic = freezed,
    Object? isRead = freezed,
    Object? readDateTime = freezed,
    Object? notificationRecipientId = freezed,
    Object? recipientAccountId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as int?,
      entityId: freezed == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as int?,
      isPublic: freezed == isPublic
          ? _self.isPublic
          : isPublic // ignore: cast_nullable_to_non_nullable
              as bool?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      readDateTime: freezed == readDateTime
          ? _self.readDateTime
          : readDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      notificationRecipientId: freezed == notificationRecipientId
          ? _self.notificationRecipientId
          : notificationRecipientId // ignore: cast_nullable_to_non_nullable
              as int?,
      recipientAccountId: freezed == recipientAccountId
          ? _self.recipientAccountId
          : recipientAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [NotificationApiDto].
extension NotificationApiDtoPatterns on NotificationApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NotificationApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NotificationApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NotificationApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'notificationType') int? notificationType,
            @JsonKey(name: 'entityId') int? entityId,
            @JsonKey(name: 'isPublic') bool? isPublic,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'readDateTime') DateTime? readDateTime,
            @JsonKey(name: 'notificationRecipientId')
            int? notificationRecipientId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationApiDto() when $default != null:
        return $default(
            _that.title,
            _that.description,
            _that.notificationType,
            _that.entityId,
            _that.isPublic,
            _that.isRead,
            _that.readDateTime,
            _that.notificationRecipientId,
            _that.recipientAccountId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'notificationType') int? notificationType,
            @JsonKey(name: 'entityId') int? entityId,
            @JsonKey(name: 'isPublic') bool? isPublic,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'readDateTime') DateTime? readDateTime,
            @JsonKey(name: 'notificationRecipientId')
            int? notificationRecipientId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationApiDto():
        return $default(
            _that.title,
            _that.description,
            _that.notificationType,
            _that.entityId,
            _that.isPublic,
            _that.isRead,
            _that.readDateTime,
            _that.notificationRecipientId,
            _that.recipientAccountId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'title') String? title,
            @JsonKey(name: 'description') String? description,
            @JsonKey(name: 'notificationType') int? notificationType,
            @JsonKey(name: 'entityId') int? entityId,
            @JsonKey(name: 'isPublic') bool? isPublic,
            @JsonKey(name: 'isRead') bool? isRead,
            @JsonKey(name: 'readDateTime') DateTime? readDateTime,
            @JsonKey(name: 'notificationRecipientId')
            int? notificationRecipientId,
            @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationApiDto() when $default != null:
        return $default(
            _that.title,
            _that.description,
            _that.notificationType,
            _that.entityId,
            _that.isPublic,
            _that.isRead,
            _that.readDateTime,
            _that.notificationRecipientId,
            _that.recipientAccountId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _NotificationApiDto implements NotificationApiDto {
  _NotificationApiDto(
      {@JsonKey(name: 'title') this.title,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'notificationType') this.notificationType,
      @JsonKey(name: 'entityId') this.entityId,
      @JsonKey(name: 'isPublic') this.isPublic,
      @JsonKey(name: 'isRead') this.isRead,
      @JsonKey(name: 'readDateTime') this.readDateTime,
      @JsonKey(name: 'notificationRecipientId') this.notificationRecipientId,
      @JsonKey(name: 'recipientAccountId') this.recipientAccountId,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _NotificationApiDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationApiDtoFromJson(json);

  @override
  @JsonKey(name: 'title')
  final String? title;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'notificationType')
  final int? notificationType;
  @override
  @JsonKey(name: 'entityId')
  final int? entityId;
  @override
  @JsonKey(name: 'isPublic')
  final bool? isPublic;
  @override
  @JsonKey(name: 'isRead')
  final bool? isRead;
  @override
  @JsonKey(name: 'readDateTime')
  final DateTime? readDateTime;
  @override
  @JsonKey(name: 'notificationRecipientId')
  final int? notificationRecipientId;
  @override
  @JsonKey(name: 'recipientAccountId')
  final int? recipientAccountId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of NotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$NotificationApiDtoCopyWith<_NotificationApiDto> get copyWith =>
      __$NotificationApiDtoCopyWithImpl<_NotificationApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$NotificationApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NotificationApiDto &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.isPublic, isPublic) ||
                other.isPublic == isPublic) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.readDateTime, readDateTime) ||
                other.readDateTime == readDateTime) &&
            (identical(
                    other.notificationRecipientId, notificationRecipientId) ||
                other.notificationRecipientId == notificationRecipientId) &&
            (identical(other.recipientAccountId, recipientAccountId) ||
                other.recipientAccountId == recipientAccountId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      description,
      notificationType,
      entityId,
      isPublic,
      isRead,
      readDateTime,
      notificationRecipientId,
      recipientAccountId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'NotificationApiDto(title: $title, description: $description, notificationType: $notificationType, entityId: $entityId, isPublic: $isPublic, isRead: $isRead, readDateTime: $readDateTime, notificationRecipientId: $notificationRecipientId, recipientAccountId: $recipientAccountId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$NotificationApiDtoCopyWith<$Res>
    implements $NotificationApiDtoCopyWith<$Res> {
  factory _$NotificationApiDtoCopyWith(
          _NotificationApiDto value, $Res Function(_NotificationApiDto) _then) =
      __$NotificationApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String? title,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'notificationType') int? notificationType,
      @JsonKey(name: 'entityId') int? entityId,
      @JsonKey(name: 'isPublic') bool? isPublic,
      @JsonKey(name: 'isRead') bool? isRead,
      @JsonKey(name: 'readDateTime') DateTime? readDateTime,
      @JsonKey(name: 'notificationRecipientId') int? notificationRecipientId,
      @JsonKey(name: 'recipientAccountId') int? recipientAccountId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$NotificationApiDtoCopyWithImpl<$Res>
    implements _$NotificationApiDtoCopyWith<$Res> {
  __$NotificationApiDtoCopyWithImpl(this._self, this._then);

  final _NotificationApiDto _self;
  final $Res Function(_NotificationApiDto) _then;

  /// Create a copy of NotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = freezed,
    Object? description = freezed,
    Object? notificationType = freezed,
    Object? entityId = freezed,
    Object? isPublic = freezed,
    Object? isRead = freezed,
    Object? readDateTime = freezed,
    Object? notificationRecipientId = freezed,
    Object? recipientAccountId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_NotificationApiDto(
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      notificationType: freezed == notificationType
          ? _self.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as int?,
      entityId: freezed == entityId
          ? _self.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as int?,
      isPublic: freezed == isPublic
          ? _self.isPublic
          : isPublic // ignore: cast_nullable_to_non_nullable
              as bool?,
      isRead: freezed == isRead
          ? _self.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
      readDateTime: freezed == readDateTime
          ? _self.readDateTime
          : readDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      notificationRecipientId: freezed == notificationRecipientId
          ? _self.notificationRecipientId
          : notificationRecipientId // ignore: cast_nullable_to_non_nullable
              as int?,
      recipientAccountId: freezed == recipientAccountId
          ? _self.recipientAccountId
          : recipientAccountId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$NotificationSummaryDto {
  @JsonKey(name: 'totalUnread')
  int? get totalUnread;
  @JsonKey(name: 'totalRead')
  int? get totalRead;
  @JsonKey(name: 'total')
  int? get total;

  /// Create a copy of NotificationSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $NotificationSummaryDtoCopyWith<NotificationSummaryDto> get copyWith =>
      _$NotificationSummaryDtoCopyWithImpl<NotificationSummaryDto>(
          this as NotificationSummaryDto, _$identity);

  /// Serializes this NotificationSummaryDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NotificationSummaryDto &&
            (identical(other.totalUnread, totalUnread) ||
                other.totalUnread == totalUnread) &&
            (identical(other.totalRead, totalRead) ||
                other.totalRead == totalRead) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, totalUnread, totalRead, total);

  @override
  String toString() {
    return 'NotificationSummaryDto(totalUnread: $totalUnread, totalRead: $totalRead, total: $total)';
  }
}

/// @nodoc
abstract mixin class $NotificationSummaryDtoCopyWith<$Res> {
  factory $NotificationSummaryDtoCopyWith(NotificationSummaryDto value,
          $Res Function(NotificationSummaryDto) _then) =
      _$NotificationSummaryDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'totalUnread') int? totalUnread,
      @JsonKey(name: 'totalRead') int? totalRead,
      @JsonKey(name: 'total') int? total});
}

/// @nodoc
class _$NotificationSummaryDtoCopyWithImpl<$Res>
    implements $NotificationSummaryDtoCopyWith<$Res> {
  _$NotificationSummaryDtoCopyWithImpl(this._self, this._then);

  final NotificationSummaryDto _self;
  final $Res Function(NotificationSummaryDto) _then;

  /// Create a copy of NotificationSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalUnread = freezed,
    Object? totalRead = freezed,
    Object? total = freezed,
  }) {
    return _then(_self.copyWith(
      totalUnread: freezed == totalUnread
          ? _self.totalUnread
          : totalUnread // ignore: cast_nullable_to_non_nullable
              as int?,
      totalRead: freezed == totalRead
          ? _self.totalRead
          : totalRead // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [NotificationSummaryDto].
extension NotificationSummaryDtoPatterns on NotificationSummaryDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NotificationSummaryDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationSummaryDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NotificationSummaryDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationSummaryDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NotificationSummaryDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationSummaryDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'totalUnread') int? totalUnread,
            @JsonKey(name: 'totalRead') int? totalRead,
            @JsonKey(name: 'total') int? total)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _NotificationSummaryDto() when $default != null:
        return $default(_that.totalUnread, _that.totalRead, _that.total);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'totalUnread') int? totalUnread,
            @JsonKey(name: 'totalRead') int? totalRead,
            @JsonKey(name: 'total') int? total)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationSummaryDto():
        return $default(_that.totalUnread, _that.totalRead, _that.total);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'totalUnread') int? totalUnread,
            @JsonKey(name: 'totalRead') int? totalRead,
            @JsonKey(name: 'total') int? total)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _NotificationSummaryDto() when $default != null:
        return $default(_that.totalUnread, _that.totalRead, _that.total);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _NotificationSummaryDto implements NotificationSummaryDto {
  _NotificationSummaryDto(
      {@JsonKey(name: 'totalUnread') this.totalUnread,
      @JsonKey(name: 'totalRead') this.totalRead,
      @JsonKey(name: 'total') this.total});
  factory _NotificationSummaryDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationSummaryDtoFromJson(json);

  @override
  @JsonKey(name: 'totalUnread')
  final int? totalUnread;
  @override
  @JsonKey(name: 'totalRead')
  final int? totalRead;
  @override
  @JsonKey(name: 'total')
  final int? total;

  /// Create a copy of NotificationSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$NotificationSummaryDtoCopyWith<_NotificationSummaryDto> get copyWith =>
      __$NotificationSummaryDtoCopyWithImpl<_NotificationSummaryDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$NotificationSummaryDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NotificationSummaryDto &&
            (identical(other.totalUnread, totalUnread) ||
                other.totalUnread == totalUnread) &&
            (identical(other.totalRead, totalRead) ||
                other.totalRead == totalRead) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, totalUnread, totalRead, total);

  @override
  String toString() {
    return 'NotificationSummaryDto(totalUnread: $totalUnread, totalRead: $totalRead, total: $total)';
  }
}

/// @nodoc
abstract mixin class _$NotificationSummaryDtoCopyWith<$Res>
    implements $NotificationSummaryDtoCopyWith<$Res> {
  factory _$NotificationSummaryDtoCopyWith(_NotificationSummaryDto value,
          $Res Function(_NotificationSummaryDto) _then) =
      __$NotificationSummaryDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'totalUnread') int? totalUnread,
      @JsonKey(name: 'totalRead') int? totalRead,
      @JsonKey(name: 'total') int? total});
}

/// @nodoc
class __$NotificationSummaryDtoCopyWithImpl<$Res>
    implements _$NotificationSummaryDtoCopyWith<$Res> {
  __$NotificationSummaryDtoCopyWithImpl(this._self, this._then);

  final _NotificationSummaryDto _self;
  final $Res Function(_NotificationSummaryDto) _then;

  /// Create a copy of NotificationSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? totalUnread = freezed,
    Object? totalRead = freezed,
    Object? total = freezed,
  }) {
    return _then(_NotificationSummaryDto(
      totalUnread: freezed == totalUnread
          ? _self.totalUnread
          : totalUnread // ignore: cast_nullable_to_non_nullable
              as int?,
      totalRead: freezed == totalRead
          ? _self.totalRead
          : totalRead // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfAccountDeviceSessionApiDto {
  @JsonKey(name: 'items')
  List<AccountDeviceSessionApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfAccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfAccountDeviceSessionApiDtoCopyWith<
          PagedResultOfAccountDeviceSessionApiDto>
      get copyWith => _$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl<
              PagedResultOfAccountDeviceSessionApiDto>(
          this as PagedResultOfAccountDeviceSessionApiDto, _$identity);

  /// Serializes this PagedResultOfAccountDeviceSessionApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfAccountDeviceSessionApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfAccountDeviceSessionApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfAccountDeviceSessionApiDtoCopyWith<$Res> {
  factory $PagedResultOfAccountDeviceSessionApiDtoCopyWith(
          PagedResultOfAccountDeviceSessionApiDto value,
          $Res Function(PagedResultOfAccountDeviceSessionApiDto) _then) =
      _$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<AccountDeviceSessionApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfAccountDeviceSessionApiDtoCopyWith<$Res> {
  _$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfAccountDeviceSessionApiDto _self;
  final $Res Function(PagedResultOfAccountDeviceSessionApiDto) _then;

  /// Create a copy of PagedResultOfAccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<AccountDeviceSessionApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfAccountDeviceSessionApiDto].
extension PagedResultOfAccountDeviceSessionApiDtoPatterns
    on PagedResultOfAccountDeviceSessionApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfAccountDeviceSessionApiDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfAccountDeviceSessionApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfAccountDeviceSessionApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfAccountDeviceSessionApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfAccountDeviceSessionApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfAccountDeviceSessionApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<AccountDeviceSessionApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfAccountDeviceSessionApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<AccountDeviceSessionApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfAccountDeviceSessionApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<AccountDeviceSessionApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfAccountDeviceSessionApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfAccountDeviceSessionApiDto
    implements PagedResultOfAccountDeviceSessionApiDto {
  _PagedResultOfAccountDeviceSessionApiDto(
      {@JsonKey(name: 'items') final List<AccountDeviceSessionApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfAccountDeviceSessionApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfAccountDeviceSessionApiDtoFromJson(json);

  final List<AccountDeviceSessionApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<AccountDeviceSessionApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfAccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfAccountDeviceSessionApiDtoCopyWith<
          _PagedResultOfAccountDeviceSessionApiDto>
      get copyWith => __$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl<
          _PagedResultOfAccountDeviceSessionApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfAccountDeviceSessionApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfAccountDeviceSessionApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfAccountDeviceSessionApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfAccountDeviceSessionApiDtoCopyWith<$Res>
    implements $PagedResultOfAccountDeviceSessionApiDtoCopyWith<$Res> {
  factory _$PagedResultOfAccountDeviceSessionApiDtoCopyWith(
          _PagedResultOfAccountDeviceSessionApiDto value,
          $Res Function(_PagedResultOfAccountDeviceSessionApiDto) _then) =
      __$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<AccountDeviceSessionApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfAccountDeviceSessionApiDtoCopyWith<$Res> {
  __$PagedResultOfAccountDeviceSessionApiDtoCopyWithImpl(
      this._self, this._then);

  final _PagedResultOfAccountDeviceSessionApiDto _self;
  final $Res Function(_PagedResultOfAccountDeviceSessionApiDto) _then;

  /// Create a copy of PagedResultOfAccountDeviceSessionApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfAccountDeviceSessionApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<AccountDeviceSessionApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfBranchApiDto {
  @JsonKey(name: 'items')
  List<BranchApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfBranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfBranchApiDtoCopyWith<PagedResultOfBranchApiDto> get copyWith =>
      _$PagedResultOfBranchApiDtoCopyWithImpl<PagedResultOfBranchApiDto>(
          this as PagedResultOfBranchApiDto, _$identity);

  /// Serializes this PagedResultOfBranchApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfBranchApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfBranchApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfBranchApiDtoCopyWith<$Res> {
  factory $PagedResultOfBranchApiDtoCopyWith(PagedResultOfBranchApiDto value,
          $Res Function(PagedResultOfBranchApiDto) _then) =
      _$PagedResultOfBranchApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<BranchApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfBranchApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfBranchApiDtoCopyWith<$Res> {
  _$PagedResultOfBranchApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfBranchApiDto _self;
  final $Res Function(PagedResultOfBranchApiDto) _then;

  /// Create a copy of PagedResultOfBranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<BranchApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfBranchApiDto].
extension PagedResultOfBranchApiDtoPatterns on PagedResultOfBranchApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfBranchApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfBranchApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfBranchApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfBranchApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfBranchApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfBranchApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<BranchApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfBranchApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<BranchApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfBranchApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<BranchApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfBranchApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfBranchApiDto implements PagedResultOfBranchApiDto {
  _PagedResultOfBranchApiDto(
      {@JsonKey(name: 'items') final List<BranchApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfBranchApiDto.fromJson(Map<String, dynamic> json) =>
      _$PagedResultOfBranchApiDtoFromJson(json);

  final List<BranchApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<BranchApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfBranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfBranchApiDtoCopyWith<_PagedResultOfBranchApiDto>
      get copyWith =>
          __$PagedResultOfBranchApiDtoCopyWithImpl<_PagedResultOfBranchApiDto>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfBranchApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfBranchApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfBranchApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfBranchApiDtoCopyWith<$Res>
    implements $PagedResultOfBranchApiDtoCopyWith<$Res> {
  factory _$PagedResultOfBranchApiDtoCopyWith(_PagedResultOfBranchApiDto value,
          $Res Function(_PagedResultOfBranchApiDto) _then) =
      __$PagedResultOfBranchApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<BranchApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfBranchApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfBranchApiDtoCopyWith<$Res> {
  __$PagedResultOfBranchApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfBranchApiDto _self;
  final $Res Function(_PagedResultOfBranchApiDto) _then;

  /// Create a copy of PagedResultOfBranchApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfBranchApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<BranchApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfCalendarItemApiDto {
  @JsonKey(name: 'items')
  List<CalendarItemApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfCalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfCalendarItemApiDtoCopyWith<PagedResultOfCalendarItemApiDto>
      get copyWith => _$PagedResultOfCalendarItemApiDtoCopyWithImpl<
              PagedResultOfCalendarItemApiDto>(
          this as PagedResultOfCalendarItemApiDto, _$identity);

  /// Serializes this PagedResultOfCalendarItemApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfCalendarItemApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfCalendarItemApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfCalendarItemApiDtoCopyWith<$Res> {
  factory $PagedResultOfCalendarItemApiDtoCopyWith(
          PagedResultOfCalendarItemApiDto value,
          $Res Function(PagedResultOfCalendarItemApiDto) _then) =
      _$PagedResultOfCalendarItemApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<CalendarItemApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfCalendarItemApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfCalendarItemApiDtoCopyWith<$Res> {
  _$PagedResultOfCalendarItemApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfCalendarItemApiDto _self;
  final $Res Function(PagedResultOfCalendarItemApiDto) _then;

  /// Create a copy of PagedResultOfCalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<CalendarItemApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfCalendarItemApiDto].
extension PagedResultOfCalendarItemApiDtoPatterns
    on PagedResultOfCalendarItemApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfCalendarItemApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfCalendarItemApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfCalendarItemApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfCalendarItemApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfCalendarItemApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfCalendarItemApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<CalendarItemApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfCalendarItemApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<CalendarItemApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfCalendarItemApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<CalendarItemApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfCalendarItemApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfCalendarItemApiDto
    implements PagedResultOfCalendarItemApiDto {
  _PagedResultOfCalendarItemApiDto(
      {@JsonKey(name: 'items') final List<CalendarItemApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfCalendarItemApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfCalendarItemApiDtoFromJson(json);

  final List<CalendarItemApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<CalendarItemApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfCalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfCalendarItemApiDtoCopyWith<_PagedResultOfCalendarItemApiDto>
      get copyWith => __$PagedResultOfCalendarItemApiDtoCopyWithImpl<
          _PagedResultOfCalendarItemApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfCalendarItemApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfCalendarItemApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfCalendarItemApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfCalendarItemApiDtoCopyWith<$Res>
    implements $PagedResultOfCalendarItemApiDtoCopyWith<$Res> {
  factory _$PagedResultOfCalendarItemApiDtoCopyWith(
          _PagedResultOfCalendarItemApiDto value,
          $Res Function(_PagedResultOfCalendarItemApiDto) _then) =
      __$PagedResultOfCalendarItemApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<CalendarItemApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfCalendarItemApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfCalendarItemApiDtoCopyWith<$Res> {
  __$PagedResultOfCalendarItemApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfCalendarItemApiDto _self;
  final $Res Function(_PagedResultOfCalendarItemApiDto) _then;

  /// Create a copy of PagedResultOfCalendarItemApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfCalendarItemApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<CalendarItemApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfClassApiDto {
  @JsonKey(name: 'items')
  List<ClassApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfClassApiDtoCopyWith<PagedResultOfClassApiDto> get copyWith =>
      _$PagedResultOfClassApiDtoCopyWithImpl<PagedResultOfClassApiDto>(
          this as PagedResultOfClassApiDto, _$identity);

  /// Serializes this PagedResultOfClassApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfClassApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfClassApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfClassApiDtoCopyWith<$Res> {
  factory $PagedResultOfClassApiDtoCopyWith(PagedResultOfClassApiDto value,
          $Res Function(PagedResultOfClassApiDto) _then) =
      _$PagedResultOfClassApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ClassApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfClassApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfClassApiDtoCopyWith<$Res> {
  _$PagedResultOfClassApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfClassApiDto _self;
  final $Res Function(PagedResultOfClassApiDto) _then;

  /// Create a copy of PagedResultOfClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ClassApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfClassApiDto].
extension PagedResultOfClassApiDtoPatterns on PagedResultOfClassApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfClassApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfClassApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfClassApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfClassApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfClassApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfClassApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ClassApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfClassApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ClassApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfClassApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<ClassApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfClassApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfClassApiDto implements PagedResultOfClassApiDto {
  _PagedResultOfClassApiDto(
      {@JsonKey(name: 'items') final List<ClassApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfClassApiDto.fromJson(Map<String, dynamic> json) =>
      _$PagedResultOfClassApiDtoFromJson(json);

  final List<ClassApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<ClassApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfClassApiDtoCopyWith<_PagedResultOfClassApiDto> get copyWith =>
      __$PagedResultOfClassApiDtoCopyWithImpl<_PagedResultOfClassApiDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfClassApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfClassApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfClassApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfClassApiDtoCopyWith<$Res>
    implements $PagedResultOfClassApiDtoCopyWith<$Res> {
  factory _$PagedResultOfClassApiDtoCopyWith(_PagedResultOfClassApiDto value,
          $Res Function(_PagedResultOfClassApiDto) _then) =
      __$PagedResultOfClassApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ClassApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfClassApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfClassApiDtoCopyWith<$Res> {
  __$PagedResultOfClassApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfClassApiDto _self;
  final $Res Function(_PagedResultOfClassApiDto) _then;

  /// Create a copy of PagedResultOfClassApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfClassApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ClassApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfContentApiDto {
  @JsonKey(name: 'items')
  List<ContentApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfContentApiDtoCopyWith<PagedResultOfContentApiDto>
      get copyWith =>
          _$PagedResultOfContentApiDtoCopyWithImpl<PagedResultOfContentApiDto>(
              this as PagedResultOfContentApiDto, _$identity);

  /// Serializes this PagedResultOfContentApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfContentApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfContentApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfContentApiDtoCopyWith<$Res> {
  factory $PagedResultOfContentApiDtoCopyWith(PagedResultOfContentApiDto value,
          $Res Function(PagedResultOfContentApiDto) _then) =
      _$PagedResultOfContentApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ContentApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfContentApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfContentApiDtoCopyWith<$Res> {
  _$PagedResultOfContentApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfContentApiDto _self;
  final $Res Function(PagedResultOfContentApiDto) _then;

  /// Create a copy of PagedResultOfContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ContentApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfContentApiDto].
extension PagedResultOfContentApiDtoPatterns on PagedResultOfContentApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfContentApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfContentApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfContentApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfContentApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfContentApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfContentApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ContentApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfContentApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ContentApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfContentApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<ContentApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfContentApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfContentApiDto implements PagedResultOfContentApiDto {
  _PagedResultOfContentApiDto(
      {@JsonKey(name: 'items') final List<ContentApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfContentApiDto.fromJson(Map<String, dynamic> json) =>
      _$PagedResultOfContentApiDtoFromJson(json);

  final List<ContentApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<ContentApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfContentApiDtoCopyWith<_PagedResultOfContentApiDto>
      get copyWith => __$PagedResultOfContentApiDtoCopyWithImpl<
          _PagedResultOfContentApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfContentApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfContentApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfContentApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfContentApiDtoCopyWith<$Res>
    implements $PagedResultOfContentApiDtoCopyWith<$Res> {
  factory _$PagedResultOfContentApiDtoCopyWith(
          _PagedResultOfContentApiDto value,
          $Res Function(_PagedResultOfContentApiDto) _then) =
      __$PagedResultOfContentApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ContentApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfContentApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfContentApiDtoCopyWith<$Res> {
  __$PagedResultOfContentApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfContentApiDto _self;
  final $Res Function(_PagedResultOfContentApiDto) _then;

  /// Create a copy of PagedResultOfContentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfContentApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ContentApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfConversationApiDto {
  @JsonKey(name: 'items')
  List<ConversationApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfConversationApiDtoCopyWith<PagedResultOfConversationApiDto>
      get copyWith => _$PagedResultOfConversationApiDtoCopyWithImpl<
              PagedResultOfConversationApiDto>(
          this as PagedResultOfConversationApiDto, _$identity);

  /// Serializes this PagedResultOfConversationApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfConversationApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfConversationApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfConversationApiDtoCopyWith<$Res> {
  factory $PagedResultOfConversationApiDtoCopyWith(
          PagedResultOfConversationApiDto value,
          $Res Function(PagedResultOfConversationApiDto) _then) =
      _$PagedResultOfConversationApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ConversationApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfConversationApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfConversationApiDtoCopyWith<$Res> {
  _$PagedResultOfConversationApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfConversationApiDto _self;
  final $Res Function(PagedResultOfConversationApiDto) _then;

  /// Create a copy of PagedResultOfConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ConversationApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfConversationApiDto].
extension PagedResultOfConversationApiDtoPatterns
    on PagedResultOfConversationApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfConversationApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfConversationApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfConversationApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ConversationApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ConversationApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<ConversationApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfConversationApiDto
    implements PagedResultOfConversationApiDto {
  _PagedResultOfConversationApiDto(
      {@JsonKey(name: 'items') final List<ConversationApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfConversationApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfConversationApiDtoFromJson(json);

  final List<ConversationApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<ConversationApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfConversationApiDtoCopyWith<_PagedResultOfConversationApiDto>
      get copyWith => __$PagedResultOfConversationApiDtoCopyWithImpl<
          _PagedResultOfConversationApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfConversationApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfConversationApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfConversationApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfConversationApiDtoCopyWith<$Res>
    implements $PagedResultOfConversationApiDtoCopyWith<$Res> {
  factory _$PagedResultOfConversationApiDtoCopyWith(
          _PagedResultOfConversationApiDto value,
          $Res Function(_PagedResultOfConversationApiDto) _then) =
      __$PagedResultOfConversationApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ConversationApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfConversationApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfConversationApiDtoCopyWith<$Res> {
  __$PagedResultOfConversationApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfConversationApiDto _self;
  final $Res Function(_PagedResultOfConversationApiDto) _then;

  /// Create a copy of PagedResultOfConversationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfConversationApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ConversationApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfConversationMessageApiDto {
  @JsonKey(name: 'items')
  List<ConversationMessageApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfConversationMessageApiDtoCopyWith<
          PagedResultOfConversationMessageApiDto>
      get copyWith => _$PagedResultOfConversationMessageApiDtoCopyWithImpl<
              PagedResultOfConversationMessageApiDto>(
          this as PagedResultOfConversationMessageApiDto, _$identity);

  /// Serializes this PagedResultOfConversationMessageApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfConversationMessageApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfConversationMessageApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfConversationMessageApiDtoCopyWith<$Res> {
  factory $PagedResultOfConversationMessageApiDtoCopyWith(
          PagedResultOfConversationMessageApiDto value,
          $Res Function(PagedResultOfConversationMessageApiDto) _then) =
      _$PagedResultOfConversationMessageApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ConversationMessageApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfConversationMessageApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfConversationMessageApiDtoCopyWith<$Res> {
  _$PagedResultOfConversationMessageApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfConversationMessageApiDto _self;
  final $Res Function(PagedResultOfConversationMessageApiDto) _then;

  /// Create a copy of PagedResultOfConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ConversationMessageApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfConversationMessageApiDto].
extension PagedResultOfConversationMessageApiDtoPatterns
    on PagedResultOfConversationMessageApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfConversationMessageApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationMessageApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfConversationMessageApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationMessageApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfConversationMessageApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationMessageApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ConversationMessageApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationMessageApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<ConversationMessageApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationMessageApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<ConversationMessageApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfConversationMessageApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfConversationMessageApiDto
    implements PagedResultOfConversationMessageApiDto {
  _PagedResultOfConversationMessageApiDto(
      {@JsonKey(name: 'items') final List<ConversationMessageApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfConversationMessageApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfConversationMessageApiDtoFromJson(json);

  final List<ConversationMessageApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<ConversationMessageApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfConversationMessageApiDtoCopyWith<
          _PagedResultOfConversationMessageApiDto>
      get copyWith => __$PagedResultOfConversationMessageApiDtoCopyWithImpl<
          _PagedResultOfConversationMessageApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfConversationMessageApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfConversationMessageApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfConversationMessageApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfConversationMessageApiDtoCopyWith<$Res>
    implements $PagedResultOfConversationMessageApiDtoCopyWith<$Res> {
  factory _$PagedResultOfConversationMessageApiDtoCopyWith(
          _PagedResultOfConversationMessageApiDto value,
          $Res Function(_PagedResultOfConversationMessageApiDto) _then) =
      __$PagedResultOfConversationMessageApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<ConversationMessageApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfConversationMessageApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfConversationMessageApiDtoCopyWith<$Res> {
  __$PagedResultOfConversationMessageApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfConversationMessageApiDto _self;
  final $Res Function(_PagedResultOfConversationMessageApiDto) _then;

  /// Create a copy of PagedResultOfConversationMessageApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfConversationMessageApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<ConversationMessageApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfInfantCareActivityApiDto {
  @JsonKey(name: 'items')
  List<InfantCareActivityApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfInfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfInfantCareActivityApiDtoCopyWith<
          PagedResultOfInfantCareActivityApiDto>
      get copyWith => _$PagedResultOfInfantCareActivityApiDtoCopyWithImpl<
              PagedResultOfInfantCareActivityApiDto>(
          this as PagedResultOfInfantCareActivityApiDto, _$identity);

  /// Serializes this PagedResultOfInfantCareActivityApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfInfantCareActivityApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfInfantCareActivityApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfInfantCareActivityApiDtoCopyWith<$Res> {
  factory $PagedResultOfInfantCareActivityApiDtoCopyWith(
          PagedResultOfInfantCareActivityApiDto value,
          $Res Function(PagedResultOfInfantCareActivityApiDto) _then) =
      _$PagedResultOfInfantCareActivityApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<InfantCareActivityApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfInfantCareActivityApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfInfantCareActivityApiDtoCopyWith<$Res> {
  _$PagedResultOfInfantCareActivityApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfInfantCareActivityApiDto _self;
  final $Res Function(PagedResultOfInfantCareActivityApiDto) _then;

  /// Create a copy of PagedResultOfInfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<InfantCareActivityApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfInfantCareActivityApiDto].
extension PagedResultOfInfantCareActivityApiDtoPatterns
    on PagedResultOfInfantCareActivityApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfInfantCareActivityApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfInfantCareActivityApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfInfantCareActivityApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<InfantCareActivityApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<InfantCareActivityApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<InfantCareActivityApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfInfantCareActivityApiDto
    implements PagedResultOfInfantCareActivityApiDto {
  _PagedResultOfInfantCareActivityApiDto(
      {@JsonKey(name: 'items') final List<InfantCareActivityApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfInfantCareActivityApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfInfantCareActivityApiDtoFromJson(json);

  final List<InfantCareActivityApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<InfantCareActivityApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfInfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfInfantCareActivityApiDtoCopyWith<
          _PagedResultOfInfantCareActivityApiDto>
      get copyWith => __$PagedResultOfInfantCareActivityApiDtoCopyWithImpl<
          _PagedResultOfInfantCareActivityApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfInfantCareActivityApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfInfantCareActivityApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfInfantCareActivityApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfInfantCareActivityApiDtoCopyWith<$Res>
    implements $PagedResultOfInfantCareActivityApiDtoCopyWith<$Res> {
  factory _$PagedResultOfInfantCareActivityApiDtoCopyWith(
          _PagedResultOfInfantCareActivityApiDto value,
          $Res Function(_PagedResultOfInfantCareActivityApiDto) _then) =
      __$PagedResultOfInfantCareActivityApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<InfantCareActivityApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfInfantCareActivityApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfInfantCareActivityApiDtoCopyWith<$Res> {
  __$PagedResultOfInfantCareActivityApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfInfantCareActivityApiDto _self;
  final $Res Function(_PagedResultOfInfantCareActivityApiDto) _then;

  /// Create a copy of PagedResultOfInfantCareActivityApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfInfantCareActivityApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<InfantCareActivityApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfInfantCareActivityLogApiDto {
  @JsonKey(name: 'items')
  List<InfantCareActivityLogApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfInfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfInfantCareActivityLogApiDtoCopyWith<
          PagedResultOfInfantCareActivityLogApiDto>
      get copyWith => _$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl<
              PagedResultOfInfantCareActivityLogApiDto>(
          this as PagedResultOfInfantCareActivityLogApiDto, _$identity);

  /// Serializes this PagedResultOfInfantCareActivityLogApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfInfantCareActivityLogApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfInfantCareActivityLogApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfInfantCareActivityLogApiDtoCopyWith<$Res> {
  factory $PagedResultOfInfantCareActivityLogApiDtoCopyWith(
          PagedResultOfInfantCareActivityLogApiDto value,
          $Res Function(PagedResultOfInfantCareActivityLogApiDto) _then) =
      _$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<InfantCareActivityLogApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfInfantCareActivityLogApiDtoCopyWith<$Res> {
  _$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl(
      this._self, this._then);

  final PagedResultOfInfantCareActivityLogApiDto _self;
  final $Res Function(PagedResultOfInfantCareActivityLogApiDto) _then;

  /// Create a copy of PagedResultOfInfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<InfantCareActivityLogApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfInfantCareActivityLogApiDto].
extension PagedResultOfInfantCareActivityLogApiDtoPatterns
    on PagedResultOfInfantCareActivityLogApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfInfantCareActivityLogApiDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityLogApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfInfantCareActivityLogApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityLogApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfInfantCareActivityLogApiDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityLogApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<InfantCareActivityLogApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityLogApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<InfantCareActivityLogApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityLogApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<InfantCareActivityLogApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfInfantCareActivityLogApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfInfantCareActivityLogApiDto
    implements PagedResultOfInfantCareActivityLogApiDto {
  _PagedResultOfInfantCareActivityLogApiDto(
      {@JsonKey(name: 'items') final List<InfantCareActivityLogApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfInfantCareActivityLogApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfInfantCareActivityLogApiDtoFromJson(json);

  final List<InfantCareActivityLogApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<InfantCareActivityLogApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfInfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfInfantCareActivityLogApiDtoCopyWith<
          _PagedResultOfInfantCareActivityLogApiDto>
      get copyWith => __$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl<
          _PagedResultOfInfantCareActivityLogApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfInfantCareActivityLogApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfInfantCareActivityLogApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfInfantCareActivityLogApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfInfantCareActivityLogApiDtoCopyWith<$Res>
    implements $PagedResultOfInfantCareActivityLogApiDtoCopyWith<$Res> {
  factory _$PagedResultOfInfantCareActivityLogApiDtoCopyWith(
          _PagedResultOfInfantCareActivityLogApiDto value,
          $Res Function(_PagedResultOfInfantCareActivityLogApiDto) _then) =
      __$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<InfantCareActivityLogApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfInfantCareActivityLogApiDtoCopyWith<$Res> {
  __$PagedResultOfInfantCareActivityLogApiDtoCopyWithImpl(
      this._self, this._then);

  final _PagedResultOfInfantCareActivityLogApiDto _self;
  final $Res Function(_PagedResultOfInfantCareActivityLogApiDto) _then;

  /// Create a copy of PagedResultOfInfantCareActivityLogApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfInfantCareActivityLogApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<InfantCareActivityLogApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfNotificationApiDto {
  @JsonKey(name: 'items')
  List<NotificationApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfNotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfNotificationApiDtoCopyWith<PagedResultOfNotificationApiDto>
      get copyWith => _$PagedResultOfNotificationApiDtoCopyWithImpl<
              PagedResultOfNotificationApiDto>(
          this as PagedResultOfNotificationApiDto, _$identity);

  /// Serializes this PagedResultOfNotificationApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfNotificationApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfNotificationApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfNotificationApiDtoCopyWith<$Res> {
  factory $PagedResultOfNotificationApiDtoCopyWith(
          PagedResultOfNotificationApiDto value,
          $Res Function(PagedResultOfNotificationApiDto) _then) =
      _$PagedResultOfNotificationApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<NotificationApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfNotificationApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfNotificationApiDtoCopyWith<$Res> {
  _$PagedResultOfNotificationApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfNotificationApiDto _self;
  final $Res Function(PagedResultOfNotificationApiDto) _then;

  /// Create a copy of PagedResultOfNotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<NotificationApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfNotificationApiDto].
extension PagedResultOfNotificationApiDtoPatterns
    on PagedResultOfNotificationApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfNotificationApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfNotificationApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfNotificationApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfNotificationApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfNotificationApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfNotificationApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<NotificationApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfNotificationApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<NotificationApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfNotificationApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<NotificationApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfNotificationApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfNotificationApiDto
    implements PagedResultOfNotificationApiDto {
  _PagedResultOfNotificationApiDto(
      {@JsonKey(name: 'items') final List<NotificationApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfNotificationApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfNotificationApiDtoFromJson(json);

  final List<NotificationApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<NotificationApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfNotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfNotificationApiDtoCopyWith<_PagedResultOfNotificationApiDto>
      get copyWith => __$PagedResultOfNotificationApiDtoCopyWithImpl<
          _PagedResultOfNotificationApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfNotificationApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfNotificationApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfNotificationApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfNotificationApiDtoCopyWith<$Res>
    implements $PagedResultOfNotificationApiDtoCopyWith<$Res> {
  factory _$PagedResultOfNotificationApiDtoCopyWith(
          _PagedResultOfNotificationApiDto value,
          $Res Function(_PagedResultOfNotificationApiDto) _then) =
      __$PagedResultOfNotificationApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<NotificationApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfNotificationApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfNotificationApiDtoCopyWith<$Res> {
  __$PagedResultOfNotificationApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfNotificationApiDto _self;
  final $Res Function(_PagedResultOfNotificationApiDto) _then;

  /// Create a copy of PagedResultOfNotificationApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfNotificationApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<NotificationApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfStudentApiDto {
  @JsonKey(name: 'items')
  List<StudentApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfStudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfStudentApiDtoCopyWith<PagedResultOfStudentApiDto>
      get copyWith =>
          _$PagedResultOfStudentApiDtoCopyWithImpl<PagedResultOfStudentApiDto>(
              this as PagedResultOfStudentApiDto, _$identity);

  /// Serializes this PagedResultOfStudentApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfStudentApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfStudentApiDtoCopyWith<$Res> {
  factory $PagedResultOfStudentApiDtoCopyWith(PagedResultOfStudentApiDto value,
          $Res Function(PagedResultOfStudentApiDto) _then) =
      _$PagedResultOfStudentApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfStudentApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfStudentApiDtoCopyWith<$Res> {
  _$PagedResultOfStudentApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfStudentApiDto _self;
  final $Res Function(PagedResultOfStudentApiDto) _then;

  /// Create a copy of PagedResultOfStudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfStudentApiDto].
extension PagedResultOfStudentApiDtoPatterns on PagedResultOfStudentApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfStudentApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<StudentApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfStudentApiDto implements PagedResultOfStudentApiDto {
  _PagedResultOfStudentApiDto(
      {@JsonKey(name: 'items') final List<StudentApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfStudentApiDto.fromJson(Map<String, dynamic> json) =>
      _$PagedResultOfStudentApiDtoFromJson(json);

  final List<StudentApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<StudentApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfStudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfStudentApiDtoCopyWith<_PagedResultOfStudentApiDto>
      get copyWith => __$PagedResultOfStudentApiDtoCopyWithImpl<
          _PagedResultOfStudentApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfStudentApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfStudentApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfStudentApiDtoCopyWith<$Res>
    implements $PagedResultOfStudentApiDtoCopyWith<$Res> {
  factory _$PagedResultOfStudentApiDtoCopyWith(
          _PagedResultOfStudentApiDto value,
          $Res Function(_PagedResultOfStudentApiDto) _then) =
      __$PagedResultOfStudentApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfStudentApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfStudentApiDtoCopyWith<$Res> {
  __$PagedResultOfStudentApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfStudentApiDto _self;
  final $Res Function(_PagedResultOfStudentApiDto) _then;

  /// Create a copy of PagedResultOfStudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfStudentApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfStudentAttendanceApiDto {
  @JsonKey(name: 'items')
  List<StudentAttendanceApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfStudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfStudentAttendanceApiDtoCopyWith<
          PagedResultOfStudentAttendanceApiDto>
      get copyWith => _$PagedResultOfStudentAttendanceApiDtoCopyWithImpl<
              PagedResultOfStudentAttendanceApiDto>(
          this as PagedResultOfStudentAttendanceApiDto, _$identity);

  /// Serializes this PagedResultOfStudentAttendanceApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfStudentAttendanceApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentAttendanceApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfStudentAttendanceApiDtoCopyWith<$Res> {
  factory $PagedResultOfStudentAttendanceApiDtoCopyWith(
          PagedResultOfStudentAttendanceApiDto value,
          $Res Function(PagedResultOfStudentAttendanceApiDto) _then) =
      _$PagedResultOfStudentAttendanceApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentAttendanceApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfStudentAttendanceApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfStudentAttendanceApiDtoCopyWith<$Res> {
  _$PagedResultOfStudentAttendanceApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfStudentAttendanceApiDto _self;
  final $Res Function(PagedResultOfStudentAttendanceApiDto) _then;

  /// Create a copy of PagedResultOfStudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentAttendanceApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfStudentAttendanceApiDto].
extension PagedResultOfStudentAttendanceApiDtoPatterns
    on PagedResultOfStudentAttendanceApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentAttendanceApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAttendanceApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentAttendanceApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAttendanceApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfStudentAttendanceApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAttendanceApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentAttendanceApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAttendanceApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentAttendanceApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAttendanceApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<StudentAttendanceApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAttendanceApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfStudentAttendanceApiDto
    implements PagedResultOfStudentAttendanceApiDto {
  _PagedResultOfStudentAttendanceApiDto(
      {@JsonKey(name: 'items') final List<StudentAttendanceApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfStudentAttendanceApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfStudentAttendanceApiDtoFromJson(json);

  final List<StudentAttendanceApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<StudentAttendanceApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfStudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfStudentAttendanceApiDtoCopyWith<
          _PagedResultOfStudentAttendanceApiDto>
      get copyWith => __$PagedResultOfStudentAttendanceApiDtoCopyWithImpl<
          _PagedResultOfStudentAttendanceApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfStudentAttendanceApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfStudentAttendanceApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentAttendanceApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfStudentAttendanceApiDtoCopyWith<$Res>
    implements $PagedResultOfStudentAttendanceApiDtoCopyWith<$Res> {
  factory _$PagedResultOfStudentAttendanceApiDtoCopyWith(
          _PagedResultOfStudentAttendanceApiDto value,
          $Res Function(_PagedResultOfStudentAttendanceApiDto) _then) =
      __$PagedResultOfStudentAttendanceApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentAttendanceApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfStudentAttendanceApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfStudentAttendanceApiDtoCopyWith<$Res> {
  __$PagedResultOfStudentAttendanceApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfStudentAttendanceApiDto _self;
  final $Res Function(_PagedResultOfStudentAttendanceApiDto) _then;

  /// Create a copy of PagedResultOfStudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfStudentAttendanceApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentAttendanceApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfStudentAuthorisedPersonApiDto {
  @JsonKey(name: 'items')
  List<StudentAuthorisedPersonApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfStudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfStudentAuthorisedPersonApiDtoCopyWith<
          PagedResultOfStudentAuthorisedPersonApiDto>
      get copyWith => _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl<
              PagedResultOfStudentAuthorisedPersonApiDto>(
          this as PagedResultOfStudentAuthorisedPersonApiDto, _$identity);

  /// Serializes this PagedResultOfStudentAuthorisedPersonApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfStudentAuthorisedPersonApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentAuthorisedPersonApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfStudentAuthorisedPersonApiDtoCopyWith<$Res> {
  factory $PagedResultOfStudentAuthorisedPersonApiDtoCopyWith(
          PagedResultOfStudentAuthorisedPersonApiDto value,
          $Res Function(PagedResultOfStudentAuthorisedPersonApiDto) _then) =
      _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentAuthorisedPersonApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfStudentAuthorisedPersonApiDtoCopyWith<$Res> {
  _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl(
      this._self, this._then);

  final PagedResultOfStudentAuthorisedPersonApiDto _self;
  final $Res Function(PagedResultOfStudentAuthorisedPersonApiDto) _then;

  /// Create a copy of PagedResultOfStudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentAuthorisedPersonApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfStudentAuthorisedPersonApiDto].
extension PagedResultOfStudentAuthorisedPersonApiDtoPatterns
    on PagedResultOfStudentAuthorisedPersonApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentAuthorisedPersonApiDto value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAuthorisedPersonApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentAuthorisedPersonApiDto value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAuthorisedPersonApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfStudentAuthorisedPersonApiDto value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAuthorisedPersonApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentAuthorisedPersonApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAuthorisedPersonApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentAuthorisedPersonApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAuthorisedPersonApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<StudentAuthorisedPersonApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentAuthorisedPersonApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfStudentAuthorisedPersonApiDto
    implements PagedResultOfStudentAuthorisedPersonApiDto {
  _PagedResultOfStudentAuthorisedPersonApiDto(
      {@JsonKey(name: 'items') final List<StudentAuthorisedPersonApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfStudentAuthorisedPersonApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfStudentAuthorisedPersonApiDtoFromJson(json);

  final List<StudentAuthorisedPersonApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<StudentAuthorisedPersonApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfStudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWith<
          _PagedResultOfStudentAuthorisedPersonApiDto>
      get copyWith => __$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl<
          _PagedResultOfStudentAuthorisedPersonApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfStudentAuthorisedPersonApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfStudentAuthorisedPersonApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentAuthorisedPersonApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWith<$Res>
    implements $PagedResultOfStudentAuthorisedPersonApiDtoCopyWith<$Res> {
  factory _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWith(
          _PagedResultOfStudentAuthorisedPersonApiDto value,
          $Res Function(_PagedResultOfStudentAuthorisedPersonApiDto) _then) =
      __$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentAuthorisedPersonApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfStudentAuthorisedPersonApiDtoCopyWith<$Res> {
  __$PagedResultOfStudentAuthorisedPersonApiDtoCopyWithImpl(
      this._self, this._then);

  final _PagedResultOfStudentAuthorisedPersonApiDto _self;
  final $Res Function(_PagedResultOfStudentAuthorisedPersonApiDto) _then;

  /// Create a copy of PagedResultOfStudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfStudentAuthorisedPersonApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentAuthorisedPersonApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfStudentCheckInOutApiDto {
  @JsonKey(name: 'items')
  List<StudentCheckInOutApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfStudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfStudentCheckInOutApiDtoCopyWith<
          PagedResultOfStudentCheckInOutApiDto>
      get copyWith => _$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl<
              PagedResultOfStudentCheckInOutApiDto>(
          this as PagedResultOfStudentCheckInOutApiDto, _$identity);

  /// Serializes this PagedResultOfStudentCheckInOutApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfStudentCheckInOutApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentCheckInOutApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfStudentCheckInOutApiDtoCopyWith<$Res> {
  factory $PagedResultOfStudentCheckInOutApiDtoCopyWith(
          PagedResultOfStudentCheckInOutApiDto value,
          $Res Function(PagedResultOfStudentCheckInOutApiDto) _then) =
      _$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentCheckInOutApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfStudentCheckInOutApiDtoCopyWith<$Res> {
  _$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfStudentCheckInOutApiDto _self;
  final $Res Function(PagedResultOfStudentCheckInOutApiDto) _then;

  /// Create a copy of PagedResultOfStudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentCheckInOutApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfStudentCheckInOutApiDto].
extension PagedResultOfStudentCheckInOutApiDtoPatterns
    on PagedResultOfStudentCheckInOutApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentCheckInOutApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentCheckInOutApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentCheckInOutApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentCheckInOutApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfStudentCheckInOutApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentCheckInOutApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentCheckInOutApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentCheckInOutApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentCheckInOutApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentCheckInOutApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<StudentCheckInOutApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentCheckInOutApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfStudentCheckInOutApiDto
    implements PagedResultOfStudentCheckInOutApiDto {
  _PagedResultOfStudentCheckInOutApiDto(
      {@JsonKey(name: 'items') final List<StudentCheckInOutApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfStudentCheckInOutApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfStudentCheckInOutApiDtoFromJson(json);

  final List<StudentCheckInOutApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<StudentCheckInOutApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfStudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfStudentCheckInOutApiDtoCopyWith<
          _PagedResultOfStudentCheckInOutApiDto>
      get copyWith => __$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl<
          _PagedResultOfStudentCheckInOutApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfStudentCheckInOutApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfStudentCheckInOutApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentCheckInOutApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfStudentCheckInOutApiDtoCopyWith<$Res>
    implements $PagedResultOfStudentCheckInOutApiDtoCopyWith<$Res> {
  factory _$PagedResultOfStudentCheckInOutApiDtoCopyWith(
          _PagedResultOfStudentCheckInOutApiDto value,
          $Res Function(_PagedResultOfStudentCheckInOutApiDto) _then) =
      __$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentCheckInOutApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfStudentCheckInOutApiDtoCopyWith<$Res> {
  __$PagedResultOfStudentCheckInOutApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfStudentCheckInOutApiDto _self;
  final $Res Function(_PagedResultOfStudentCheckInOutApiDto) _then;

  /// Create a copy of PagedResultOfStudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfStudentCheckInOutApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentCheckInOutApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfStudentTemperatureApiDto {
  @JsonKey(name: 'items')
  List<StudentTemperatureApiDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfStudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfStudentTemperatureApiDtoCopyWith<
          PagedResultOfStudentTemperatureApiDto>
      get copyWith => _$PagedResultOfStudentTemperatureApiDtoCopyWithImpl<
              PagedResultOfStudentTemperatureApiDto>(
          this as PagedResultOfStudentTemperatureApiDto, _$identity);

  /// Serializes this PagedResultOfStudentTemperatureApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfStudentTemperatureApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentTemperatureApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfStudentTemperatureApiDtoCopyWith<$Res> {
  factory $PagedResultOfStudentTemperatureApiDtoCopyWith(
          PagedResultOfStudentTemperatureApiDto value,
          $Res Function(PagedResultOfStudentTemperatureApiDto) _then) =
      _$PagedResultOfStudentTemperatureApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentTemperatureApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfStudentTemperatureApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfStudentTemperatureApiDtoCopyWith<$Res> {
  _$PagedResultOfStudentTemperatureApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfStudentTemperatureApiDto _self;
  final $Res Function(PagedResultOfStudentTemperatureApiDto) _then;

  /// Create a copy of PagedResultOfStudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentTemperatureApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfStudentTemperatureApiDto].
extension PagedResultOfStudentTemperatureApiDtoPatterns
    on PagedResultOfStudentTemperatureApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentTemperatureApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentTemperatureApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfStudentTemperatureApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentTemperatureApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfStudentTemperatureApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentTemperatureApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentTemperatureApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentTemperatureApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<StudentTemperatureApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentTemperatureApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<StudentTemperatureApiDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfStudentTemperatureApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfStudentTemperatureApiDto
    implements PagedResultOfStudentTemperatureApiDto {
  _PagedResultOfStudentTemperatureApiDto(
      {@JsonKey(name: 'items') final List<StudentTemperatureApiDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfStudentTemperatureApiDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfStudentTemperatureApiDtoFromJson(json);

  final List<StudentTemperatureApiDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<StudentTemperatureApiDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfStudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfStudentTemperatureApiDtoCopyWith<
          _PagedResultOfStudentTemperatureApiDto>
      get copyWith => __$PagedResultOfStudentTemperatureApiDtoCopyWithImpl<
          _PagedResultOfStudentTemperatureApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfStudentTemperatureApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfStudentTemperatureApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfStudentTemperatureApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfStudentTemperatureApiDtoCopyWith<$Res>
    implements $PagedResultOfStudentTemperatureApiDtoCopyWith<$Res> {
  factory _$PagedResultOfStudentTemperatureApiDtoCopyWith(
          _PagedResultOfStudentTemperatureApiDto value,
          $Res Function(_PagedResultOfStudentTemperatureApiDto) _then) =
      __$PagedResultOfStudentTemperatureApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<StudentTemperatureApiDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfStudentTemperatureApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfStudentTemperatureApiDtoCopyWith<$Res> {
  __$PagedResultOfStudentTemperatureApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfStudentTemperatureApiDto _self;
  final $Res Function(_PagedResultOfStudentTemperatureApiDto) _then;

  /// Create a copy of PagedResultOfStudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfStudentTemperatureApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<StudentTemperatureApiDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfTeacherApiDto {
  @JsonKey(name: 'items')
  List<TeacherApiDto2Dto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfTeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfTeacherApiDtoCopyWith<PagedResultOfTeacherApiDto>
      get copyWith =>
          _$PagedResultOfTeacherApiDtoCopyWithImpl<PagedResultOfTeacherApiDto>(
              this as PagedResultOfTeacherApiDto, _$identity);

  /// Serializes this PagedResultOfTeacherApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfTeacherApiDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfTeacherApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfTeacherApiDtoCopyWith<$Res> {
  factory $PagedResultOfTeacherApiDtoCopyWith(PagedResultOfTeacherApiDto value,
          $Res Function(PagedResultOfTeacherApiDto) _then) =
      _$PagedResultOfTeacherApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<TeacherApiDto2Dto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfTeacherApiDtoCopyWithImpl<$Res>
    implements $PagedResultOfTeacherApiDtoCopyWith<$Res> {
  _$PagedResultOfTeacherApiDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfTeacherApiDto _self;
  final $Res Function(PagedResultOfTeacherApiDto) _then;

  /// Create a copy of PagedResultOfTeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<TeacherApiDto2Dto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfTeacherApiDto].
extension PagedResultOfTeacherApiDtoPatterns on PagedResultOfTeacherApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfTeacherApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfTeacherApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfTeacherApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfTeacherApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfTeacherApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfTeacherApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<TeacherApiDto2Dto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfTeacherApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<TeacherApiDto2Dto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfTeacherApiDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<TeacherApiDto2Dto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfTeacherApiDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfTeacherApiDto implements PagedResultOfTeacherApiDto {
  _PagedResultOfTeacherApiDto(
      {@JsonKey(name: 'items') final List<TeacherApiDto2Dto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfTeacherApiDto.fromJson(Map<String, dynamic> json) =>
      _$PagedResultOfTeacherApiDtoFromJson(json);

  final List<TeacherApiDto2Dto>? _items;
  @override
  @JsonKey(name: 'items')
  List<TeacherApiDto2Dto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfTeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfTeacherApiDtoCopyWith<_PagedResultOfTeacherApiDto>
      get copyWith => __$PagedResultOfTeacherApiDtoCopyWithImpl<
          _PagedResultOfTeacherApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfTeacherApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfTeacherApiDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfTeacherApiDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfTeacherApiDtoCopyWith<$Res>
    implements $PagedResultOfTeacherApiDtoCopyWith<$Res> {
  factory _$PagedResultOfTeacherApiDtoCopyWith(
          _PagedResultOfTeacherApiDto value,
          $Res Function(_PagedResultOfTeacherApiDto) _then) =
      __$PagedResultOfTeacherApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<TeacherApiDto2Dto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfTeacherApiDtoCopyWithImpl<$Res>
    implements _$PagedResultOfTeacherApiDtoCopyWith<$Res> {
  __$PagedResultOfTeacherApiDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfTeacherApiDto _self;
  final $Res Function(_PagedResultOfTeacherApiDto) _then;

  /// Create a copy of PagedResultOfTeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfTeacherApiDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<TeacherApiDto2Dto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$PagedResultOfUserBranchRoleViewDto {
  @JsonKey(name: 'items')
  List<UserBranchRoleViewDto>? get items;
  @JsonKey(name: 'page')
  int? get page;
  @JsonKey(name: 'pageSize')
  int? get pageSize;
  @JsonKey(name: 'totalCount')
  int? get totalCount;
  @JsonKey(name: 'hasNextPage')
  bool? get hasNextPage;
  @JsonKey(name: 'hasPreviousPage')
  bool? get hasPreviousPage;
  @JsonKey(name: 'totalPages')
  int? get totalPages;

  /// Create a copy of PagedResultOfUserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PagedResultOfUserBranchRoleViewDtoCopyWith<
          PagedResultOfUserBranchRoleViewDto>
      get copyWith => _$PagedResultOfUserBranchRoleViewDtoCopyWithImpl<
              PagedResultOfUserBranchRoleViewDto>(
          this as PagedResultOfUserBranchRoleViewDto, _$identity);

  /// Serializes this PagedResultOfUserBranchRoleViewDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PagedResultOfUserBranchRoleViewDto &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfUserBranchRoleViewDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class $PagedResultOfUserBranchRoleViewDtoCopyWith<$Res> {
  factory $PagedResultOfUserBranchRoleViewDtoCopyWith(
          PagedResultOfUserBranchRoleViewDto value,
          $Res Function(PagedResultOfUserBranchRoleViewDto) _then) =
      _$PagedResultOfUserBranchRoleViewDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<UserBranchRoleViewDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class _$PagedResultOfUserBranchRoleViewDtoCopyWithImpl<$Res>
    implements $PagedResultOfUserBranchRoleViewDtoCopyWith<$Res> {
  _$PagedResultOfUserBranchRoleViewDtoCopyWithImpl(this._self, this._then);

  final PagedResultOfUserBranchRoleViewDto _self;
  final $Res Function(PagedResultOfUserBranchRoleViewDto) _then;

  /// Create a copy of PagedResultOfUserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_self.copyWith(
      items: freezed == items
          ? _self.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<UserBranchRoleViewDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [PagedResultOfUserBranchRoleViewDto].
extension PagedResultOfUserBranchRoleViewDtoPatterns
    on PagedResultOfUserBranchRoleViewDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PagedResultOfUserBranchRoleViewDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfUserBranchRoleViewDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PagedResultOfUserBranchRoleViewDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfUserBranchRoleViewDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PagedResultOfUserBranchRoleViewDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfUserBranchRoleViewDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<UserBranchRoleViewDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfUserBranchRoleViewDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'items') List<UserBranchRoleViewDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfUserBranchRoleViewDto():
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'items') List<UserBranchRoleViewDto>? items,
            @JsonKey(name: 'page') int? page,
            @JsonKey(name: 'pageSize') int? pageSize,
            @JsonKey(name: 'totalCount') int? totalCount,
            @JsonKey(name: 'hasNextPage') bool? hasNextPage,
            @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
            @JsonKey(name: 'totalPages') int? totalPages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PagedResultOfUserBranchRoleViewDto() when $default != null:
        return $default(
            _that.items,
            _that.page,
            _that.pageSize,
            _that.totalCount,
            _that.hasNextPage,
            _that.hasPreviousPage,
            _that.totalPages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PagedResultOfUserBranchRoleViewDto
    implements PagedResultOfUserBranchRoleViewDto {
  _PagedResultOfUserBranchRoleViewDto(
      {@JsonKey(name: 'items') final List<UserBranchRoleViewDto>? items,
      @JsonKey(name: 'page') this.page,
      @JsonKey(name: 'pageSize') this.pageSize,
      @JsonKey(name: 'totalCount') this.totalCount,
      @JsonKey(name: 'hasNextPage') this.hasNextPage,
      @JsonKey(name: 'hasPreviousPage') this.hasPreviousPage,
      @JsonKey(name: 'totalPages') this.totalPages})
      : _items = items;
  factory _PagedResultOfUserBranchRoleViewDto.fromJson(
          Map<String, dynamic> json) =>
      _$PagedResultOfUserBranchRoleViewDtoFromJson(json);

  final List<UserBranchRoleViewDto>? _items;
  @override
  @JsonKey(name: 'items')
  List<UserBranchRoleViewDto>? get items {
    final value = _items;
    if (value == null) return null;
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'page')
  final int? page;
  @override
  @JsonKey(name: 'pageSize')
  final int? pageSize;
  @override
  @JsonKey(name: 'totalCount')
  final int? totalCount;
  @override
  @JsonKey(name: 'hasNextPage')
  final bool? hasNextPage;
  @override
  @JsonKey(name: 'hasPreviousPage')
  final bool? hasPreviousPage;
  @override
  @JsonKey(name: 'totalPages')
  final int? totalPages;

  /// Create a copy of PagedResultOfUserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PagedResultOfUserBranchRoleViewDtoCopyWith<
          _PagedResultOfUserBranchRoleViewDto>
      get copyWith => __$PagedResultOfUserBranchRoleViewDtoCopyWithImpl<
          _PagedResultOfUserBranchRoleViewDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PagedResultOfUserBranchRoleViewDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PagedResultOfUserBranchRoleViewDto &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.hasPreviousPage, hasPreviousPage) ||
                other.hasPreviousPage == hasPreviousPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_items),
      page,
      pageSize,
      totalCount,
      hasNextPage,
      hasPreviousPage,
      totalPages);

  @override
  String toString() {
    return 'PagedResultOfUserBranchRoleViewDto(items: $items, page: $page, pageSize: $pageSize, totalCount: $totalCount, hasNextPage: $hasNextPage, hasPreviousPage: $hasPreviousPage, totalPages: $totalPages)';
  }
}

/// @nodoc
abstract mixin class _$PagedResultOfUserBranchRoleViewDtoCopyWith<$Res>
    implements $PagedResultOfUserBranchRoleViewDtoCopyWith<$Res> {
  factory _$PagedResultOfUserBranchRoleViewDtoCopyWith(
          _PagedResultOfUserBranchRoleViewDto value,
          $Res Function(_PagedResultOfUserBranchRoleViewDto) _then) =
      __$PagedResultOfUserBranchRoleViewDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'items') List<UserBranchRoleViewDto>? items,
      @JsonKey(name: 'page') int? page,
      @JsonKey(name: 'pageSize') int? pageSize,
      @JsonKey(name: 'totalCount') int? totalCount,
      @JsonKey(name: 'hasNextPage') bool? hasNextPage,
      @JsonKey(name: 'hasPreviousPage') bool? hasPreviousPage,
      @JsonKey(name: 'totalPages') int? totalPages});
}

/// @nodoc
class __$PagedResultOfUserBranchRoleViewDtoCopyWithImpl<$Res>
    implements _$PagedResultOfUserBranchRoleViewDtoCopyWith<$Res> {
  __$PagedResultOfUserBranchRoleViewDtoCopyWithImpl(this._self, this._then);

  final _PagedResultOfUserBranchRoleViewDto _self;
  final $Res Function(_PagedResultOfUserBranchRoleViewDto) _then;

  /// Create a copy of PagedResultOfUserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? items = freezed,
    Object? page = freezed,
    Object? pageSize = freezed,
    Object? totalCount = freezed,
    Object? hasNextPage = freezed,
    Object? hasPreviousPage = freezed,
    Object? totalPages = freezed,
  }) {
    return _then(_PagedResultOfUserBranchRoleViewDto(
      items: freezed == items
          ? _self._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<UserBranchRoleViewDto>?,
      page: freezed == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      pageSize: freezed == pageSize
          ? _self.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int?,
      totalCount: freezed == totalCount
          ? _self.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      hasNextPage: freezed == hasNextPage
          ? _self.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPreviousPage: freezed == hasPreviousPage
          ? _self.hasPreviousPage
          : hasPreviousPage // ignore: cast_nullable_to_non_nullable
              as bool?,
      totalPages: freezed == totalPages
          ? _self.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$StudentApiDto {
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'account')
  AccountApiDto2Dto? get account;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'email')
  String? get email;
  @JsonKey(name: 'phoneNumber')
  String? get phoneNumber;
  @JsonKey(name: 'identifier')
  String? get identifier;
  @JsonKey(name: 'dateOfBirth')
  String? get dateOfBirth;
  @JsonKey(name: 'age')
  int? get age;
  @JsonKey(name: 'genderId')
  int? get genderId;
  @JsonKey(name: 'citizenshipId')
  int? get citizenshipId;
  @JsonKey(name: 'mainLanguageSpokenId')
  int? get mainLanguageSpokenId;
  @JsonKey(name: 'raceId')
  int? get raceId;
  @JsonKey(name: 'residenceStatusId')
  int? get residenceStatusId;
  @JsonKey(name: 'enrolments')
  List<EnrolmentApiDto>? get enrolments;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of StudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentApiDtoCopyWith<StudentApiDto> get copyWith =>
      _$StudentApiDtoCopyWithImpl<StudentApiDto>(
          this as StudentApiDto, _$identity);

  /// Serializes this StudentApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentApiDto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                other.dateOfBirth == dateOfBirth) &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.genderId, genderId) ||
                other.genderId == genderId) &&
            (identical(other.citizenshipId, citizenshipId) ||
                other.citizenshipId == citizenshipId) &&
            (identical(other.mainLanguageSpokenId, mainLanguageSpokenId) ||
                other.mainLanguageSpokenId == mainLanguageSpokenId) &&
            (identical(other.raceId, raceId) || other.raceId == raceId) &&
            (identical(other.residenceStatusId, residenceStatusId) ||
                other.residenceStatusId == residenceStatusId) &&
            const DeepCollectionEquality()
                .equals(other.enrolments, enrolments) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        studentId,
        accountId,
        account,
        name,
        email,
        phoneNumber,
        identifier,
        dateOfBirth,
        age,
        genderId,
        citizenshipId,
        mainLanguageSpokenId,
        raceId,
        residenceStatusId,
        const DeepCollectionEquality().hash(enrolments),
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'StudentApiDto(studentId: $studentId, accountId: $accountId, account: $account, name: $name, email: $email, phoneNumber: $phoneNumber, identifier: $identifier, dateOfBirth: $dateOfBirth, age: $age, genderId: $genderId, citizenshipId: $citizenshipId, mainLanguageSpokenId: $mainLanguageSpokenId, raceId: $raceId, residenceStatusId: $residenceStatusId, enrolments: $enrolments, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $StudentApiDtoCopyWith<$Res> {
  factory $StudentApiDtoCopyWith(
          StudentApiDto value, $Res Function(StudentApiDto) _then) =
      _$StudentApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto2Dto? account,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'dateOfBirth') String? dateOfBirth,
      @JsonKey(name: 'age') int? age,
      @JsonKey(name: 'genderId') int? genderId,
      @JsonKey(name: 'citizenshipId') int? citizenshipId,
      @JsonKey(name: 'mainLanguageSpokenId') int? mainLanguageSpokenId,
      @JsonKey(name: 'raceId') int? raceId,
      @JsonKey(name: 'residenceStatusId') int? residenceStatusId,
      @JsonKey(name: 'enrolments') List<EnrolmentApiDto>? enrolments,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $AccountApiDto2DtoCopyWith<$Res>? get account;
}

/// @nodoc
class _$StudentApiDtoCopyWithImpl<$Res>
    implements $StudentApiDtoCopyWith<$Res> {
  _$StudentApiDtoCopyWithImpl(this._self, this._then);

  final StudentApiDto _self;
  final $Res Function(StudentApiDto) _then;

  /// Create a copy of StudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentId = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
    Object? name = freezed,
    Object? email = freezed,
    Object? phoneNumber = freezed,
    Object? identifier = freezed,
    Object? dateOfBirth = freezed,
    Object? age = freezed,
    Object? genderId = freezed,
    Object? citizenshipId = freezed,
    Object? mainLanguageSpokenId = freezed,
    Object? raceId = freezed,
    Object? residenceStatusId = freezed,
    Object? enrolments = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto2Dto?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      dateOfBirth: freezed == dateOfBirth
          ? _self.dateOfBirth
          : dateOfBirth // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _self.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      genderId: freezed == genderId
          ? _self.genderId
          : genderId // ignore: cast_nullable_to_non_nullable
              as int?,
      citizenshipId: freezed == citizenshipId
          ? _self.citizenshipId
          : citizenshipId // ignore: cast_nullable_to_non_nullable
              as int?,
      mainLanguageSpokenId: freezed == mainLanguageSpokenId
          ? _self.mainLanguageSpokenId
          : mainLanguageSpokenId // ignore: cast_nullable_to_non_nullable
              as int?,
      raceId: freezed == raceId
          ? _self.raceId
          : raceId // ignore: cast_nullable_to_non_nullable
              as int?,
      residenceStatusId: freezed == residenceStatusId
          ? _self.residenceStatusId
          : residenceStatusId // ignore: cast_nullable_to_non_nullable
              as int?,
      enrolments: freezed == enrolments
          ? _self.enrolments
          : enrolments // ignore: cast_nullable_to_non_nullable
              as List<EnrolmentApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of StudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDto2DtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDto2DtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StudentApiDto].
extension StudentApiDtoPatterns on StudentApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'dateOfBirth') String? dateOfBirth,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'genderId') int? genderId,
            @JsonKey(name: 'citizenshipId') int? citizenshipId,
            @JsonKey(name: 'mainLanguageSpokenId') int? mainLanguageSpokenId,
            @JsonKey(name: 'raceId') int? raceId,
            @JsonKey(name: 'residenceStatusId') int? residenceStatusId,
            @JsonKey(name: 'enrolments') List<EnrolmentApiDto>? enrolments,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentApiDto() when $default != null:
        return $default(
            _that.studentId,
            _that.accountId,
            _that.account,
            _that.name,
            _that.email,
            _that.phoneNumber,
            _that.identifier,
            _that.dateOfBirth,
            _that.age,
            _that.genderId,
            _that.citizenshipId,
            _that.mainLanguageSpokenId,
            _that.raceId,
            _that.residenceStatusId,
            _that.enrolments,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'dateOfBirth') String? dateOfBirth,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'genderId') int? genderId,
            @JsonKey(name: 'citizenshipId') int? citizenshipId,
            @JsonKey(name: 'mainLanguageSpokenId') int? mainLanguageSpokenId,
            @JsonKey(name: 'raceId') int? raceId,
            @JsonKey(name: 'residenceStatusId') int? residenceStatusId,
            @JsonKey(name: 'enrolments') List<EnrolmentApiDto>? enrolments,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentApiDto():
        return $default(
            _that.studentId,
            _that.accountId,
            _that.account,
            _that.name,
            _that.email,
            _that.phoneNumber,
            _that.identifier,
            _that.dateOfBirth,
            _that.age,
            _that.genderId,
            _that.citizenshipId,
            _that.mainLanguageSpokenId,
            _that.raceId,
            _that.residenceStatusId,
            _that.enrolments,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'account') AccountApiDto2Dto? account,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'email') String? email,
            @JsonKey(name: 'phoneNumber') String? phoneNumber,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'dateOfBirth') String? dateOfBirth,
            @JsonKey(name: 'age') int? age,
            @JsonKey(name: 'genderId') int? genderId,
            @JsonKey(name: 'citizenshipId') int? citizenshipId,
            @JsonKey(name: 'mainLanguageSpokenId') int? mainLanguageSpokenId,
            @JsonKey(name: 'raceId') int? raceId,
            @JsonKey(name: 'residenceStatusId') int? residenceStatusId,
            @JsonKey(name: 'enrolments') List<EnrolmentApiDto>? enrolments,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentApiDto() when $default != null:
        return $default(
            _that.studentId,
            _that.accountId,
            _that.account,
            _that.name,
            _that.email,
            _that.phoneNumber,
            _that.identifier,
            _that.dateOfBirth,
            _that.age,
            _that.genderId,
            _that.citizenshipId,
            _that.mainLanguageSpokenId,
            _that.raceId,
            _that.residenceStatusId,
            _that.enrolments,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentApiDto implements StudentApiDto {
  _StudentApiDto(
      {@JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'account') this.account,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'email') this.email,
      @JsonKey(name: 'phoneNumber') this.phoneNumber,
      @JsonKey(name: 'identifier') this.identifier,
      @JsonKey(name: 'dateOfBirth') this.dateOfBirth,
      @JsonKey(name: 'age') this.age,
      @JsonKey(name: 'genderId') this.genderId,
      @JsonKey(name: 'citizenshipId') this.citizenshipId,
      @JsonKey(name: 'mainLanguageSpokenId') this.mainLanguageSpokenId,
      @JsonKey(name: 'raceId') this.raceId,
      @JsonKey(name: 'residenceStatusId') this.residenceStatusId,
      @JsonKey(name: 'enrolments') final List<EnrolmentApiDto>? enrolments,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _enrolments = enrolments;
  factory _StudentApiDto.fromJson(Map<String, dynamic> json) =>
      _$StudentApiDtoFromJson(json);

  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'account')
  final AccountApiDto2Dto? account;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'email')
  final String? email;
  @override
  @JsonKey(name: 'phoneNumber')
  final String? phoneNumber;
  @override
  @JsonKey(name: 'identifier')
  final String? identifier;
  @override
  @JsonKey(name: 'dateOfBirth')
  final String? dateOfBirth;
  @override
  @JsonKey(name: 'age')
  final int? age;
  @override
  @JsonKey(name: 'genderId')
  final int? genderId;
  @override
  @JsonKey(name: 'citizenshipId')
  final int? citizenshipId;
  @override
  @JsonKey(name: 'mainLanguageSpokenId')
  final int? mainLanguageSpokenId;
  @override
  @JsonKey(name: 'raceId')
  final int? raceId;
  @override
  @JsonKey(name: 'residenceStatusId')
  final int? residenceStatusId;
  final List<EnrolmentApiDto>? _enrolments;
  @override
  @JsonKey(name: 'enrolments')
  List<EnrolmentApiDto>? get enrolments {
    final value = _enrolments;
    if (value == null) return null;
    if (_enrolments is EqualUnmodifiableListView) return _enrolments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of StudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentApiDtoCopyWith<_StudentApiDto> get copyWith =>
      __$StudentApiDtoCopyWithImpl<_StudentApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentApiDto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                other.dateOfBirth == dateOfBirth) &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.genderId, genderId) ||
                other.genderId == genderId) &&
            (identical(other.citizenshipId, citizenshipId) ||
                other.citizenshipId == citizenshipId) &&
            (identical(other.mainLanguageSpokenId, mainLanguageSpokenId) ||
                other.mainLanguageSpokenId == mainLanguageSpokenId) &&
            (identical(other.raceId, raceId) || other.raceId == raceId) &&
            (identical(other.residenceStatusId, residenceStatusId) ||
                other.residenceStatusId == residenceStatusId) &&
            const DeepCollectionEquality()
                .equals(other._enrolments, _enrolments) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        studentId,
        accountId,
        account,
        name,
        email,
        phoneNumber,
        identifier,
        dateOfBirth,
        age,
        genderId,
        citizenshipId,
        mainLanguageSpokenId,
        raceId,
        residenceStatusId,
        const DeepCollectionEquality().hash(_enrolments),
        isDeleted,
        createdByUserId,
        createdDate,
        lastUpdatedByUserId,
        updatedDate
      ]);

  @override
  String toString() {
    return 'StudentApiDto(studentId: $studentId, accountId: $accountId, account: $account, name: $name, email: $email, phoneNumber: $phoneNumber, identifier: $identifier, dateOfBirth: $dateOfBirth, age: $age, genderId: $genderId, citizenshipId: $citizenshipId, mainLanguageSpokenId: $mainLanguageSpokenId, raceId: $raceId, residenceStatusId: $residenceStatusId, enrolments: $enrolments, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$StudentApiDtoCopyWith<$Res>
    implements $StudentApiDtoCopyWith<$Res> {
  factory _$StudentApiDtoCopyWith(
          _StudentApiDto value, $Res Function(_StudentApiDto) _then) =
      __$StudentApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'account') AccountApiDto2Dto? account,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'email') String? email,
      @JsonKey(name: 'phoneNumber') String? phoneNumber,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'dateOfBirth') String? dateOfBirth,
      @JsonKey(name: 'age') int? age,
      @JsonKey(name: 'genderId') int? genderId,
      @JsonKey(name: 'citizenshipId') int? citizenshipId,
      @JsonKey(name: 'mainLanguageSpokenId') int? mainLanguageSpokenId,
      @JsonKey(name: 'raceId') int? raceId,
      @JsonKey(name: 'residenceStatusId') int? residenceStatusId,
      @JsonKey(name: 'enrolments') List<EnrolmentApiDto>? enrolments,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $AccountApiDto2DtoCopyWith<$Res>? get account;
}

/// @nodoc
class __$StudentApiDtoCopyWithImpl<$Res>
    implements _$StudentApiDtoCopyWith<$Res> {
  __$StudentApiDtoCopyWithImpl(this._self, this._then);

  final _StudentApiDto _self;
  final $Res Function(_StudentApiDto) _then;

  /// Create a copy of StudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentId = freezed,
    Object? accountId = freezed,
    Object? account = freezed,
    Object? name = freezed,
    Object? email = freezed,
    Object? phoneNumber = freezed,
    Object? identifier = freezed,
    Object? dateOfBirth = freezed,
    Object? age = freezed,
    Object? genderId = freezed,
    Object? citizenshipId = freezed,
    Object? mainLanguageSpokenId = freezed,
    Object? raceId = freezed,
    Object? residenceStatusId = freezed,
    Object? enrolments = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_StudentApiDto(
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      account: freezed == account
          ? _self.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountApiDto2Dto?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _self.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      dateOfBirth: freezed == dateOfBirth
          ? _self.dateOfBirth
          : dateOfBirth // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _self.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      genderId: freezed == genderId
          ? _self.genderId
          : genderId // ignore: cast_nullable_to_non_nullable
              as int?,
      citizenshipId: freezed == citizenshipId
          ? _self.citizenshipId
          : citizenshipId // ignore: cast_nullable_to_non_nullable
              as int?,
      mainLanguageSpokenId: freezed == mainLanguageSpokenId
          ? _self.mainLanguageSpokenId
          : mainLanguageSpokenId // ignore: cast_nullable_to_non_nullable
              as int?,
      raceId: freezed == raceId
          ? _self.raceId
          : raceId // ignore: cast_nullable_to_non_nullable
              as int?,
      residenceStatusId: freezed == residenceStatusId
          ? _self.residenceStatusId
          : residenceStatusId // ignore: cast_nullable_to_non_nullable
              as int?,
      enrolments: freezed == enrolments
          ? _self._enrolments
          : enrolments // ignore: cast_nullable_to_non_nullable
              as List<EnrolmentApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of StudentApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccountApiDto2DtoCopyWith<$Res>? get account {
    if (_self.account == null) {
      return null;
    }

    return $AccountApiDto2DtoCopyWith<$Res>(_self.account!, (value) {
      return _then(_self.copyWith(account: value));
    });
  }
}

/// @nodoc
mixin _$StudentAttendanceApiDto {
  @JsonKey(name: 'studentAttendanceId')
  int? get studentAttendanceId;
  @JsonKey(name: 'date')
  String? get date;
  @JsonKey(name: 'isPresent')
  bool? get isPresent;
  @JsonKey(name: 'remarks')
  String? get remarks;
  @JsonKey(name: 'classId')
  int? get classId;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of StudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentAttendanceApiDtoCopyWith<StudentAttendanceApiDto> get copyWith =>
      _$StudentAttendanceApiDtoCopyWithImpl<StudentAttendanceApiDto>(
          this as StudentAttendanceApiDto, _$identity);

  /// Serializes this StudentAttendanceApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentAttendanceApiDto &&
            (identical(other.studentAttendanceId, studentAttendanceId) ||
                other.studentAttendanceId == studentAttendanceId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.isPresent, isPresent) ||
                other.isPresent == isPresent) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentAttendanceId,
      date,
      isPresent,
      remarks,
      classId,
      studentId,
      accountId,
      branchId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentAttendanceApiDto(studentAttendanceId: $studentAttendanceId, date: $date, isPresent: $isPresent, remarks: $remarks, classId: $classId, studentId: $studentId, accountId: $accountId, branchId: $branchId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $StudentAttendanceApiDtoCopyWith<$Res> {
  factory $StudentAttendanceApiDtoCopyWith(StudentAttendanceApiDto value,
          $Res Function(StudentAttendanceApiDto) _then) =
      _$StudentAttendanceApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentAttendanceId') int? studentAttendanceId,
      @JsonKey(name: 'date') String? date,
      @JsonKey(name: 'isPresent') bool? isPresent,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$StudentAttendanceApiDtoCopyWithImpl<$Res>
    implements $StudentAttendanceApiDtoCopyWith<$Res> {
  _$StudentAttendanceApiDtoCopyWithImpl(this._self, this._then);

  final StudentAttendanceApiDto _self;
  final $Res Function(StudentAttendanceApiDto) _then;

  /// Create a copy of StudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentAttendanceId = freezed,
    Object? date = freezed,
    Object? isPresent = freezed,
    Object? remarks = freezed,
    Object? classId = freezed,
    Object? studentId = freezed,
    Object? accountId = freezed,
    Object? branchId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      studentAttendanceId: freezed == studentAttendanceId
          ? _self.studentAttendanceId
          : studentAttendanceId // ignore: cast_nullable_to_non_nullable
              as int?,
      date: freezed == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
      isPresent: freezed == isPresent
          ? _self.isPresent
          : isPresent // ignore: cast_nullable_to_non_nullable
              as bool?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StudentAttendanceApiDto].
extension StudentAttendanceApiDtoPatterns on StudentAttendanceApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentAttendanceApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentAttendanceApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentAttendanceApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentAttendanceId') int? studentAttendanceId,
            @JsonKey(name: 'date') String? date,
            @JsonKey(name: 'isPresent') bool? isPresent,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceApiDto() when $default != null:
        return $default(
            _that.studentAttendanceId,
            _that.date,
            _that.isPresent,
            _that.remarks,
            _that.classId,
            _that.studentId,
            _that.accountId,
            _that.branchId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentAttendanceId') int? studentAttendanceId,
            @JsonKey(name: 'date') String? date,
            @JsonKey(name: 'isPresent') bool? isPresent,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceApiDto():
        return $default(
            _that.studentAttendanceId,
            _that.date,
            _that.isPresent,
            _that.remarks,
            _that.classId,
            _that.studentId,
            _that.accountId,
            _that.branchId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentAttendanceId') int? studentAttendanceId,
            @JsonKey(name: 'date') String? date,
            @JsonKey(name: 'isPresent') bool? isPresent,
            @JsonKey(name: 'remarks') String? remarks,
            @JsonKey(name: 'classId') int? classId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceApiDto() when $default != null:
        return $default(
            _that.studentAttendanceId,
            _that.date,
            _that.isPresent,
            _that.remarks,
            _that.classId,
            _that.studentId,
            _that.accountId,
            _that.branchId,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentAttendanceApiDto implements StudentAttendanceApiDto {
  _StudentAttendanceApiDto(
      {@JsonKey(name: 'studentAttendanceId') this.studentAttendanceId,
      @JsonKey(name: 'date') this.date,
      @JsonKey(name: 'isPresent') this.isPresent,
      @JsonKey(name: 'remarks') this.remarks,
      @JsonKey(name: 'classId') this.classId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _StudentAttendanceApiDto.fromJson(Map<String, dynamic> json) =>
      _$StudentAttendanceApiDtoFromJson(json);

  @override
  @JsonKey(name: 'studentAttendanceId')
  final int? studentAttendanceId;
  @override
  @JsonKey(name: 'date')
  final String? date;
  @override
  @JsonKey(name: 'isPresent')
  final bool? isPresent;
  @override
  @JsonKey(name: 'remarks')
  final String? remarks;
  @override
  @JsonKey(name: 'classId')
  final int? classId;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of StudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentAttendanceApiDtoCopyWith<_StudentAttendanceApiDto> get copyWith =>
      __$StudentAttendanceApiDtoCopyWithImpl<_StudentAttendanceApiDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentAttendanceApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentAttendanceApiDto &&
            (identical(other.studentAttendanceId, studentAttendanceId) ||
                other.studentAttendanceId == studentAttendanceId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.isPresent, isPresent) ||
                other.isPresent == isPresent) &&
            (identical(other.remarks, remarks) || other.remarks == remarks) &&
            (identical(other.classId, classId) || other.classId == classId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentAttendanceId,
      date,
      isPresent,
      remarks,
      classId,
      studentId,
      accountId,
      branchId,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentAttendanceApiDto(studentAttendanceId: $studentAttendanceId, date: $date, isPresent: $isPresent, remarks: $remarks, classId: $classId, studentId: $studentId, accountId: $accountId, branchId: $branchId, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$StudentAttendanceApiDtoCopyWith<$Res>
    implements $StudentAttendanceApiDtoCopyWith<$Res> {
  factory _$StudentAttendanceApiDtoCopyWith(_StudentAttendanceApiDto value,
          $Res Function(_StudentAttendanceApiDto) _then) =
      __$StudentAttendanceApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentAttendanceId') int? studentAttendanceId,
      @JsonKey(name: 'date') String? date,
      @JsonKey(name: 'isPresent') bool? isPresent,
      @JsonKey(name: 'remarks') String? remarks,
      @JsonKey(name: 'classId') int? classId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$StudentAttendanceApiDtoCopyWithImpl<$Res>
    implements _$StudentAttendanceApiDtoCopyWith<$Res> {
  __$StudentAttendanceApiDtoCopyWithImpl(this._self, this._then);

  final _StudentAttendanceApiDto _self;
  final $Res Function(_StudentAttendanceApiDto) _then;

  /// Create a copy of StudentAttendanceApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentAttendanceId = freezed,
    Object? date = freezed,
    Object? isPresent = freezed,
    Object? remarks = freezed,
    Object? classId = freezed,
    Object? studentId = freezed,
    Object? accountId = freezed,
    Object? branchId = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_StudentAttendanceApiDto(
      studentAttendanceId: freezed == studentAttendanceId
          ? _self.studentAttendanceId
          : studentAttendanceId // ignore: cast_nullable_to_non_nullable
              as int?,
      date: freezed == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
      isPresent: freezed == isPresent
          ? _self.isPresent
          : isPresent // ignore: cast_nullable_to_non_nullable
              as bool?,
      remarks: freezed == remarks
          ? _self.remarks
          : remarks // ignore: cast_nullable_to_non_nullable
              as String?,
      classId: freezed == classId
          ? _self.classId
          : classId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$StudentAttendanceDTODto {
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'identifier')
  String? get identifier;
  @JsonKey(name: 'studentName')
  String? get studentName;
  @JsonKey(name: 'enrolmentDate')
  String? get enrolmentDate;
  @JsonKey(name: 'dob')
  String? get dob;
  @JsonKey(name: 'gender')
  String? get gender;
  @JsonKey(name: 'countSchoolDays')
  int? get countSchoolDays;
  @JsonKey(name: 'countPresent')
  int? get countPresent;
  @JsonKey(name: 'countAbsent')
  int? get countAbsent;
  @JsonKey(name: 'rate')
  int? get rate;
  @JsonKey(name: 'attendanceRecords')
  List<AttendanceRecordDTODto>? get attendanceRecords;

  /// Create a copy of StudentAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentAttendanceDTODtoCopyWith<StudentAttendanceDTODto> get copyWith =>
      _$StudentAttendanceDTODtoCopyWithImpl<StudentAttendanceDTODto>(
          this as StudentAttendanceDTODto, _$identity);

  /// Serializes this StudentAttendanceDTODto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentAttendanceDTODto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName) &&
            (identical(other.enrolmentDate, enrolmentDate) ||
                other.enrolmentDate == enrolmentDate) &&
            (identical(other.dob, dob) || other.dob == dob) &&
            (identical(other.gender, gender) || other.gender == gender) &&
            (identical(other.countSchoolDays, countSchoolDays) ||
                other.countSchoolDays == countSchoolDays) &&
            (identical(other.countPresent, countPresent) ||
                other.countPresent == countPresent) &&
            (identical(other.countAbsent, countAbsent) ||
                other.countAbsent == countAbsent) &&
            (identical(other.rate, rate) || other.rate == rate) &&
            const DeepCollectionEquality()
                .equals(other.attendanceRecords, attendanceRecords));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentId,
      identifier,
      studentName,
      enrolmentDate,
      dob,
      gender,
      countSchoolDays,
      countPresent,
      countAbsent,
      rate,
      const DeepCollectionEquality().hash(attendanceRecords));

  @override
  String toString() {
    return 'StudentAttendanceDTODto(studentId: $studentId, identifier: $identifier, studentName: $studentName, enrolmentDate: $enrolmentDate, dob: $dob, gender: $gender, countSchoolDays: $countSchoolDays, countPresent: $countPresent, countAbsent: $countAbsent, rate: $rate, attendanceRecords: $attendanceRecords)';
  }
}

/// @nodoc
abstract mixin class $StudentAttendanceDTODtoCopyWith<$Res> {
  factory $StudentAttendanceDTODtoCopyWith(StudentAttendanceDTODto value,
          $Res Function(StudentAttendanceDTODto) _then) =
      _$StudentAttendanceDTODtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'studentName') String? studentName,
      @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
      @JsonKey(name: 'dob') String? dob,
      @JsonKey(name: 'gender') String? gender,
      @JsonKey(name: 'countSchoolDays') int? countSchoolDays,
      @JsonKey(name: 'countPresent') int? countPresent,
      @JsonKey(name: 'countAbsent') int? countAbsent,
      @JsonKey(name: 'rate') int? rate,
      @JsonKey(name: 'attendanceRecords')
      List<AttendanceRecordDTODto>? attendanceRecords});
}

/// @nodoc
class _$StudentAttendanceDTODtoCopyWithImpl<$Res>
    implements $StudentAttendanceDTODtoCopyWith<$Res> {
  _$StudentAttendanceDTODtoCopyWithImpl(this._self, this._then);

  final StudentAttendanceDTODto _self;
  final $Res Function(StudentAttendanceDTODto) _then;

  /// Create a copy of StudentAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentId = freezed,
    Object? identifier = freezed,
    Object? studentName = freezed,
    Object? enrolmentDate = freezed,
    Object? dob = freezed,
    Object? gender = freezed,
    Object? countSchoolDays = freezed,
    Object? countPresent = freezed,
    Object? countAbsent = freezed,
    Object? rate = freezed,
    Object? attendanceRecords = freezed,
  }) {
    return _then(_self.copyWith(
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
      enrolmentDate: freezed == enrolmentDate
          ? _self.enrolmentDate
          : enrolmentDate // ignore: cast_nullable_to_non_nullable
              as String?,
      dob: freezed == dob
          ? _self.dob
          : dob // ignore: cast_nullable_to_non_nullable
              as String?,
      gender: freezed == gender
          ? _self.gender
          : gender // ignore: cast_nullable_to_non_nullable
              as String?,
      countSchoolDays: freezed == countSchoolDays
          ? _self.countSchoolDays
          : countSchoolDays // ignore: cast_nullable_to_non_nullable
              as int?,
      countPresent: freezed == countPresent
          ? _self.countPresent
          : countPresent // ignore: cast_nullable_to_non_nullable
              as int?,
      countAbsent: freezed == countAbsent
          ? _self.countAbsent
          : countAbsent // ignore: cast_nullable_to_non_nullable
              as int?,
      rate: freezed == rate
          ? _self.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int?,
      attendanceRecords: freezed == attendanceRecords
          ? _self.attendanceRecords
          : attendanceRecords // ignore: cast_nullable_to_non_nullable
              as List<AttendanceRecordDTODto>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StudentAttendanceDTODto].
extension StudentAttendanceDTODtoPatterns on StudentAttendanceDTODto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentAttendanceDTODto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceDTODto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentAttendanceDTODto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceDTODto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentAttendanceDTODto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceDTODto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'studentName') String? studentName,
            @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
            @JsonKey(name: 'dob') String? dob,
            @JsonKey(name: 'gender') String? gender,
            @JsonKey(name: 'countSchoolDays') int? countSchoolDays,
            @JsonKey(name: 'countPresent') int? countPresent,
            @JsonKey(name: 'countAbsent') int? countAbsent,
            @JsonKey(name: 'rate') int? rate,
            @JsonKey(name: 'attendanceRecords')
            List<AttendanceRecordDTODto>? attendanceRecords)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceDTODto() when $default != null:
        return $default(
            _that.studentId,
            _that.identifier,
            _that.studentName,
            _that.enrolmentDate,
            _that.dob,
            _that.gender,
            _that.countSchoolDays,
            _that.countPresent,
            _that.countAbsent,
            _that.rate,
            _that.attendanceRecords);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'studentName') String? studentName,
            @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
            @JsonKey(name: 'dob') String? dob,
            @JsonKey(name: 'gender') String? gender,
            @JsonKey(name: 'countSchoolDays') int? countSchoolDays,
            @JsonKey(name: 'countPresent') int? countPresent,
            @JsonKey(name: 'countAbsent') int? countAbsent,
            @JsonKey(name: 'rate') int? rate,
            @JsonKey(name: 'attendanceRecords')
            List<AttendanceRecordDTODto>? attendanceRecords)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceDTODto():
        return $default(
            _that.studentId,
            _that.identifier,
            _that.studentName,
            _that.enrolmentDate,
            _that.dob,
            _that.gender,
            _that.countSchoolDays,
            _that.countPresent,
            _that.countAbsent,
            _that.rate,
            _that.attendanceRecords);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'studentName') String? studentName,
            @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
            @JsonKey(name: 'dob') String? dob,
            @JsonKey(name: 'gender') String? gender,
            @JsonKey(name: 'countSchoolDays') int? countSchoolDays,
            @JsonKey(name: 'countPresent') int? countPresent,
            @JsonKey(name: 'countAbsent') int? countAbsent,
            @JsonKey(name: 'rate') int? rate,
            @JsonKey(name: 'attendanceRecords')
            List<AttendanceRecordDTODto>? attendanceRecords)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAttendanceDTODto() when $default != null:
        return $default(
            _that.studentId,
            _that.identifier,
            _that.studentName,
            _that.enrolmentDate,
            _that.dob,
            _that.gender,
            _that.countSchoolDays,
            _that.countPresent,
            _that.countAbsent,
            _that.rate,
            _that.attendanceRecords);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentAttendanceDTODto implements StudentAttendanceDTODto {
  _StudentAttendanceDTODto(
      {@JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'identifier') this.identifier,
      @JsonKey(name: 'studentName') this.studentName,
      @JsonKey(name: 'enrolmentDate') this.enrolmentDate,
      @JsonKey(name: 'dob') this.dob,
      @JsonKey(name: 'gender') this.gender,
      @JsonKey(name: 'countSchoolDays') this.countSchoolDays,
      @JsonKey(name: 'countPresent') this.countPresent,
      @JsonKey(name: 'countAbsent') this.countAbsent,
      @JsonKey(name: 'rate') this.rate,
      @JsonKey(name: 'attendanceRecords')
      final List<AttendanceRecordDTODto>? attendanceRecords})
      : _attendanceRecords = attendanceRecords;
  factory _StudentAttendanceDTODto.fromJson(Map<String, dynamic> json) =>
      _$StudentAttendanceDTODtoFromJson(json);

  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'identifier')
  final String? identifier;
  @override
  @JsonKey(name: 'studentName')
  final String? studentName;
  @override
  @JsonKey(name: 'enrolmentDate')
  final String? enrolmentDate;
  @override
  @JsonKey(name: 'dob')
  final String? dob;
  @override
  @JsonKey(name: 'gender')
  final String? gender;
  @override
  @JsonKey(name: 'countSchoolDays')
  final int? countSchoolDays;
  @override
  @JsonKey(name: 'countPresent')
  final int? countPresent;
  @override
  @JsonKey(name: 'countAbsent')
  final int? countAbsent;
  @override
  @JsonKey(name: 'rate')
  final int? rate;
  final List<AttendanceRecordDTODto>? _attendanceRecords;
  @override
  @JsonKey(name: 'attendanceRecords')
  List<AttendanceRecordDTODto>? get attendanceRecords {
    final value = _attendanceRecords;
    if (value == null) return null;
    if (_attendanceRecords is EqualUnmodifiableListView)
      return _attendanceRecords;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of StudentAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentAttendanceDTODtoCopyWith<_StudentAttendanceDTODto> get copyWith =>
      __$StudentAttendanceDTODtoCopyWithImpl<_StudentAttendanceDTODto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentAttendanceDTODtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentAttendanceDTODto &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.studentName, studentName) ||
                other.studentName == studentName) &&
            (identical(other.enrolmentDate, enrolmentDate) ||
                other.enrolmentDate == enrolmentDate) &&
            (identical(other.dob, dob) || other.dob == dob) &&
            (identical(other.gender, gender) || other.gender == gender) &&
            (identical(other.countSchoolDays, countSchoolDays) ||
                other.countSchoolDays == countSchoolDays) &&
            (identical(other.countPresent, countPresent) ||
                other.countPresent == countPresent) &&
            (identical(other.countAbsent, countAbsent) ||
                other.countAbsent == countAbsent) &&
            (identical(other.rate, rate) || other.rate == rate) &&
            const DeepCollectionEquality()
                .equals(other._attendanceRecords, _attendanceRecords));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentId,
      identifier,
      studentName,
      enrolmentDate,
      dob,
      gender,
      countSchoolDays,
      countPresent,
      countAbsent,
      rate,
      const DeepCollectionEquality().hash(_attendanceRecords));

  @override
  String toString() {
    return 'StudentAttendanceDTODto(studentId: $studentId, identifier: $identifier, studentName: $studentName, enrolmentDate: $enrolmentDate, dob: $dob, gender: $gender, countSchoolDays: $countSchoolDays, countPresent: $countPresent, countAbsent: $countAbsent, rate: $rate, attendanceRecords: $attendanceRecords)';
  }
}

/// @nodoc
abstract mixin class _$StudentAttendanceDTODtoCopyWith<$Res>
    implements $StudentAttendanceDTODtoCopyWith<$Res> {
  factory _$StudentAttendanceDTODtoCopyWith(_StudentAttendanceDTODto value,
          $Res Function(_StudentAttendanceDTODto) _then) =
      __$StudentAttendanceDTODtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'studentName') String? studentName,
      @JsonKey(name: 'enrolmentDate') String? enrolmentDate,
      @JsonKey(name: 'dob') String? dob,
      @JsonKey(name: 'gender') String? gender,
      @JsonKey(name: 'countSchoolDays') int? countSchoolDays,
      @JsonKey(name: 'countPresent') int? countPresent,
      @JsonKey(name: 'countAbsent') int? countAbsent,
      @JsonKey(name: 'rate') int? rate,
      @JsonKey(name: 'attendanceRecords')
      List<AttendanceRecordDTODto>? attendanceRecords});
}

/// @nodoc
class __$StudentAttendanceDTODtoCopyWithImpl<$Res>
    implements _$StudentAttendanceDTODtoCopyWith<$Res> {
  __$StudentAttendanceDTODtoCopyWithImpl(this._self, this._then);

  final _StudentAttendanceDTODto _self;
  final $Res Function(_StudentAttendanceDTODto) _then;

  /// Create a copy of StudentAttendanceDTODto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentId = freezed,
    Object? identifier = freezed,
    Object? studentName = freezed,
    Object? enrolmentDate = freezed,
    Object? dob = freezed,
    Object? gender = freezed,
    Object? countSchoolDays = freezed,
    Object? countPresent = freezed,
    Object? countAbsent = freezed,
    Object? rate = freezed,
    Object? attendanceRecords = freezed,
  }) {
    return _then(_StudentAttendanceDTODto(
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      studentName: freezed == studentName
          ? _self.studentName
          : studentName // ignore: cast_nullable_to_non_nullable
              as String?,
      enrolmentDate: freezed == enrolmentDate
          ? _self.enrolmentDate
          : enrolmentDate // ignore: cast_nullable_to_non_nullable
              as String?,
      dob: freezed == dob
          ? _self.dob
          : dob // ignore: cast_nullable_to_non_nullable
              as String?,
      gender: freezed == gender
          ? _self.gender
          : gender // ignore: cast_nullable_to_non_nullable
              as String?,
      countSchoolDays: freezed == countSchoolDays
          ? _self.countSchoolDays
          : countSchoolDays // ignore: cast_nullable_to_non_nullable
              as int?,
      countPresent: freezed == countPresent
          ? _self.countPresent
          : countPresent // ignore: cast_nullable_to_non_nullable
              as int?,
      countAbsent: freezed == countAbsent
          ? _self.countAbsent
          : countAbsent // ignore: cast_nullable_to_non_nullable
              as int?,
      rate: freezed == rate
          ? _self.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int?,
      attendanceRecords: freezed == attendanceRecords
          ? _self._attendanceRecords
          : attendanceRecords // ignore: cast_nullable_to_non_nullable
              as List<AttendanceRecordDTODto>?,
    ));
  }
}

/// @nodoc
mixin _$StudentAuthorisedPersonApiDto {
  @JsonKey(name: 'studentAuthorisedPersonId')
  int? get studentAuthorisedPersonId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'identifier')
  String? get identifier;
  @JsonKey(name: 'contactNumber')
  String? get contactNumber;
  @JsonKey(name: 'relationToChild')
  LookUpApiDto? get relationToChild;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'isActive')
  bool? get isActive;
  @JsonKey(name: 'statusReasons')
  List<AuthorisedPersonDeactivationReasonApiDto>? get statusReasons;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of StudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentAuthorisedPersonApiDtoCopyWith<StudentAuthorisedPersonApiDto>
      get copyWith => _$StudentAuthorisedPersonApiDtoCopyWithImpl<
              StudentAuthorisedPersonApiDto>(
          this as StudentAuthorisedPersonApiDto, _$identity);

  /// Serializes this StudentAuthorisedPersonApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentAuthorisedPersonApiDto &&
            (identical(other.studentAuthorisedPersonId,
                    studentAuthorisedPersonId) ||
                other.studentAuthorisedPersonId == studentAuthorisedPersonId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.contactNumber, contactNumber) ||
                other.contactNumber == contactNumber) &&
            (identical(other.relationToChild, relationToChild) ||
                other.relationToChild == relationToChild) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            const DeepCollectionEquality()
                .equals(other.statusReasons, statusReasons) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentAuthorisedPersonId,
      name,
      identifier,
      contactNumber,
      relationToChild,
      studentId,
      branchId,
      isActive,
      const DeepCollectionEquality().hash(statusReasons),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentAuthorisedPersonApiDto(studentAuthorisedPersonId: $studentAuthorisedPersonId, name: $name, identifier: $identifier, contactNumber: $contactNumber, relationToChild: $relationToChild, studentId: $studentId, branchId: $branchId, isActive: $isActive, statusReasons: $statusReasons, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $StudentAuthorisedPersonApiDtoCopyWith<$Res> {
  factory $StudentAuthorisedPersonApiDtoCopyWith(
          StudentAuthorisedPersonApiDto value,
          $Res Function(StudentAuthorisedPersonApiDto) _then) =
      _$StudentAuthorisedPersonApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentAuthorisedPersonId')
      int? studentAuthorisedPersonId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contactNumber') String? contactNumber,
      @JsonKey(name: 'relationToChild') LookUpApiDto? relationToChild,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isActive') bool? isActive,
      @JsonKey(name: 'statusReasons')
      List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $LookUpApiDtoCopyWith<$Res>? get relationToChild;
}

/// @nodoc
class _$StudentAuthorisedPersonApiDtoCopyWithImpl<$Res>
    implements $StudentAuthorisedPersonApiDtoCopyWith<$Res> {
  _$StudentAuthorisedPersonApiDtoCopyWithImpl(this._self, this._then);

  final StudentAuthorisedPersonApiDto _self;
  final $Res Function(StudentAuthorisedPersonApiDto) _then;

  /// Create a copy of StudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentAuthorisedPersonId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contactNumber = freezed,
    Object? relationToChild = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? isActive = freezed,
    Object? statusReasons = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      studentAuthorisedPersonId: freezed == studentAuthorisedPersonId
          ? _self.studentAuthorisedPersonId
          : studentAuthorisedPersonId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contactNumber: freezed == contactNumber
          ? _self.contactNumber
          : contactNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      relationToChild: freezed == relationToChild
          ? _self.relationToChild
          : relationToChild // ignore: cast_nullable_to_non_nullable
              as LookUpApiDto?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      statusReasons: freezed == statusReasons
          ? _self.statusReasons
          : statusReasons // ignore: cast_nullable_to_non_nullable
              as List<AuthorisedPersonDeactivationReasonApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of StudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LookUpApiDtoCopyWith<$Res>? get relationToChild {
    if (_self.relationToChild == null) {
      return null;
    }

    return $LookUpApiDtoCopyWith<$Res>(_self.relationToChild!, (value) {
      return _then(_self.copyWith(relationToChild: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StudentAuthorisedPersonApiDto].
extension StudentAuthorisedPersonApiDtoPatterns
    on StudentAuthorisedPersonApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentAuthorisedPersonApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentAuthorisedPersonApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentAuthorisedPersonApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentAuthorisedPersonId')
            int? studentAuthorisedPersonId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'relationToChild') LookUpApiDto? relationToChild,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'statusReasons')
            List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto() when $default != null:
        return $default(
            _that.studentAuthorisedPersonId,
            _that.name,
            _that.identifier,
            _that.contactNumber,
            _that.relationToChild,
            _that.studentId,
            _that.branchId,
            _that.isActive,
            _that.statusReasons,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentAuthorisedPersonId')
            int? studentAuthorisedPersonId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'relationToChild') LookUpApiDto? relationToChild,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'statusReasons')
            List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto():
        return $default(
            _that.studentAuthorisedPersonId,
            _that.name,
            _that.identifier,
            _that.contactNumber,
            _that.relationToChild,
            _that.studentId,
            _that.branchId,
            _that.isActive,
            _that.statusReasons,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentAuthorisedPersonId')
            int? studentAuthorisedPersonId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'relationToChild') LookUpApiDto? relationToChild,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'statusReasons')
            List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto() when $default != null:
        return $default(
            _that.studentAuthorisedPersonId,
            _that.name,
            _that.identifier,
            _that.contactNumber,
            _that.relationToChild,
            _that.studentId,
            _that.branchId,
            _that.isActive,
            _that.statusReasons,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentAuthorisedPersonApiDto implements StudentAuthorisedPersonApiDto {
  _StudentAuthorisedPersonApiDto(
      {@JsonKey(name: 'studentAuthorisedPersonId')
      this.studentAuthorisedPersonId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'identifier') this.identifier,
      @JsonKey(name: 'contactNumber') this.contactNumber,
      @JsonKey(name: 'relationToChild') this.relationToChild,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'isActive') this.isActive,
      @JsonKey(name: 'statusReasons')
      final List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _statusReasons = statusReasons;
  factory _StudentAuthorisedPersonApiDto.fromJson(Map<String, dynamic> json) =>
      _$StudentAuthorisedPersonApiDtoFromJson(json);

  @override
  @JsonKey(name: 'studentAuthorisedPersonId')
  final int? studentAuthorisedPersonId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'identifier')
  final String? identifier;
  @override
  @JsonKey(name: 'contactNumber')
  final String? contactNumber;
  @override
  @JsonKey(name: 'relationToChild')
  final LookUpApiDto? relationToChild;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'isActive')
  final bool? isActive;
  final List<AuthorisedPersonDeactivationReasonApiDto>? _statusReasons;
  @override
  @JsonKey(name: 'statusReasons')
  List<AuthorisedPersonDeactivationReasonApiDto>? get statusReasons {
    final value = _statusReasons;
    if (value == null) return null;
    if (_statusReasons is EqualUnmodifiableListView) return _statusReasons;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of StudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentAuthorisedPersonApiDtoCopyWith<_StudentAuthorisedPersonApiDto>
      get copyWith => __$StudentAuthorisedPersonApiDtoCopyWithImpl<
          _StudentAuthorisedPersonApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentAuthorisedPersonApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentAuthorisedPersonApiDto &&
            (identical(other.studentAuthorisedPersonId,
                    studentAuthorisedPersonId) ||
                other.studentAuthorisedPersonId == studentAuthorisedPersonId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.contactNumber, contactNumber) ||
                other.contactNumber == contactNumber) &&
            (identical(other.relationToChild, relationToChild) ||
                other.relationToChild == relationToChild) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            const DeepCollectionEquality()
                .equals(other._statusReasons, _statusReasons) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentAuthorisedPersonId,
      name,
      identifier,
      contactNumber,
      relationToChild,
      studentId,
      branchId,
      isActive,
      const DeepCollectionEquality().hash(_statusReasons),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentAuthorisedPersonApiDto(studentAuthorisedPersonId: $studentAuthorisedPersonId, name: $name, identifier: $identifier, contactNumber: $contactNumber, relationToChild: $relationToChild, studentId: $studentId, branchId: $branchId, isActive: $isActive, statusReasons: $statusReasons, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$StudentAuthorisedPersonApiDtoCopyWith<$Res>
    implements $StudentAuthorisedPersonApiDtoCopyWith<$Res> {
  factory _$StudentAuthorisedPersonApiDtoCopyWith(
          _StudentAuthorisedPersonApiDto value,
          $Res Function(_StudentAuthorisedPersonApiDto) _then) =
      __$StudentAuthorisedPersonApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentAuthorisedPersonId')
      int? studentAuthorisedPersonId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contactNumber') String? contactNumber,
      @JsonKey(name: 'relationToChild') LookUpApiDto? relationToChild,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isActive') bool? isActive,
      @JsonKey(name: 'statusReasons')
      List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $LookUpApiDtoCopyWith<$Res>? get relationToChild;
}

/// @nodoc
class __$StudentAuthorisedPersonApiDtoCopyWithImpl<$Res>
    implements _$StudentAuthorisedPersonApiDtoCopyWith<$Res> {
  __$StudentAuthorisedPersonApiDtoCopyWithImpl(this._self, this._then);

  final _StudentAuthorisedPersonApiDto _self;
  final $Res Function(_StudentAuthorisedPersonApiDto) _then;

  /// Create a copy of StudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentAuthorisedPersonId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contactNumber = freezed,
    Object? relationToChild = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? isActive = freezed,
    Object? statusReasons = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_StudentAuthorisedPersonApiDto(
      studentAuthorisedPersonId: freezed == studentAuthorisedPersonId
          ? _self.studentAuthorisedPersonId
          : studentAuthorisedPersonId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contactNumber: freezed == contactNumber
          ? _self.contactNumber
          : contactNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      relationToChild: freezed == relationToChild
          ? _self.relationToChild
          : relationToChild // ignore: cast_nullable_to_non_nullable
              as LookUpApiDto?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      statusReasons: freezed == statusReasons
          ? _self._statusReasons
          : statusReasons // ignore: cast_nullable_to_non_nullable
              as List<AuthorisedPersonDeactivationReasonApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of StudentAuthorisedPersonApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LookUpApiDtoCopyWith<$Res>? get relationToChild {
    if (_self.relationToChild == null) {
      return null;
    }

    return $LookUpApiDtoCopyWith<$Res>(_self.relationToChild!, (value) {
      return _then(_self.copyWith(relationToChild: value));
    });
  }
}

/// @nodoc
mixin _$StudentAuthorisedPersonApiDto2Dto {
  @JsonKey(name: 'studentAuthorisedPersonId')
  int? get studentAuthorisedPersonId;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'identifier')
  String? get identifier;
  @JsonKey(name: 'contactNumber')
  String? get contactNumber;
  @JsonKey(name: 'relationToChild')
  dynamic get relationToChild;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'isActive')
  bool? get isActive;
  @JsonKey(name: 'statusReasons')
  List<AuthorisedPersonDeactivationReasonApiDto>? get statusReasons;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of StudentAuthorisedPersonApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentAuthorisedPersonApiDto2DtoCopyWith<StudentAuthorisedPersonApiDto2Dto>
      get copyWith => _$StudentAuthorisedPersonApiDto2DtoCopyWithImpl<
              StudentAuthorisedPersonApiDto2Dto>(
          this as StudentAuthorisedPersonApiDto2Dto, _$identity);

  /// Serializes this StudentAuthorisedPersonApiDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentAuthorisedPersonApiDto2Dto &&
            (identical(other.studentAuthorisedPersonId,
                    studentAuthorisedPersonId) ||
                other.studentAuthorisedPersonId == studentAuthorisedPersonId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.contactNumber, contactNumber) ||
                other.contactNumber == contactNumber) &&
            const DeepCollectionEquality()
                .equals(other.relationToChild, relationToChild) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            const DeepCollectionEquality()
                .equals(other.statusReasons, statusReasons) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentAuthorisedPersonId,
      name,
      identifier,
      contactNumber,
      const DeepCollectionEquality().hash(relationToChild),
      studentId,
      branchId,
      isActive,
      const DeepCollectionEquality().hash(statusReasons),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentAuthorisedPersonApiDto2Dto(studentAuthorisedPersonId: $studentAuthorisedPersonId, name: $name, identifier: $identifier, contactNumber: $contactNumber, relationToChild: $relationToChild, studentId: $studentId, branchId: $branchId, isActive: $isActive, statusReasons: $statusReasons, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res> {
  factory $StudentAuthorisedPersonApiDto2DtoCopyWith(
          StudentAuthorisedPersonApiDto2Dto value,
          $Res Function(StudentAuthorisedPersonApiDto2Dto) _then) =
      _$StudentAuthorisedPersonApiDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentAuthorisedPersonId')
      int? studentAuthorisedPersonId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contactNumber') String? contactNumber,
      @JsonKey(name: 'relationToChild') dynamic relationToChild,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isActive') bool? isActive,
      @JsonKey(name: 'statusReasons')
      List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$StudentAuthorisedPersonApiDto2DtoCopyWithImpl<$Res>
    implements $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res> {
  _$StudentAuthorisedPersonApiDto2DtoCopyWithImpl(this._self, this._then);

  final StudentAuthorisedPersonApiDto2Dto _self;
  final $Res Function(StudentAuthorisedPersonApiDto2Dto) _then;

  /// Create a copy of StudentAuthorisedPersonApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentAuthorisedPersonId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contactNumber = freezed,
    Object? relationToChild = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? isActive = freezed,
    Object? statusReasons = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      studentAuthorisedPersonId: freezed == studentAuthorisedPersonId
          ? _self.studentAuthorisedPersonId
          : studentAuthorisedPersonId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contactNumber: freezed == contactNumber
          ? _self.contactNumber
          : contactNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      relationToChild: freezed == relationToChild
          ? _self.relationToChild
          : relationToChild // ignore: cast_nullable_to_non_nullable
              as dynamic,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      statusReasons: freezed == statusReasons
          ? _self.statusReasons
          : statusReasons // ignore: cast_nullable_to_non_nullable
              as List<AuthorisedPersonDeactivationReasonApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StudentAuthorisedPersonApiDto2Dto].
extension StudentAuthorisedPersonApiDto2DtoPatterns
    on StudentAuthorisedPersonApiDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentAuthorisedPersonApiDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentAuthorisedPersonApiDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentAuthorisedPersonApiDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentAuthorisedPersonId')
            int? studentAuthorisedPersonId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'relationToChild') dynamic relationToChild,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'statusReasons')
            List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto2Dto() when $default != null:
        return $default(
            _that.studentAuthorisedPersonId,
            _that.name,
            _that.identifier,
            _that.contactNumber,
            _that.relationToChild,
            _that.studentId,
            _that.branchId,
            _that.isActive,
            _that.statusReasons,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentAuthorisedPersonId')
            int? studentAuthorisedPersonId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'relationToChild') dynamic relationToChild,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'statusReasons')
            List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto2Dto():
        return $default(
            _that.studentAuthorisedPersonId,
            _that.name,
            _that.identifier,
            _that.contactNumber,
            _that.relationToChild,
            _that.studentId,
            _that.branchId,
            _that.isActive,
            _that.statusReasons,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentAuthorisedPersonId')
            int? studentAuthorisedPersonId,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'identifier') String? identifier,
            @JsonKey(name: 'contactNumber') String? contactNumber,
            @JsonKey(name: 'relationToChild') dynamic relationToChild,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'isActive') bool? isActive,
            @JsonKey(name: 'statusReasons')
            List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentAuthorisedPersonApiDto2Dto() when $default != null:
        return $default(
            _that.studentAuthorisedPersonId,
            _that.name,
            _that.identifier,
            _that.contactNumber,
            _that.relationToChild,
            _that.studentId,
            _that.branchId,
            _that.isActive,
            _that.statusReasons,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentAuthorisedPersonApiDto2Dto
    implements StudentAuthorisedPersonApiDto2Dto {
  _StudentAuthorisedPersonApiDto2Dto(
      {@JsonKey(name: 'studentAuthorisedPersonId')
      this.studentAuthorisedPersonId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'identifier') this.identifier,
      @JsonKey(name: 'contactNumber') this.contactNumber,
      @JsonKey(name: 'relationToChild') this.relationToChild,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'isActive') this.isActive,
      @JsonKey(name: 'statusReasons')
      final List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _statusReasons = statusReasons;
  factory _StudentAuthorisedPersonApiDto2Dto.fromJson(
          Map<String, dynamic> json) =>
      _$StudentAuthorisedPersonApiDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'studentAuthorisedPersonId')
  final int? studentAuthorisedPersonId;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'identifier')
  final String? identifier;
  @override
  @JsonKey(name: 'contactNumber')
  final String? contactNumber;
  @override
  @JsonKey(name: 'relationToChild')
  final dynamic relationToChild;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'isActive')
  final bool? isActive;
  final List<AuthorisedPersonDeactivationReasonApiDto>? _statusReasons;
  @override
  @JsonKey(name: 'statusReasons')
  List<AuthorisedPersonDeactivationReasonApiDto>? get statusReasons {
    final value = _statusReasons;
    if (value == null) return null;
    if (_statusReasons is EqualUnmodifiableListView) return _statusReasons;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of StudentAuthorisedPersonApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentAuthorisedPersonApiDto2DtoCopyWith<
          _StudentAuthorisedPersonApiDto2Dto>
      get copyWith => __$StudentAuthorisedPersonApiDto2DtoCopyWithImpl<
          _StudentAuthorisedPersonApiDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentAuthorisedPersonApiDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentAuthorisedPersonApiDto2Dto &&
            (identical(other.studentAuthorisedPersonId,
                    studentAuthorisedPersonId) ||
                other.studentAuthorisedPersonId == studentAuthorisedPersonId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.contactNumber, contactNumber) ||
                other.contactNumber == contactNumber) &&
            const DeepCollectionEquality()
                .equals(other.relationToChild, relationToChild) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            const DeepCollectionEquality()
                .equals(other._statusReasons, _statusReasons) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentAuthorisedPersonId,
      name,
      identifier,
      contactNumber,
      const DeepCollectionEquality().hash(relationToChild),
      studentId,
      branchId,
      isActive,
      const DeepCollectionEquality().hash(_statusReasons),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentAuthorisedPersonApiDto2Dto(studentAuthorisedPersonId: $studentAuthorisedPersonId, name: $name, identifier: $identifier, contactNumber: $contactNumber, relationToChild: $relationToChild, studentId: $studentId, branchId: $branchId, isActive: $isActive, statusReasons: $statusReasons, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$StudentAuthorisedPersonApiDto2DtoCopyWith<$Res>
    implements $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res> {
  factory _$StudentAuthorisedPersonApiDto2DtoCopyWith(
          _StudentAuthorisedPersonApiDto2Dto value,
          $Res Function(_StudentAuthorisedPersonApiDto2Dto) _then) =
      __$StudentAuthorisedPersonApiDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentAuthorisedPersonId')
      int? studentAuthorisedPersonId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'identifier') String? identifier,
      @JsonKey(name: 'contactNumber') String? contactNumber,
      @JsonKey(name: 'relationToChild') dynamic relationToChild,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'isActive') bool? isActive,
      @JsonKey(name: 'statusReasons')
      List<AuthorisedPersonDeactivationReasonApiDto>? statusReasons,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$StudentAuthorisedPersonApiDto2DtoCopyWithImpl<$Res>
    implements _$StudentAuthorisedPersonApiDto2DtoCopyWith<$Res> {
  __$StudentAuthorisedPersonApiDto2DtoCopyWithImpl(this._self, this._then);

  final _StudentAuthorisedPersonApiDto2Dto _self;
  final $Res Function(_StudentAuthorisedPersonApiDto2Dto) _then;

  /// Create a copy of StudentAuthorisedPersonApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentAuthorisedPersonId = freezed,
    Object? name = freezed,
    Object? identifier = freezed,
    Object? contactNumber = freezed,
    Object? relationToChild = freezed,
    Object? studentId = freezed,
    Object? branchId = freezed,
    Object? isActive = freezed,
    Object? statusReasons = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_StudentAuthorisedPersonApiDto2Dto(
      studentAuthorisedPersonId: freezed == studentAuthorisedPersonId
          ? _self.studentAuthorisedPersonId
          : studentAuthorisedPersonId // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _self.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      contactNumber: freezed == contactNumber
          ? _self.contactNumber
          : contactNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      relationToChild: freezed == relationToChild
          ? _self.relationToChild
          : relationToChild // ignore: cast_nullable_to_non_nullable
              as dynamic,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: freezed == isActive
          ? _self.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      statusReasons: freezed == statusReasons
          ? _self._statusReasons
          : statusReasons // ignore: cast_nullable_to_non_nullable
              as List<AuthorisedPersonDeactivationReasonApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$StudentCheckInOutApiDto {
  @JsonKey(name: 'studentCheckInOutId')
  int? get studentCheckInOutId;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'checkInTime')
  DateTime? get checkInTime;
  @JsonKey(name: 'checkInRemarks')
  String? get checkInRemarks;
  @JsonKey(name: 'checkOutTime')
  DateTime? get checkOutTime;
  @JsonKey(name: 'checkOutRemarks')
  String? get checkOutRemarks;
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'checkInAuthorisedPerson')
  StudentAuthorisedPersonApiDto? get checkInAuthorisedPerson;
  @JsonKey(name: 'checkOutAuthorisedPerson')
  StudentAuthorisedPersonApiDto2Dto? get checkOutAuthorisedPerson;
  @JsonKey(name: 'temperatures')
  List<StudentTemperatureApiDto>? get temperatures;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentCheckInOutApiDtoCopyWith<StudentCheckInOutApiDto> get copyWith =>
      _$StudentCheckInOutApiDtoCopyWithImpl<StudentCheckInOutApiDto>(
          this as StudentCheckInOutApiDto, _$identity);

  /// Serializes this StudentCheckInOutApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentCheckInOutApiDto &&
            (identical(other.studentCheckInOutId, studentCheckInOutId) ||
                other.studentCheckInOutId == studentCheckInOutId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.checkInTime, checkInTime) ||
                other.checkInTime == checkInTime) &&
            (identical(other.checkInRemarks, checkInRemarks) ||
                other.checkInRemarks == checkInRemarks) &&
            (identical(other.checkOutTime, checkOutTime) ||
                other.checkOutTime == checkOutTime) &&
            (identical(other.checkOutRemarks, checkOutRemarks) ||
                other.checkOutRemarks == checkOutRemarks) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(
                    other.checkInAuthorisedPerson, checkInAuthorisedPerson) ||
                other.checkInAuthorisedPerson == checkInAuthorisedPerson) &&
            (identical(
                    other.checkOutAuthorisedPerson, checkOutAuthorisedPerson) ||
                other.checkOutAuthorisedPerson == checkOutAuthorisedPerson) &&
            const DeepCollectionEquality()
                .equals(other.temperatures, temperatures) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentCheckInOutId,
      studentId,
      accountId,
      checkInTime,
      checkInRemarks,
      checkOutTime,
      checkOutRemarks,
      branchId,
      checkInAuthorisedPerson,
      checkOutAuthorisedPerson,
      const DeepCollectionEquality().hash(temperatures),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentCheckInOutApiDto(studentCheckInOutId: $studentCheckInOutId, studentId: $studentId, accountId: $accountId, checkInTime: $checkInTime, checkInRemarks: $checkInRemarks, checkOutTime: $checkOutTime, checkOutRemarks: $checkOutRemarks, branchId: $branchId, checkInAuthorisedPerson: $checkInAuthorisedPerson, checkOutAuthorisedPerson: $checkOutAuthorisedPerson, temperatures: $temperatures, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $StudentCheckInOutApiDtoCopyWith<$Res> {
  factory $StudentCheckInOutApiDtoCopyWith(StudentCheckInOutApiDto value,
          $Res Function(StudentCheckInOutApiDto) _then) =
      _$StudentCheckInOutApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'studentCheckInOutId') int? studentCheckInOutId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'checkInTime') DateTime? checkInTime,
      @JsonKey(name: 'checkInRemarks') String? checkInRemarks,
      @JsonKey(name: 'checkOutTime') DateTime? checkOutTime,
      @JsonKey(name: 'checkOutRemarks') String? checkOutRemarks,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'checkInAuthorisedPerson')
      StudentAuthorisedPersonApiDto? checkInAuthorisedPerson,
      @JsonKey(name: 'checkOutAuthorisedPerson')
      StudentAuthorisedPersonApiDto2Dto? checkOutAuthorisedPerson,
      @JsonKey(name: 'temperatures')
      List<StudentTemperatureApiDto>? temperatures,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $StudentAuthorisedPersonApiDtoCopyWith<$Res>? get checkInAuthorisedPerson;
  $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res>?
      get checkOutAuthorisedPerson;
}

/// @nodoc
class _$StudentCheckInOutApiDtoCopyWithImpl<$Res>
    implements $StudentCheckInOutApiDtoCopyWith<$Res> {
  _$StudentCheckInOutApiDtoCopyWithImpl(this._self, this._then);

  final StudentCheckInOutApiDto _self;
  final $Res Function(StudentCheckInOutApiDto) _then;

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? studentCheckInOutId = freezed,
    Object? studentId = freezed,
    Object? accountId = freezed,
    Object? checkInTime = freezed,
    Object? checkInRemarks = freezed,
    Object? checkOutTime = freezed,
    Object? checkOutRemarks = freezed,
    Object? branchId = freezed,
    Object? checkInAuthorisedPerson = freezed,
    Object? checkOutAuthorisedPerson = freezed,
    Object? temperatures = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      studentCheckInOutId: freezed == studentCheckInOutId
          ? _self.studentCheckInOutId
          : studentCheckInOutId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      checkInTime: freezed == checkInTime
          ? _self.checkInTime
          : checkInTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      checkInRemarks: freezed == checkInRemarks
          ? _self.checkInRemarks
          : checkInRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      checkOutTime: freezed == checkOutTime
          ? _self.checkOutTime
          : checkOutTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      checkOutRemarks: freezed == checkOutRemarks
          ? _self.checkOutRemarks
          : checkOutRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      checkInAuthorisedPerson: freezed == checkInAuthorisedPerson
          ? _self.checkInAuthorisedPerson
          : checkInAuthorisedPerson // ignore: cast_nullable_to_non_nullable
              as StudentAuthorisedPersonApiDto?,
      checkOutAuthorisedPerson: freezed == checkOutAuthorisedPerson
          ? _self.checkOutAuthorisedPerson
          : checkOutAuthorisedPerson // ignore: cast_nullable_to_non_nullable
              as StudentAuthorisedPersonApiDto2Dto?,
      temperatures: freezed == temperatures
          ? _self.temperatures
          : temperatures // ignore: cast_nullable_to_non_nullable
              as List<StudentTemperatureApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentAuthorisedPersonApiDtoCopyWith<$Res>? get checkInAuthorisedPerson {
    if (_self.checkInAuthorisedPerson == null) {
      return null;
    }

    return $StudentAuthorisedPersonApiDtoCopyWith<$Res>(
        _self.checkInAuthorisedPerson!, (value) {
      return _then(_self.copyWith(checkInAuthorisedPerson: value));
    });
  }

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res>?
      get checkOutAuthorisedPerson {
    if (_self.checkOutAuthorisedPerson == null) {
      return null;
    }

    return $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res>(
        _self.checkOutAuthorisedPerson!, (value) {
      return _then(_self.copyWith(checkOutAuthorisedPerson: value));
    });
  }
}

/// Adds pattern-matching-related methods to [StudentCheckInOutApiDto].
extension StudentCheckInOutApiDtoPatterns on StudentCheckInOutApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentCheckInOutApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentCheckInOutApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentCheckInOutApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentCheckInOutApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentCheckInOutApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentCheckInOutApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentCheckInOutId') int? studentCheckInOutId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'checkInTime') DateTime? checkInTime,
            @JsonKey(name: 'checkInRemarks') String? checkInRemarks,
            @JsonKey(name: 'checkOutTime') DateTime? checkOutTime,
            @JsonKey(name: 'checkOutRemarks') String? checkOutRemarks,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'checkInAuthorisedPerson')
            StudentAuthorisedPersonApiDto? checkInAuthorisedPerson,
            @JsonKey(name: 'checkOutAuthorisedPerson')
            StudentAuthorisedPersonApiDto2Dto? checkOutAuthorisedPerson,
            @JsonKey(name: 'temperatures')
            List<StudentTemperatureApiDto>? temperatures,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentCheckInOutApiDto() when $default != null:
        return $default(
            _that.studentCheckInOutId,
            _that.studentId,
            _that.accountId,
            _that.checkInTime,
            _that.checkInRemarks,
            _that.checkOutTime,
            _that.checkOutRemarks,
            _that.branchId,
            _that.checkInAuthorisedPerson,
            _that.checkOutAuthorisedPerson,
            _that.temperatures,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'studentCheckInOutId') int? studentCheckInOutId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'checkInTime') DateTime? checkInTime,
            @JsonKey(name: 'checkInRemarks') String? checkInRemarks,
            @JsonKey(name: 'checkOutTime') DateTime? checkOutTime,
            @JsonKey(name: 'checkOutRemarks') String? checkOutRemarks,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'checkInAuthorisedPerson')
            StudentAuthorisedPersonApiDto? checkInAuthorisedPerson,
            @JsonKey(name: 'checkOutAuthorisedPerson')
            StudentAuthorisedPersonApiDto2Dto? checkOutAuthorisedPerson,
            @JsonKey(name: 'temperatures')
            List<StudentTemperatureApiDto>? temperatures,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentCheckInOutApiDto():
        return $default(
            _that.studentCheckInOutId,
            _that.studentId,
            _that.accountId,
            _that.checkInTime,
            _that.checkInRemarks,
            _that.checkOutTime,
            _that.checkOutRemarks,
            _that.branchId,
            _that.checkInAuthorisedPerson,
            _that.checkOutAuthorisedPerson,
            _that.temperatures,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'studentCheckInOutId') int? studentCheckInOutId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'checkInTime') DateTime? checkInTime,
            @JsonKey(name: 'checkInRemarks') String? checkInRemarks,
            @JsonKey(name: 'checkOutTime') DateTime? checkOutTime,
            @JsonKey(name: 'checkOutRemarks') String? checkOutRemarks,
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'checkInAuthorisedPerson')
            StudentAuthorisedPersonApiDto? checkInAuthorisedPerson,
            @JsonKey(name: 'checkOutAuthorisedPerson')
            StudentAuthorisedPersonApiDto2Dto? checkOutAuthorisedPerson,
            @JsonKey(name: 'temperatures')
            List<StudentTemperatureApiDto>? temperatures,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentCheckInOutApiDto() when $default != null:
        return $default(
            _that.studentCheckInOutId,
            _that.studentId,
            _that.accountId,
            _that.checkInTime,
            _that.checkInRemarks,
            _that.checkOutTime,
            _that.checkOutRemarks,
            _that.branchId,
            _that.checkInAuthorisedPerson,
            _that.checkOutAuthorisedPerson,
            _that.temperatures,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentCheckInOutApiDto implements StudentCheckInOutApiDto {
  _StudentCheckInOutApiDto(
      {@JsonKey(name: 'studentCheckInOutId') this.studentCheckInOutId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'checkInTime') this.checkInTime,
      @JsonKey(name: 'checkInRemarks') this.checkInRemarks,
      @JsonKey(name: 'checkOutTime') this.checkOutTime,
      @JsonKey(name: 'checkOutRemarks') this.checkOutRemarks,
      @JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'checkInAuthorisedPerson') this.checkInAuthorisedPerson,
      @JsonKey(name: 'checkOutAuthorisedPerson') this.checkOutAuthorisedPerson,
      @JsonKey(name: 'temperatures')
      final List<StudentTemperatureApiDto>? temperatures,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate})
      : _temperatures = temperatures;
  factory _StudentCheckInOutApiDto.fromJson(Map<String, dynamic> json) =>
      _$StudentCheckInOutApiDtoFromJson(json);

  @override
  @JsonKey(name: 'studentCheckInOutId')
  final int? studentCheckInOutId;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'checkInTime')
  final DateTime? checkInTime;
  @override
  @JsonKey(name: 'checkInRemarks')
  final String? checkInRemarks;
  @override
  @JsonKey(name: 'checkOutTime')
  final DateTime? checkOutTime;
  @override
  @JsonKey(name: 'checkOutRemarks')
  final String? checkOutRemarks;
  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'checkInAuthorisedPerson')
  final StudentAuthorisedPersonApiDto? checkInAuthorisedPerson;
  @override
  @JsonKey(name: 'checkOutAuthorisedPerson')
  final StudentAuthorisedPersonApiDto2Dto? checkOutAuthorisedPerson;
  final List<StudentTemperatureApiDto>? _temperatures;
  @override
  @JsonKey(name: 'temperatures')
  List<StudentTemperatureApiDto>? get temperatures {
    final value = _temperatures;
    if (value == null) return null;
    if (_temperatures is EqualUnmodifiableListView) return _temperatures;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentCheckInOutApiDtoCopyWith<_StudentCheckInOutApiDto> get copyWith =>
      __$StudentCheckInOutApiDtoCopyWithImpl<_StudentCheckInOutApiDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentCheckInOutApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentCheckInOutApiDto &&
            (identical(other.studentCheckInOutId, studentCheckInOutId) ||
                other.studentCheckInOutId == studentCheckInOutId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.checkInTime, checkInTime) ||
                other.checkInTime == checkInTime) &&
            (identical(other.checkInRemarks, checkInRemarks) ||
                other.checkInRemarks == checkInRemarks) &&
            (identical(other.checkOutTime, checkOutTime) ||
                other.checkOutTime == checkOutTime) &&
            (identical(other.checkOutRemarks, checkOutRemarks) ||
                other.checkOutRemarks == checkOutRemarks) &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(
                    other.checkInAuthorisedPerson, checkInAuthorisedPerson) ||
                other.checkInAuthorisedPerson == checkInAuthorisedPerson) &&
            (identical(
                    other.checkOutAuthorisedPerson, checkOutAuthorisedPerson) ||
                other.checkOutAuthorisedPerson == checkOutAuthorisedPerson) &&
            const DeepCollectionEquality()
                .equals(other._temperatures, _temperatures) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      studentCheckInOutId,
      studentId,
      accountId,
      checkInTime,
      checkInRemarks,
      checkOutTime,
      checkOutRemarks,
      branchId,
      checkInAuthorisedPerson,
      checkOutAuthorisedPerson,
      const DeepCollectionEquality().hash(_temperatures),
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentCheckInOutApiDto(studentCheckInOutId: $studentCheckInOutId, studentId: $studentId, accountId: $accountId, checkInTime: $checkInTime, checkInRemarks: $checkInRemarks, checkOutTime: $checkOutTime, checkOutRemarks: $checkOutRemarks, branchId: $branchId, checkInAuthorisedPerson: $checkInAuthorisedPerson, checkOutAuthorisedPerson: $checkOutAuthorisedPerson, temperatures: $temperatures, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$StudentCheckInOutApiDtoCopyWith<$Res>
    implements $StudentCheckInOutApiDtoCopyWith<$Res> {
  factory _$StudentCheckInOutApiDtoCopyWith(_StudentCheckInOutApiDto value,
          $Res Function(_StudentCheckInOutApiDto) _then) =
      __$StudentCheckInOutApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'studentCheckInOutId') int? studentCheckInOutId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'checkInTime') DateTime? checkInTime,
      @JsonKey(name: 'checkInRemarks') String? checkInRemarks,
      @JsonKey(name: 'checkOutTime') DateTime? checkOutTime,
      @JsonKey(name: 'checkOutRemarks') String? checkOutRemarks,
      @JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'checkInAuthorisedPerson')
      StudentAuthorisedPersonApiDto? checkInAuthorisedPerson,
      @JsonKey(name: 'checkOutAuthorisedPerson')
      StudentAuthorisedPersonApiDto2Dto? checkOutAuthorisedPerson,
      @JsonKey(name: 'temperatures')
      List<StudentTemperatureApiDto>? temperatures,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $StudentAuthorisedPersonApiDtoCopyWith<$Res>? get checkInAuthorisedPerson;
  @override
  $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res>?
      get checkOutAuthorisedPerson;
}

/// @nodoc
class __$StudentCheckInOutApiDtoCopyWithImpl<$Res>
    implements _$StudentCheckInOutApiDtoCopyWith<$Res> {
  __$StudentCheckInOutApiDtoCopyWithImpl(this._self, this._then);

  final _StudentCheckInOutApiDto _self;
  final $Res Function(_StudentCheckInOutApiDto) _then;

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? studentCheckInOutId = freezed,
    Object? studentId = freezed,
    Object? accountId = freezed,
    Object? checkInTime = freezed,
    Object? checkInRemarks = freezed,
    Object? checkOutTime = freezed,
    Object? checkOutRemarks = freezed,
    Object? branchId = freezed,
    Object? checkInAuthorisedPerson = freezed,
    Object? checkOutAuthorisedPerson = freezed,
    Object? temperatures = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_StudentCheckInOutApiDto(
      studentCheckInOutId: freezed == studentCheckInOutId
          ? _self.studentCheckInOutId
          : studentCheckInOutId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      checkInTime: freezed == checkInTime
          ? _self.checkInTime
          : checkInTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      checkInRemarks: freezed == checkInRemarks
          ? _self.checkInRemarks
          : checkInRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      checkOutTime: freezed == checkOutTime
          ? _self.checkOutTime
          : checkOutTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      checkOutRemarks: freezed == checkOutRemarks
          ? _self.checkOutRemarks
          : checkOutRemarks // ignore: cast_nullable_to_non_nullable
              as String?,
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      checkInAuthorisedPerson: freezed == checkInAuthorisedPerson
          ? _self.checkInAuthorisedPerson
          : checkInAuthorisedPerson // ignore: cast_nullable_to_non_nullable
              as StudentAuthorisedPersonApiDto?,
      checkOutAuthorisedPerson: freezed == checkOutAuthorisedPerson
          ? _self.checkOutAuthorisedPerson
          : checkOutAuthorisedPerson // ignore: cast_nullable_to_non_nullable
              as StudentAuthorisedPersonApiDto2Dto?,
      temperatures: freezed == temperatures
          ? _self._temperatures
          : temperatures // ignore: cast_nullable_to_non_nullable
              as List<StudentTemperatureApiDto>?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentAuthorisedPersonApiDtoCopyWith<$Res>? get checkInAuthorisedPerson {
    if (_self.checkInAuthorisedPerson == null) {
      return null;
    }

    return $StudentAuthorisedPersonApiDtoCopyWith<$Res>(
        _self.checkInAuthorisedPerson!, (value) {
      return _then(_self.copyWith(checkInAuthorisedPerson: value));
    });
  }

  /// Create a copy of StudentCheckInOutApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res>?
      get checkOutAuthorisedPerson {
    if (_self.checkOutAuthorisedPerson == null) {
      return null;
    }

    return $StudentAuthorisedPersonApiDto2DtoCopyWith<$Res>(
        _self.checkOutAuthorisedPerson!, (value) {
      return _then(_self.copyWith(checkOutAuthorisedPerson: value));
    });
  }
}

/// @nodoc
mixin _$StudentTemperatureApiDto {
  @JsonKey(name: 'temperatureId')
  int? get temperatureId;
  @JsonKey(name: 'accountId')
  int? get accountId;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'checkInOutId')
  int? get checkInOutId;
  @JsonKey(name: 'temperatureValue')
  num? get temperatureValue;
  @JsonKey(name: 'date')
  DateTime? get date;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of StudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StudentTemperatureApiDtoCopyWith<StudentTemperatureApiDto> get copyWith =>
      _$StudentTemperatureApiDtoCopyWithImpl<StudentTemperatureApiDto>(
          this as StudentTemperatureApiDto, _$identity);

  /// Serializes this StudentTemperatureApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StudentTemperatureApiDto &&
            (identical(other.temperatureId, temperatureId) ||
                other.temperatureId == temperatureId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.checkInOutId, checkInOutId) ||
                other.checkInOutId == checkInOutId) &&
            (identical(other.temperatureValue, temperatureValue) ||
                other.temperatureValue == temperatureValue) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      temperatureId,
      accountId,
      studentId,
      checkInOutId,
      temperatureValue,
      date,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentTemperatureApiDto(temperatureId: $temperatureId, accountId: $accountId, studentId: $studentId, checkInOutId: $checkInOutId, temperatureValue: $temperatureValue, date: $date, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $StudentTemperatureApiDtoCopyWith<$Res> {
  factory $StudentTemperatureApiDtoCopyWith(StudentTemperatureApiDto value,
          $Res Function(StudentTemperatureApiDto) _then) =
      _$StudentTemperatureApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'temperatureId') int? temperatureId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'checkInOutId') int? checkInOutId,
      @JsonKey(name: 'temperatureValue') num? temperatureValue,
      @JsonKey(name: 'date') DateTime? date,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class _$StudentTemperatureApiDtoCopyWithImpl<$Res>
    implements $StudentTemperatureApiDtoCopyWith<$Res> {
  _$StudentTemperatureApiDtoCopyWithImpl(this._self, this._then);

  final StudentTemperatureApiDto _self;
  final $Res Function(StudentTemperatureApiDto) _then;

  /// Create a copy of StudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? temperatureId = freezed,
    Object? accountId = freezed,
    Object? studentId = freezed,
    Object? checkInOutId = freezed,
    Object? temperatureValue = freezed,
    Object? date = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      temperatureId: freezed == temperatureId
          ? _self.temperatureId
          : temperatureId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      checkInOutId: freezed == checkInOutId
          ? _self.checkInOutId
          : checkInOutId // ignore: cast_nullable_to_non_nullable
              as int?,
      temperatureValue: freezed == temperatureValue
          ? _self.temperatureValue
          : temperatureValue // ignore: cast_nullable_to_non_nullable
              as num?,
      date: freezed == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// Adds pattern-matching-related methods to [StudentTemperatureApiDto].
extension StudentTemperatureApiDtoPatterns on StudentTemperatureApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StudentTemperatureApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentTemperatureApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StudentTemperatureApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentTemperatureApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StudentTemperatureApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentTemperatureApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'temperatureId') int? temperatureId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'checkInOutId') int? checkInOutId,
            @JsonKey(name: 'temperatureValue') num? temperatureValue,
            @JsonKey(name: 'date') DateTime? date,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StudentTemperatureApiDto() when $default != null:
        return $default(
            _that.temperatureId,
            _that.accountId,
            _that.studentId,
            _that.checkInOutId,
            _that.temperatureValue,
            _that.date,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'temperatureId') int? temperatureId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'checkInOutId') int? checkInOutId,
            @JsonKey(name: 'temperatureValue') num? temperatureValue,
            @JsonKey(name: 'date') DateTime? date,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentTemperatureApiDto():
        return $default(
            _that.temperatureId,
            _that.accountId,
            _that.studentId,
            _that.checkInOutId,
            _that.temperatureValue,
            _that.date,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'temperatureId') int? temperatureId,
            @JsonKey(name: 'accountId') int? accountId,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'checkInOutId') int? checkInOutId,
            @JsonKey(name: 'temperatureValue') num? temperatureValue,
            @JsonKey(name: 'date') DateTime? date,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StudentTemperatureApiDto() when $default != null:
        return $default(
            _that.temperatureId,
            _that.accountId,
            _that.studentId,
            _that.checkInOutId,
            _that.temperatureValue,
            _that.date,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StudentTemperatureApiDto implements StudentTemperatureApiDto {
  _StudentTemperatureApiDto(
      {@JsonKey(name: 'temperatureId') this.temperatureId,
      @JsonKey(name: 'accountId') this.accountId,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'checkInOutId') this.checkInOutId,
      @JsonKey(name: 'temperatureValue') this.temperatureValue,
      @JsonKey(name: 'date') this.date,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _StudentTemperatureApiDto.fromJson(Map<String, dynamic> json) =>
      _$StudentTemperatureApiDtoFromJson(json);

  @override
  @JsonKey(name: 'temperatureId')
  final int? temperatureId;
  @override
  @JsonKey(name: 'accountId')
  final int? accountId;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'checkInOutId')
  final int? checkInOutId;
  @override
  @JsonKey(name: 'temperatureValue')
  final num? temperatureValue;
  @override
  @JsonKey(name: 'date')
  final DateTime? date;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of StudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StudentTemperatureApiDtoCopyWith<_StudentTemperatureApiDto> get copyWith =>
      __$StudentTemperatureApiDtoCopyWithImpl<_StudentTemperatureApiDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StudentTemperatureApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StudentTemperatureApiDto &&
            (identical(other.temperatureId, temperatureId) ||
                other.temperatureId == temperatureId) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.checkInOutId, checkInOutId) ||
                other.checkInOutId == checkInOutId) &&
            (identical(other.temperatureValue, temperatureValue) ||
                other.temperatureValue == temperatureValue) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      temperatureId,
      accountId,
      studentId,
      checkInOutId,
      temperatureValue,
      date,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'StudentTemperatureApiDto(temperatureId: $temperatureId, accountId: $accountId, studentId: $studentId, checkInOutId: $checkInOutId, temperatureValue: $temperatureValue, date: $date, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$StudentTemperatureApiDtoCopyWith<$Res>
    implements $StudentTemperatureApiDtoCopyWith<$Res> {
  factory _$StudentTemperatureApiDtoCopyWith(_StudentTemperatureApiDto value,
          $Res Function(_StudentTemperatureApiDto) _then) =
      __$StudentTemperatureApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'temperatureId') int? temperatureId,
      @JsonKey(name: 'accountId') int? accountId,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'checkInOutId') int? checkInOutId,
      @JsonKey(name: 'temperatureValue') num? temperatureValue,
      @JsonKey(name: 'date') DateTime? date,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});
}

/// @nodoc
class __$StudentTemperatureApiDtoCopyWithImpl<$Res>
    implements _$StudentTemperatureApiDtoCopyWith<$Res> {
  __$StudentTemperatureApiDtoCopyWithImpl(this._self, this._then);

  final _StudentTemperatureApiDto _self;
  final $Res Function(_StudentTemperatureApiDto) _then;

  /// Create a copy of StudentTemperatureApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? temperatureId = freezed,
    Object? accountId = freezed,
    Object? studentId = freezed,
    Object? checkInOutId = freezed,
    Object? temperatureValue = freezed,
    Object? date = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_StudentTemperatureApiDto(
      temperatureId: freezed == temperatureId
          ? _self.temperatureId
          : temperatureId // ignore: cast_nullable_to_non_nullable
              as int?,
      accountId: freezed == accountId
          ? _self.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as int?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      checkInOutId: freezed == checkInOutId
          ? _self.checkInOutId
          : checkInOutId // ignore: cast_nullable_to_non_nullable
              as int?,
      temperatureValue: freezed == temperatureValue
          ? _self.temperatureValue
          : temperatureValue // ignore: cast_nullable_to_non_nullable
              as num?,
      date: freezed == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$SubjectApiDto {
  @JsonKey(name: 'subjectId')
  int? get subjectId;
  @JsonKey(name: 'levelId')
  int? get levelId;
  @JsonKey(name: 'level')
  LevelApiDto2Dto? get level;
  @JsonKey(name: 'name')
  String? get name;
  @JsonKey(name: 'startDate')
  String? get startDate;
  @JsonKey(name: 'endDate')
  String? get endDate;
  @JsonKey(name: 'maxCapacity')
  int? get maxCapacity;
  @JsonKey(name: 'isDeleted')
  bool? get isDeleted;
  @JsonKey(name: 'createdByUserId')
  String? get createdByUserId;
  @JsonKey(name: 'createdDate')
  DateTime? get createdDate;
  @JsonKey(name: 'lastUpdatedByUserId')
  String? get lastUpdatedByUserId;
  @JsonKey(name: 'updatedDate')
  DateTime? get updatedDate;

  /// Create a copy of SubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SubjectApiDtoCopyWith<SubjectApiDto> get copyWith =>
      _$SubjectApiDtoCopyWithImpl<SubjectApiDto>(
          this as SubjectApiDto, _$identity);

  /// Serializes this SubjectApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SubjectApiDto &&
            (identical(other.subjectId, subjectId) ||
                other.subjectId == subjectId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.maxCapacity, maxCapacity) ||
                other.maxCapacity == maxCapacity) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      subjectId,
      levelId,
      level,
      name,
      startDate,
      endDate,
      maxCapacity,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'SubjectApiDto(subjectId: $subjectId, levelId: $levelId, level: $level, name: $name, startDate: $startDate, endDate: $endDate, maxCapacity: $maxCapacity, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class $SubjectApiDtoCopyWith<$Res> {
  factory $SubjectApiDtoCopyWith(
          SubjectApiDto value, $Res Function(SubjectApiDto) _then) =
      _$SubjectApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'subjectId') int? subjectId,
      @JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'level') LevelApiDto2Dto? level,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'maxCapacity') int? maxCapacity,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  $LevelApiDto2DtoCopyWith<$Res>? get level;
}

/// @nodoc
class _$SubjectApiDtoCopyWithImpl<$Res>
    implements $SubjectApiDtoCopyWith<$Res> {
  _$SubjectApiDtoCopyWithImpl(this._self, this._then);

  final SubjectApiDto _self;
  final $Res Function(SubjectApiDto) _then;

  /// Create a copy of SubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subjectId = freezed,
    Object? levelId = freezed,
    Object? level = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? maxCapacity = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_self.copyWith(
      subjectId: freezed == subjectId
          ? _self.subjectId
          : subjectId // ignore: cast_nullable_to_non_nullable
              as int?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      level: freezed == level
          ? _self.level
          : level // ignore: cast_nullable_to_non_nullable
              as LevelApiDto2Dto?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      maxCapacity: freezed == maxCapacity
          ? _self.maxCapacity
          : maxCapacity // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of SubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LevelApiDto2DtoCopyWith<$Res>? get level {
    if (_self.level == null) {
      return null;
    }

    return $LevelApiDto2DtoCopyWith<$Res>(_self.level!, (value) {
      return _then(_self.copyWith(level: value));
    });
  }
}

/// Adds pattern-matching-related methods to [SubjectApiDto].
extension SubjectApiDtoPatterns on SubjectApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SubjectApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _SubjectApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SubjectApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubjectApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_SubjectApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubjectApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'subjectId') int? subjectId,
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'level') LevelApiDto2Dto? level,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'maxCapacity') int? maxCapacity,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _SubjectApiDto() when $default != null:
        return $default(
            _that.subjectId,
            _that.levelId,
            _that.level,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.maxCapacity,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'subjectId') int? subjectId,
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'level') LevelApiDto2Dto? level,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'maxCapacity') int? maxCapacity,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubjectApiDto():
        return $default(
            _that.subjectId,
            _that.levelId,
            _that.level,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.maxCapacity,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'subjectId') int? subjectId,
            @JsonKey(name: 'levelId') int? levelId,
            @JsonKey(name: 'level') LevelApiDto2Dto? level,
            @JsonKey(name: 'name') String? name,
            @JsonKey(name: 'startDate') String? startDate,
            @JsonKey(name: 'endDate') String? endDate,
            @JsonKey(name: 'maxCapacity') int? maxCapacity,
            @JsonKey(name: 'isDeleted') bool? isDeleted,
            @JsonKey(name: 'createdByUserId') String? createdByUserId,
            @JsonKey(name: 'createdDate') DateTime? createdDate,
            @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
            @JsonKey(name: 'updatedDate') DateTime? updatedDate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubjectApiDto() when $default != null:
        return $default(
            _that.subjectId,
            _that.levelId,
            _that.level,
            _that.name,
            _that.startDate,
            _that.endDate,
            _that.maxCapacity,
            _that.isDeleted,
            _that.createdByUserId,
            _that.createdDate,
            _that.lastUpdatedByUserId,
            _that.updatedDate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _SubjectApiDto implements SubjectApiDto {
  _SubjectApiDto(
      {@JsonKey(name: 'subjectId') this.subjectId,
      @JsonKey(name: 'levelId') this.levelId,
      @JsonKey(name: 'level') this.level,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'startDate') this.startDate,
      @JsonKey(name: 'endDate') this.endDate,
      @JsonKey(name: 'maxCapacity') this.maxCapacity,
      @JsonKey(name: 'isDeleted') this.isDeleted,
      @JsonKey(name: 'createdByUserId') this.createdByUserId,
      @JsonKey(name: 'createdDate') this.createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') this.lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') this.updatedDate});
  factory _SubjectApiDto.fromJson(Map<String, dynamic> json) =>
      _$SubjectApiDtoFromJson(json);

  @override
  @JsonKey(name: 'subjectId')
  final int? subjectId;
  @override
  @JsonKey(name: 'levelId')
  final int? levelId;
  @override
  @JsonKey(name: 'level')
  final LevelApiDto2Dto? level;
  @override
  @JsonKey(name: 'name')
  final String? name;
  @override
  @JsonKey(name: 'startDate')
  final String? startDate;
  @override
  @JsonKey(name: 'endDate')
  final String? endDate;
  @override
  @JsonKey(name: 'maxCapacity')
  final int? maxCapacity;
  @override
  @JsonKey(name: 'isDeleted')
  final bool? isDeleted;
  @override
  @JsonKey(name: 'createdByUserId')
  final String? createdByUserId;
  @override
  @JsonKey(name: 'createdDate')
  final DateTime? createdDate;
  @override
  @JsonKey(name: 'lastUpdatedByUserId')
  final String? lastUpdatedByUserId;
  @override
  @JsonKey(name: 'updatedDate')
  final DateTime? updatedDate;

  /// Create a copy of SubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SubjectApiDtoCopyWith<_SubjectApiDto> get copyWith =>
      __$SubjectApiDtoCopyWithImpl<_SubjectApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$SubjectApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SubjectApiDto &&
            (identical(other.subjectId, subjectId) ||
                other.subjectId == subjectId) &&
            (identical(other.levelId, levelId) || other.levelId == levelId) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.maxCapacity, maxCapacity) ||
                other.maxCapacity == maxCapacity) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            (identical(other.createdByUserId, createdByUserId) ||
                other.createdByUserId == createdByUserId) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.lastUpdatedByUserId, lastUpdatedByUserId) ||
                other.lastUpdatedByUserId == lastUpdatedByUserId) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      subjectId,
      levelId,
      level,
      name,
      startDate,
      endDate,
      maxCapacity,
      isDeleted,
      createdByUserId,
      createdDate,
      lastUpdatedByUserId,
      updatedDate);

  @override
  String toString() {
    return 'SubjectApiDto(subjectId: $subjectId, levelId: $levelId, level: $level, name: $name, startDate: $startDate, endDate: $endDate, maxCapacity: $maxCapacity, isDeleted: $isDeleted, createdByUserId: $createdByUserId, createdDate: $createdDate, lastUpdatedByUserId: $lastUpdatedByUserId, updatedDate: $updatedDate)';
  }
}

/// @nodoc
abstract mixin class _$SubjectApiDtoCopyWith<$Res>
    implements $SubjectApiDtoCopyWith<$Res> {
  factory _$SubjectApiDtoCopyWith(
          _SubjectApiDto value, $Res Function(_SubjectApiDto) _then) =
      __$SubjectApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'subjectId') int? subjectId,
      @JsonKey(name: 'levelId') int? levelId,
      @JsonKey(name: 'level') LevelApiDto2Dto? level,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'startDate') String? startDate,
      @JsonKey(name: 'endDate') String? endDate,
      @JsonKey(name: 'maxCapacity') int? maxCapacity,
      @JsonKey(name: 'isDeleted') bool? isDeleted,
      @JsonKey(name: 'createdByUserId') String? createdByUserId,
      @JsonKey(name: 'createdDate') DateTime? createdDate,
      @JsonKey(name: 'lastUpdatedByUserId') String? lastUpdatedByUserId,
      @JsonKey(name: 'updatedDate') DateTime? updatedDate});

  @override
  $LevelApiDto2DtoCopyWith<$Res>? get level;
}

/// @nodoc
class __$SubjectApiDtoCopyWithImpl<$Res>
    implements _$SubjectApiDtoCopyWith<$Res> {
  __$SubjectApiDtoCopyWithImpl(this._self, this._then);

  final _SubjectApiDto _self;
  final $Res Function(_SubjectApiDto) _then;

  /// Create a copy of SubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? subjectId = freezed,
    Object? levelId = freezed,
    Object? level = freezed,
    Object? name = freezed,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? maxCapacity = freezed,
    Object? isDeleted = freezed,
    Object? createdByUserId = freezed,
    Object? createdDate = freezed,
    Object? lastUpdatedByUserId = freezed,
    Object? updatedDate = freezed,
  }) {
    return _then(_SubjectApiDto(
      subjectId: freezed == subjectId
          ? _self.subjectId
          : subjectId // ignore: cast_nullable_to_non_nullable
              as int?,
      levelId: freezed == levelId
          ? _self.levelId
          : levelId // ignore: cast_nullable_to_non_nullable
              as int?,
      level: freezed == level
          ? _self.level
          : level // ignore: cast_nullable_to_non_nullable
              as LevelApiDto2Dto?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      startDate: freezed == startDate
          ? _self.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as String?,
      endDate: freezed == endDate
          ? _self.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as String?,
      maxCapacity: freezed == maxCapacity
          ? _self.maxCapacity
          : maxCapacity // ignore: cast_nullable_to_non_nullable
              as int?,
      isDeleted: freezed == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      createdByUserId: freezed == createdByUserId
          ? _self.createdByUserId
          : createdByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdDate: freezed == createdDate
          ? _self.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastUpdatedByUserId: freezed == lastUpdatedByUserId
          ? _self.lastUpdatedByUserId
          : lastUpdatedByUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedDate: freezed == updatedDate
          ? _self.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }

  /// Create a copy of SubjectApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LevelApiDto2DtoCopyWith<$Res>? get level {
    if (_self.level == null) {
      return null;
    }

    return $LevelApiDto2DtoCopyWith<$Res>(_self.level!, (value) {
      return _then(_self.copyWith(level: value));
    });
  }
}

/// @nodoc
mixin _$TeacherApiDto {
  @JsonKey(name: 'teacherId')
  int? get teacherId;
  @JsonKey(name: 'employeeId')
  int? get employeeId;
  @JsonKey(name: 'employee')
  EmployeeApiDto? get employee;

  /// Create a copy of TeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TeacherApiDtoCopyWith<TeacherApiDto> get copyWith =>
      _$TeacherApiDtoCopyWithImpl<TeacherApiDto>(
          this as TeacherApiDto, _$identity);

  /// Serializes this TeacherApiDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TeacherApiDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.employeeId, employeeId) ||
                other.employeeId == employeeId) &&
            (identical(other.employee, employee) ||
                other.employee == employee));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, employeeId, employee);

  @override
  String toString() {
    return 'TeacherApiDto(teacherId: $teacherId, employeeId: $employeeId, employee: $employee)';
  }
}

/// @nodoc
abstract mixin class $TeacherApiDtoCopyWith<$Res> {
  factory $TeacherApiDtoCopyWith(
          TeacherApiDto value, $Res Function(TeacherApiDto) _then) =
      _$TeacherApiDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') int? teacherId,
      @JsonKey(name: 'employeeId') int? employeeId,
      @JsonKey(name: 'employee') EmployeeApiDto? employee});

  $EmployeeApiDtoCopyWith<$Res>? get employee;
}

/// @nodoc
class _$TeacherApiDtoCopyWithImpl<$Res>
    implements $TeacherApiDtoCopyWith<$Res> {
  _$TeacherApiDtoCopyWithImpl(this._self, this._then);

  final TeacherApiDto _self;
  final $Res Function(TeacherApiDto) _then;

  /// Create a copy of TeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? teacherId = freezed,
    Object? employeeId = freezed,
    Object? employee = freezed,
  }) {
    return _then(_self.copyWith(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      employeeId: freezed == employeeId
          ? _self.employeeId
          : employeeId // ignore: cast_nullable_to_non_nullable
              as int?,
      employee: freezed == employee
          ? _self.employee
          : employee // ignore: cast_nullable_to_non_nullable
              as EmployeeApiDto?,
    ));
  }

  /// Create a copy of TeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmployeeApiDtoCopyWith<$Res>? get employee {
    if (_self.employee == null) {
      return null;
    }

    return $EmployeeApiDtoCopyWith<$Res>(_self.employee!, (value) {
      return _then(_self.copyWith(employee: value));
    });
  }
}

/// Adds pattern-matching-related methods to [TeacherApiDto].
extension TeacherApiDtoPatterns on TeacherApiDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TeacherApiDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TeacherApiDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TeacherApiDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'employeeId') int? employeeId,
            @JsonKey(name: 'employee') EmployeeApiDto? employee)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto() when $default != null:
        return $default(_that.teacherId, _that.employeeId, _that.employee);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'employeeId') int? employeeId,
            @JsonKey(name: 'employee') EmployeeApiDto? employee)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto():
        return $default(_that.teacherId, _that.employeeId, _that.employee);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'employeeId') int? employeeId,
            @JsonKey(name: 'employee') EmployeeApiDto? employee)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto() when $default != null:
        return $default(_that.teacherId, _that.employeeId, _that.employee);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TeacherApiDto implements TeacherApiDto {
  _TeacherApiDto(
      {@JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'employeeId') this.employeeId,
      @JsonKey(name: 'employee') this.employee});
  factory _TeacherApiDto.fromJson(Map<String, dynamic> json) =>
      _$TeacherApiDtoFromJson(json);

  @override
  @JsonKey(name: 'teacherId')
  final int? teacherId;
  @override
  @JsonKey(name: 'employeeId')
  final int? employeeId;
  @override
  @JsonKey(name: 'employee')
  final EmployeeApiDto? employee;

  /// Create a copy of TeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TeacherApiDtoCopyWith<_TeacherApiDto> get copyWith =>
      __$TeacherApiDtoCopyWithImpl<_TeacherApiDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TeacherApiDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TeacherApiDto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.employeeId, employeeId) ||
                other.employeeId == employeeId) &&
            (identical(other.employee, employee) ||
                other.employee == employee));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, employeeId, employee);

  @override
  String toString() {
    return 'TeacherApiDto(teacherId: $teacherId, employeeId: $employeeId, employee: $employee)';
  }
}

/// @nodoc
abstract mixin class _$TeacherApiDtoCopyWith<$Res>
    implements $TeacherApiDtoCopyWith<$Res> {
  factory _$TeacherApiDtoCopyWith(
          _TeacherApiDto value, $Res Function(_TeacherApiDto) _then) =
      __$TeacherApiDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') int? teacherId,
      @JsonKey(name: 'employeeId') int? employeeId,
      @JsonKey(name: 'employee') EmployeeApiDto? employee});

  @override
  $EmployeeApiDtoCopyWith<$Res>? get employee;
}

/// @nodoc
class __$TeacherApiDtoCopyWithImpl<$Res>
    implements _$TeacherApiDtoCopyWith<$Res> {
  __$TeacherApiDtoCopyWithImpl(this._self, this._then);

  final _TeacherApiDto _self;
  final $Res Function(_TeacherApiDto) _then;

  /// Create a copy of TeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? teacherId = freezed,
    Object? employeeId = freezed,
    Object? employee = freezed,
  }) {
    return _then(_TeacherApiDto(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      employeeId: freezed == employeeId
          ? _self.employeeId
          : employeeId // ignore: cast_nullable_to_non_nullable
              as int?,
      employee: freezed == employee
          ? _self.employee
          : employee // ignore: cast_nullable_to_non_nullable
              as EmployeeApiDto?,
    ));
  }

  /// Create a copy of TeacherApiDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmployeeApiDtoCopyWith<$Res>? get employee {
    if (_self.employee == null) {
      return null;
    }

    return $EmployeeApiDtoCopyWith<$Res>(_self.employee!, (value) {
      return _then(_self.copyWith(employee: value));
    });
  }
}

/// @nodoc
mixin _$TeacherApiDto2Dto {
  @JsonKey(name: 'teacherId')
  int? get teacherId;
  @JsonKey(name: 'employeeId')
  int? get employeeId;
  @JsonKey(name: 'employee')
  EmployeeApiDto? get employee;

  /// Create a copy of TeacherApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TeacherApiDto2DtoCopyWith<TeacherApiDto2Dto> get copyWith =>
      _$TeacherApiDto2DtoCopyWithImpl<TeacherApiDto2Dto>(
          this as TeacherApiDto2Dto, _$identity);

  /// Serializes this TeacherApiDto2Dto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TeacherApiDto2Dto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.employeeId, employeeId) ||
                other.employeeId == employeeId) &&
            (identical(other.employee, employee) ||
                other.employee == employee));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, employeeId, employee);

  @override
  String toString() {
    return 'TeacherApiDto2Dto(teacherId: $teacherId, employeeId: $employeeId, employee: $employee)';
  }
}

/// @nodoc
abstract mixin class $TeacherApiDto2DtoCopyWith<$Res> {
  factory $TeacherApiDto2DtoCopyWith(
          TeacherApiDto2Dto value, $Res Function(TeacherApiDto2Dto) _then) =
      _$TeacherApiDto2DtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') int? teacherId,
      @JsonKey(name: 'employeeId') int? employeeId,
      @JsonKey(name: 'employee') EmployeeApiDto? employee});

  $EmployeeApiDtoCopyWith<$Res>? get employee;
}

/// @nodoc
class _$TeacherApiDto2DtoCopyWithImpl<$Res>
    implements $TeacherApiDto2DtoCopyWith<$Res> {
  _$TeacherApiDto2DtoCopyWithImpl(this._self, this._then);

  final TeacherApiDto2Dto _self;
  final $Res Function(TeacherApiDto2Dto) _then;

  /// Create a copy of TeacherApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? teacherId = freezed,
    Object? employeeId = freezed,
    Object? employee = freezed,
  }) {
    return _then(_self.copyWith(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      employeeId: freezed == employeeId
          ? _self.employeeId
          : employeeId // ignore: cast_nullable_to_non_nullable
              as int?,
      employee: freezed == employee
          ? _self.employee
          : employee // ignore: cast_nullable_to_non_nullable
              as EmployeeApiDto?,
    ));
  }

  /// Create a copy of TeacherApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmployeeApiDtoCopyWith<$Res>? get employee {
    if (_self.employee == null) {
      return null;
    }

    return $EmployeeApiDtoCopyWith<$Res>(_self.employee!, (value) {
      return _then(_self.copyWith(employee: value));
    });
  }
}

/// Adds pattern-matching-related methods to [TeacherApiDto2Dto].
extension TeacherApiDto2DtoPatterns on TeacherApiDto2Dto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TeacherApiDto2Dto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TeacherApiDto2Dto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto2Dto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TeacherApiDto2Dto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto2Dto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'employeeId') int? employeeId,
            @JsonKey(name: 'employee') EmployeeApiDto? employee)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto2Dto() when $default != null:
        return $default(_that.teacherId, _that.employeeId, _that.employee);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'employeeId') int? employeeId,
            @JsonKey(name: 'employee') EmployeeApiDto? employee)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto2Dto():
        return $default(_that.teacherId, _that.employeeId, _that.employee);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'teacherId') int? teacherId,
            @JsonKey(name: 'employeeId') int? employeeId,
            @JsonKey(name: 'employee') EmployeeApiDto? employee)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TeacherApiDto2Dto() when $default != null:
        return $default(_that.teacherId, _that.employeeId, _that.employee);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TeacherApiDto2Dto implements TeacherApiDto2Dto {
  _TeacherApiDto2Dto(
      {@JsonKey(name: 'teacherId') this.teacherId,
      @JsonKey(name: 'employeeId') this.employeeId,
      @JsonKey(name: 'employee') this.employee});
  factory _TeacherApiDto2Dto.fromJson(Map<String, dynamic> json) =>
      _$TeacherApiDto2DtoFromJson(json);

  @override
  @JsonKey(name: 'teacherId')
  final int? teacherId;
  @override
  @JsonKey(name: 'employeeId')
  final int? employeeId;
  @override
  @JsonKey(name: 'employee')
  final EmployeeApiDto? employee;

  /// Create a copy of TeacherApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TeacherApiDto2DtoCopyWith<_TeacherApiDto2Dto> get copyWith =>
      __$TeacherApiDto2DtoCopyWithImpl<_TeacherApiDto2Dto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TeacherApiDto2DtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TeacherApiDto2Dto &&
            (identical(other.teacherId, teacherId) ||
                other.teacherId == teacherId) &&
            (identical(other.employeeId, employeeId) ||
                other.employeeId == employeeId) &&
            (identical(other.employee, employee) ||
                other.employee == employee));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, teacherId, employeeId, employee);

  @override
  String toString() {
    return 'TeacherApiDto2Dto(teacherId: $teacherId, employeeId: $employeeId, employee: $employee)';
  }
}

/// @nodoc
abstract mixin class _$TeacherApiDto2DtoCopyWith<$Res>
    implements $TeacherApiDto2DtoCopyWith<$Res> {
  factory _$TeacherApiDto2DtoCopyWith(
          _TeacherApiDto2Dto value, $Res Function(_TeacherApiDto2Dto) _then) =
      __$TeacherApiDto2DtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'teacherId') int? teacherId,
      @JsonKey(name: 'employeeId') int? employeeId,
      @JsonKey(name: 'employee') EmployeeApiDto? employee});

  @override
  $EmployeeApiDtoCopyWith<$Res>? get employee;
}

/// @nodoc
class __$TeacherApiDto2DtoCopyWithImpl<$Res>
    implements _$TeacherApiDto2DtoCopyWith<$Res> {
  __$TeacherApiDto2DtoCopyWithImpl(this._self, this._then);

  final _TeacherApiDto2Dto _self;
  final $Res Function(_TeacherApiDto2Dto) _then;

  /// Create a copy of TeacherApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? teacherId = freezed,
    Object? employeeId = freezed,
    Object? employee = freezed,
  }) {
    return _then(_TeacherApiDto2Dto(
      teacherId: freezed == teacherId
          ? _self.teacherId
          : teacherId // ignore: cast_nullable_to_non_nullable
              as int?,
      employeeId: freezed == employeeId
          ? _self.employeeId
          : employeeId // ignore: cast_nullable_to_non_nullable
              as int?,
      employee: freezed == employee
          ? _self.employee
          : employee // ignore: cast_nullable_to_non_nullable
              as EmployeeApiDto?,
    ));
  }

  /// Create a copy of TeacherApiDto2Dto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmployeeApiDtoCopyWith<$Res>? get employee {
    if (_self.employee == null) {
      return null;
    }

    return $EmployeeApiDtoCopyWith<$Res>(_self.employee!, (value) {
      return _then(_self.copyWith(employee: value));
    });
  }
}

/// @nodoc
mixin _$UserBranchRoleDto {
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'roleCode')
  String? get roleCode;
  @JsonKey(name: 'studentId')
  int? get studentId;

  /// Create a copy of UserBranchRoleDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserBranchRoleDtoCopyWith<UserBranchRoleDto> get copyWith =>
      _$UserBranchRoleDtoCopyWithImpl<UserBranchRoleDto>(
          this as UserBranchRoleDto, _$identity);

  /// Serializes this UserBranchRoleDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserBranchRoleDto &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.roleCode, roleCode) ||
                other.roleCode == roleCode) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, branchId, roleCode, studentId);

  @override
  String toString() {
    return 'UserBranchRoleDto(branchId: $branchId, roleCode: $roleCode, studentId: $studentId)';
  }
}

/// @nodoc
abstract mixin class $UserBranchRoleDtoCopyWith<$Res> {
  factory $UserBranchRoleDtoCopyWith(
          UserBranchRoleDto value, $Res Function(UserBranchRoleDto) _then) =
      _$UserBranchRoleDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'roleCode') String? roleCode,
      @JsonKey(name: 'studentId') int? studentId});
}

/// @nodoc
class _$UserBranchRoleDtoCopyWithImpl<$Res>
    implements $UserBranchRoleDtoCopyWith<$Res> {
  _$UserBranchRoleDtoCopyWithImpl(this._self, this._then);

  final UserBranchRoleDto _self;
  final $Res Function(UserBranchRoleDto) _then;

  /// Create a copy of UserBranchRoleDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? branchId = freezed,
    Object? roleCode = freezed,
    Object? studentId = freezed,
  }) {
    return _then(_self.copyWith(
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      roleCode: freezed == roleCode
          ? _self.roleCode
          : roleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [UserBranchRoleDto].
extension UserBranchRoleDtoPatterns on UserBranchRoleDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserBranchRoleDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserBranchRoleDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UserBranchRoleDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'roleCode') String? roleCode,
            @JsonKey(name: 'studentId') int? studentId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleDto() when $default != null:
        return $default(_that.branchId, _that.roleCode, _that.studentId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'roleCode') String? roleCode,
            @JsonKey(name: 'studentId') int? studentId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleDto():
        return $default(_that.branchId, _that.roleCode, _that.studentId);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'roleCode') String? roleCode,
            @JsonKey(name: 'studentId') int? studentId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleDto() when $default != null:
        return $default(_that.branchId, _that.roleCode, _that.studentId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UserBranchRoleDto implements UserBranchRoleDto {
  _UserBranchRoleDto(
      {@JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'roleCode') this.roleCode,
      @JsonKey(name: 'studentId') this.studentId});
  factory _UserBranchRoleDto.fromJson(Map<String, dynamic> json) =>
      _$UserBranchRoleDtoFromJson(json);

  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'roleCode')
  final String? roleCode;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;

  /// Create a copy of UserBranchRoleDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserBranchRoleDtoCopyWith<_UserBranchRoleDto> get copyWith =>
      __$UserBranchRoleDtoCopyWithImpl<_UserBranchRoleDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserBranchRoleDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserBranchRoleDto &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.roleCode, roleCode) ||
                other.roleCode == roleCode) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, branchId, roleCode, studentId);

  @override
  String toString() {
    return 'UserBranchRoleDto(branchId: $branchId, roleCode: $roleCode, studentId: $studentId)';
  }
}

/// @nodoc
abstract mixin class _$UserBranchRoleDtoCopyWith<$Res>
    implements $UserBranchRoleDtoCopyWith<$Res> {
  factory _$UserBranchRoleDtoCopyWith(
          _UserBranchRoleDto value, $Res Function(_UserBranchRoleDto) _then) =
      __$UserBranchRoleDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'roleCode') String? roleCode,
      @JsonKey(name: 'studentId') int? studentId});
}

/// @nodoc
class __$UserBranchRoleDtoCopyWithImpl<$Res>
    implements _$UserBranchRoleDtoCopyWith<$Res> {
  __$UserBranchRoleDtoCopyWithImpl(this._self, this._then);

  final _UserBranchRoleDto _self;
  final $Res Function(_UserBranchRoleDto) _then;

  /// Create a copy of UserBranchRoleDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? branchId = freezed,
    Object? roleCode = freezed,
    Object? studentId = freezed,
  }) {
    return _then(_UserBranchRoleDto(
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      roleCode: freezed == roleCode
          ? _self.roleCode
          : roleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$UserBranchRoleViewDto {
  @JsonKey(name: 'branchId')
  int? get branchId;
  @JsonKey(name: 'userId')
  String? get userId;
  @JsonKey(name: 'roleCode')
  String? get roleCode;
  @JsonKey(name: 'studentId')
  int? get studentId;
  @JsonKey(name: 'email')
  String? get email;

  /// Create a copy of UserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserBranchRoleViewDtoCopyWith<UserBranchRoleViewDto> get copyWith =>
      _$UserBranchRoleViewDtoCopyWithImpl<UserBranchRoleViewDto>(
          this as UserBranchRoleViewDto, _$identity);

  /// Serializes this UserBranchRoleViewDto to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserBranchRoleViewDto &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.roleCode, roleCode) ||
                other.roleCode == roleCode) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, branchId, userId, roleCode, studentId, email);

  @override
  String toString() {
    return 'UserBranchRoleViewDto(branchId: $branchId, userId: $userId, roleCode: $roleCode, studentId: $studentId, email: $email)';
  }
}

/// @nodoc
abstract mixin class $UserBranchRoleViewDtoCopyWith<$Res> {
  factory $UserBranchRoleViewDtoCopyWith(UserBranchRoleViewDto value,
          $Res Function(UserBranchRoleViewDto) _then) =
      _$UserBranchRoleViewDtoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'roleCode') String? roleCode,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'email') String? email});
}

/// @nodoc
class _$UserBranchRoleViewDtoCopyWithImpl<$Res>
    implements $UserBranchRoleViewDtoCopyWith<$Res> {
  _$UserBranchRoleViewDtoCopyWithImpl(this._self, this._then);

  final UserBranchRoleViewDto _self;
  final $Res Function(UserBranchRoleViewDto) _then;

  /// Create a copy of UserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? branchId = freezed,
    Object? userId = freezed,
    Object? roleCode = freezed,
    Object? studentId = freezed,
    Object? email = freezed,
  }) {
    return _then(_self.copyWith(
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      roleCode: freezed == roleCode
          ? _self.roleCode
          : roleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [UserBranchRoleViewDto].
extension UserBranchRoleViewDtoPatterns on UserBranchRoleViewDto {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserBranchRoleViewDto value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleViewDto() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserBranchRoleViewDto value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleViewDto():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UserBranchRoleViewDto value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleViewDto() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'roleCode') String? roleCode,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'email') String? email)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleViewDto() when $default != null:
        return $default(_that.branchId, _that.userId, _that.roleCode,
            _that.studentId, _that.email);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'roleCode') String? roleCode,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'email') String? email)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleViewDto():
        return $default(_that.branchId, _that.userId, _that.roleCode,
            _that.studentId, _that.email);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'branchId') int? branchId,
            @JsonKey(name: 'userId') String? userId,
            @JsonKey(name: 'roleCode') String? roleCode,
            @JsonKey(name: 'studentId') int? studentId,
            @JsonKey(name: 'email') String? email)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UserBranchRoleViewDto() when $default != null:
        return $default(_that.branchId, _that.userId, _that.roleCode,
            _that.studentId, _that.email);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UserBranchRoleViewDto implements UserBranchRoleViewDto {
  _UserBranchRoleViewDto(
      {@JsonKey(name: 'branchId') this.branchId,
      @JsonKey(name: 'userId') this.userId,
      @JsonKey(name: 'roleCode') this.roleCode,
      @JsonKey(name: 'studentId') this.studentId,
      @JsonKey(name: 'email') this.email});
  factory _UserBranchRoleViewDto.fromJson(Map<String, dynamic> json) =>
      _$UserBranchRoleViewDtoFromJson(json);

  @override
  @JsonKey(name: 'branchId')
  final int? branchId;
  @override
  @JsonKey(name: 'userId')
  final String? userId;
  @override
  @JsonKey(name: 'roleCode')
  final String? roleCode;
  @override
  @JsonKey(name: 'studentId')
  final int? studentId;
  @override
  @JsonKey(name: 'email')
  final String? email;

  /// Create a copy of UserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserBranchRoleViewDtoCopyWith<_UserBranchRoleViewDto> get copyWith =>
      __$UserBranchRoleViewDtoCopyWithImpl<_UserBranchRoleViewDto>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserBranchRoleViewDtoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserBranchRoleViewDto &&
            (identical(other.branchId, branchId) ||
                other.branchId == branchId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.roleCode, roleCode) ||
                other.roleCode == roleCode) &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId) &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, branchId, userId, roleCode, studentId, email);

  @override
  String toString() {
    return 'UserBranchRoleViewDto(branchId: $branchId, userId: $userId, roleCode: $roleCode, studentId: $studentId, email: $email)';
  }
}

/// @nodoc
abstract mixin class _$UserBranchRoleViewDtoCopyWith<$Res>
    implements $UserBranchRoleViewDtoCopyWith<$Res> {
  factory _$UserBranchRoleViewDtoCopyWith(_UserBranchRoleViewDto value,
          $Res Function(_UserBranchRoleViewDto) _then) =
      __$UserBranchRoleViewDtoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'branchId') int? branchId,
      @JsonKey(name: 'userId') String? userId,
      @JsonKey(name: 'roleCode') String? roleCode,
      @JsonKey(name: 'studentId') int? studentId,
      @JsonKey(name: 'email') String? email});
}

/// @nodoc
class __$UserBranchRoleViewDtoCopyWithImpl<$Res>
    implements _$UserBranchRoleViewDtoCopyWith<$Res> {
  __$UserBranchRoleViewDtoCopyWithImpl(this._self, this._then);

  final _UserBranchRoleViewDto _self;
  final $Res Function(_UserBranchRoleViewDto) _then;

  /// Create a copy of UserBranchRoleViewDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? branchId = freezed,
    Object? userId = freezed,
    Object? roleCode = freezed,
    Object? studentId = freezed,
    Object? email = freezed,
  }) {
    return _then(_UserBranchRoleViewDto(
      branchId: freezed == branchId
          ? _self.branchId
          : branchId // ignore: cast_nullable_to_non_nullable
              as int?,
      userId: freezed == userId
          ? _self.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      roleCode: freezed == roleCode
          ? _self.roleCode
          : roleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      studentId: freezed == studentId
          ? _self.studentId
          : studentId // ignore: cast_nullable_to_non_nullable
              as int?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on
